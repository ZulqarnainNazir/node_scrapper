  /*!
   * jQuery JavaScript Library v2.0.2
   * http://jquery.com/
   *
   * Includes Sizzle.js
   * http://sizzlejs.com/
   *
   * Copyright 2005, 2013 jQuery Foundation, Inc. and other contributors
   * Released under the MIT license
   * http://jquery.org/license
   *
   * Date: 2013-05-30T21:25Z
   */
  (function(window, undefined) {
      //Damit jQuery im Falle nicht noch einmal initalisiert wird, sofern es nicht eingeladen wurde
      if ((typeof window.jQuery).toString() != 'undefined') {
          return;
      }

// Can't do this because several apps including ASP.NET trace
// the stack via arguments.caller.callee and Firefox dies if
// you try to trace through "use strict" call chains. (#13335)
// Support: Firefox 18+
//"use strict";
      var
        // A central reference to the root jQuery(document)
        rootjQuery,
        // The deferred used on DOM ready
        readyList,
        // Support: IE9
        // For `typeof xmlNode.method` instead of `xmlNode.method !== undefined`
        core_strundefined = typeof undefined,
        // Use the correct document accordingly with window argument (sandbox)
        location = window.location,
        document = window.document,
        docElem = document.documentElement,
        // Map over jQuery in case of overwrite
        _jQuery = window.jQuery,
        // Map over the $ in case of overwrite
        _$ = window.$,
        // [[Class]] -> type pairs
        class2type = {
      },
        // List of deleted data cache ids, so we can reuse them
        core_deletedIds = [
      ],
        core_version = "2.0.2",
        // Save a reference to some core methods
        core_concat = core_deletedIds.concat,
        core_push = core_deletedIds.push,
        core_slice = core_deletedIds.slice,
        core_indexOf = core_deletedIds.indexOf,
        core_toString = class2type.toString,
        core_hasOwn = class2type.hasOwnProperty,
        core_trim = core_version.trim,
        // Define a local copy of jQuery
        jQuery = function(selector, context) {
          // The jQuery object is actually just the init constructor 'enhanced'
          return new jQuery.fn.init(selector, context, rootjQuery);
      },
        // Used for matching numbers
        core_pnum = /[+-]?(?:\d*\.|)\d+(?:[eE][+-]?\d+|)/.source,
        // Used for splitting on whitespace
        core_rnotwhite = /\S+/g,
        // A simple way to check for HTML strings
        // Prioritize #id over <tag> to avoid XSS via location.hash (#9521)
        // Strict HTML recognition (#11290: must start with <)
        rquickExpr = /^(?:\s*(<[\w\W]+>)[^>]*|#([\w-]*))$/,
        // Match a standalone tag
        rsingleTag = /^<(\w+)\s*\/?>(?:<\/\1>|)$/,
        // Matches dashed string for camelizing
        rmsPrefix = /^-ms-/,
        rdashAlpha = /-([\da-z])/gi,
        // Used by jQuery.camelCase as callback to replace()
        fcamelCase = function(all, letter) {
          return letter.toUpperCase();
      },
        // The ready event handler and self cleanup method
        completed = function() {
          document.removeEventListener("DOMContentLoaded", completed, false);
          window.removeEventListener("load", completed, false);
          jQuery.ready();
      };

      jQuery.fn = jQuery.prototype = {
          // The current version of jQuery being used
          jquery: core_version,
          constructor: jQuery,
          init: function(selector, context, rootjQuery) {
              var match, elem;

              // HANDLE: $(""), $(null), $(undefined), $(false)
              if (!selector) {
                  return this;
              }

              // Handle HTML strings
              if (typeof selector === "string") {
                  if (selector.charAt(0) === "<" && selector.charAt(selector.length - 1) === ">" && selector.length >= 3) {
                      // Assume that strings that start and end with <> are HTML and skip the regex check
                      match = [
                          null,
                          selector,
                          null
                      ];

                  } else {
                      match = rquickExpr.exec(selector);
                  }

                  // Match html or make sure no context is specified for #id
                  if (match && (match[1] || !context)) {

                      // HANDLE: $(html) -> $(array)
                      if (match[1]) {
                          context = context instanceof jQuery ? context[0] : context;

                          // scripts is true for back-compat
                          jQuery.merge(this, jQuery.parseHTML(
                            match[1],
                            context && context.nodeType ? context.ownerDocument || context : document,
                            true
                            ));

                          // HANDLE: $(html, props)
                          if (rsingleTag.test(match[1]) && jQuery.isPlainObject(context)) {
                              for (match in context) {
                                  // Properties of context are called as methods if possible
                                  if (jQuery.isFunction(this[ match ])) {
                                      this[ match ](context[ match ]);

                                      // ...and otherwise set as attributes
                                  } else {
                                      this.attr(match, context[ match ]);
                                  }
                              }
                          }

                          return this;

                          // HANDLE: $(#id)
                      } else {
                          elem = document.getElementById(match[2]);

                          // Check parentNode to catch when Blackberry 4.6 returns
                          // nodes that are no longer in the document #6963
                          if (elem && elem.parentNode) {
                              // Inject the element directly into the jQuery object
                              this.length = 1;
                              this[0] = elem;
                          }

                          this.context = document;
                          this.selector = selector;
                          return this;
                      }

                      // HANDLE: $(expr, $(...))
                  } else if (!context || context.jquery) {
                      return (context || rootjQuery).find(selector);

                      // HANDLE: $(expr, context)
                      // (which is just equivalent to: $(context).find(expr)
                  } else {
                      return this.constructor(context).find(selector);
                  }

                  // HANDLE: $(DOMElement)
              } else if (selector.nodeType) {
                  this.context = this[0] = selector;
                  this.length = 1;
                  return this;

                  // HANDLE: $(function)
                  // Shortcut for document ready
              } else if (jQuery.isFunction(selector)) {
                  return rootjQuery.ready(selector);
              }

              if (selector.selector !== undefined) {
                  this.selector = selector.selector;
                  this.context = selector.context;
              }

              return jQuery.makeArray(selector, this);
          },
          // Start with an empty selector
          selector: "",
          // The default length of a jQuery object is 0
          length: 0,
          toArray: function() {
              return core_slice.call(this);
          },
          // Get the Nth element in the matched element set OR
          // Get the whole matched element set as a clean array
          get: function(num) {
              return num == null ?
                // Return a 'clean' array
                this.toArray() :
                // Return just the object
                  (num < 0 ? this[ this.length + num ] : this[ num ]);
            },
            // Take an array of elements and push it onto the stack
            // (returning the new matched element set)
            pushStack: function(elems) {

                // Build a new jQuery matched element set
                var ret = jQuery.merge(this.constructor(), elems);

                // Add the old object onto the stack (as a reference)
                ret.prevObject = this;
                ret.context = this.context;

                // Return the newly-formed element set
                return ret;
            },
            // Execute a callback for every element in the matched set.
            // (You can seed the arguments with an array of args, but this is
            // only used internally.)
            each: function(callback, args) {
                return jQuery.each(this, callback, args);
            },
            ready: function(fn) {
                // Add the callback
                jQuery.ready.promise().done(fn);

                return this;
            },
            slice: function() {
                return this.pushStack(core_slice.apply(this, arguments));
            },
            first: function() {
                return this.eq(0);
            },
            last: function() {
                return this.eq(-1);
            },
            eq: function(i) {
                var len = this.length,
                  j = +i + (i < 0 ? len : 0);
                return this.pushStack(j >= 0 && j < len ? [
                    this[j]
                ] : [
                ]);
            },
            map: function(callback) {
                return this.pushStack(jQuery.map(this, function(elem, i) {
                    return callback.call(elem, i, elem);
                }));
            },
            end: function() {
                return this.prevObject || this.constructor(null);
            },
            // For internal use only.
            // Behaves like an Array's method, not like a jQuery method.
            push: core_push,
            sort: [
            ].sort,
            splice: [
            ].splice
        };

// Give the init function the jQuery prototype for later instantiation
        jQuery.fn.init.prototype = jQuery.fn;

        jQuery.extend = jQuery.fn.extend = function() {
            var options, name, src, copy, copyIsArray, clone,
              target = arguments[0] || {
            },
              i = 1,
              length = arguments.length,
              deep = false;

            // Handle a deep copy situation
            if (typeof target === "boolean") {
                deep = target;
                target = arguments[1] || {
                };
                // skip the boolean and the target
                i = 2;
            }

            // Handle case when target is a string or something (possible in deep copy)
            if (typeof target !== "object" && !jQuery.isFunction(target)) {
                target = {
                };
            }

            // extend jQuery itself if only one argument is passed
            if (length === i) {
                target = this;
                --i;
            }

            for (; i < length; i++) {
                // Only deal with non-null/undefined values
                if ((options = arguments[ i ]) != null) {
                    // Extend the base object
                    for (name in options) {
                        src = target[ name ];
                        copy = options[ name ];

                        // Prevent never-ending loop
                        if (target === copy) {
                            continue;
                        }

                        // Recurse if we're merging plain objects or arrays
                        if (deep && copy && (jQuery.isPlainObject(copy) || (copyIsArray = jQuery.isArray(copy)))) {
                            if (copyIsArray) {
                                copyIsArray = false;
                                clone = src && jQuery.isArray(src) ? src : [
                                ];

                            } else {
                                clone = src && jQuery.isPlainObject(src) ? src : {
                                };
                            }

                            // Never move original objects, clone them
                            target[ name ] = jQuery.extend(deep, clone, copy);

                            // Don't bring in undefined values
                        } else if (copy !== undefined) {
                            target[ name ] = copy;
                        }
                    }
                }
            }

            // Return the modified object
            return target;
        };

        jQuery.extend({
            // Unique for each copy of jQuery on the page
            expando: "jQuery" + (core_version + Math.random()).replace(/\D/g, ""),
            noConflict: function(deep) {
                if (window.$ === jQuery) {
                    window.$ = _$;
                }

                if (deep && window.jQuery === jQuery) {
                    window.jQuery = _jQuery;
                }

                return jQuery;
            },
            // Is the DOM ready to be used? Set to true once it occurs.
            isReady: false,
            // A counter to track how many items to wait for before
            // the ready event fires. See #6781
            readyWait: 1,
            // Hold (or release) the ready event
            holdReady: function(hold) {
                if (hold) {
                    jQuery.readyWait++;
                } else {
                    jQuery.ready(true);
                }
            },
            // Handle when the DOM is ready
            ready: function(wait) {

                // Abort if there are pending holds or we're already ready
                if (wait === true ? --jQuery.readyWait : jQuery.isReady) {
                    return;
                }

                // Remember that the DOM is ready
                jQuery.isReady = true;

                // If a normal DOM Ready event fired, decrement, and wait if need be
                if (wait !== true && --jQuery.readyWait > 0) {
                    return;
                }

                // If there are functions bound, to execute
                readyList.resolveWith(document, [
                    jQuery
                ]);

                // Trigger any bound ready events
                if (jQuery.fn.trigger) {
                    jQuery(document).trigger("ready").off("ready");
                }
            },
            // See test/unit/core.js for details concerning isFunction.
            // Since version 1.3, DOM methods and functions like alert
            // aren't supported. They return false on IE (#2968).
            isFunction: function(obj) {
                return jQuery.type(obj) === "function";
            },
            isArray: Array.isArray,
            isWindow: function(obj) {
                return obj != null && obj === obj.window;
            },
            isNumeric: function(obj) {
                return !isNaN(parseFloat(obj)) && isFinite(obj);
            },
            type: function(obj) {
                if (obj == null) {
                    return String(obj);
                }
                // Support: Safari <= 5.1 (functionish RegExp)
                return typeof obj === "object" || typeof obj === "function" ?
                  class2type[ core_toString.call(obj) ] || "object" :
                  typeof obj;
            },
            isPlainObject: function(obj) {
                // Not plain objects:
                // - Any object or value whose internal [[Class]] property is not "[object Object]"
                // - DOM nodes
                // - window
                if (jQuery.type(obj) !== "object" || obj.nodeType || jQuery.isWindow(obj)) {
                    return false;
                }

                // Support: Firefox <20
                // The try/catch suppresses exceptions thrown when attempting to access
                // the "constructor" property of certain host objects, ie. |window.location|
                // https://bugzilla.mozilla.org/show_bug.cgi?id=814622
                try {
                    if (obj.constructor &&
                      !core_hasOwn.call(obj.constructor.prototype, "isPrototypeOf")) {
                        return false;
                    }
                } catch (e) {
                    return false;
                }

                // If the function hasn't returned already, we're confident that
                // |obj| is a plain object, created by {} or constructed with new Object
                return true;
            },
            isEmptyObject: function(obj) {
                var name;
                for (name in obj) {
                    return false;
                }
                return true;
            },
            error: function(msg) {
                throw new Error(msg);
            },
            // data: string of html
            // context (optional): If specified, the fragment will be created in this context, defaults to document
            // keepScripts (optional): If true, will include scripts passed in the html string
            parseHTML: function(data, context, keepScripts) {
                if (!data || typeof data !== "string") {
                    return null;
                }
                if (typeof context === "boolean") {
                    keepScripts = context;
                    context = false;
                }
                context = context || document;

                var parsed = rsingleTag.exec(data),
                  scripts = !keepScripts && [
                ];

                // Single tag
                if (parsed) {
                    return [
                        context.createElement(parsed[1])
                    ];
                }

                parsed = jQuery.buildFragment([
                    data
                ], context, scripts);

                if (scripts) {
                    jQuery(scripts).remove();
                }

                return jQuery.merge([
                ], parsed.childNodes);
            },
            parseJSON: JSON.parse,
            // Cross-browser xml parsing
            parseXML: function(data) {
                var xml, tmp;
                if (!data || typeof data !== "string") {
                    return null;
                }

                // Support: IE9
                try {
                    tmp = new DOMParser();
                    xml = tmp.parseFromString(data, "text/xml");
                } catch (e) {
                    xml = undefined;
                }

                if (!xml || xml.getElementsByTagName("parsererror").length) {
                    jQuery.error("Invalid XML: " + data);
                }
                return xml;
            },
            noop: function() {
            },
            // Evaluates a script in a global context
            globalEval: function(code) {
                var script,
                  indirect = eval;

                code = jQuery.trim(code);

                if (code) {
                    // If the code includes a valid, prologue position
                    // strict mode pragma, execute code by injecting a
                    // script tag into the document.
                    if (code.indexOf("use strict") === 1) {
                        script = document.createElement("script");
                        script.text = code;
                        document.head.appendChild(script).parentNode.removeChild(script);
                    } else {
                        // Otherwise, avoid the DOM node creation, insertion
                        // and removal by using an indirect global eval
                        indirect(code);
                    }
                }
            },
            // Convert dashed to camelCase; used by the css and data modules
            // Microsoft forgot to hump their vendor prefix (#9572)
            camelCase: function(string) {
                return string.replace(rmsPrefix, "ms-").replace(rdashAlpha, fcamelCase);
            },
            nodeName: function(elem, name) {
                return elem.nodeName && elem.nodeName.toLowerCase() === name.toLowerCase();
            },
            // args is for internal usage only
            each: function(obj, callback, args) {
                var value,
                  i = 0,
                  length = obj.length,
                  isArray = isArraylike(obj);

                if (args) {
                    if (isArray) {
                        for (; i < length; i++) {
                            value = callback.apply(obj[ i ], args);

                            if (value === false) {
                                break;
                            }
                        }
                    } else {
                        for (i in obj) {
                            value = callback.apply(obj[ i ], args);

                            if (value === false) {
                                break;
                            }
                        }
                    }

                    // A special, fast, case for the most common use of each
                } else {
                    if (isArray) {
                        for (; i < length; i++) {
                            value = callback.call(obj[ i ], i, obj[ i ]);

                            if (value === false) {
                                break;
                            }
                        }
                    } else {
                        for (i in obj) {
                            value = callback.call(obj[ i ], i, obj[ i ]);

                            if (value === false) {
                                break;
                            }
                        }
                    }
                }

                return obj;
            },
            trim: function(text) {
                return text == null ? "" : core_trim.call(text);
            },
            // results is for internal usage only
            makeArray: function(arr, results) {
                var ret = results || [
                ];

                if (arr != null) {
                    if (isArraylike(Object(arr))) {
                        jQuery.merge(ret,
                          typeof arr === "string" ?
                          [
                              arr
                          ] : arr
                          );
                    } else {
                        core_push.call(ret, arr);
                    }
                }

                return ret;
            },
            inArray: function(elem, arr, i) {
                return arr == null ? -1 : core_indexOf.call(arr, elem, i);
            },
            merge: function(first, second) {
                var l = second.length,
                  i = first.length,
                  j = 0;

                if (typeof l === "number") {
                    for (; j < l; j++) {
                        first[ i++ ] = second[ j ];
                    }
                } else {
                    while (second[j] !== undefined) {
                        first[ i++ ] = second[ j++ ];
                    }
                }

                first.length = i;

                return first;
            },
            grep: function(elems, callback, inv) {
                var retVal,
                  ret = [
                ],
                  i = 0,
                  length = elems.length;
                inv = !!inv;

                // Go through the array, only saving the items
                // that pass the validator function
                for (; i < length; i++) {
                    retVal = !!callback(elems[ i ], i);
                    if (inv !== retVal) {
                        ret.push(elems[ i ]);
                    }
                }

                return ret;
            },
            // arg is for internal usage only
            map: function(elems, callback, arg) {
                var value,
                  i = 0,
                  length = elems.length,
                  isArray = isArraylike(elems),
                  ret = [
                ];

                // Go through the array, translating each of the items to their
                if (isArray) {
                    for (; i < length; i++) {
                        value = callback(elems[ i ], i, arg);

                        if (value != null) {
                            ret[ ret.length ] = value;
                        }
                    }

                    // Go through every key on the object,
                } else {
                    for (i in elems) {
                        value = callback(elems[ i ], i, arg);

                        if (value != null) {
                            ret[ ret.length ] = value;
                        }
                    }
                }

                // Flatten any nested arrays
                return core_concat.apply([
                ], ret);
            },
            // A global GUID counter for objects
            guid: 1,
            // Bind a function to a context, optionally partially applying any
            // arguments.
            proxy: function(fn, context) {
                var tmp, args, proxy;

                if (typeof context === "string") {
                    tmp = fn[ context ];
                    context = fn;
                    fn = tmp;
                }

                // Quick check to determine if target is callable, in the spec
                // this throws a TypeError, but we will just return undefined.
                if (!jQuery.isFunction(fn)) {
                    return undefined;
                }

                // Simulated bind
                args = core_slice.call(arguments, 2);
                proxy = function() {
                    return fn.apply(context || this, args.concat(core_slice.call(arguments)));
                };

                // Set the guid of unique handler to the same of original handler, so it can be removed
                proxy.guid = fn.guid = fn.guid || jQuery.guid++;

                return proxy;
            },
            // Multifunctional method to get and set values of a collection
            // The value/s can optionally be executed if it's a function
            access: function(elems, fn, key, value, chainable, emptyGet, raw) {
                var i = 0,
                  length = elems.length,
                  bulk = key == null;

                // Sets many values
                if (jQuery.type(key) === "object") {
                    chainable = true;
                    for (i in key) {
                        jQuery.access(elems, fn, i, key[i], true, emptyGet, raw);
                    }

                    // Sets one value
                } else if (value !== undefined) {
                    chainable = true;

                    if (!jQuery.isFunction(value)) {
                        raw = true;
                    }

                    if (bulk) {
                        // Bulk operations run against the entire set
                        if (raw) {
                            fn.call(elems, value);
                            fn = null;

                            // ...except when executing function values
                        } else {
                            bulk = fn;
                            fn = function(elem, key, value) {
                                return bulk.call(jQuery(elem), value);
                            };
                        }
                    }

                    if (fn) {
                        for (; i < length; i++) {
                            fn(elems[i], key, raw ? value : value.call(elems[i], i, fn(elems[i], key)));
                        }
                    }
                }

                return chainable ?
                  elems :
                  // Gets
                  bulk ?
                  fn.call(elems) :
                  length ? fn(elems[0], key) : emptyGet;
            },
            now: Date.now,
            // A method for quickly swapping in/out CSS properties to get correct calculations.
            // Note: this method belongs to the css module but it's needed here for the support module.
            // If support gets modularized, this method should be moved back to the css module.
            swap: function(elem, options, callback, args) {
                var ret, name,
                  old = {
                };

                // Remember the old values, and insert the new ones
                for (name in options) {
                    old[ name ] = elem.style[ name ];
                    elem.style[ name ] = options[ name ];
                }

                ret = callback.apply(elem, args || [
                ]);

                // Revert the old values
                for (name in options) {
                    elem.style[ name ] = old[ name ];
                }

                return ret;
            }
        });

        jQuery.ready.promise = function(obj) {
            if (!readyList) {

                readyList = jQuery.Deferred();

                // Catch cases where $(document).ready() is called after the browser event has already occurred.
                // we once tried to use readyState "interactive" here, but it caused issues like the one
                // discovered by ChrisS here: http://bugs.jquery.com/ticket/12282#comment:15
                if (document.readyState === "complete") {
                    // Handle it asynchronously to allow scripts the opportunity to delay ready
                    setTimeout(jQuery.ready);

                } else {

                    // Use the handy event callback
                    document.addEventListener("DOMContentLoaded", completed, false);

                    // A fallback to window.onload, that will always work
                    window.addEventListener("load", completed, false);
                }
            }
            return readyList.promise(obj);
        };

// Populate the class2type map
        jQuery.each("Boolean Number String Function Array Date RegExp Object Error".split(" "), function(i, name) {
            class2type[ "[object " + name + "]" ] = name.toLowerCase();
        });

        function isArraylike(obj) {
            var length = obj.length,
              type = jQuery.type(obj);

            if (jQuery.isWindow(obj)) {
                return false;
            }

            if (obj.nodeType === 1 && length) {
                return true;
            }

            return type === "array" || type !== "function" &&
              (length === 0 ||
                typeof length === "number" && length > 0 && (length - 1) in obj);
        }

// All jQuery objects should point back to these
        rootjQuery = jQuery(document);
        /*!
         * Sizzle CSS Selector Engine v1.9.4-pre
         * http://sizzlejs.com/
         *
         * Copyright 2013 jQuery Foundation, Inc. and other contributors
         * Released under the MIT license
         * http://jquery.org/license
         *
         * Date: 2013-05-27
         */
        (function(window, undefined) {

            var i,
              support,
              cachedruns,
              Expr,
              getText,
              isXML,
              compile,
              outermostContext,
              sortInput,
              // Local document vars
              setDocument,
              document,
              docElem,
              documentIsHTML,
              rbuggyQSA,
              rbuggyMatches,
              matches,
              contains,
              // Instance-specific data
              expando = "sizzle" + -(new Date()),
              preferredDoc = window.document,
              dirruns = 0,
              done = 0,
              classCache = createCache(),
              tokenCache = createCache(),
              compilerCache = createCache(),
              hasDuplicate = false,
              sortOrder = function() {
                return 0;
            },
              // General-purpose constants
              strundefined = typeof undefined,
              MAX_NEGATIVE = 1 << 31,
              // Instance methods
              hasOwn = ({
            }).hasOwnProperty,
              arr = [
            ],
              pop = arr.pop,
              push_native = arr.push,
              push = arr.push,
              slice = arr.slice,
              // Use a stripped-down indexOf if we can't use a native one
              indexOf = arr.indexOf || function(elem) {
                var i = 0,
                  len = this.length;
                for (; i < len; i++) {
                    if (this[i] === elem) {
                        return i;
                    }
                }
                return -1;
            },
              booleans = "checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|ismap|loop|multiple|open|readonly|required|scoped",
              // Regular expressions

              // Whitespace characters http://www.w3.org/TR/css3-selectors/#whitespace
              whitespace = "[\\x20\\t\\r\\n\\f]",
              // http://www.w3.org/TR/css3-syntax/#characters
              characterEncoding = "(?:\\\\.|[\\w-]|[^\\x00-\\xa0])+",
              // Loosely modeled on CSS identifier characters
              // An unquoted value should be a CSS identifier http://www.w3.org/TR/css3-selectors/#attribute-selectors
              // Proper syntax: http://www.w3.org/TR/CSS21/syndata.html#value-def-identifier
              identifier = characterEncoding.replace("w", "w#"),
              // Acceptable operators http://www.w3.org/TR/selectors/#attribute-selectors
              attributes = "\\[" + whitespace + "*(" + characterEncoding + ")" + whitespace +
              "*(?:([*^$|!~]?=)" + whitespace + "*(?:(['\"])((?:\\\\.|[^\\\\])*?)\\3|(" + identifier + ")|)|)" + whitespace + "*\\]",
              // Prefer arguments quoted,
              //   then not containing pseudos/brackets,
              //   then attribute selectors/non-parenthetical expressions,
              //   then anything else
              // These preferences are here to reduce the number of selectors
              //   needing tokenize in the PSEUDO preFilter
              pseudos = ":(" + characterEncoding + ")(?:\\(((['\"])((?:\\\\.|[^\\\\])*?)\\3|((?:\\\\.|[^\\\\()[\\]]|" + attributes.replace(3, 8) + ")*)|.*)\\)|)",
              // Leading and non-escaped trailing whitespace, capturing some non-whitespace characters preceding the latter
              rtrim = new RegExp("^" + whitespace + "+|((?:^|[^\\\\])(?:\\\\.)*)" + whitespace + "+$", "g"),
              rcomma = new RegExp("^" + whitespace + "*," + whitespace + "*"),
              rcombinators = new RegExp("^" + whitespace + "*([>+~]|" + whitespace + ")" + whitespace + "*"),
              rsibling = new RegExp(whitespace + "*[+~]"),
              rattributeQuotes = new RegExp("=" + whitespace + "*([^\\]'\"]*)" + whitespace + "*\\]", "g"),
              rpseudo = new RegExp(pseudos),
              ridentifier = new RegExp("^" + identifier + "$"),
              matchExpr = {
                "ID": new RegExp("^#(" + characterEncoding + ")"),
                "CLASS": new RegExp("^\\.(" + characterEncoding + ")"),
                "TAG": new RegExp("^(" + characterEncoding.replace("w", "w*") + ")"),
                "ATTR": new RegExp("^" + attributes),
                "PSEUDO": new RegExp("^" + pseudos),
                "CHILD": new RegExp("^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\(" + whitespace +
                  "*(even|odd|(([+-]|)(\\d*)n|)" + whitespace + "*(?:([+-]|)" + whitespace +
                  "*(\\d+)|))" + whitespace + "*\\)|)", "i"),
                "bool": new RegExp("^(?:" + booleans + ")$", "i"),
                // For use in libraries implementing .is()
                // We use this for POS matching in `select`
                "needsContext": new RegExp("^" + whitespace + "*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\(" +
                  whitespace + "*((?:-\\d)?\\d*)" + whitespace + "*\\)|)(?=[^-]|$)", "i")
            },
            rnative = /^[^{]+\{\s*\[native \w/,
              // Easily-parseable/retrievable ID or TAG or CLASS selectors
              rquickExpr = /^(?:#([\w-]+)|(\w+)|\.([\w-]+))$/,
              rinputs = /^(?:input|select|textarea|button)$/i,
              rheader = /^h\d$/i,
              rescape = /'|\\/g,
              // CSS escapes http://www.w3.org/TR/CSS21/syndata.html#escaped-characters
              runescape = new RegExp("\\\\([\\da-f]{1,6}" + whitespace + "?|(" + whitespace + ")|.)", "ig"),
              funescape = function(_, escaped, escapedWhitespace) {
                var high = "0x" + escaped - 0x10000;
                // NaN means non-codepoint
                // Support: Firefox
                // Workaround erroneous numeric interpretation of +"0x"
                return high !== high || escapedWhitespace ?
                  escaped :
                  // BMP codepoint
                  high < 0 ?
                  String.fromCharCode(high + 0x10000) :
                  // Supplemental Plane codepoint (surrogate pair)
                  String.fromCharCode(high >> 10 | 0xD800, high & 0x3FF | 0xDC00);
            };

// Optimize for push.apply( _, NodeList )
            try {
                push.apply(
                  (arr = slice.call(preferredDoc.childNodes)),
                  preferredDoc.childNodes
                  );
                // Support: Android<4.0
                // Detect silently failing push.apply
                arr[ preferredDoc.childNodes.length ].nodeType;
            } catch (e) {
                push = {
                    apply: arr.length ?
                      // Leverage slice if possible
                        function(target, els) {
                            push_native.apply(target, slice.call(els));
                        } :
                        // Support: IE<9
                          // Otherwise append directly
                            function(target, els) {
                                var j = target.length,
                                  i = 0;
                                // Can't trust NodeList.length
                                while ((target[j++] = els[i++])) {
                                }
                                target.length = j - 1;
                            }
                      };
                }

              function Sizzle(selector, context, results, seed) {
                  var match, elem, m, nodeType,
                    // QSA vars
                    i, groups, old, nid, newContext, newSelector;

                  if ((context ? context.ownerDocument || context : preferredDoc) !== document) {
                      setDocument(context);
                  }

                  context = context || document;
                  results = results || [
                  ];

                  if (!selector || typeof selector !== "string") {
                      return results;
                  }

                  if ((nodeType = context.nodeType) !== 1 && nodeType !== 9) {
                      return [
                      ];
                  }

                  if (documentIsHTML && !seed) {

                      // Shortcuts
                      if ((match = rquickExpr.exec(selector))) {
                          // Speed-up: Sizzle("#ID")
                          if ((m = match[1])) {
                              if (nodeType === 9) {
                                  elem = context.getElementById(m);
                                  // Check parentNode to catch when Blackberry 4.6 returns
                                  // nodes that are no longer in the document #6963
                                  if (elem && elem.parentNode) {
                                      // Handle the case where IE, Opera, and Webkit return items
                                      // by name instead of ID
                                      if (elem.id === m) {
                                          results.push(elem);
                                          return results;
                                      }
                                  } else {
                                      return results;
                                  }
                              } else {
                                  // Context is not a document
                                  if (context.ownerDocument && (elem = context.ownerDocument.getElementById(m)) &&
                                    contains(context, elem) && elem.id === m) {
                                      results.push(elem);
                                      return results;
                                  }
                              }

                              // Speed-up: Sizzle("TAG")
                          } else if (match[2]) {
                              push.apply(results, context.getElementsByTagName(selector));
                              return results;

                              // Speed-up: Sizzle(".CLASS")
                          } else if ((m = match[3]) && support.getElementsByClassName && context.getElementsByClassName) {
                              push.apply(results, context.getElementsByClassName(m));
                              return results;
                          }
                      }

                      // QSA path
                      if (support.qsa && (!rbuggyQSA || !rbuggyQSA.test(selector))) {
                          nid = old = expando;
                          newContext = context;
                          newSelector = nodeType === 9 && selector;

                          // qSA works strangely on Element-rooted queries
                          // We can work around this by specifying an extra ID on the root
                          // and working up from there (Thanks to Andrew Dupont for the technique)
                          // IE 8 doesn't work on object elements
                          if (nodeType === 1 && context.nodeName.toLowerCase() !== "object") {
                              groups = tokenize(selector);

                              if ((old = context.getAttribute("id"))) {
                                  nid = old.replace(rescape, "\\$&");
                              } else {
                                  context.setAttribute("id", nid);
                              }
                              nid = "[id='" + nid + "'] ";

                              i = groups.length;
                              while (i--) {
                                  groups[i] = nid + toSelector(groups[i]);
                              }
                              newContext = rsibling.test(selector) && context.parentNode || context;
                              newSelector = groups.join(",");
                          }

                          if (newSelector) {
                              try {
                                  push.apply(results,
                                    newContext.querySelectorAll(newSelector)
                                    );
                                  return results;
                              } catch (qsaError) {
                              } finally {
                                  if (!old) {
                                      context.removeAttribute("id");
                                  }
                              }
                          }
                      }
                  }

                  // All others
                  return select(selector.replace(rtrim, "$1"), context, results, seed);
              }

              /**
               * For feature detection
               * @param {Function} fn The function to test for native support
               */
              function isNative(fn) {
                  return rnative.test(fn + "");
              }

              /**
               * Create key-value caches of limited size
               * @returns {Function(string, Object)} Returns the Object data after storing it on itself with
               *	property name the (space-suffixed) string and (if the cache is larger than Expr.cacheLength)
               *	deleting the oldest entry
               */
              function createCache() {
                  var keys = [
                  ];

                  function cache(key, value) {
                      // Use (key + " ") to avoid collision with native prototype properties (see Issue #157)
                      if (keys.push(key += " ") > Expr.cacheLength) {
                          // Only keep the most recent entries
                          delete cache[ keys.shift() ];
                      }
                      return (cache[ key ] = value);
                  }
                  return cache;
              }

              /**
               * Mark a function for special use by Sizzle
               * @param {Function} fn The function to mark
               */
              function markFunction(fn) {
                  fn[ expando ] = true;
                  return fn;
              }

              /**
               * Support testing using an element
               * @param {Function} fn Passed the created div and expects a boolean result
               */
              function assert(fn) {
                  var div = document.createElement("div");

                  try {
                      return !!fn(div);
                  } catch (e) {
                      return false;
                  } finally {
                      // Remove from its parent by default
                      if (div.parentNode) {
                          div.parentNode.removeChild(div);
                      }
                      // release memory in IE
                      div = null;
                  }
              }

              /**
               * Adds the same handler for all of the specified attrs
               * @param {String} attrs Pipe-separated list of attributes
               * @param {Function} handler The method that will be applied if the test fails
               * @param {Boolean} test The result of a test. If true, null will be set as the handler in leiu of the specified handler
               */
              function addHandle(attrs, handler, test) {
                  attrs = attrs.split("|");
                  var current,
                    i = attrs.length,
                    setHandle = test ? null : handler;

                  while (i--) {
                      // Don't override a user's handler
                      if (!(current = Expr.attrHandle[ attrs[i] ]) || current === handler) {
                          Expr.attrHandle[ attrs[i] ] = setHandle;
                      }
                  }
              }

              /**
               * Fetches boolean attributes by node
               * @param {Element} elem
               * @param {String} name
               */
              function boolHandler(elem, name) {
                  // XML does not need to be checked as this will not be assigned for XML documents
                  var val = elem.getAttributeNode(name);
                  return val && val.specified ?
                    val.value :
                    elem[ name ] === true ? name.toLowerCase() : null;
              }

              /**
               * Fetches attributes without interpolation
               * http://msdn.microsoft.com/en-us/library/ms536429%28VS.85%29.aspx
               * @param {Element} elem
               * @param {String} name
               */
              function interpolationHandler(elem, name) {
                  // XML does not need to be checked as this will not be assigned for XML documents
                  return elem.getAttribute(name, name.toLowerCase() === "type" ? 1 : 2);
              }

              /**
               * Uses defaultValue to retrieve value in IE6/7
               * @param {Element} elem
               * @param {String} name
               */
              function valueHandler(elem) {
                  // Ignore the value *property* on inputs by using defaultValue
                  // Fallback to Sizzle.attr by returning undefined where appropriate
                  // XML does not need to be checked as this will not be assigned for XML documents
                  if (elem.nodeName.toLowerCase() === "input") {
                      return elem.defaultValue;
                  }
              }

              /**
               * Checks document order of two siblings
               * @param {Element} a
               * @param {Element} b
               * @returns Returns -1 if a precedes b, 1 if a follows b
               */
              function siblingCheck(a, b) {
                  var cur = b && a,
                    diff = cur && a.nodeType === 1 && b.nodeType === 1 &&
                    (~b.sourceIndex || MAX_NEGATIVE) -
                    (~a.sourceIndex || MAX_NEGATIVE);

                  // Use IE sourceIndex if available on both nodes
                  if (diff) {
                      return diff;
                  }

                  // Check if b follows a
                  if (cur) {
                      while ((cur = cur.nextSibling)) {
                          if (cur === b) {
                              return -1;
                          }
                      }
                  }

                  return a ? 1 : -1;
              }

              /**
               * Returns a function to use in pseudos for input types
               * @param {String} type
               */
              function createInputPseudo(type) {
                  return function(elem) {
                      var name = elem.nodeName.toLowerCase();
                      return name === "input" && elem.type === type;
                  };
              }

              /**
               * Returns a function to use in pseudos for buttons
               * @param {String} type
               */
              function createButtonPseudo(type) {
                  return function(elem) {
                      var name = elem.nodeName.toLowerCase();
                      return (name === "input" || name === "button") && elem.type === type;
                  };
              }

              /**
               * Returns a function to use in pseudos for positionals
               * @param {Function} fn
               */
              function createPositionalPseudo(fn) {
                  return markFunction(function(argument) {
                      argument = +argument;
                      return markFunction(function(seed, matches) {
                          var j,
                            matchIndexes = fn([
                          ], seed.length, argument),
                            i = matchIndexes.length;

                          // Match elements found at the specified indexes
                          while (i--) {
                              if (seed[ (j = matchIndexes[i]) ]) {
                                  seed[j] = !(matches[j] = seed[j]);
                              }
                          }
                      });
                  });
              }

              /**
               * Detect xml
               * @param {Element|Object} elem An element or a document
               */
              isXML = Sizzle.isXML = function(elem) {
                  // documentElement is verified for cases where it doesn't yet exist
                  // (such as loading iframes in IE - #4833)
                  var documentElement = elem && (elem.ownerDocument || elem).documentElement;
                  return documentElement ? documentElement.nodeName !== "HTML" : false;
              };

// Expose support vars for convenience
              support = Sizzle.support = {
              };

              /**
               * Sets document-related variables once based on the current document
               * @param {Element|Object} [doc] An element or document object to use to set the document
               * @returns {Object} Returns the current document
               */
              setDocument = Sizzle.setDocument = function(node) {
                  var doc = node ? node.ownerDocument || node : preferredDoc,
                    parent = doc.parentWindow;

                  // If no document and documentElement is available, return
                  if (doc === document || doc.nodeType !== 9 || !doc.documentElement) {
                      return document;
                  }

                  // Set our document
                  document = doc;
                  docElem = doc.documentElement;

                  // Support tests
                  documentIsHTML = !isXML(doc);

                  // Support: IE>8
                  // If iframe document is assigned to "document" variable and if iframe has been reloaded,
                  // IE will throw "permission denied" error when accessing "document" variable, see jQuery #13936
                  if (parent && parent.frameElement) {
                      parent.attachEvent("onbeforeunload", function() {
                          setDocument();
                      });
                  }

                  /* Attributes
                   ---------------------------------------------------------------------- */

                  // Support: IE<8
                  // Verify that getAttribute really returns attributes and not properties (excepting IE8 booleans)
                  support.attributes = assert(function(div) {

                      // Support: IE<8
                      // Prevent attribute/property "interpolation"
                      div.innerHTML = "<a href='#'></a>";
                      addHandle("type|href|height|width", interpolationHandler, div.firstChild.getAttribute("href") === "#");

                      // Support: IE<9
                      // Use getAttributeNode to fetch booleans when getAttribute lies
                      addHandle(booleans, boolHandler, div.getAttribute("disabled") == null);

                      div.className = "i";
                      return !div.getAttribute("className");
                  });

                  // Support: IE<9
                  // Retrieving value should defer to defaultValue
                  support.input = assert(function(div) {
                      div.innerHTML = "<input>";
                      div.firstChild.setAttribute("value", "");
                      return div.firstChild.getAttribute("value") === "";
                  });

                  // IE6/7 still return empty string for value,
                  // but are actually retrieving the property
                  addHandle("value", valueHandler, support.attributes && support.input);

                  /* getElement(s)By*
                   ---------------------------------------------------------------------- */

                  // Check if getElementsByTagName("*") returns only elements
                  support.getElementsByTagName = assert(function(div) {
                      div.appendChild(doc.createComment(""));
                      return !div.getElementsByTagName("*").length;
                  });

                  // Check if getElementsByClassName can be trusted
                  support.getElementsByClassName = assert(function(div) {
                      div.innerHTML = "<div class='a'></div><div class='a i'></div>";

                      // Support: Safari<4
                      // Catch class over-caching
                      div.firstChild.className = "i";
                      // Support: Opera<10
                      // Catch gEBCN failure to find non-leading classes
                      return div.getElementsByClassName("i").length === 2;
                  });

                  // Support: IE<10
                  // Check if getElementById returns elements by name
                  // The broken getElementById methods don't pick up programatically-set names,
                  // so use a roundabout getElementsByName test
                  support.getById = assert(function(div) {
                      docElem.appendChild(div).id = expando;
                      return !doc.getElementsByName || !doc.getElementsByName(expando).length;
                  });

                  // ID find and filter
                  if (support.getById) {
                      Expr.find["ID"] = function(id, context) {
                          if (typeof context.getElementById !== strundefined && documentIsHTML) {
                              var m = context.getElementById(id);
                              // Check parentNode to catch when Blackberry 4.6 returns
                              // nodes that are no longer in the document #6963
                              return m && m.parentNode ? [
                                  m
                              ] : [
                              ];
                          }
                      };
                      Expr.filter["ID"] = function(id) {
                          var attrId = id.replace(runescape, funescape);
                          return function(elem) {
                              return elem.getAttribute("id") === attrId;
                          };
                      };
                  } else {
                      // Support: IE6/7
                      // getElementById is not reliable as a find shortcut
                      delete Expr.find["ID"];

                      Expr.filter["ID"] = function(id) {
                          var attrId = id.replace(runescape, funescape);
                          return function(elem) {
                              var node = typeof elem.getAttributeNode !== strundefined && elem.getAttributeNode("id");
                              return node && node.value === attrId;
                          };
                      };
                  }

                  // Tag
                  Expr.find["TAG"] = support.getElementsByTagName ?
                    function(tag, context) {
                        if (typeof context.getElementsByTagName !== strundefined) {
                            return context.getElementsByTagName(tag);
                        }
                    } :
                    function(tag, context) {
                        var elem,
                          tmp = [
                        ],
                          i = 0,
                          results = context.getElementsByTagName(tag);

                        // Filter out possible comments
                        if (tag === "*") {
                            while ((elem = results[i++])) {
                                if (elem.nodeType === 1) {
                                    tmp.push(elem);
                                }
                            }

                            return tmp;
                        }
                        return results;
                    };

                  // Class
                  Expr.find["CLASS"] = support.getElementsByClassName && function(className, context) {
                      if (typeof context.getElementsByClassName !== strundefined && documentIsHTML) {
                          return context.getElementsByClassName(className);
                      }
                  };

                  /* QSA/matchesSelector
                   ---------------------------------------------------------------------- */

                  // QSA and matchesSelector support

                  // matchesSelector(:active) reports false when true (IE9/Opera 11.5)
                  rbuggyMatches = [
                  ];

                  // qSa(:focus) reports false when true (Chrome 21)
                  // We allow this because of a bug in IE8/9 that throws an error
                  // whenever `document.activeElement` is accessed on an iframe
                  // So, we allow :focus to pass through QSA all the time to avoid the IE error
                  // See http://bugs.jquery.com/ticket/13378
                  rbuggyQSA = [
                  ];

                  if ((support.qsa = isNative(doc.querySelectorAll))) {
                      // Build QSA regex
                      // Regex strategy adopted from Diego Perini
                      assert(function(div) {
                          // Select is set to empty string on purpose
                          // This is to test IE's treatment of not explicitly
                          // setting a boolean content attribute,
                          // since its presence should be enough
                          // http://bugs.jquery.com/ticket/12359
                          div.innerHTML = "<select><option selected=''></option></select>";

                          // Support: IE8
                          // Boolean attributes and "value" are not treated correctly
                          if (!div.querySelectorAll("[selected]").length) {
                              rbuggyQSA.push("\\[" + whitespace + "*(?:value|" + booleans + ")");
                          }

                          // Webkit/Opera - :checked should return selected option elements
                          // http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked
                          // IE8 throws error here and will not see later tests
                          if (!div.querySelectorAll(":checked").length) {
                              rbuggyQSA.push(":checked");
                          }
                      });

                      assert(function(div) {

                          // Support: Opera 10-12/IE8
                          // ^= $= *= and empty values
                          // Should not select anything
                          // Support: Windows 8 Native Apps
                          // The type attribute is restricted during .innerHTML assignment
                          var input = doc.createElement("input");
                          input.setAttribute("type", "hidden");
                          div.appendChild(input).setAttribute("t", "");

                          if (div.querySelectorAll("[t^='']").length) {
                              rbuggyQSA.push("[*^$]=" + whitespace + "*(?:''|\"\")");
                          }

                          // FF 3.5 - :enabled/:disabled and hidden elements (hidden elements are still enabled)
                          // IE8 throws error here and will not see later tests
                          if (!div.querySelectorAll(":enabled").length) {
                              rbuggyQSA.push(":enabled", ":disabled");
                          }

                          // Opera 10-11 does not throw on post-comma invalid pseudos
                          div.querySelectorAll("*,:x");
                          rbuggyQSA.push(",.*:");
                      });
                  }

                  if ((support.matchesSelector = isNative((matches = docElem.webkitMatchesSelector ||
                    docElem.mozMatchesSelector ||
                    docElem.oMatchesSelector ||
                    docElem.msMatchesSelector)))) {

                      assert(function(div) {
                          // Check to see if it's possible to do matchesSelector
                          // on a disconnected node (IE 9)
                          support.disconnectedMatch = matches.call(div, "div");

                          // This should fail with an exception
                          // Gecko does not error, returns false instead
                          matches.call(div, "[s!='']:x");
                          rbuggyMatches.push("!=", pseudos);
                      });
                  }

                  rbuggyQSA = rbuggyQSA.length && new RegExp(rbuggyQSA.join("|"));
                  rbuggyMatches = rbuggyMatches.length && new RegExp(rbuggyMatches.join("|"));

                  /* Contains
                   ---------------------------------------------------------------------- */

                  // Element contains another
                  // Purposefully does not implement inclusive descendent
                  // As in, an element does not contain itself
                  contains = isNative(docElem.contains) || docElem.compareDocumentPosition ?
                    function(a, b) {
                        var adown = a.nodeType === 9 ? a.documentElement : a,
                          bup = b && b.parentNode;
                        return a === bup || !!(bup && bup.nodeType === 1 && (
                          adown.contains ?
                          adown.contains(bup) :
                          a.compareDocumentPosition && a.compareDocumentPosition(bup) & 16
                          ));
                    } :
                    function(a, b) {
                        if (b) {
                            while ((b = b.parentNode)) {
                                if (b === a) {
                                    return true;
                                }
                            }
                        }
                        return false;
                    };

                  /* Sorting
                   ---------------------------------------------------------------------- */

                  // Support: Webkit<537.32 - Safari 6.0.3/Chrome 25 (fixed in Chrome 27)
                  // Detached nodes confoundingly follow *each other*
                  support.sortDetached = assert(function(div1) {
                      // Should return 1, but returns 4 (following)
                      return div1.compareDocumentPosition(doc.createElement("div")) & 1;
                  });

                  // Document order sorting
                  sortOrder = docElem.compareDocumentPosition ?
                    function(a, b) {

                        // Flag for duplicate removal
                        if (a === b) {
                            hasDuplicate = true;
                            return 0;
                        }

                        var compare = b.compareDocumentPosition && a.compareDocumentPosition && a.compareDocumentPosition(b);

                        if (compare) {
                            // Disconnected nodes
                            if (compare & 1 ||
                              (!support.sortDetached && b.compareDocumentPosition(a) === compare)) {

                                // Choose the first element that is related to our preferred document
                                if (a === doc || contains(preferredDoc, a)) {
                                    return -1;
                                }
                                if (b === doc || contains(preferredDoc, b)) {
                                    return 1;
                                }

                                // Maintain original order
                                return sortInput ?
                                  (indexOf.call(sortInput, a) - indexOf.call(sortInput, b)) :
                                  0;
                            }

                            return compare & 4 ? -1 : 1;
                        }

                        // Not directly comparable, sort on existence of method
                        return a.compareDocumentPosition ? -1 : 1;
                    } :
                    function(a, b) {
                        var cur,
                          i = 0,
                          aup = a.parentNode,
                          bup = b.parentNode,
                          ap = [
                            a
                        ],
                          bp = [
                            b
                        ];

                        // Exit early if the nodes are identical
                        if (a === b) {
                            hasDuplicate = true;
                            return 0;

                            // Parentless nodes are either documents or disconnected
                        } else if (!aup || !bup) {
                            return a === doc ? -1 :
                              b === doc ? 1 :
                              aup ? -1 :
                              bup ? 1 :
                              sortInput ?
                              (indexOf.call(sortInput, a) - indexOf.call(sortInput, b)) :
                              0;

                            // If the nodes are siblings, we can do a quick check
                        } else if (aup === bup) {
                            return siblingCheck(a, b);
                        }

                        // Otherwise we need full lists of their ancestors for comparison
                        cur = a;
                        while ((cur = cur.parentNode)) {
                            ap.unshift(cur);
                        }
                        cur = b;
                        while ((cur = cur.parentNode)) {
                            bp.unshift(cur);
                        }

                        // Walk down the tree looking for a discrepancy
                        while (ap[i] === bp[i]) {
                            i++;
                        }

                        return i ?
                          // Do a sibling check if the nodes have a common ancestor
                          siblingCheck(ap[i], bp[i]) :
                          // Otherwise nodes in our document sort first
                          ap[i] === preferredDoc ? -1 :
                          bp[i] === preferredDoc ? 1 :
                          0;
                    };

                  return doc;
              };

              Sizzle.matches = function(expr, elements) {
                  return Sizzle(expr, null, null, elements);
              };

              Sizzle.matchesSelector = function(elem, expr) {
                  // Set document vars if needed
                  if ((elem.ownerDocument || elem) !== document) {
                      setDocument(elem);
                  }

                  // Make sure that attribute selectors are quoted
                  expr = expr.replace(rattributeQuotes, "='$1']");

                  if (support.matchesSelector && documentIsHTML &&
                    (!rbuggyMatches || !rbuggyMatches.test(expr)) &&
                    (!rbuggyQSA || !rbuggyQSA.test(expr))) {

                      try {
                          var ret = matches.call(elem, expr);

                          // IE 9's matchesSelector returns false on disconnected nodes
                          if (ret || support.disconnectedMatch ||
                            // As well, disconnected nodes are said to be in a document
                            // fragment in IE 9
                            elem.document && elem.document.nodeType !== 11) {
                              return ret;
                          }
                      } catch (e) {
                      }
                  }

                  return Sizzle(expr, document, null, [
                      elem
                  ]).length > 0;
              };

              Sizzle.contains = function(context, elem) {
                  // Set document vars if needed
                  if ((context.ownerDocument || context) !== document) {
                      setDocument(context);
                  }
                  return contains(context, elem);
              };

              Sizzle.attr = function(elem, name) {
                  // Set document vars if needed
                  if ((elem.ownerDocument || elem) !== document) {
                      setDocument(elem);
                  }

                  var fn = Expr.attrHandle[ name.toLowerCase() ],
                    // Don't get fooled by Object.prototype properties (jQuery #13807)
                    val = (fn && hasOwn.call(Expr.attrHandle, name.toLowerCase()) ?
                    fn(elem, name, !documentIsHTML) :
                    undefined);

                  return val === undefined ?
                    support.attributes || !documentIsHTML ?
                    elem.getAttribute(name) :
                    (val = elem.getAttributeNode(name)) && val.specified ?
                    val.value :
                    null :
                    val;
              };

              Sizzle.error = function(msg) {
                  throw new Error("Syntax error, unrecognized expression: " + msg);
              };

              /**
               * Document sorting and removing duplicates
               * @param {ArrayLike} results
               */
              Sizzle.uniqueSort = function(results) {
                  var elem,
                    duplicates = [
                  ],
                    j = 0,
                    i = 0;

                  // Unless we *know* we can detect duplicates, assume their presence
                  hasDuplicate = !support.detectDuplicates;
                  sortInput = !support.sortStable && results.slice(0);
                  results.sort(sortOrder);

                  if (hasDuplicate) {
                      while ((elem = results[i++])) {
                          if (elem === results[ i ]) {
                              j = duplicates.push(i);
                          }
                      }
                      while (j--) {
                          results.splice(duplicates[ j ], 1);
                      }
                  }

                  return results;
              };

              /**
               * Utility function for retrieving the text value of an array of DOM nodes
               * @param {Array|Element} elem
               */
              getText = Sizzle.getText = function(elem) {
                  var node,
                    ret = "",
                    i = 0,
                    nodeType = elem.nodeType;

                  if (!nodeType) {
                      // If no nodeType, this is expected to be an array
                      for (; (node = elem[i]); i++) {
                          // Do not traverse comment nodes
                          ret += getText(node);
                      }
                  } else if (nodeType === 1 || nodeType === 9 || nodeType === 11) {
                      // Use textContent for elements
                      // innerText usage removed for consistency of new lines (see #11153)
                      if (typeof elem.textContent === "string") {
                          return elem.textContent;
                      } else {
                          // Traverse its children
                          for (elem = elem.firstChild; elem; elem = elem.nextSibling) {
                              ret += getText(elem);
                          }
                      }
                  } else if (nodeType === 3 || nodeType === 4) {
                      return elem.nodeValue;
                  }
                  // Do not include comment or processing instruction nodes

                  return ret;
              };

              Expr = Sizzle.selectors = {
                  // Can be adjusted by the user
                  cacheLength: 50,
                  createPseudo: markFunction,
                  match: matchExpr,
                  attrHandle: {
                  },
                  find: {
                  },
                  relative: {
                      ">": {
                          dir: "parentNode",
                          first: true
                      },
                      " ": {
                          dir: "parentNode"
                      },
                      "+": {
                          dir: "previousSibling",
                          first: true
                      },
                      "~": {
                          dir: "previousSibling"
                      }
                  },
                  preFilter: {
                      "ATTR": function(match) {
                          match[1] = match[1].replace(runescape, funescape);

                          // Move the given value to match[3] whether quoted or unquoted
                          match[3] = (match[4] || match[5] || "").replace(runescape, funescape);

                          if (match[2] === "~=") {
                              match[3] = " " + match[3] + " ";
                          }

                          return match.slice(0, 4);
                      },
                      "CHILD": function(match) {
                          /* matches from matchExpr["CHILD"]
                           1 type (only|nth|...)
                           2 what (child|of-type)
                           3 argument (even|odd|\d*|\d*n([+-]\d+)?|...)
                           4 xn-component of xn+y argument ([+-]?\d*n|)
                           5 sign of xn-component
                           6 x of xn-component
                           7 sign of y-component
                           8 y of y-component
                           */
                          match[1] = match[1].toLowerCase();

                          if (match[1].slice(0, 3) === "nth") {
                              // nth-* requires argument
                              if (!match[3]) {
                                  Sizzle.error(match[0]);
                              }

                              // numeric x and y parameters for Expr.filter.CHILD
                              // remember that false/true cast respectively to 0/1
                              match[4] = +(match[4] ? match[5] + (match[6] || 1) : 2 * (match[3] === "even" || match[3] === "odd"));
                              match[5] = +((match[7] + match[8]) || match[3] === "odd");

                              // other types prohibit arguments
                          } else if (match[3]) {
                              Sizzle.error(match[0]);
                          }

                          return match;
                      },
                      "PSEUDO": function(match) {
                          var excess,
                            unquoted = !match[5] && match[2];

                          if (matchExpr["CHILD"].test(match[0])) {
                              return null;
                          }

                          // Accept quoted arguments as-is
                          if (match[3] && match[4] !== undefined) {
                              match[2] = match[4];

                              // Strip excess characters from unquoted arguments
                          } else if (unquoted && rpseudo.test(unquoted) &&
                            // Get excess from tokenize (recursively)
                              (excess = tokenize(unquoted, true)) &&
                              // advance to the next closing parenthesis
                                (excess = unquoted.indexOf(")", unquoted.length - excess) - unquoted.length)) {

                              // excess is a negative index
                              match[0] = match[0].slice(0, excess);
                              match[2] = unquoted.slice(0, excess);
                          }

                          // Return only captures needed by the pseudo filter method (type and argument)
                          return match.slice(0, 3);
                      }
                  },
                  filter: {
                      "TAG": function(nodeNameSelector) {
                          var nodeName = nodeNameSelector.replace(runescape, funescape).toLowerCase();
                          return nodeNameSelector === "*" ?
                            function() {
                                return true;
                            } :
                            function(elem) {
                                return elem.nodeName && elem.nodeName.toLowerCase() === nodeName;
                            };
                      },
                      "CLASS": function(className) {
                          var pattern = classCache[ className + " " ];

                          return pattern ||
                            (pattern = new RegExp("(^|" + whitespace + ")" + className + "(" + whitespace + "|$)")) &&
                            classCache(className, function(elem) {
                              return pattern.test(typeof elem.className === "string" && elem.className || typeof elem.getAttribute !== strundefined && elem.getAttribute("class") || "");
                          });
                      },
                      "ATTR": function(name, operator, check) {
                          return function(elem) {
                              var result = Sizzle.attr(elem, name);

                              if (result == null) {
                                  return operator === "!=";
                              }
                              if (!operator) {
                                  return true;
                              }

                              result += "";

                              return operator === "=" ? result === check :
                                operator === "!=" ? result !== check :
                                operator === "^=" ? check && result.indexOf(check) === 0 :
                                operator === "*=" ? check && result.indexOf(check) > -1 :
                                operator === "$=" ? check && result.slice(-check.length) === check :
                                operator === "~=" ? (" " + result + " ").indexOf(check) > -1 :
                                operator === "|=" ? result === check || result.slice(0, check.length + 1) === check + "-" :
                                false;
                          };
                      },
                      "CHILD": function(type, what, argument, first, last) {
                          var simple = type.slice(0, 3) !== "nth",
                            forward = type.slice(-4) !== "last",
                            ofType = what === "of-type";

                          return first === 1 && last === 0 ?
                            // Shortcut for :nth-*(n)
                              function(elem) {
                                  return !!elem.parentNode;
                              } :
                              function(elem, context, xml) {
                                  var cache, outerCache, node, diff, nodeIndex, start,
                                    dir = simple !== forward ? "nextSibling" : "previousSibling",
                                    parent = elem.parentNode,
                                    name = ofType && elem.nodeName.toLowerCase(),
                                    useCache = !xml && !ofType;

                                  if (parent) {

                                      // :(first|last|only)-(child|of-type)
                                      if (simple) {
                                          while (dir) {
                                              node = elem;
                                              while ((node = node[ dir ])) {
                                                  if (ofType ? node.nodeName.toLowerCase() === name : node.nodeType === 1) {
                                                      return false;
                                                  }
                                              }
                                              // Reverse direction for :only-* (if we haven't yet done so)
                                              start = dir = type === "only" && !start && "nextSibling";
                                          }
                                          return true;
                                      }

                                      start = [
                                          forward ? parent.firstChild : parent.lastChild
                                      ];

                                      // non-xml :nth-child(...) stores cache data on `parent`
                                      if (forward && useCache) {
                                          // Seek `elem` from a previously-cached index
                                          outerCache = parent[ expando ] || (parent[ expando ] = {
                                          });
                                          cache = outerCache[ type ] || [
                                          ];
                                          nodeIndex = cache[0] === dirruns && cache[1];
                                          diff = cache[0] === dirruns && cache[2];
                                          node = nodeIndex && parent.childNodes[ nodeIndex ];

                                          while ((node = ++nodeIndex && node && node[ dir ] ||
                                            // Fallback to seeking `elem` from the start
                                              (diff = nodeIndex = 0) || start.pop())) {

                                              // When found, cache indexes on `parent` and break
                                              if (node.nodeType === 1 && ++diff && node === elem) {
                                                  outerCache[ type ] = [
                                                      dirruns,
                                                      nodeIndex,
                                                      diff
                                                  ];
                                                  break;
                                              }
                                          }

                                          // Use previously-cached element index if available
                                      } else if (useCache && (cache = (elem[ expando ] || (elem[ expando ] = {
                                      }))[ type ]) && cache[0] === dirruns) {
                                          diff = cache[1];

                                          // xml :nth-child(...) or :nth-last-child(...) or :nth(-last)?-of-type(...)
                                      } else {
                                          // Use the same loop as above to seek `elem` from the start
                                          while ((node = ++nodeIndex && node && node[ dir ] ||
                                            (diff = nodeIndex = 0) || start.pop())) {

                                              if ((ofType ? node.nodeName.toLowerCase() === name : node.nodeType === 1) && ++diff) {
                                                  // Cache the index of each encountered element
                                                  if (useCache) {
                                                      (node[ expando ] || (node[ expando ] = {
                                                      }))[ type ] = [
                                                          dirruns,
                                                          diff
                                                      ];
                                                  }

                                                  if (node === elem) {
                                                      break;
                                                  }
                                              }
                                          }
                                      }

                                      // Incorporate the offset, then check against cycle size
                                      diff -= last;
                                      return diff === first || (diff % first === 0 && diff / first >= 0);
                                  }
                              };
                          },
                          "PSEUDO": function(pseudo, argument) {
                              // pseudo-class names are case-insensitive
                              // http://www.w3.org/TR/selectors/#pseudo-classes
                              // Prioritize by case sensitivity in case custom pseudos are added with uppercase letters
                              // Remember that setFilters inherits from pseudos
                              var args,
                                fn = Expr.pseudos[ pseudo ] || Expr.setFilters[ pseudo.toLowerCase() ] ||
                                Sizzle.error("unsupported pseudo: " + pseudo);

                              // The user may use createPseudo to indicate that
                              // arguments are needed to create the filter function
                              // just as Sizzle does
                              if (fn[ expando ]) {
                                  return fn(argument);
                              }

                              // But maintain support for old signatures
                              if (fn.length > 1) {
                                  args = [
                                      pseudo,
                                      pseudo,
                                      "",
                                      argument
                                  ];
                                  return Expr.setFilters.hasOwnProperty(pseudo.toLowerCase()) ?
                                    markFunction(function(seed, matches) {
                                      var idx,
                                        matched = fn(seed, argument),
                                        i = matched.length;
                                      while (i--) {
                                          idx = indexOf.call(seed, matched[i]);
                                          seed[ idx ] = !(matches[ idx ] = matched[i]);
                                      }
                                  }) :
                                    function(elem) {
                                        return fn(elem, 0, args);
                                    };
                              }

                              return fn;
                          }
                      },
                      pseudos: {
                          // Potentially complex pseudos
                          "not": markFunction(function(selector) {
                              // Trim the selector passed to compile
                              // to avoid treating leading and trailing
                              // spaces as combinators
                              var input = [
                              ],
                                results = [
                              ],
                                matcher = compile(selector.replace(rtrim, "$1"));

                              return matcher[ expando ] ?
                                markFunction(function(seed, matches, context, xml) {
                                  var elem,
                                    unmatched = matcher(seed, null, xml, [
                                  ]),
                                    i = seed.length;

                                  // Match elements unmatched by `matcher`
                                  while (i--) {
                                      if ((elem = unmatched[i])) {
                                          seed[i] = !(matches[i] = elem);
                                      }
                                  }
                              }) :
                                function(elem, context, xml) {
                                    input[0] = elem;
                                    matcher(input, null, xml, results);
                                    return !results.pop();
                                };
                          }),
                          "has": markFunction(function(selector) {
                              return function(elem) {
                                  return Sizzle(selector, elem).length > 0;
                              };
                          }),
                          "contains": markFunction(function(text) {
                              return function(elem) {
                                  return (elem.textContent || elem.innerText || getText(elem)).indexOf(text) > -1;
                              };
                          }),
                          // "Whether an element is represented by a :lang() selector
                          // is based solely on the element's language value
                          // being equal to the identifier C,
                          // or beginning with the identifier C immediately followed by "-".
                          // The matching of C against the element's language value is performed case-insensitively.
                          // The identifier C does not have to be a valid language name."
                          // http://www.w3.org/TR/selectors/#lang-pseudo
                          "lang": markFunction(function(lang) {
                              // lang value must be a valid identifier
                              if (!ridentifier.test(lang || "")) {
                                  Sizzle.error("unsupported lang: " + lang);
                              }
                              lang = lang.replace(runescape, funescape).toLowerCase();
                              return function(elem) {
                                  var elemLang;
                                  do {
                                      if ((elemLang = documentIsHTML ?
                                        elem.lang :
                                        elem.getAttribute("xml:lang") || elem.getAttribute("lang"))) {

                                          elemLang = elemLang.toLowerCase();
                                          return elemLang === lang || elemLang.indexOf(lang + "-") === 0;
                                      }
                                  } while ((elem = elem.parentNode) && elem.nodeType === 1);
                                  return false;
                              };
                          }),
                          // Miscellaneous
                          "target": function(elem) {
                              var hash = window.location && window.location.hash;
                              return hash && hash.slice(1) === elem.id;
                          },
                          "root": function(elem) {
                              return elem === docElem;
                          },
                          "focus": function(elem) {
                              return elem === document.activeElement && (!document.hasFocus || document.hasFocus()) && !!(elem.type || elem.href || ~elem.tabIndex);
                          },
                          // Boolean properties
                          "enabled": function(elem) {
                              return elem.disabled === false;
                          },
                          "disabled": function(elem) {
                              return elem.disabled === true;
                          },
                          "checked": function(elem) {
                              // In CSS3, :checked should return both checked and selected elements
                              // http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked
                              var nodeName = elem.nodeName.toLowerCase();
                              return (nodeName === "input" && !!elem.checked) || (nodeName === "option" && !!elem.selected);
                          },
                          "selected": function(elem) {
                              // Accessing this property makes selected-by-default
                              // options in Safari work properly
                              if (elem.parentNode) {
                                  elem.parentNode.selectedIndex;
                              }

                              return elem.selected === true;
                          },
                          // Contents
                          "empty": function(elem) {
                              // http://www.w3.org/TR/selectors/#empty-pseudo
                              // :empty is only affected by element nodes and content nodes(including text(3), cdata(4)),
                              //   not comment, processing instructions, or others
                              // Thanks to Diego Perini for the nodeName shortcut
                              //   Greater than "@" means alpha characters (specifically not starting with "#" or "?")
                              for (elem = elem.firstChild; elem; elem = elem.nextSibling) {
                                  if (elem.nodeName > "@" || elem.nodeType === 3 || elem.nodeType === 4) {
                                      return false;
                                  }
                              }
                              return true;
                          },
                          "parent": function(elem) {
                              return !Expr.pseudos["empty"](elem);
                          },
                          // Element/input types
                          "header": function(elem) {
                              return rheader.test(elem.nodeName);
                          },
                          "input": function(elem) {
                              return rinputs.test(elem.nodeName);
                          },
                          "button": function(elem) {
                              var name = elem.nodeName.toLowerCase();
                              return name === "input" && elem.type === "button" || name === "button";
                          },
                          "text": function(elem) {
                              var attr;
                              // IE6 and 7 will map elem.type to 'text' for new HTML5 types (search, etc)
                              // use getAttribute instead to test this case
                              return elem.nodeName.toLowerCase() === "input" &&
                                elem.type === "text" &&
                                ((attr = elem.getAttribute("type")) == null || attr.toLowerCase() === elem.type);
                          },
                          // Position-in-collection
                          "first": createPositionalPseudo(function() {
                              return [
                                  0
                              ];
                          }),
                          "last": createPositionalPseudo(function(matchIndexes, length) {
                              return [
                                  length - 1
                              ];
                          }),
                          "eq": createPositionalPseudo(function(matchIndexes, length, argument) {
                              return [
                                  argument < 0 ? argument + length : argument
                              ];
                          }),
                          "even": createPositionalPseudo(function(matchIndexes, length) {
                              var i = 0;
                              for (; i < length; i += 2) {
                                  matchIndexes.push(i);
                              }
                              return matchIndexes;
                          }),
                          "odd": createPositionalPseudo(function(matchIndexes, length) {
                              var i = 1;
                              for (; i < length; i += 2) {
                                  matchIndexes.push(i);
                              }
                              return matchIndexes;
                          }),
                          "lt": createPositionalPseudo(function(matchIndexes, length, argument) {
                              var i = argument < 0 ? argument + length : argument;
                              for (; --i >= 0; ) {
                                  matchIndexes.push(i);
                              }
                              return matchIndexes;
                          }),
                          "gt": createPositionalPseudo(function(matchIndexes, length, argument) {
                              var i = argument < 0 ? argument + length : argument;
                              for (; ++i < length; ) {
                                  matchIndexes.push(i);
                              }
                              return matchIndexes;
                          })
                      }
                  };

// Add button/input type pseudos
                  for (i in {
                      radio: true,
                      checkbox: true,
                      file: true,
                      password: true,
                      image: true
                  }) {
                      Expr.pseudos[ i ] = createInputPseudo(i);
                  }
                  for (i in {
                      submit: true,
                      reset: true
                  }) {
                      Expr.pseudos[ i ] = createButtonPseudo(i);
                  }

                  function tokenize(selector, parseOnly) {
                      var matched, match, tokens, type,
                        soFar, groups, preFilters,
                        cached = tokenCache[ selector + " " ];

                      if (cached) {
                          return parseOnly ? 0 : cached.slice(0);
                      }

                      soFar = selector;
                      groups = [
                      ];
                      preFilters = Expr.preFilter;

                      while (soFar) {

                          // Comma and first run
                          if (!matched || (match = rcomma.exec(soFar))) {
                              if (match) {
                                  // Don't consume trailing commas as valid
                                  soFar = soFar.slice(match[0].length) || soFar;
                              }
                              groups.push(tokens = [
                              ]);
                          }

                          matched = false;

                          // Combinators
                          if ((match = rcombinators.exec(soFar))) {
                              matched = match.shift();
                              tokens.push({
                                  value: matched,
                                  // Cast descendant combinators to space
                                  type: match[0].replace(rtrim, " ")
                              });
                              soFar = soFar.slice(matched.length);
                          }

                          // Filters
                          for (type in Expr.filter) {
                              if ((match = matchExpr[ type ].exec(soFar)) && (!preFilters[ type ] ||
                                (match = preFilters[ type ](match)))) {
                                  matched = match.shift();
                                  tokens.push({
                                      value: matched,
                                      type: type,
                                      matches: match
                                  });
                                  soFar = soFar.slice(matched.length);
                              }
                          }

                          if (!matched) {
                              break;
                          }
                      }

                      // Return the length of the invalid excess
                      // if we're just parsing
                      // Otherwise, throw an error or return tokens
                      return parseOnly ?
                        soFar.length :
                        soFar ?
                        Sizzle.error(selector) :
                        // Cache the tokens
                        tokenCache(selector, groups).slice(0);
                  }

                  function toSelector(tokens) {
                      var i = 0,
                        len = tokens.length,
                        selector = "";
                      for (; i < len; i++) {
                          selector += tokens[i].value;
                      }
                      return selector;
                  }

                  function addCombinator(matcher, combinator, base) {
                      var dir = combinator.dir,
                        checkNonElements = base && dir === "parentNode",
                        doneName = done++;

                      return combinator.first ?
                        // Check against closest ancestor/preceding element
                          function(elem, context, xml) {
                              while ((elem = elem[ dir ])) {
                                  if (elem.nodeType === 1 || checkNonElements) {
                                      return matcher(elem, context, xml);
                                  }
                              }
                          } :
                          // Check against all ancestor/preceding elements
                            function(elem, context, xml) {
                                var data, cache, outerCache,
                                  dirkey = dirruns + " " + doneName;

                                // We can't set arbitrary data on XML nodes, so they don't benefit from dir caching
                                if (xml) {
                                    while ((elem = elem[ dir ])) {
                                        if (elem.nodeType === 1 || checkNonElements) {
                                            if (matcher(elem, context, xml)) {
                                                return true;
                                            }
                                        }
                                    }
                                } else {
                                    while ((elem = elem[ dir ])) {
                                        if (elem.nodeType === 1 || checkNonElements) {
                                            outerCache = elem[ expando ] || (elem[ expando ] = {
                                            });
                                            if ((cache = outerCache[ dir ]) && cache[0] === dirkey) {
                                                if ((data = cache[1]) === true || data === cachedruns) {
                                                    return data === true;
                                                }
                                            } else {
                                                cache = outerCache[ dir ] = [
                                                    dirkey
                                                ];
                                                cache[1] = matcher(elem, context, xml) || cachedruns;
                                                if (cache[1] === true) {
                                                    return true;
                                                }
                                            }
                                        }
                                    }
                                }
                            };
                      }

                    function elementMatcher(matchers) {
                        return matchers.length > 1 ?
                          function(elem, context, xml) {
                              var i = matchers.length;
                              while (i--) {
                                  if (!matchers[i](elem, context, xml)) {
                                      return false;
                                  }
                              }
                              return true;
                          } :
                          matchers[0];
                    }

                    function condense(unmatched, map, filter, context, xml) {
                        var elem,
                          newUnmatched = [
                        ],
                          i = 0,
                          len = unmatched.length,
                          mapped = map != null;

                        for (; i < len; i++) {
                            if ((elem = unmatched[i])) {
                                if (!filter || filter(elem, context, xml)) {
                                    newUnmatched.push(elem);
                                    if (mapped) {
                                        map.push(i);
                                    }
                                }
                            }
                        }

                        return newUnmatched;
                    }

                    function setMatcher(preFilter, selector, matcher, postFilter, postFinder, postSelector) {
                        if (postFilter && !postFilter[ expando ]) {
                            postFilter = setMatcher(postFilter);
                        }
                        if (postFinder && !postFinder[ expando ]) {
                            postFinder = setMatcher(postFinder, postSelector);
                        }
                        return markFunction(function(seed, results, context, xml) {
                            var temp, i, elem,
                              preMap = [
                            ],
                              postMap = [
                            ],
                              preexisting = results.length,
                              // Get initial elements from seed or context
                              elems = seed || multipleContexts(selector || "*", context.nodeType ? [
                                context
                            ] : context, [
                            ]),
                              // Prefilter to get matcher input, preserving a map for seed-results synchronization
                              matcherIn = preFilter && (seed || !selector) ?
                              condense(elems, preMap, preFilter, context, xml) :
                              elems,
                              matcherOut = matcher ?
                              // If we have a postFinder, or filtered seed, or non-seed postFilter or preexisting results,
                              postFinder || (seed ? preFilter : preexisting || postFilter) ?
                              // ...intermediate processing is necessary
                                [
                                ] :
                                // ...otherwise use results directly
                                results :
                                matcherIn;

                              // Find primary matches
                              if (matcher) {
                                  matcher(matcherIn, matcherOut, context, xml);
                              }

                              // Apply postFilter
                              if (postFilter) {
                                  temp = condense(matcherOut, postMap);
                                  postFilter(temp, [
                                  ], context, xml);

                                  // Un-match failing elements by moving them back to matcherIn
                                  i = temp.length;
                                  while (i--) {
                                      if ((elem = temp[i])) {
                                          matcherOut[ postMap[i] ] = !(matcherIn[ postMap[i] ] = elem);
                                      }
                                  }
                              }

                              if (seed) {
                                  if (postFinder || preFilter) {
                                      if (postFinder) {
                                          // Get the final matcherOut by condensing this intermediate into postFinder contexts
                                          temp = [
                                          ];
                                          i = matcherOut.length;
                                          while (i--) {
                                              if ((elem = matcherOut[i])) {
                                                  // Restore matcherIn since elem is not yet a final match
                                                  temp.push((matcherIn[i] = elem));
                                              }
                                          }
                                          postFinder(null, (matcherOut = [
                                          ]), temp, xml);
                                      }

                                      // Move matched elements from seed to results to keep them synchronized
                                      i = matcherOut.length;
                                      while (i--) {
                                          if ((elem = matcherOut[i]) &&
                                            (temp = postFinder ? indexOf.call(seed, elem) : preMap[i]) > -1) {

                                              seed[temp] = !(results[temp] = elem);
                                          }
                                      }
                                  }

                                  // Add elements to results, through postFinder if defined
                              } else {
                                  matcherOut = condense(
                                    matcherOut === results ?
                                    matcherOut.splice(preexisting, matcherOut.length) :
                                    matcherOut
                                    );
                                  if (postFinder) {
                                      postFinder(null, results, matcherOut, xml);
                                  } else {
                                      push.apply(results, matcherOut);
                                  }
                              }
                          });
                      }

                      function matcherFromTokens(tokens) {
                          var checkContext, matcher, j,
                            len = tokens.length,
                            leadingRelative = Expr.relative[ tokens[0].type ],
                            implicitRelative = leadingRelative || Expr.relative[" "],
                            i = leadingRelative ? 1 : 0,
                            // The foundational matcher ensures that elements are reachable from top-level context(s)
                            matchContext = addCombinator(function(elem) {
                              return elem === checkContext;
                          }, implicitRelative, true),
                            matchAnyContext = addCombinator(function(elem) {
                              return indexOf.call(checkContext, elem) > -1;
                          }, implicitRelative, true),
                            matchers = [
                              function(elem, context, xml) {
                                  return (!leadingRelative && (xml || context !== outermostContext)) || (
                                    (checkContext = context).nodeType ?
                                    matchContext(elem, context, xml) :
                                    matchAnyContext(elem, context, xml));
                              }
                          ];

                          for (; i < len; i++) {
                              if ((matcher = Expr.relative[ tokens[i].type ])) {
                                  matchers = [
                                      addCombinator(elementMatcher(matchers), matcher)
                                  ];
                              } else {
                                  matcher = Expr.filter[ tokens[i].type ].apply(null, tokens[i].matches);

                                  // Return special upon seeing a positional matcher
                                  if (matcher[ expando ]) {
                                      // Find the next relative operator (if any) for proper handling
                                      j = ++i;
                                      for (; j < len; j++) {
                                          if (Expr.relative[ tokens[j].type ]) {
                                              break;
                                          }
                                      }
                                      return setMatcher(
                                        i > 1 && elementMatcher(matchers),
                                        i > 1 && toSelector(
                                        // If the preceding token was a descendant combinator, insert an implicit any-element `*`
                                        tokens.slice(0, i - 1).concat({
                                          value: tokens[ i - 2 ].type === " " ? "*" : ""
                                      })
                                        ).replace(rtrim, "$1"),
                                        matcher,
                                        i < j && matcherFromTokens(tokens.slice(i, j)),
                                        j < len && matcherFromTokens((tokens = tokens.slice(j))),
                                        j < len && toSelector(tokens)
                                        );
                                  }
                                  matchers.push(matcher);
                              }
                          }

                          return elementMatcher(matchers);
                      }

                      function matcherFromGroupMatchers(elementMatchers, setMatchers) {
                          // A counter to specify which element is currently being matched
                          var matcherCachedRuns = 0,
                            bySet = setMatchers.length > 0,
                            byElement = elementMatchers.length > 0,
                            superMatcher = function(seed, context, xml, results, expandContext) {
                              var elem, j, matcher,
                                setMatched = [
                              ],
                                matchedCount = 0,
                                i = "0",
                                unmatched = seed && [
                              ],
                                outermost = expandContext != null,
                                contextBackup = outermostContext,
                                // We must always have either seed elements or context
                                elems = seed || byElement && Expr.find["TAG"]("*", expandContext && context.parentNode || context),
                                // Use integer dirruns iff this is the outermost matcher
                                dirrunsUnique = (dirruns += contextBackup == null ? 1 : Math.random() || 0.1);

                              if (outermost) {
                                  outermostContext = context !== document && context;
                                  cachedruns = matcherCachedRuns;
                              }

                              // Add elements passing elementMatchers directly to results
                              // Keep `i` a string if there are no elements so `matchedCount` will be "00" below
                              for (; (elem = elems[i]) != null; i++) {
                                  if (byElement && elem) {
                                      j = 0;
                                      while ((matcher = elementMatchers[j++])) {
                                          if (matcher(elem, context, xml)) {
                                              results.push(elem);
                                              break;
                                          }
                                      }
                                      if (outermost) {
                                          dirruns = dirrunsUnique;
                                          cachedruns = ++matcherCachedRuns;
                                      }
                                  }

                                  // Track unmatched elements for set filters
                                  if (bySet) {
                                      // They will have gone through all possible matchers
                                      if ((elem = !matcher && elem)) {
                                          matchedCount--;
                                      }

                                      // Lengthen the array for every element, matched or not
                                      if (seed) {
                                          unmatched.push(elem);
                                      }
                                  }
                              }

                              // Apply set filters to unmatched elements
                              matchedCount += i;
                              if (bySet && i !== matchedCount) {
                                  j = 0;
                                  while ((matcher = setMatchers[j++])) {
                                      matcher(unmatched, setMatched, context, xml);
                                  }

                                  if (seed) {
                                      // Reintegrate element matches to eliminate the need for sorting
                                      if (matchedCount > 0) {
                                          while (i--) {
                                              if (!(unmatched[i] || setMatched[i])) {
                                                  setMatched[i] = pop.call(results);
                                              }
                                          }
                                      }

                                      // Discard index placeholder values to get only actual matches
                                      setMatched = condense(setMatched);
                                  }

                                  // Add matches to results
                                  push.apply(results, setMatched);

                                  // Seedless set matches succeeding multiple successful matchers stipulate sorting
                                  if (outermost && !seed && setMatched.length > 0 &&
                                    (matchedCount + setMatchers.length) > 1) {

                                      Sizzle.uniqueSort(results);
                                  }
                              }

                              // Override manipulation of globals by nested matchers
                              if (outermost) {
                                  dirruns = dirrunsUnique;
                                  outermostContext = contextBackup;
                              }

                              return unmatched;
                          };

                          return bySet ?
                            markFunction(superMatcher) :
                            superMatcher;
                      }

                      compile = Sizzle.compile = function(selector, group /* Internal Use Only */) {
                          var i,
                            setMatchers = [
                          ],
                            elementMatchers = [
                          ],
                            cached = compilerCache[ selector + " " ];

                          if (!cached) {
                              // Generate a function of recursive functions that can be used to check each element
                              if (!group) {
                                  group = tokenize(selector);
                              }
                              i = group.length;
                              while (i--) {
                                  cached = matcherFromTokens(group[i]);
                                  if (cached[ expando ]) {
                                      setMatchers.push(cached);
                                  } else {
                                      elementMatchers.push(cached);
                                  }
                              }

                              // Cache the compiled function
                              cached = compilerCache(selector, matcherFromGroupMatchers(elementMatchers, setMatchers));
                          }
                          return cached;
                      };

                      function multipleContexts(selector, contexts, results) {
                          var i = 0,
                            len = contexts.length;
                          for (; i < len; i++) {
                              Sizzle(selector, contexts[i], results);
                          }
                          return results;
                      }

                      function select(selector, context, results, seed) {
                          var i, tokens, token, type, find,
                            match = tokenize(selector);

                          if (!seed) {
                              // Try to minimize operations if there is only one group
                              if (match.length === 1) {

                                  // Take a shortcut and set the context if the root selector is an ID
                                  tokens = match[0] = match[0].slice(0);
                                  if (tokens.length > 2 && (token = tokens[0]).type === "ID" &&
                                    support.getById && context.nodeType === 9 && documentIsHTML &&
                                    Expr.relative[ tokens[1].type ]) {

                                      context = (Expr.find["ID"](token.matches[0].replace(runescape, funescape), context) || [
                                      ])[0];
                                      if (!context) {
                                          return results;
                                      }
                                      selector = selector.slice(tokens.shift().value.length);
                                  }

                                  // Fetch a seed set for right-to-left matching
                                  i = matchExpr["needsContext"].test(selector) ? 0 : tokens.length;
                                  while (i--) {
                                      token = tokens[i];

                                      // Abort if we hit a combinator
                                      if (Expr.relative[ (type = token.type) ]) {
                                          break;
                                      }
                                      if ((find = Expr.find[ type ])) {
                                          // Search, expanding context for leading sibling combinators
                                          if ((seed = find(
                                            token.matches[0].replace(runescape, funescape),
                                            rsibling.test(tokens[0].type) && context.parentNode || context
                                            ))) {

                                              // If seed is empty or no tokens remain, we can return early
                                              tokens.splice(i, 1);
                                              selector = seed.length && toSelector(tokens);
                                              if (!selector) {
                                                  push.apply(results, seed);
                                                  return results;
                                              }

                                              break;
                                          }
                                      }
                                  }
                              }
                          }

                          // Compile and execute a filtering function
                          // Provide `match` to avoid retokenization if we modified the selector above
                          compile(selector, match)(
                            seed,
                            context,
                            !documentIsHTML,
                            results,
                            rsibling.test(selector)
                            );
                          return results;
                      }

// Deprecated
                      Expr.pseudos["nth"] = Expr.pseudos["eq"];

// Easy API for creating new setFilters
                      function setFilters() {
                      }
                      setFilters.prototype = Expr.filters = Expr.pseudos;
                      Expr.setFilters = new setFilters();

// One-time assignments

// Sort stability
                      support.sortStable = expando.split("").sort(sortOrder).join("") === expando;

// Initialize against the default document
                      setDocument();

// Support: Chrome<<14
// Always assume duplicates if they aren't passed to the comparison function
                      [
                          0,
                          0
                      ].sort(sortOrder);
                      support.detectDuplicates = hasDuplicate;

                      jQuery.find = Sizzle;
                      jQuery.expr = Sizzle.selectors;
                      jQuery.expr[":"] = jQuery.expr.pseudos;
                      jQuery.unique = Sizzle.uniqueSort;
                      jQuery.text = Sizzle.getText;
                      jQuery.isXMLDoc = Sizzle.isXML;
                      jQuery.contains = Sizzle.contains;


                  })(window);
// String to Object options format cache
                  var optionsCache = {
                  };

// Convert String-formatted options into Object-formatted ones and store in cache
                  function createOptions(options) {
                      var object = optionsCache[ options ] = {
                      };
                      jQuery.each(options.match(core_rnotwhite) || [
                      ], function(_, flag) {
                          object[ flag ] = true;
                      });
                      return object;
                  }

                  /*
                   * Create a callback list using the following parameters:
                   *
                   *	options: an optional list of space-separated options that will change how
                   *			the callback list behaves or a more traditional option object
                   *
                   * By default a callback list will act like an event callback list and can be
                   * "fired" multiple times.
                   *
                   * Possible options:
                   *
                   *	once:			will ensure the callback list can only be fired once (like a Deferred)
                   *
                   *	memory:			will keep track of previous values and will call any callback added
                   *					after the list has been fired right away with the latest "memorized"
                   *					values (like a Deferred)
                   *
                   *	unique:			will ensure a callback can only be added once (no duplicate in the list)
                   *
                   *	stopOnFalse:	interrupt callings when a callback returns false
                   *
                   */
                  jQuery.Callbacks = function(options) {

                      // Convert options from String-formatted to Object-formatted if needed
                      // (we check in cache first)
                      options = typeof options === "string" ?
                        (optionsCache[ options ] || createOptions(options)) :
                        jQuery.extend({
                      }, options);

                      var // Last fire value (for non-forgettable lists)
                        memory,
                        // Flag to know if list was already fired
                        fired,
                        // Flag to know if list is currently firing
                        firing,
                        // First callback to fire (used internally by add and fireWith)
                        firingStart,
                        // End of the loop when firing
                        firingLength,
                        // Index of currently firing callback (modified by remove if needed)
                        firingIndex,
                        // Actual callback list
                        list = [
                      ],
                        // Stack of fire calls for repeatable lists
                        stack = !options.once && [
                      ],
                        // Fire callbacks
                        fire = function(data) {
                          memory = options.memory && data;
                          fired = true;
                          firingIndex = firingStart || 0;
                          firingStart = 0;
                          firingLength = list.length;
                          firing = true;
                          for (; list && firingIndex < firingLength; firingIndex++) {
                              if (list[ firingIndex ].apply(data[ 0 ], data[ 1 ]) === false && options.stopOnFalse) {
                                  memory = false; // To prevent further calls using add
                                  break;
                              }
                          }
                          firing = false;
                          if (list) {
                              if (stack) {
                                  if (stack.length) {
                                      fire(stack.shift());
                                  }
                              } else if (memory) {
                                  list = [
                                  ];
                              } else {
                                  self.disable();
                              }
                          }
                      },
                        // Actual Callbacks object
                        self = {
                          // Add a callback or a collection of callbacks to the list
                          add: function() {
                              if (list) {
                                  // First, we save the current length
                                  var start = list.length;
                                  (function add(args) {
                                      jQuery.each(args, function(_, arg) {
                                          var type = jQuery.type(arg);
                                          if (type === "function") {
                                              if (!options.unique || !self.has(arg)) {
                                                  list.push(arg);
                                              }
                                          } else if (arg && arg.length && type !== "string") {
                                              // Inspect recursively
                                              add(arg);
                                          }
                                      });
                                  })(arguments);
                                  // Do we need to add the callbacks to the
                                  // current firing batch?
                                  if (firing) {
                                      firingLength = list.length;
                                      // With memory, if we're not firing then
                                      // we should call right away
                                  } else if (memory) {
                                      firingStart = start;
                                      fire(memory);
                                  }
                              }
                              return this;
                          },
                          // Remove a callback from the list
                          remove: function() {
                              if (list) {
                                  jQuery.each(arguments, function(_, arg) {
                                      var index;
                                      while ((index = jQuery.inArray(arg, list, index)) > -1) {
                                          list.splice(index, 1);
                                          // Handle firing indexes
                                          if (firing) {
                                              if (index <= firingLength) {
                                                  firingLength--;
                                              }
                                              if (index <= firingIndex) {
                                                  firingIndex--;
                                              }
                                          }
                                      }
                                  });
                              }
                              return this;
                          },
                          // Check if a given callback is in the list.
                          // If no argument is given, return whether or not list has callbacks attached.
                          has: function(fn) {
                              return fn ? jQuery.inArray(fn, list) > -1 : !!(list && list.length);
                          },
                          // Remove all callbacks from the list
                          empty: function() {
                              list = [
                              ];
                              firingLength = 0;
                              return this;
                          },
                          // Have the list do nothing anymore
                          disable: function() {
                              list = stack = memory = undefined;
                              return this;
                          },
                          // Is it disabled?
                          disabled: function() {
                              return !list;
                          },
                          // Lock the list in its current state
                          lock: function() {
                              stack = undefined;
                              if (!memory) {
                                  self.disable();
                              }
                              return this;
                          },
                          // Is it locked?
                          locked: function() {
                              return !stack;
                          },
                          // Call all callbacks with the given context and arguments
                          fireWith: function(context, args) {
                              args = args || [
                              ];
                              args = [
                                  context,
                                  args.slice ? args.slice() : args
                              ];
                              if (list && (!fired || stack)) {
                                  if (firing) {
                                      stack.push(args);
                                  } else {
                                      fire(args);
                                  }
                              }
                              return this;
                          },
                          // Call all the callbacks with the given arguments
                          fire: function() {
                              self.fireWith(this, arguments);
                              return this;
                          },
                          // To know if the callbacks have already been called at least once
                          fired: function() {
                              return !!fired;
                          }
                      };

                      return self;
                  };
                  jQuery.extend({
                      Deferred: function(func) {
                          var tuples = [
                              // action, add listener, listener list, final state
                              [
                                  "resolve",
                                  "done",
                                  jQuery.Callbacks("once memory"),
                                  "resolved"
                              ],
                              [
                                  "reject",
                                  "fail",
                                  jQuery.Callbacks("once memory"),
                                  "rejected"
                              ],
                              [
                                  "notify",
                                  "progress",
                                  jQuery.Callbacks("memory")
                              ]
                          ],
                            state = "pending",
                            promise = {
                              state: function() {
                                  return state;
                              },
                              always: function() {
                                  deferred.done(arguments).fail(arguments);
                                  return this;
                              },
                              then: function( /* fnDone, fnFail, fnProgress */ ) {
                                  var fns = arguments;
                                  return jQuery.Deferred(function(newDefer) {
                                      jQuery.each(tuples, function(i, tuple) {
                                          var action = tuple[ 0 ],
                                            fn = jQuery.isFunction(fns[ i ]) && fns[ i ];
                                          // deferred[ done | fail | progress ] for forwarding actions to newDefer
                                          deferred[ tuple[1] ](function() {
                                              var returned = fn && fn.apply(this, arguments);
                                              if (returned && jQuery.isFunction(returned.promise)) {
                                                  returned.promise()
                                                    .done(newDefer.resolve)
                                                    .fail(newDefer.reject)
                                                    .progress(newDefer.notify);
                                              } else {
                                                  newDefer[ action + "With" ](this === promise ? newDefer.promise() : this, fn ? [
                                                      returned
                                                  ] : arguments);
                                              }
                                          });
                                      });
                                      fns = null;
                                  }).promise();
                              },
                              // Get a promise for this deferred
                              // If obj is provided, the promise aspect is added to the object
                              promise: function(obj) {
                                  return obj != null ? jQuery.extend(obj, promise) : promise;
                              }
                          },
                          deferred = {
                          };

                          // Keep pipe for back-compat
                          promise.pipe = promise.then;

                          // Add list-specific methods
                          jQuery.each(tuples, function(i, tuple) {
                              var list = tuple[ 2 ],
                                stateString = tuple[ 3 ];

                              // promise[ done | fail | progress ] = list.add
                              promise[ tuple[1] ] = list.add;

                              // Handle state
                              if (stateString) {
                                  list.add(function() {
                                      // state = [ resolved | rejected ]
                                      state = stateString;

                                      // [ reject_list | resolve_list ].disable; progress_list.lock
                                  }, tuples[ i ^ 1 ][ 2 ].disable, tuples[ 2 ][ 2 ].lock);
                              }

                              // deferred[ resolve | reject | notify ]
                              deferred[ tuple[0] ] = function() {
                                  deferred[ tuple[0] + "With" ](this === deferred ? promise : this, arguments);
                                  return this;
                              };
                              deferred[ tuple[0] + "With" ] = list.fireWith;
                          });

                          // Make the deferred a promise
                          promise.promise(deferred);

                          // Call given func if any
                          if (func) {
                              func.call(deferred, deferred);
                          }

                          // All done!
                          return deferred;
                      },
                      // Deferred helper
                      when: function(subordinate /* , ..., subordinateN */) {
                          var i = 0,
                            resolveValues = core_slice.call(arguments),
                            length = resolveValues.length,
                            // the count of uncompleted subordinates
                            remaining = length !== 1 || (subordinate && jQuery.isFunction(subordinate.promise)) ? length : 0,
                            // the master Deferred. If resolveValues consist of only a single Deferred, just use that.
                            deferred = remaining === 1 ? subordinate : jQuery.Deferred(),
                            // Update function for both resolve and progress values
                            updateFunc = function(i, contexts, values) {
                              return function(value) {
                                  contexts[ i ] = this;
                                  values[ i ] = arguments.length > 1 ? core_slice.call(arguments) : value;
                                  if (values === progressValues) {
                                      deferred.notifyWith(contexts, values);
                                  } else if (!(--remaining)) {
                                      deferred.resolveWith(contexts, values);
                                  }
                              };
                          },
                            progressValues, progressContexts, resolveContexts;

                          // add listeners to Deferred subordinates; treat others as resolved
                          if (length > 1) {
                              progressValues = new Array(length);
                              progressContexts = new Array(length);
                              resolveContexts = new Array(length);
                              for (; i < length; i++) {
                                  if (resolveValues[ i ] && jQuery.isFunction(resolveValues[ i ].promise)) {
                                      resolveValues[ i ].promise()
                                        .done(updateFunc(i, resolveContexts, resolveValues))
                                        .fail(deferred.reject)
                                        .progress(updateFunc(i, progressContexts, progressValues));
                                  } else {
                                      --remaining;
                                  }
                              }
                          }

                          // if we're not waiting on anything, resolve the master
                          if (!remaining) {
                              deferred.resolveWith(resolveContexts, resolveValues);
                          }

                          return deferred.promise();
                      }
                  });
                  jQuery.support = (function(support) {
                      var input = document.createElement("input"),
                        fragment = document.createDocumentFragment(),
                        div = document.createElement("div"),
                        select = document.createElement("select"),
                        opt = select.appendChild(document.createElement("option"));

                      // Finish early in limited environments
                      if (!input.type) {
                          return support;
                      }

                      input.type = "checkbox";

                      // Support: Safari 5.1, iOS 5.1, Android 4.x, Android 2.3
                      // Check the default checkbox/radio value ("" on old WebKit; "on" elsewhere)
                      support.checkOn = input.value !== "";

                      // Must access the parent to make an option select properly
                      // Support: IE9, IE10
                      support.optSelected = opt.selected;

                      // Will be defined later
                      support.reliableMarginRight = true;
                      support.boxSizingReliable = true;
                      support.pixelPosition = false;

                      // Make sure checked status is properly cloned
                      // Support: IE9, IE10
                      input.checked = true;
                      support.noCloneChecked = input.cloneNode(true).checked;

                      // Make sure that the options inside disabled selects aren't marked as disabled
                      // (WebKit marks them as disabled)
                      select.disabled = true;
                      support.optDisabled = !opt.disabled;

                      // Check if an input maintains its value after becoming a radio
                      // Support: IE9, IE10
                      input = document.createElement("input");
                      input.value = "t";
                      input.type = "radio";
                      support.radioValue = input.value === "t";

                      // #11217 - WebKit loses check when the name is after the checked attribute
                      input.setAttribute("checked", "t");
                      input.setAttribute("name", "t");

                      fragment.appendChild(input);

                      // Support: Safari 5.1, Android 4.x, Android 2.3
                      // old WebKit doesn't clone checked state correctly in fragments
                      support.checkClone = fragment.cloneNode(true).cloneNode(true).lastChild.checked;

                      // Support: Firefox, Chrome, Safari
                      // Beware of CSP restrictions (https://developer.mozilla.org/en/Security/CSP)
                      support.focusinBubbles = "onfocusin" in window;

                      div.style.backgroundClip = "content-box";
                      div.cloneNode(true).style.backgroundClip = "";
                      support.clearCloneStyle = div.style.backgroundClip === "content-box";

                      // Run tests that need a body at doc ready
                      jQuery(function() {
                          var container, marginDiv,
                            // Support: Firefox, Android 2.3 (Prefixed box-sizing versions).
                            divReset = "padding:0;margin:0;border:0;display:block;-webkit-box-sizing:content-box;-moz-box-sizing:content-box;box-sizing:content-box",
                            body = document.getElementsByTagName("body")[ 0 ];

                          if (!body) {
                              // Return for frameset docs that don't have a body
                              return;
                          }

                          container = document.createElement("div");
                          container.style.cssText = "border:0;width:0;height:0;position:absolute;top:0;left:-9999px;margin-top:1px";

                          // Check box-sizing and margin behavior.
                          body.appendChild(container).appendChild(div);
                          div.innerHTML = "";
                          // Support: Firefox, Android 2.3 (Prefixed box-sizing versions).
                          div.style.cssText = "-webkit-box-sizing:border-box;-moz-box-sizing:border-box;box-sizing:border-box;padding:1px;border:1px;display:block;width:4px;margin-top:1%;position:absolute;top:1%";

                          // Workaround failing boxSizing test due to offsetWidth returning wrong value
                          // with some non-1 values of body zoom, ticket #13543
                          jQuery.swap(body, body.style.zoom != null ? {
                              zoom: 1
                          } : {
                          }, function() {
                              support.boxSizing = div.offsetWidth === 4;
                          });

                          // Use window.getComputedStyle because jsdom on node.js will break without it.
                          if (window.getComputedStyle) {
                              support.pixelPosition = (window.getComputedStyle(div, null) || {
                              }).top !== "1%";
                              support.boxSizingReliable = (window.getComputedStyle(div, null) || {
                                  width: "4px"
                              }).width === "4px";

                              // Support: Android 2.3
                              // Check if div with explicit width and no margin-right incorrectly
                              // gets computed margin-right based on width of container. (#3333)
                              // WebKit Bug 13343 - getComputedStyle returns wrong value for margin-right
                              marginDiv = div.appendChild(document.createElement("div"));
                              marginDiv.style.cssText = div.style.cssText = divReset;
                              marginDiv.style.marginRight = marginDiv.style.width = "0";
                              div.style.width = "1px";

                              support.reliableMarginRight =
                                !parseFloat((window.getComputedStyle(marginDiv, null) || {
                              }).marginRight);
                          }

                          body.removeChild(container);
                      });

                      return support;
                  })({
                  });

                  /*
                   Implementation Summary

                   1. Enforce API surface and semantic compatibility with 1.9.x branch
                   2. Improve the module's maintainability by reducing the storage
                   paths to a single mechanism.
                   3. Use the same single mechanism to support "private" and "user" data.
                   4. _Never_ expose "private" data to user code (TODO: Drop _data, _removeData)
                   5. Avoid exposing implementation details on user objects (eg. expando properties)
                   6. Provide a clear path for implementation upgrade to WeakMap in 2014
                   */
                  var data_user, data_priv,
                    rbrace = /(?:\{[\s\S]*\}|\[[\s\S]*\])$/,
                    rmultiDash = /([A-Z])/g;

                  function Data() {
                      // Support: Android < 4,
                      // Old WebKit does not have Object.preventExtensions/freeze method,
                      // return new empty object instead with no [[set]] accessor
                      Object.defineProperty(this.cache = {
                      }, 0, {
                          get: function() {
                              return {
                              };
                          }
                      });

                      this.expando = jQuery.expando + Math.random();
                  }

                  Data.uid = 1;

                  Data.accepts = function(owner) {
                      // Accepts only:
                      //  - Node
                      //    - Node.ELEMENT_NODE
                      //    - Node.DOCUMENT_NODE
                      //  - Object
                      //    - Any
                      return owner.nodeType ?
                        owner.nodeType === 1 || owner.nodeType === 9 : true;
                  };

                  Data.prototype = {
                      key: function(owner) {
                          // We can accept data for non-element nodes in modern browsers,
                          // but we should not, see #8335.
                          // Always return the key for a frozen object.
                          if (!Data.accepts(owner)) {
                              return 0;
                          }

                          var descriptor = {
                          },
                            // Check if the owner object already has a cache key
                            unlock = owner[ this.expando ];

                          // If not, create one
                          if (!unlock) {
                              unlock = Data.uid++;

                              // Secure it in a non-enumerable, non-writable property
                              try {
                                  descriptor[ this.expando ] = {
                                      value: unlock
                                  };
                                  Object.defineProperties(owner, descriptor);

                                  // Support: Android < 4
                                  // Fallback to a less secure definition
                              } catch (e) {
                                  descriptor[ this.expando ] = unlock;
                                  jQuery.extend(owner, descriptor);
                              }
                          }

                          // Ensure the cache object
                          if (!this.cache[ unlock ]) {
                              this.cache[ unlock ] = {
                              };
                          }

                          return unlock;
                      },
                      set: function(owner, data, value) {
                          var prop,
                            // There may be an unlock assigned to this node,
                            // if there is no entry for this "owner", create one inline
                            // and set the unlock as though an owner entry had always existed
                            unlock = this.key(owner),
                            cache = this.cache[ unlock ];

                          // Handle: [ owner, key, value ] args
                          if (typeof data === "string") {
                              cache[ data ] = value;

                              // Handle: [ owner, { properties } ] args
                          } else {
                              // Fresh assignments by object are shallow copied
                              if (jQuery.isEmptyObject(cache)) {
                                  jQuery.extend(this.cache[ unlock ], data);
                                  // Otherwise, copy the properties one-by-one to the cache object
                              } else {
                                  for (prop in data) {
                                      cache[ prop ] = data[ prop ];
                                  }
                              }
                          }
                          return cache;
                      },
                      get: function(owner, key) {
                          // Either a valid cache is found, or will be created.
                          // New caches will be created and the unlock returned,
                          // allowing direct access to the newly created
                          // empty data object. A valid owner object must be provided.
                          var cache = this.cache[ this.key(owner) ];

                          return key === undefined ?
                            cache : cache[ key ];
                      },
                      access: function(owner, key, value) {
                          // In cases where either:
                          //
                          //   1. No key was specified
                          //   2. A string key was specified, but no value provided
                          //
                          // Take the "read" path and allow the get method to determine
                          // which value to return, respectively either:
                          //
                          //   1. The entire cache object
                          //   2. The data stored at the key
                          //
                          if (key === undefined ||
                            ((key && typeof key === "string") && value === undefined)) {
                              return this.get(owner, key);
                          }

                          // [*]When the key is not a string, or both a key and value
                          // are specified, set or extend (existing objects) with either:
                          //
                          //   1. An object of properties
                          //   2. A key and value
                          //
                          this.set(owner, key, value);

                          // Since the "set" path can have two possible entry points
                          // return the expected data based on which path was taken[*]
                          return value !== undefined ? value : key;
                      },
                      remove: function(owner, key) {
                          var i, name, camel,
                            unlock = this.key(owner),
                            cache = this.cache[ unlock ];

                          if (key === undefined) {
                              this.cache[ unlock ] = {
                              };

                          } else {
                              // Support array or space separated string of keys
                              if (jQuery.isArray(key)) {
                                  // If "name" is an array of keys...
                                  // When data is initially created, via ("key", "val") signature,
                                  // keys will be converted to camelCase.
                                  // Since there is no way to tell _how_ a key was added, remove
                                  // both plain key and camelCase key. #12786
                                  // This will only penalize the array argument path.
                                  name = key.concat(key.map(jQuery.camelCase));
                              } else {
                                  camel = jQuery.camelCase(key);
                                  // Try the string as a key before any manipulation
                                  if (key in cache) {
                                      name = [
                                          key,
                                          camel
                                      ];
                                  } else {
                                      // If a key with the spaces exists, use it.
                                      // Otherwise, create an array by matching non-whitespace
                                      name = camel;
                                      name = name in cache ?
                                        [
                                            name
                                        ] : (name.match(core_rnotwhite) || [
                                      ]);
                                  }
                              }

                              i = name.length;
                              while (i--) {
                                  delete cache[ name[ i ] ];
                              }
                          }
                      },
                      hasData: function(owner) {
                          return !jQuery.isEmptyObject(
                            this.cache[ owner[ this.expando ] ] || {
                          }
                          );
                      },
                      discard: function(owner) {
                          if (owner[ this.expando ]) {
                              delete this.cache[ owner[ this.expando ] ];
                          }
                      }
                  };

// These may be used throughout the jQuery core codebase
                  data_user = new Data();
                  data_priv = new Data();


                  jQuery.extend({
                      acceptData: Data.accepts,
                      hasData: function(elem) {
                          return data_user.hasData(elem) || data_priv.hasData(elem);
                      },
                      data: function(elem, name, data) {
                          return data_user.access(elem, name, data);
                      },
                      removeData: function(elem, name) {
                          data_user.remove(elem, name);
                      },
                      // TODO: Now that all calls to _data and _removeData have been replaced
                      // with direct calls to data_priv methods, these can be deprecated.
                      _data: function(elem, name, data) {
                          return data_priv.access(elem, name, data);
                      },
                      _removeData: function(elem, name) {
                          data_priv.remove(elem, name);
                      }
                  });

                  jQuery.fn.extend({
                      data: function(key, value) {
                          var attrs, name,
                            elem = this[ 0 ],
                            i = 0,
                            data = null;

                          // Gets all values
                          if (key === undefined) {
                              if (this.length) {
                                  data = data_user.get(elem);

                                  if (elem.nodeType === 1 && !data_priv.get(elem, "hasDataAttrs")) {
                                      attrs = elem.attributes;
                                      for (; i < attrs.length; i++) {
                                          name = attrs[ i ].name;

                                          if (name.indexOf("data-") === 0) {
                                              name = jQuery.camelCase(name.slice(5));
                                              dataAttr(elem, name, data[ name ]);
                                          }
                                      }
                                      data_priv.set(elem, "hasDataAttrs", true);
                                  }
                              }

                              return data;
                          }

                          // Sets multiple values
                          if (typeof key === "object") {
                              return this.each(function() {
                                  data_user.set(this, key);
                              });
                          }

                          return jQuery.access(this, function(value) {
                              var data,
                                camelKey = jQuery.camelCase(key);

                              // The calling jQuery object (element matches) is not empty
                              // (and therefore has an element appears at this[ 0 ]) and the
                              // `value` parameter was not undefined. An empty jQuery object
                              // will result in `undefined` for elem = this[ 0 ] which will
                              // throw an exception if an attempt to read a data cache is made.
                              if (elem && value === undefined) {
                                  // Attempt to get data from the cache
                                  // with the key as-is
                                  data = data_user.get(elem, key);
                                  if (data !== undefined) {
                                      return data;
                                  }

                                  // Attempt to get data from the cache
                                  // with the key camelized
                                  data = data_user.get(elem, camelKey);
                                  if (data !== undefined) {
                                      return data;
                                  }

                                  // Attempt to "discover" the data in
                                  // HTML5 custom data-* attrs
                                  data = dataAttr(elem, camelKey, undefined);
                                  if (data !== undefined) {
                                      return data;
                                  }

                                  // We tried really hard, but the data doesn't exist.
                                  return;
                              }

                              // Set the data...
                              this.each(function() {
                                  // First, attempt to store a copy or reference of any
                                  // data that might've been store with a camelCased key.
                                  var data = data_user.get(this, camelKey);

                                  // For HTML5 data-* attribute interop, we have to
                                  // store property names with dashes in a camelCase form.
                                  // This might not apply to all properties...*
                                  data_user.set(this, camelKey, value);

                                  // *... In the case of properties that might _actually_
                                  // have dashes, we need to also store a copy of that
                                  // unchanged property.
                                  if (key.indexOf("-") !== -1 && data !== undefined) {
                                      data_user.set(this, key, value);
                                  }
                              });
                          }, null, value, arguments.length > 1, null, true);
                      },
                      removeData: function(key) {
                          return this.each(function() {
                              data_user.remove(this, key);
                          });
                      }
                  });

                  function dataAttr(elem, key, data) {
                      var name;

                      // If nothing was found internally, try to fetch any
                      // data from the HTML5 data-* attribute
                      if (data === undefined && elem.nodeType === 1) {
                          name = "data-" + key.replace(rmultiDash, "-$1").toLowerCase();
                          data = elem.getAttribute(name);

                          if (typeof data === "string") {
                              try {
                                  data = data === "true" ? true :
                                    data === "false" ? false :
                                    data === "null" ? null :
                                    // Only convert to a number if it doesn't change the string
                                    +data + "" === data ? +data :
                                    rbrace.test(data) ? JSON.parse(data) :
                                    data;
                              } catch (e) {
                              }

                              // Make sure we set the data so it isn't changed later
                              data_user.set(elem, key, data);
                          } else {
                              data = undefined;
                          }
                      }
                      return data;
                  }
                  jQuery.extend({
                      queue: function(elem, type, data) {
                          var queue;

                          if (elem) {
                              type = (type || "fx") + "queue";
                              queue = data_priv.get(elem, type);

                              // Speed up dequeue by getting out quickly if this is just a lookup
                              if (data) {
                                  if (!queue || jQuery.isArray(data)) {
                                      queue = data_priv.access(elem, type, jQuery.makeArray(data));
                                  } else {
                                      queue.push(data);
                                  }
                              }
                              return queue || [
                              ];
                          }
                      },
                      dequeue: function(elem, type) {
                          type = type || "fx";

                          var queue = jQuery.queue(elem, type),
                            startLength = queue.length,
                            fn = queue.shift(),
                            hooks = jQuery._queueHooks(elem, type),
                            next = function() {
                              jQuery.dequeue(elem, type);
                          };

                          // If the fx queue is dequeued, always remove the progress sentinel
                          if (fn === "inprogress") {
                              fn = queue.shift();
                              startLength--;
                          }

                          if (fn) {

                              // Add a progress sentinel to prevent the fx queue from being
                              // automatically dequeued
                              if (type === "fx") {
                                  queue.unshift("inprogress");
                              }

                              // clear up the last queue stop function
                              delete hooks.stop;
                              fn.call(elem, next, hooks);
                          }

                          if (!startLength && hooks) {
                              hooks.empty.fire();
                          }
                      },
                      // not intended for public consumption - generates a queueHooks object, or returns the current one
                      _queueHooks: function(elem, type) {
                          var key = type + "queueHooks";
                          return data_priv.get(elem, key) || data_priv.access(elem, key, {
                              empty: jQuery.Callbacks("once memory").add(function() {
                                  data_priv.remove(elem, [
                                      type + "queue",
                                      key
                                  ]);
                              })
                          });
                      }
                  });

                  jQuery.fn.extend({
                      queue: function(type, data) {
                          var setter = 2;

                          if (typeof type !== "string") {
                              data = type;
                              type = "fx";
                              setter--;
                          }

                          if (arguments.length < setter) {
                              return jQuery.queue(this[0], type);
                          }

                          return data === undefined ?
                            this :
                            this.each(function() {
                              var queue = jQuery.queue(this, type, data);

                              // ensure a hooks for this queue
                              jQuery._queueHooks(this, type);

                              if (type === "fx" && queue[0] !== "inprogress") {
                                  jQuery.dequeue(this, type);
                              }
                          });
                      },
                      dequeue: function(type) {
                          return this.each(function() {
                              jQuery.dequeue(this, type);
                          });
                      },
                      // Based off of the plugin by Clint Helfers, with permission.
                      // http://blindsignals.com/index.php/2009/07/jquery-delay/
                      delay: function(time, type) {
                          time = jQuery.fx ? jQuery.fx.speeds[ time ] || time : time;
                          type = type || "fx";

                          return this.queue(type, function(next, hooks) {
                              var timeout = setTimeout(next, time);
                              hooks.stop = function() {
                                  clearTimeout(timeout);
                              };
                          });
                      },
                      clearQueue: function(type) {
                          return this.queue(type || "fx", [
                          ]);
                      },
                      // Get a promise resolved when queues of a certain type
                      // are emptied (fx is the type by default)
                      promise: function(type, obj) {
                          var tmp,
                            count = 1,
                            defer = jQuery.Deferred(),
                            elements = this,
                            i = this.length,
                            resolve = function() {
                              if (!(--count)) {
                                  defer.resolveWith(elements, [
                                      elements
                                  ]);
                              }
                          };

                          if (typeof type !== "string") {
                              obj = type;
                              type = undefined;
                          }
                          type = type || "fx";

                          while (i--) {
                              tmp = data_priv.get(elements[ i ], type + "queueHooks");
                              if (tmp && tmp.empty) {
                                  count++;
                                  tmp.empty.add(resolve);
                              }
                          }
                          resolve();
                          return defer.promise(obj);
                      }
                  });
                  var nodeHook, boolHook,
                    rclass = /[\t\r\n\f]/g,
                    rreturn = /\r/g,
                    rfocusable = /^(?:input|select|textarea|button)$/i;

                  jQuery.fn.extend({
                      attr: function(name, value) {
                          return jQuery.access(this, jQuery.attr, name, value, arguments.length > 1);
                      },
                      removeAttr: function(name) {
                          return this.each(function() {
                              jQuery.removeAttr(this, name);
                          });
                      },
                      prop: function(name, value) {
                          return jQuery.access(this, jQuery.prop, name, value, arguments.length > 1);
                      },
                      removeProp: function(name) {
                          return this.each(function() {
                              delete this[ jQuery.propFix[ name ] || name ];
                          });
                      },
                      addClass: function(value) {
                          var classes, elem, cur, clazz, j,
                            i = 0,
                            len = this.length,
                            proceed = typeof value === "string" && value;

                          if (jQuery.isFunction(value)) {
                              return this.each(function(j) {
                                  jQuery(this).addClass(value.call(this, j, this.className));
                              });
                          }

                          if (proceed) {
                              // The disjunction here is for better compressibility (see removeClass)
                              classes = (value || "").match(core_rnotwhite) || [
                              ];

                              for (; i < len; i++) {
                                  elem = this[ i ];
                                  cur = elem.nodeType === 1 && (elem.className ?
                                    (" " + elem.className + " ").replace(rclass, " ") :
                                    " "
                                    );

                                  if (cur) {
                                      j = 0;
                                      while ((clazz = classes[j++])) {
                                          if (cur.indexOf(" " + clazz + " ") < 0) {
                                              cur += clazz + " ";
                                          }
                                      }
                                      elem.className = jQuery.trim(cur);

                                  }
                              }
                          }

                          return this;
                      },
                      removeClass: function(value) {
                          var classes, elem, cur, clazz, j,
                            i = 0,
                            len = this.length,
                            proceed = arguments.length === 0 || typeof value === "string" && value;

                          if (jQuery.isFunction(value)) {
                              return this.each(function(j) {
                                  jQuery(this).removeClass(value.call(this, j, this.className));
                              });
                          }
                          if (proceed) {
                              classes = (value || "").match(core_rnotwhite) || [
                              ];

                              for (; i < len; i++) {
                                  elem = this[ i ];
                                  // This expression is here for better compressibility (see addClass)
                                  cur = elem.nodeType === 1 && (elem.className ?
                                    (" " + elem.className + " ").replace(rclass, " ") :
                                    ""
                                    );

                                  if (cur) {
                                      j = 0;
                                      while ((clazz = classes[j++])) {
                                          // Remove *all* instances
                                          while (cur.indexOf(" " + clazz + " ") >= 0) {
                                              cur = cur.replace(" " + clazz + " ", " ");
                                          }
                                      }
                                      elem.className = value ? jQuery.trim(cur) : "";
                                  }
                              }
                          }

                          return this;
                      },
                      toggleClass: function(value, stateVal) {
                          var type = typeof value,
                            isBool = typeof stateVal === "boolean";

                          if (jQuery.isFunction(value)) {
                              return this.each(function(i) {
                                  jQuery(this).toggleClass(value.call(this, i, this.className, stateVal), stateVal);
                              });
                          }

                          return this.each(function() {
                              if (type === "string") {
                                  // toggle individual class names
                                  var className,
                                    i = 0,
                                    self = jQuery(this),
                                    state = stateVal,
                                    classNames = value.match(core_rnotwhite) || [
                                  ];

                                  while ((className = classNames[ i++ ])) {
                                      // check each className given, space separated list
                                      state = isBool ? state : !self.hasClass(className);
                                      self[ state ? "addClass" : "removeClass" ](className);
                                  }

                                  // Toggle whole class name
                              } else if (type === core_strundefined || type === "boolean") {
                                  if (this.className) {
                                      // store className if set
                                      data_priv.set(this, "__className__", this.className);
                                  }

                                  // If the element has a class name or if we're passed "false",
                                  // then remove the whole classname (if there was one, the above saved it).
                                  // Otherwise bring back whatever was previously saved (if anything),
                                  // falling back to the empty string if nothing was stored.
                                  this.className = this.className || value === false ? "" : data_priv.get(this, "__className__") || "";
                              }
                          });
                      },
                      hasClass: function(selector) {
                          var className = " " + selector + " ",
                            i = 0,
                            l = this.length;
                          for (; i < l; i++) {
                              if (this[i].nodeType === 1 && (" " + this[i].className + " ").replace(rclass, " ").indexOf(className) >= 0) {
                                  return true;
                              }
                          }

                          return false;
                      },
                      val: function(value) {
                          var hooks, ret, isFunction,
                            elem = this[0];

                          if (!arguments.length) {
                              if (elem) {
                                  hooks = jQuery.valHooks[ elem.type ] || jQuery.valHooks[ elem.nodeName.toLowerCase() ];

                                  if (hooks && "get" in hooks && (ret = hooks.get(elem, "value")) !== undefined) {
                                      return ret;
                                  }

                                  ret = elem.value;

                                  return typeof ret === "string" ?
                                    // handle most common string cases
                                    ret.replace(rreturn, "") :
                                    // handle cases where value is null/undef or number
                                    ret == null ? "" : ret;
                              }

                              return;
                          }

                          isFunction = jQuery.isFunction(value);

                          return this.each(function(i) {
                              var val;

                              if (this.nodeType !== 1) {
                                  return;
                              }

                              if (isFunction) {
                                  val = value.call(this, i, jQuery(this).val());
                              } else {
                                  val = value;
                              }

                              // Treat null/undefined as ""; convert numbers to string
                              if (val == null) {
                                  val = "";
                              } else if (typeof val === "number") {
                                  val += "";
                              } else if (jQuery.isArray(val)) {
                                  val = jQuery.map(val, function(value) {
                                      return value == null ? "" : value + "";
                                  });
                              }

                              hooks = jQuery.valHooks[ this.type ] || jQuery.valHooks[ this.nodeName.toLowerCase() ];

                              // If set returns undefined, fall back to normal setting
                              if (!hooks || !("set" in hooks) || hooks.set(this, val, "value") === undefined) {
                                  this.value = val;
                              }
                          });
                      }
                  });

                  jQuery.extend({
                      valHooks: {
                          option: {
                              get: function(elem) {
                                  // attributes.value is undefined in Blackberry 4.7 but
                                  // uses .value. See #6932
                                  var val = elem.attributes.value;
                                  return !val || val.specified ? elem.value : elem.text;
                              }
                          },
                          select: {
                              get: function(elem) {
                                  var value, option,
                                    options = elem.options,
                                    index = elem.selectedIndex,
                                    one = elem.type === "select-one" || index < 0,
                                    values = one ? null : [
                                  ],
                                    max = one ? index + 1 : options.length,
                                    i = index < 0 ?
                                    max :
                                    one ? index : 0;

                                  // Loop through all the selected options
                                  for (; i < max; i++) {
                                      option = options[ i ];

                                      // IE6-9 doesn't update selected after form reset (#2551)
                                      if ((option.selected || i === index) &&
                                        // Don't return options that are disabled or in a disabled optgroup
                                          (jQuery.support.optDisabled ? !option.disabled : option.getAttribute("disabled") === null) &&
                                          (!option.parentNode.disabled || !jQuery.nodeName(option.parentNode, "optgroup"))) {

                                          // Get the specific value for the option
                                          value = jQuery(option).val();

                                          // We don't need an array for one selects
                                          if (one) {
                                              return value;
                                          }

                                          // Multi-Selects return an array
                                          values.push(value);
                                      }
                                  }

                                  return values;
                              },
                              set: function(elem, value) {
                                  var optionSet, option,
                                    options = elem.options,
                                    values = jQuery.makeArray(value),
                                    i = options.length;

                                  while (i--) {
                                      option = options[ i ];
                                      if ((option.selected = jQuery.inArray(jQuery(option).val(), values) >= 0)) {
                                          optionSet = true;
                                      }
                                  }

                                  // force browsers to behave consistently when non-matching value is set
                                  if (!optionSet) {
                                      elem.selectedIndex = -1;
                                  }
                                  return values;
                              }
                          }
                      },
                      attr: function(elem, name, value) {
                          var hooks, ret,
                            nType = elem.nodeType;

                          // don't get/set attributes on text, comment and attribute nodes
                          if (!elem || nType === 3 || nType === 8 || nType === 2) {
                              return;
                          }

                          // Fallback to prop when attributes are not supported
                          if (typeof elem.getAttribute === core_strundefined) {
                              return jQuery.prop(elem, name, value);
                          }

                          // All attributes are lowercase
                          // Grab necessary hook if one is defined
                          if (nType !== 1 || !jQuery.isXMLDoc(elem)) {
                              name = name.toLowerCase();
                              hooks = jQuery.attrHooks[ name ] ||
                                (jQuery.expr.match.bool.test(name) ? boolHook : nodeHook);
                          }

                          if (value !== undefined) {

                              if (value === null) {
                                  jQuery.removeAttr(elem, name);

                              } else if (hooks && "set" in hooks && (ret = hooks.set(elem, value, name)) !== undefined) {
                                  return ret;

                              } else {
                                  elem.setAttribute(name, value + "");
                                  return value;
                              }

                          } else if (hooks && "get" in hooks && (ret = hooks.get(elem, name)) !== null) {
                              return ret;

                          } else {
                              ret = jQuery.find.attr(elem, name);

                              // Non-existent attributes return null, we normalize to undefined
                              return ret == null ?
                                undefined :
                                ret;
                          }
                      },
                      removeAttr: function(elem, value) {
                          var name, propName,
                            i = 0,
                            attrNames = value && value.match(core_rnotwhite);

                          if (attrNames && elem.nodeType === 1) {
                              while ((name = attrNames[i++])) {
                                  propName = jQuery.propFix[ name ] || name;

                                  // Boolean attributes get special treatment (#10870)
                                  if (jQuery.expr.match.bool.test(name)) {
                                      // Set corresponding property to false
                                      elem[ propName ] = false;
                                  }

                                  elem.removeAttribute(name);
                              }
                          }
                      },
                      attrHooks: {
                          type: {
                              set: function(elem, value) {
                                  if (!jQuery.support.radioValue && value === "radio" && jQuery.nodeName(elem, "input")) {
                                      // Setting the type on a radio button after the value resets the value in IE6-9
                                      // Reset value to default in case type is set after value during creation
                                      var val = elem.value;
                                      elem.setAttribute("type", value);
                                      if (val) {
                                          elem.value = val;
                                      }
                                      return value;
                                  }
                              }
                          }
                      },
                      propFix: {
                          "for": "htmlFor",
                          "class": "className"
                      },
                      prop: function(elem, name, value) {
                          var ret, hooks, notxml,
                            nType = elem.nodeType;

                          // don't get/set properties on text, comment and attribute nodes
                          if (!elem || nType === 3 || nType === 8 || nType === 2) {
                              return;
                          }

                          notxml = nType !== 1 || !jQuery.isXMLDoc(elem);

                          if (notxml) {
                              // Fix name and attach hooks
                              name = jQuery.propFix[ name ] || name;
                              hooks = jQuery.propHooks[ name ];
                          }

                          if (value !== undefined) {
                              return hooks && "set" in hooks && (ret = hooks.set(elem, value, name)) !== undefined ?
                                ret :
                                (elem[ name ] = value);

                          } else {
                              return hooks && "get" in hooks && (ret = hooks.get(elem, name)) !== null ?
                                ret :
                                elem[ name ];
                          }
                      },
                      propHooks: {
                          tabIndex: {
                              get: function(elem) {
                                  return elem.hasAttribute("tabindex") || rfocusable.test(elem.nodeName) || elem.href ?
                                    elem.tabIndex :
                                    -1;
                              }
                          }
                      }
                  });

// Hooks for boolean attributes
                  boolHook = {
                      set: function(elem, value, name) {
                          if (value === false) {
                              // Remove boolean attributes when set to false
                              jQuery.removeAttr(elem, name);
                          } else {
                              elem.setAttribute(name, name);
                          }
                          return name;
                      }
                  };
                  jQuery.each(jQuery.expr.match.bool.source.match(/\w+/g), function(i, name) {
                      var getter = jQuery.expr.attrHandle[ name ] || jQuery.find.attr;

                      jQuery.expr.attrHandle[ name ] = function(elem, name, isXML) {
                          var fn = jQuery.expr.attrHandle[ name ],
                            ret = isXML ?
                            undefined :
                            /* jshint eqeqeq: false */
                              // Temporarily disable this handler to check existence
                                (jQuery.expr.attrHandle[ name ] = undefined) !=
                                getter(elem, name, isXML) ?
                                name.toLowerCase() :
                                null;

                              // Restore handler
                              jQuery.expr.attrHandle[ name ] = fn;

                              return ret;
                          };
                      });

// Support: IE9+
// Selectedness for an option in an optgroup can be inaccurate
                    if (!jQuery.support.optSelected) {
                        jQuery.propHooks.selected = {
                            get: function(elem) {
                                var parent = elem.parentNode;
                                if (parent && parent.parentNode) {
                                    parent.parentNode.selectedIndex;
                                }
                                return null;
                            }
                        };
                    }

                    jQuery.each([
                        "tabIndex",
                        "readOnly",
                        "maxLength",
                        "cellSpacing",
                        "cellPadding",
                        "rowSpan",
                        "colSpan",
                        "useMap",
                        "frameBorder",
                        "contentEditable"
                    ], function() {
                        jQuery.propFix[ this.toLowerCase() ] = this;
                    });

// Radios and checkboxes getter/setter
                    jQuery.each([
                        "radio",
                        "checkbox"
                    ], function() {
                        jQuery.valHooks[ this ] = {
                            set: function(elem, value) {
                                if (jQuery.isArray(value)) {
                                    return (elem.checked = jQuery.inArray(jQuery(elem).val(), value) >= 0);
                                }
                            }
                        };
                        if (!jQuery.support.checkOn) {
                            jQuery.valHooks[ this ].get = function(elem) {
                                // Support: Webkit
                                // "" is returned instead of "on" if a value isn't specified
                                return elem.getAttribute("value") === null ? "on" : elem.value;
                            };
                        }
                    });
                    var rkeyEvent = /^key/,
                      rmouseEvent = /^(?:mouse|contextmenu)|click/,
                      rfocusMorph = /^(?:focusinfocus|focusoutblur)$/,
                      rtypenamespace = /^([^.]*)(?:\.(.+)|)$/;

                    function returnTrue() {
                        return true;
                    }

                    function returnFalse() {
                        return false;
                    }

                    function safeActiveElement() {
                        try {
                            return document.activeElement;
                        } catch (err) {
                        }
                    }

                    /*
                     * Helper functions for managing events -- not part of the public interface.
                     * Props to Dean Edwards' addEvent library for many of the ideas.
                     */
                    jQuery.event = {
                        global: {
                        },
                        add: function(elem, types, handler, data, selector) {

                            var handleObjIn, eventHandle, tmp,
                              events, t, handleObj,
                              special, handlers, type, namespaces, origType,
                              elemData = data_priv.get(elem);

                            // Don't attach events to noData or text/comment nodes (but allow plain objects)
                            if (!elemData) {
                                return;
                            }

                            // Caller can pass in an object of custom data in lieu of the handler
                            if (handler.handler) {
                                handleObjIn = handler;
                                handler = handleObjIn.handler;
                                selector = handleObjIn.selector;
                            }

                            // Make sure that the handler has a unique ID, used to find/remove it later
                            if (!handler.guid) {
                                handler.guid = jQuery.guid++;
                            }

                            // Init the element's event structure and main handler, if this is the first
                            if (!(events = elemData.events)) {
                                events = elemData.events = {
                                };
                            }
                            if (!(eventHandle = elemData.handle)) {
                                eventHandle = elemData.handle = function(e) {
                                    // Discard the second event of a jQuery.event.trigger() and
                                    // when an event is called after a page has unloaded
                                    return typeof jQuery !== core_strundefined && (!e || jQuery.event.triggered !== e.type) ?
                                      jQuery.event.dispatch.apply(eventHandle.elem, arguments) :
                                      undefined;
                                };
                                // Add elem as a property of the handle fn to prevent a memory leak with IE non-native events
                                eventHandle.elem = elem;
                            }

                            // Handle multiple events separated by a space
                            types = (types || "").match(core_rnotwhite) || [
                                ""
                            ];
                            t = types.length;
                            while (t--) {
                                tmp = rtypenamespace.exec(types[t]) || [
                                ];
                                type = origType = tmp[1];
                                namespaces = (tmp[2] || "").split(".").sort();

                                // There *must* be a type, no attaching namespace-only handlers
                                if (!type) {
                                    continue;
                                }

                                // If event changes its type, use the special event handlers for the changed type
                                special = jQuery.event.special[ type ] || {
                                };

                                // If selector defined, determine special event api type, otherwise given type
                                type = (selector ? special.delegateType : special.bindType) || type;

                                // Update special based on newly reset type
                                special = jQuery.event.special[ type ] || {
                                };

                                // handleObj is passed to all event handlers
                                handleObj = jQuery.extend({
                                    type: type,
                                    origType: origType,
                                    data: data,
                                    handler: handler,
                                    guid: handler.guid,
                                    selector: selector,
                                    needsContext: selector && jQuery.expr.match.needsContext.test(selector),
                                    namespace: namespaces.join(".")
                                },
                                handleObjIn);

                                // Init the event handler queue if we're the first
                                if (!(handlers = events[ type ])) {
                                    handlers = events[ type ] = [
                                    ];
                                    handlers.delegateCount = 0;

                                    // Only use addEventListener if the special events handler returns false
                                    if (!special.setup || special.setup.call(elem, data, namespaces, eventHandle) === false) {
                                        if (elem.addEventListener) {
                                            elem.addEventListener(type, eventHandle, false);
                                        }
                                    }
                                }

                                if (special.add) {
                                    special.add.call(elem, handleObj);

                                    if (!handleObj.handler.guid) {
                                        handleObj.handler.guid = handler.guid;
                                    }
                                }

                                // Add to the element's handler list, delegates in front
                                if (selector) {
                                    handlers.splice(handlers.delegateCount++, 0, handleObj);
                                } else {
                                    handlers.push(handleObj);
                                }

                                // Keep track of which events have ever been used, for event optimization
                                jQuery.event.global[ type ] = true;
                            }

                            // Nullify elem to prevent memory leaks in IE
                            elem = null;
                        },
                        // Detach an event or set of events from an element
                        remove: function(elem, types, handler, selector, mappedTypes) {

                            var j, origCount, tmp,
                              events, t, handleObj,
                              special, handlers, type, namespaces, origType,
                              elemData = data_priv.hasData(elem) && data_priv.get(elem);

                            if (!elemData || !(events = elemData.events)) {
                                return;
                            }

                            // Once for each type.namespace in types; type may be omitted
                            types = (types || "").match(core_rnotwhite) || [
                                ""
                            ];
                            t = types.length;
                            while (t--) {
                                tmp = rtypenamespace.exec(types[t]) || [
                                ];
                                type = origType = tmp[1];
                                namespaces = (tmp[2] || "").split(".").sort();

                                // Unbind all events (on this namespace, if provided) for the element
                                if (!type) {
                                    for (type in events) {
                                        jQuery.event.remove(elem, type + types[ t ], handler, selector, true);
                                    }
                                    continue;
                                }

                                special = jQuery.event.special[ type ] || {
                                };
                                type = (selector ? special.delegateType : special.bindType) || type;
                                handlers = events[ type ] || [
                                ];
                                tmp = tmp[2] && new RegExp("(^|\\.)" + namespaces.join("\\.(?:.*\\.|)") + "(\\.|$)");

                                // Remove matching events
                                origCount = j = handlers.length;
                                while (j--) {
                                    handleObj = handlers[ j ];

                                    if ((mappedTypes || origType === handleObj.origType) &&
                                      (!handler || handler.guid === handleObj.guid) &&
                                      (!tmp || tmp.test(handleObj.namespace)) &&
                                      (!selector || selector === handleObj.selector || selector === "**" && handleObj.selector)) {
                                        handlers.splice(j, 1);

                                        if (handleObj.selector) {
                                            handlers.delegateCount--;
                                        }
                                        if (special.remove) {
                                            special.remove.call(elem, handleObj);
                                        }
                                    }
                                }

                                // Remove generic event handler if we removed something and no more handlers exist
                                // (avoids potential for endless recursion during removal of special event handlers)
                                if (origCount && !handlers.length) {
                                    if (!special.teardown || special.teardown.call(elem, namespaces, elemData.handle) === false) {
                                        jQuery.removeEvent(elem, type, elemData.handle);
                                    }

                                    delete events[ type ];
                                }
                            }

                            // Remove the expando if it's no longer used
                            if (jQuery.isEmptyObject(events)) {
                                delete elemData.handle;
                                data_priv.remove(elem, "events");
                            }
                        },
                        trigger: function(event, data, elem, onlyHandlers) {

                            var i, cur, tmp, bubbleType, ontype, handle, special,
                              eventPath = [
                                elem || document
                            ],
                              type = core_hasOwn.call(event, "type") ? event.type : event,
                              namespaces = core_hasOwn.call(event, "namespace") ? event.namespace.split(".") : [
                            ];

                            cur = tmp = elem = elem || document;

                            // Don't do events on text and comment nodes
                            if (elem.nodeType === 3 || elem.nodeType === 8) {
                                return;
                            }

                            // focus/blur morphs to focusin/out; ensure we're not firing them right now
                            if (rfocusMorph.test(type + jQuery.event.triggered)) {
                                return;
                            }

                            if (type.indexOf(".") >= 0) {
                                // Namespaced trigger; create a regexp to match event type in handle()
                                namespaces = type.split(".");
                                type = namespaces.shift();
                                namespaces.sort();
                            }
                            ontype = type.indexOf(":") < 0 && "on" + type;

                            // Caller can pass in a jQuery.Event object, Object, or just an event type string
                            event = event[ jQuery.expando ] ?
                              event :
                              new jQuery.Event(type, typeof event === "object" && event);

                            // Trigger bitmask: & 1 for native handlers; & 2 for jQuery (always true)
                            event.isTrigger = onlyHandlers ? 2 : 3;
                            event.namespace = namespaces.join(".");
                            event.namespace_re = event.namespace ?
                              new RegExp("(^|\\.)" + namespaces.join("\\.(?:.*\\.|)") + "(\\.|$)") :
                              null;

                            // Clean up the event in case it is being reused
                            event.result = undefined;
                            if (!event.target) {
                                event.target = elem;
                            }

                            // Clone any incoming data and prepend the event, creating the handler arg list
                            data = data == null ?
                              [
                                  event
                              ] :
                              jQuery.makeArray(data, [
                                event
                            ]);

                            // Allow special events to draw outside the lines
                            special = jQuery.event.special[ type ] || {
                            };
                            if (!onlyHandlers && special.trigger && special.trigger.apply(elem, data) === false) {
                                return;
                            }

                            // Determine event propagation path in advance, per W3C events spec (#9951)
                            // Bubble up to document, then to window; watch for a global ownerDocument var (#9724)
                            if (!onlyHandlers && !special.noBubble && !jQuery.isWindow(elem)) {

                                bubbleType = special.delegateType || type;
                                if (!rfocusMorph.test(bubbleType + type)) {
                                    cur = cur.parentNode;
                                }
                                for (; cur; cur = cur.parentNode) {
                                    eventPath.push(cur);
                                    tmp = cur;
                                }

                                // Only add window if we got to document (e.g., not plain obj or detached DOM)
                                if (tmp === (elem.ownerDocument || document)) {
                                    eventPath.push(tmp.defaultView || tmp.parentWindow || window);
                                }
                            }

                            // Fire handlers on the event path
                            i = 0;
                            while ((cur = eventPath[i++]) && !event.isPropagationStopped()) {

                                event.type = i > 1 ?
                                  bubbleType :
                                  special.bindType || type;

                                // jQuery handler
                                handle = (data_priv.get(cur, "events") || {
                                })[ event.type ] && data_priv.get(cur, "handle");
                                if (handle) {
                                    handle.apply(cur, data);
                                }

                                // Native handler
                                handle = ontype && cur[ ontype ];
                                if (handle && jQuery.acceptData(cur) && handle.apply && handle.apply(cur, data) === false) {
                                    event.preventDefault();
                                }
                            }
                            event.type = type;

                            // If nobody prevented the default action, do it now
                            if (!onlyHandlers && !event.isDefaultPrevented()) {

                                if ((!special._default || special._default.apply(eventPath.pop(), data) === false) &&
                                  jQuery.acceptData(elem)) {

                                    // Call a native DOM method on the target with the same name name as the event.
                                    // Don't do default actions on window, that's where global variables be (#6170)
                                    if (ontype && jQuery.isFunction(elem[ type ]) && !jQuery.isWindow(elem)) {

                                        // Don't re-trigger an onFOO event when we call its FOO() method
                                        tmp = elem[ ontype ];

                                        if (tmp) {
                                            elem[ ontype ] = null;
                                        }

                                        // Prevent re-triggering of the same event, since we already bubbled it above
                                        jQuery.event.triggered = type;
                                        elem[ type ]();
                                        jQuery.event.triggered = undefined;

                                        if (tmp) {
                                            elem[ ontype ] = tmp;
                                        }
                                    }
                                }
                            }

                            return event.result;
                        },
                        dispatch: function(event) {

                            // Make a writable jQuery.Event from the native event object
                            event = jQuery.event.fix(event);

                            var i, j, ret, matched, handleObj,
                              handlerQueue = [
                            ],
                              args = core_slice.call(arguments),
                              handlers = (data_priv.get(this, "events") || {
                            })[ event.type ] || [
                            ],
                              special = jQuery.event.special[ event.type ] || {
                            };

                            // Use the fix-ed jQuery.Event rather than the (read-only) native event
                            args[0] = event;
                            event.delegateTarget = this;

                            // Call the preDispatch hook for the mapped type, and let it bail if desired
                            if (special.preDispatch && special.preDispatch.call(this, event) === false) {
                                return;
                            }

                            // Determine handlers
                            handlerQueue = jQuery.event.handlers.call(this, event, handlers);

                            // Run delegates first; they may want to stop propagation beneath us
                            i = 0;
                            while ((matched = handlerQueue[ i++ ]) && !event.isPropagationStopped()) {
                                event.currentTarget = matched.elem;

                                j = 0;
                                while ((handleObj = matched.handlers[ j++ ]) && !event.isImmediatePropagationStopped()) {

                                    // Triggered event must either 1) have no namespace, or
                                    // 2) have namespace(s) a subset or equal to those in the bound event (both can have no namespace).
                                    if (!event.namespace_re || event.namespace_re.test(handleObj.namespace)) {

                                        event.handleObj = handleObj;
                                        event.data = handleObj.data;

                                        ret = ((jQuery.event.special[ handleObj.origType ] || {
                                        }).handle || handleObj.handler)
                                          .apply(matched.elem, args);

                                        if (ret !== undefined) {
                                            if ((event.result = ret) === false) {
                                                event.preventDefault();
                                                event.stopPropagation();
                                            }
                                        }
                                    }
                                }
                            }

                            // Call the postDispatch hook for the mapped type
                            if (special.postDispatch) {
                                special.postDispatch.call(this, event);
                            }

                            return event.result;
                        },
                        handlers: function(event, handlers) {
                            var i, matches, sel, handleObj,
                              handlerQueue = [
                            ],
                              delegateCount = handlers.delegateCount,
                              cur = event.target;

                            // Find delegate handlers
                            // Black-hole SVG <use> instance trees (#13180)
                            // Avoid non-left-click bubbling in Firefox (#3861)
                            if (delegateCount && cur.nodeType && (!event.button || event.type !== "click")) {

                                for (; cur !== this; cur = cur.parentNode || this) {

                                    // Don't process clicks on disabled elements (#6911, #8165, #11382, #11764)
                                    if (cur.disabled !== true || event.type !== "click") {
                                        matches = [
                                        ];
                                        for (i = 0; i < delegateCount; i++) {
                                            handleObj = handlers[ i ];

                                            // Don't conflict with Object.prototype properties (#13203)
                                            sel = handleObj.selector + " ";

                                            if (matches[ sel ] === undefined) {
                                                matches[ sel ] = handleObj.needsContext ?
                                                  jQuery(sel, this).index(cur) >= 0 :
                                                  jQuery.find(sel, this, null, [
                                                    cur
                                                ]).length;
                                            }
                                            if (matches[ sel ]) {
                                                matches.push(handleObj);
                                            }
                                        }
                                        if (matches.length) {
                                            handlerQueue.push({
                                                elem: cur,
                                                handlers: matches
                                            });
                                        }
                                    }
                                }
                            }

                            // Add the remaining (directly-bound) handlers
                            if (delegateCount < handlers.length) {
                                handlerQueue.push({
                                    elem: this,
                                    handlers: handlers.slice(delegateCount)
                                });
                            }

                            return handlerQueue;
                        },
                        // Includes some event props shared by KeyEvent and MouseEvent
                        props: "altKey bubbles cancelable ctrlKey currentTarget eventPhase metaKey relatedTarget shiftKey target timeStamp view which".split(" "),
                        fixHooks: {
                        },
                        keyHooks: {
                            props: "char charCode key keyCode".split(" "),
                            filter: function(event, original) {

                                // Add which for key events
                                if (event.which == null) {
                                    event.which = original.charCode != null ? original.charCode : original.keyCode;
                                }

                                return event;
                            }
                        },
                        mouseHooks: {
                            props: "button buttons clientX clientY offsetX offsetY pageX pageY screenX screenY toElement".split(" "),
                            filter: function(event, original) {
                                var eventDoc, doc, body,
                                  button = original.button;

                                // Calculate pageX/Y if missing and clientX/Y available
                                if (event.pageX == null && original.clientX != null) {
                                    eventDoc = event.target.ownerDocument || document;
                                    doc = eventDoc.documentElement;
                                    body = eventDoc.body;

                                    event.pageX = original.clientX + (doc && doc.scrollLeft || body && body.scrollLeft || 0) - (doc && doc.clientLeft || body && body.clientLeft || 0);
                                    event.pageY = original.clientY + (doc && doc.scrollTop || body && body.scrollTop || 0) - (doc && doc.clientTop || body && body.clientTop || 0);
                                }

                                // Add which for click: 1 === left; 2 === middle; 3 === right
                                // Note: button is not normalized, so don't use it
                                if (!event.which && button !== undefined) {
                                    event.which = (button & 1 ? 1 : (button & 2 ? 3 : (button & 4 ? 2 : 0)));
                                }

                                return event;
                            }
                        },
                        fix: function(event) {
                            if (event[ jQuery.expando ]) {
                                return event;
                            }

                            // Create a writable copy of the event object and normalize some properties
                            var i, prop, copy,
                              type = event.type,
                              originalEvent = event,
                              fixHook = this.fixHooks[ type ];

                            if (!fixHook) {
                                this.fixHooks[ type ] = fixHook =
                                  rmouseEvent.test(type) ? this.mouseHooks :
                                  rkeyEvent.test(type) ? this.keyHooks :
                                  {
                                  };
                            }
                            copy = fixHook.props ? this.props.concat(fixHook.props) : this.props;

                            event = new jQuery.Event(originalEvent);

                            i = copy.length;
                            while (i--) {
                                prop = copy[ i ];
                                event[ prop ] = originalEvent[ prop ];
                            }

                            // Support: Cordova 2.5 (WebKit) (#13255)
                            // All events should have a target; Cordova deviceready doesn't
                            if (!event.target) {
                                event.target = document;
                            }

                            // Support: Safari 6.0+, Chrome < 28
                            // Target should not be a text node (#504, #13143)
                            if (event.target.nodeType === 3) {
                                event.target = event.target.parentNode;
                            }

                            return fixHook.filter ? fixHook.filter(event, originalEvent) : event;
                        },
                        special: {
                            load: {
                                // Prevent triggered image.load events from bubbling to window.load
                                noBubble: true
                            },
                            focus: {
                                // Fire native event if possible so blur/focus sequence is correct
                                trigger: function() {
                                    if (this !== safeActiveElement() && this.focus) {
                                        this.focus();
                                        return false;
                                    }
                                },
                                delegateType: "focusin"
                            },
                            blur: {
                                trigger: function() {
                                    if (this === safeActiveElement() && this.blur) {
                                        this.blur();
                                        return false;
                                    }
                                },
                                delegateType: "focusout"
                            },
                            click: {
                                // For checkbox, fire native event so checked state will be right
                                trigger: function() {
                                    if (this.type === "checkbox" && this.click && jQuery.nodeName(this, "input")) {
                                        this.click();
                                        return false;
                                    }
                                },
                                // For cross-browser consistency, don't fire native .click() on links
                                _default: function(event) {
                                    return jQuery.nodeName(event.target, "a");
                                }
                            },
                            beforeunload: {
                                postDispatch: function(event) {

                                    // Support: Firefox 20+
                                    // Firefox doesn't alert if the returnValue field is not set.
                                    if (event.result !== undefined) {
                                        event.originalEvent.returnValue = event.result;
                                    }
                                }
                            }
                        },
                        simulate: function(type, elem, event, bubble) {
                            // Piggyback on a donor event to simulate a different one.
                            // Fake originalEvent to avoid donor's stopPropagation, but if the
                            // simulated event prevents default then we do the same on the donor.
                            var e = jQuery.extend(
                              new jQuery.Event(),
                              event,
                              {
                                  type: type,
                                  isSimulated: true,
                                  originalEvent: {
                                  }
                              }
                            );
                            if (bubble) {
                                jQuery.event.trigger(e, null, elem);
                            } else {
                                jQuery.event.dispatch.call(elem, e);
                            }
                            if (e.isDefaultPrevented()) {
                                event.preventDefault();
                            }
                        }
                    };

                    jQuery.removeEvent = function(elem, type, handle) {
                        if (elem.removeEventListener) {
                            elem.removeEventListener(type, handle, false);
                        }
                    };

                    jQuery.Event = function(src, props) {
                        // Allow instantiation without the 'new' keyword
                        if (!(this instanceof jQuery.Event)) {
                            return new jQuery.Event(src, props);
                        }

                        // Event object
                        if (src && src.type) {
                            this.originalEvent = src;
                            this.type = src.type;

                            // Events bubbling up the document may have been marked as prevented
                            // by a handler lower down the tree; reflect the correct value.
                            this.isDefaultPrevented = (src.defaultPrevented ||
                              src.getPreventDefault && src.getPreventDefault()) ? returnTrue : returnFalse;

                            // Event type
                        } else {
                            this.type = src;
                        }

                        // Put explicitly provided properties onto the event object
                        if (props) {
                            jQuery.extend(this, props);
                        }

                        // Create a timestamp if incoming event doesn't have one
                        this.timeStamp = src && src.timeStamp || jQuery.now();

                        // Mark it as fixed
                        this[ jQuery.expando ] = true;
                    };

// jQuery.Event is based on DOM3 Events as specified by the ECMAScript Language Binding
// http://www.w3.org/TR/2003/WD-DOM-Level-3-Events-20030331/ecma-script-binding.html
                    jQuery.Event.prototype = {
                        isDefaultPrevented: returnFalse,
                        isPropagationStopped: returnFalse,
                        isImmediatePropagationStopped: returnFalse,
                        preventDefault: function() {
                            var e = this.originalEvent;

                            this.isDefaultPrevented = returnTrue;

                            if (e && e.preventDefault) {
                                e.preventDefault();
                            }
                        },
                        stopPropagation: function() {
                            var e = this.originalEvent;

                            this.isPropagationStopped = returnTrue;

                            if (e && e.stopPropagation) {
                                e.stopPropagation();
                            }
                        },
                        stopImmediatePropagation: function() {
                            this.isImmediatePropagationStopped = returnTrue;
                            this.stopPropagation();
                        }
                    };

// Create mouseenter/leave events using mouseover/out and event-time checks
// Support: Chrome 15+
                    jQuery.each({
                        mouseenter: "mouseover",
                        mouseleave: "mouseout"
                    },
                    function(orig, fix) {
                        jQuery.event.special[ orig ] = {
                            delegateType: fix,
                            bindType: fix,
                            handle: function(event) {
                                var ret,
                                  target = this,
                                  related = event.relatedTarget,
                                  handleObj = event.handleObj;

                                // For mousenter/leave call the handler if related is outside the target.
                                // NB: No relatedTarget if the mouse left/entered the browser window
                                if (!related || (related !== target && !jQuery.contains(target, related))) {
                                    event.type = handleObj.origType;
                                    ret = handleObj.handler.apply(this, arguments);
                                    event.type = fix;
                                }
                                return ret;
                            }
                        };
                    });

// Create "bubbling" focus and blur events
// Support: Firefox, Chrome, Safari
                    if (!jQuery.support.focusinBubbles) {
                        jQuery.each({
                            focus: "focusin",
                            blur: "focusout"
                        },
                        function(orig, fix) {

                            // Attach a single capturing handler while someone wants focusin/focusout
                            var attaches = 0,
                              handler = function(event) {
                                jQuery.event.simulate(fix, event.target, jQuery.event.fix(event), true);
                            };

                            jQuery.event.special[ fix ] = {
                                setup: function() {
                                    if (attaches++ === 0) {
                                        document.addEventListener(orig, handler, true);
                                    }
                                },
                                teardown: function() {
                                    if (--attaches === 0) {
                                        document.removeEventListener(orig, handler, true);
                                    }
                                }
                            };
                        });
                    }

                    jQuery.fn.extend({
                        on: function(types, selector, data, fn, /*INTERNAL*/ one) {
                            var origFn, type;

                            // Types can be a map of types/handlers
                            if (typeof types === "object") {
                                // ( types-Object, selector, data )
                                if (typeof selector !== "string") {
                                    // ( types-Object, data )
                                    data = data || selector;
                                    selector = undefined;
                                }
                                for (type in types) {
                                    this.on(type, selector, data, types[ type ], one);
                                }
                                return this;
                            }

                            if (data == null && fn == null) {
                                // ( types, fn )
                                fn = selector;
                                data = selector = undefined;
                            } else if (fn == null) {
                                if (typeof selector === "string") {
                                    // ( types, selector, fn )
                                    fn = data;
                                    data = undefined;
                                } else {
                                    // ( types, data, fn )
                                    fn = data;
                                    data = selector;
                                    selector = undefined;
                                }
                            }
                            if (fn === false) {
                                fn = returnFalse;
                            } else if (!fn) {
                                return this;
                            }

                            if (one === 1) {
                                origFn = fn;
                                fn = function(event) {
                                    // Can use an empty set, since event contains the info
                                    jQuery().off(event);
                                    return origFn.apply(this, arguments);
                                };
                                // Use same guid so caller can remove using origFn
                                fn.guid = origFn.guid || (origFn.guid = jQuery.guid++);
                            }
                            return this.each(function() {
                                jQuery.event.add(this, types, fn, data, selector);
                            });
                        },
                        one: function(types, selector, data, fn) {
                            return this.on(types, selector, data, fn, 1);
                        },
                        off: function(types, selector, fn) {
                            var handleObj, type;
                            if (types && types.preventDefault && types.handleObj) {
                                // ( event )  dispatched jQuery.Event
                                handleObj = types.handleObj;
                                jQuery(types.delegateTarget).off(
                                  handleObj.namespace ? handleObj.origType + "." + handleObj.namespace : handleObj.origType,
                                  handleObj.selector,
                                  handleObj.handler
                                  );
                                return this;
                            }
                            if (typeof types === "object") {
                                // ( types-object [, selector] )
                                for (type in types) {
                                    this.off(type, selector, types[ type ]);
                                }
                                return this;
                            }
                            if (selector === false || typeof selector === "function") {
                                // ( types [, fn] )
                                fn = selector;
                                selector = undefined;
                            }
                            if (fn === false) {
                                fn = returnFalse;
                            }
                            return this.each(function() {
                                jQuery.event.remove(this, types, fn, selector);
                            });
                        },
                        trigger: function(type, data) {
                            return this.each(function() {
                                jQuery.event.trigger(type, data, this);
                            });
                        },
                        triggerHandler: function(type, data) {
                            var elem = this[0];
                            if (elem) {
                                return jQuery.event.trigger(type, data, elem, true);
                            }
                        }
                    });
                    var isSimple = /^.[^:#\[\.,]*$/,
                      rparentsprev = /^(?:parents|prev(?:Until|All))/,
                      rneedsContext = jQuery.expr.match.needsContext,
                      // methods guaranteed to produce a unique set when starting from a unique set
                      guaranteedUnique = {
                        children: true,
                        contents: true,
                        next: true,
                        prev: true
                    };

                    jQuery.fn.extend({
                        find: function(selector) {
                            var i,
                              ret = [
                            ],
                              self = this,
                              len = self.length;

                            if (typeof selector !== "string") {
                                return this.pushStack(jQuery(selector).filter(function() {
                                    for (i = 0; i < len; i++) {
                                        if (jQuery.contains(self[ i ], this)) {
                                            return true;
                                        }
                                    }
                                }));
                            }

                            for (i = 0; i < len; i++) {
                                jQuery.find(selector, self[ i ], ret);
                            }

                            // Needed because $( selector, context ) becomes $( context ).find( selector )
                            ret = this.pushStack(len > 1 ? jQuery.unique(ret) : ret);
                            ret.selector = this.selector ? this.selector + " " + selector : selector;
                            return ret;
                        },
                        has: function(target) {
                            var targets = jQuery(target, this),
                              l = targets.length;

                            return this.filter(function() {
                                var i = 0;
                                for (; i < l; i++) {
                                    if (jQuery.contains(this, targets[i])) {
                                        return true;
                                    }
                                }
                            });
                        },
                        not: function(selector) {
                            return this.pushStack(winnow(this, selector || [
                            ], true));
                        },
                        filter: function(selector) {
                            return this.pushStack(winnow(this, selector || [
                            ], false));
                        },
                        is: function(selector) {
                            return !!winnow(
                              this,
                              // If this is a positional/relative selector, check membership in the returned set
                              // so $("p:first").is("p:last") won't return true for a doc with two "p".
                              typeof selector === "string" && rneedsContext.test(selector) ?
                              jQuery(selector) :
                              selector || [
                            ],
                              false
                              ).length;
                        },
                        closest: function(selectors, context) {
                            var cur,
                              i = 0,
                              l = this.length,
                              matched = [
                            ],
                              pos = (rneedsContext.test(selectors) || typeof selectors !== "string") ?
                              jQuery(selectors, context || this.context) :
                              0;

                            for (; i < l; i++) {
                                for (cur = this[i]; cur && cur !== context; cur = cur.parentNode) {
                                    // Always skip document fragments
                                    if (cur.nodeType < 11 && (pos ?
                                      pos.index(cur) > -1 :
                                      // Don't pass non-elements to Sizzle
                                      cur.nodeType === 1 &&
                                      jQuery.find.matchesSelector(cur, selectors))) {

                                        cur = matched.push(cur);
                                        break;
                                    }
                                }
                            }

                            return this.pushStack(matched.length > 1 ? jQuery.unique(matched) : matched);
                        },
                        // Determine the position of an element within
                        // the matched set of elements
                        index: function(elem) {

                            // No argument, return index in parent
                            if (!elem) {
                                return (this[ 0 ] && this[ 0 ].parentNode) ? this.first().prevAll().length : -1;
                            }

                            // index in selector
                            if (typeof elem === "string") {
                                return core_indexOf.call(jQuery(elem), this[ 0 ]);
                            }

                            // Locate the position of the desired element
                            return core_indexOf.call(this,
                              // If it receives a jQuery object, the first element is used
                              elem.jquery ? elem[ 0 ] : elem
                              );
                        },
                        add: function(selector, context) {
                            var set = typeof selector === "string" ?
                              jQuery(selector, context) :
                              jQuery.makeArray(selector && selector.nodeType ? [
                                selector
                            ] : selector),
                              all = jQuery.merge(this.get(), set);

                            return this.pushStack(jQuery.unique(all));
                        },
                        addBack: function(selector) {
                            return this.add(selector == null ?
                              this.prevObject : this.prevObject.filter(selector)
                              );
                        }
                    });

                    function sibling(cur, dir) {
                        while ((cur = cur[dir]) && cur.nodeType !== 1) {
                        }

                        return cur;
                    }

                    jQuery.each({
                        parent: function(elem) {
                            var parent = elem.parentNode;
                            return parent && parent.nodeType !== 11 ? parent : null;
                        },
                        parents: function(elem) {
                            return jQuery.dir(elem, "parentNode");
                        },
                        parentsUntil: function(elem, i, until) {
                            return jQuery.dir(elem, "parentNode", until);
                        },
                        next: function(elem) {
                            return sibling(elem, "nextSibling");
                        },
                        prev: function(elem) {
                            return sibling(elem, "previousSibling");
                        },
                        nextAll: function(elem) {
                            return jQuery.dir(elem, "nextSibling");
                        },
                        prevAll: function(elem) {
                            return jQuery.dir(elem, "previousSibling");
                        },
                        nextUntil: function(elem, i, until) {
                            return jQuery.dir(elem, "nextSibling", until);
                        },
                        prevUntil: function(elem, i, until) {
                            return jQuery.dir(elem, "previousSibling", until);
                        },
                        siblings: function(elem) {
                            return jQuery.sibling((elem.parentNode || {
                            }).firstChild, elem);
                        },
                        children: function(elem) {
                            return jQuery.sibling(elem.firstChild);
                        },
                        contents: function(elem) {
                            return elem.contentDocument || jQuery.merge([
                            ], elem.childNodes);
                        }
                    },
                    function(name, fn) {
                        jQuery.fn[ name ] = function(until, selector) {
                            var matched = jQuery.map(this, fn, until);

                            if (name.slice(-5) !== "Until") {
                                selector = until;
                            }

                            if (selector && typeof selector === "string") {
                                matched = jQuery.filter(selector, matched);
                            }

                            if (this.length > 1) {
                                // Remove duplicates
                                if (!guaranteedUnique[ name ]) {
                                    jQuery.unique(matched);
                                }

                                // Reverse order for parents* and prev-derivatives
                                if (rparentsprev.test(name)) {
                                    matched.reverse();
                                }
                            }

                            return this.pushStack(matched);
                        };
                    });

                    jQuery.extend({
                        filter: function(expr, elems, not) {
                            var elem = elems[ 0 ];

                            if (not) {
                                expr = ":not(" + expr + ")";
                            }

                            return elems.length === 1 && elem.nodeType === 1 ?
                              jQuery.find.matchesSelector(elem, expr) ? [
                                elem
                            ] : [
                            ] :
                              jQuery.find.matches(expr, jQuery.grep(elems, function(elem) {
                                return elem.nodeType === 1;
                            }));
                        },
                        dir: function(elem, dir, until) {
                            var matched = [
                            ],
                              truncate = until !== undefined;

                            while ((elem = elem[ dir ]) && elem.nodeType !== 9) {
                                if (elem.nodeType === 1) {
                                    if (truncate && jQuery(elem).is(until)) {
                                        break;
                                    }
                                    matched.push(elem);
                                }
                            }
                            return matched;
                        },
                        sibling: function(n, elem) {
                            var matched = [
                            ];

                            for (; n; n = n.nextSibling) {
                                if (n.nodeType === 1 && n !== elem) {
                                    matched.push(n);
                                }
                            }

                            return matched;
                        }
                    });

// Implement the identical functionality for filter and not
                    function winnow(elements, qualifier, not) {
                        if (jQuery.isFunction(qualifier)) {
                            return jQuery.grep(elements, function(elem, i) {
                                /* jshint -W018 */
                                return !!qualifier.call(elem, i, elem) !== not;
                            });

                        }

                        if (qualifier.nodeType) {
                            return jQuery.grep(elements, function(elem) {
                                return (elem === qualifier) !== not;
                            });

                        }

                        if (typeof qualifier === "string") {
                            if (isSimple.test(qualifier)) {
                                return jQuery.filter(qualifier, elements, not);
                            }

                            qualifier = jQuery.filter(qualifier, elements);
                        }

                        return jQuery.grep(elements, function(elem) {
                            return (core_indexOf.call(qualifier, elem) >= 0) !== not;
                        });
                    }
                    var rxhtmlTag = /<(?!area|br|col|embed|hr|img|input|link|meta|param)(([\w:]+)[^>]*)\/>/gi,
                      rtagName = /<([\w:]+)/,
                      rhtml = /<|&#?\w+;/,
                      rnoInnerhtml = /<(?:script|style|link)/i,
                      manipulation_rcheckableType = /^(?:checkbox|radio)$/i,
                      // checked="checked" or checked
                      rchecked = /checked\s*(?:[^=]|=\s*.checked.)/i,
                      rscriptType = /^$|\/(?:java|ecma)script/i,
                      rscriptTypeMasked = /^true\/(.*)/,
                      rcleanScript = /^\s*<!(?:\[CDATA\[|--)|(?:\]\]|--)>\s*$/g,
                      // We have to close these tags to support XHTML (#13200)
                      wrapMap = {
                        // Support: IE 9
                        option: [
                            1,
                            "<select multiple='multiple'>",
                            "</select>"
                        ],
                        thead: [
                            1,
                            "<table>",
                            "</table>"
                        ],
                        col: [
                            2,
                            "<table><colgroup>",
                            "</colgroup></table>"
                        ],
                        tr: [
                            2,
                            "<table><tbody>",
                            "</tbody></table>"
                        ],
                        td: [
                            3,
                            "<table><tbody><tr>",
                            "</tr></tbody></table>"
                        ],
                        _default: [
                            0,
                            "",
                            ""
                        ]
                    };

// Support: IE 9
                    wrapMap.optgroup = wrapMap.option;

                    wrapMap.tbody = wrapMap.tfoot = wrapMap.colgroup = wrapMap.caption = wrapMap.thead;
                    wrapMap.th = wrapMap.td;

                    jQuery.fn.extend({
                        text: function(value) {
                            return jQuery.access(this, function(value) {
                                return value === undefined ?
                                  jQuery.text(this) :
                                  this.empty().append((this[ 0 ] && this[ 0 ].ownerDocument || document).createTextNode(value));
                            }, null, value, arguments.length);
                        },
                        append: function() {
                            return this.domManip(arguments, function(elem) {
                                if (this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9) {
                                    var target = manipulationTarget(this, elem);
                                    target.appendChild(elem);
                                }
                            });
                        },
                        prepend: function() {
                            return this.domManip(arguments, function(elem) {
                                if (this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9) {
                                    var target = manipulationTarget(this, elem);
                                    target.insertBefore(elem, target.firstChild);
                                }
                            });
                        },
                        before: function() {
                            return this.domManip(arguments, function(elem) {
                                if (this.parentNode) {
                                    this.parentNode.insertBefore(elem, this);
                                }
                            });
                        },
                        after: function() {
                            return this.domManip(arguments, function(elem) {
                                if (this.parentNode) {
                                    this.parentNode.insertBefore(elem, this.nextSibling);
                                }
                            });
                        },
                        // keepData is for internal use only--do not document
                        remove: function(selector, keepData) {
                            var elem,
                              elems = selector ? jQuery.filter(selector, this) : this,
                              i = 0;

                            for (; (elem = elems[i]) != null; i++) {
                                if (!keepData && elem.nodeType === 1) {
                                    jQuery.cleanData(getAll(elem));
                                }

                                if (elem.parentNode) {
                                    if (keepData && jQuery.contains(elem.ownerDocument, elem)) {
                                        setGlobalEval(getAll(elem, "script"));
                                    }
                                    elem.parentNode.removeChild(elem);
                                }
                            }

                            return this;
                        },
                        empty: function() {
                            var elem,
                              i = 0;

                            for (; (elem = this[i]) != null; i++) {
                                if (elem.nodeType === 1) {

                                    // Prevent memory leaks
                                    jQuery.cleanData(getAll(elem, false));

                                    // Remove any remaining nodes
                                    elem.textContent = "";
                                }
                            }

                            return this;
                        },
                        clone: function(dataAndEvents, deepDataAndEvents) {
                            dataAndEvents = dataAndEvents == null ? false : dataAndEvents;
                            deepDataAndEvents = deepDataAndEvents == null ? dataAndEvents : deepDataAndEvents;

                            return this.map(function() {
                                return jQuery.clone(this, dataAndEvents, deepDataAndEvents);
                            });
                        },
                        html: function(value) {
                            return jQuery.access(this, function(value) {
                                var elem = this[ 0 ] || {
                                },
                                  i = 0,
                                  l = this.length;

                                if (value === undefined && elem.nodeType === 1) {
                                    return elem.innerHTML;
                                }

                                // See if we can take a shortcut and just use innerHTML
                                if (typeof value === "string" && !rnoInnerhtml.test(value) &&
                                  !wrapMap[ (rtagName.exec(value) || [
                                    "",
                                    ""
                                ])[ 1 ].toLowerCase() ]) {

                                    value = value.replace(rxhtmlTag, "<$1></$2>");

                                    try {
                                        for (; i < l; i++) {
                                            elem = this[ i ] || {
                                            };

                                            // Remove element nodes and prevent memory leaks
                                            if (elem.nodeType === 1) {
                                                jQuery.cleanData(getAll(elem, false));
                                                elem.innerHTML = value;
                                            }
                                        }

                                        elem = 0;

                                        // If using innerHTML throws an exception, use the fallback method
                                    } catch (e) {
                                    }
                                }

                                if (elem) {
                                    this.empty().append(value);
                                }
                            }, null, value, arguments.length);
                        },
                        replaceWith: function() {
                            var
                              // Snapshot the DOM in case .domManip sweeps something relevant into its fragment
                              args = jQuery.map(this, function(elem) {
                                return [
                                    elem.nextSibling,
                                    elem.parentNode
                                ];
                            }),
                              i = 0;

                            // Make the changes, replacing each context element with the new content
                            this.domManip(arguments, function(elem) {
                                var next = args[ i++ ],
                                  parent = args[ i++ ];

                                if (parent) {
                                    // Don't use the snapshot next if it has moved (#13810)
                                    if (next && next.parentNode !== parent) {
                                        next = this.nextSibling;
                                    }
                                    jQuery(this).remove();
                                    parent.insertBefore(elem, next);
                                }
                                // Allow new content to include elements from the context set
                            }, true);

                            // Force removal if there was no new content (e.g., from empty arguments)
                            return i ? this : this.remove();
                        },
                        detach: function(selector) {
                            return this.remove(selector, true);
                        },
                        domManip: function(args, callback, allowIntersection) {

                            // Flatten any nested arrays
                            args = core_concat.apply([
                            ], args);

                            var fragment, first, scripts, hasScripts, node, doc,
                              i = 0,
                              l = this.length,
                              set = this,
                              iNoClone = l - 1,
                              value = args[ 0 ],
                              isFunction = jQuery.isFunction(value);

                            // We can't cloneNode fragments that contain checked, in WebKit
                            if (isFunction || !(l <= 1 || typeof value !== "string" || jQuery.support.checkClone || !rchecked.test(value))) {
                                return this.each(function(index) {
                                    var self = set.eq(index);
                                    if (isFunction) {
                                        args[ 0 ] = value.call(this, index, self.html());
                                    }
                                    self.domManip(args, callback, allowIntersection);
                                });
                            }

                            if (l) {
                                fragment = jQuery.buildFragment(args, this[ 0 ].ownerDocument, false, !allowIntersection && this);
                                first = fragment.firstChild;

                                if (fragment.childNodes.length === 1) {
                                    fragment = first;
                                }

                                if (first) {
                                    scripts = jQuery.map(getAll(fragment, "script"), disableScript);
                                    hasScripts = scripts.length;

                                    // Use the original fragment for the last item instead of the first because it can end up
                                    // being emptied incorrectly in certain situations (#8070).
                                    for (; i < l; i++) {
                                        node = fragment;

                                        if (i !== iNoClone) {
                                            node = jQuery.clone(node, true, true);

                                            // Keep references to cloned scripts for later restoration
                                            if (hasScripts) {
                                                // Support: QtWebKit
                                                // jQuery.merge because core_push.apply(_, arraylike) throws
                                                jQuery.merge(scripts, getAll(node, "script"));
                                            }
                                        }

                                        callback.call(this[ i ], node, i);
                                    }

                                    if (hasScripts) {
                                        doc = scripts[ scripts.length - 1 ].ownerDocument;

                                        // Reenable scripts
                                        jQuery.map(scripts, restoreScript);

                                        // Evaluate executable scripts on first document insertion
                                        for (i = 0; i < hasScripts; i++) {
                                            node = scripts[ i ];
                                            if (rscriptType.test(node.type || "") &&
                                              !data_priv.access(node, "globalEval") && jQuery.contains(doc, node)) {

                                                if (node.src) {
                                                    // Hope ajax is available...
                                                    jQuery._evalUrl(node.src);
                                                } else {
                                                    jQuery.globalEval(node.textContent.replace(rcleanScript, ""));
                                                }
                                            }
                                        }
                                    }
                                }
                            }

                            return this;
                        }
                    });

                    jQuery.each({
                        appendTo: "append",
                        prependTo: "prepend",
                        insertBefore: "before",
                        insertAfter: "after",
                        replaceAll: "replaceWith"
                    },
                    function(name, original) {
                        jQuery.fn[ name ] = function(selector) {
                            var elems,
                              ret = [
                            ],
                              insert = jQuery(selector),
                              last = insert.length - 1,
                              i = 0;

                            for (; i <= last; i++) {
                                elems = i === last ? this : this.clone(true);
                                jQuery(insert[ i ])[ original ](elems);

                                // Support: QtWebKit
                                // .get() because core_push.apply(_, arraylike) throws
                                core_push.apply(ret, elems.get());
                            }

                            return this.pushStack(ret);
                        };
                    });

                    jQuery.extend({
                        clone: function(elem, dataAndEvents, deepDataAndEvents) {
                            var i, l, srcElements, destElements,
                              clone = elem.cloneNode(true),
                              inPage = jQuery.contains(elem.ownerDocument, elem);

                            // Support: IE >= 9
                            // Fix Cloning issues
                            if (!jQuery.support.noCloneChecked && (elem.nodeType === 1 || elem.nodeType === 11) && !jQuery.isXMLDoc(elem)) {

                                // We eschew Sizzle here for performance reasons: http://jsperf.com/getall-vs-sizzle/2
                                destElements = getAll(clone);
                                srcElements = getAll(elem);

                                for (i = 0, l = srcElements.length; i < l; i++) {
                                    fixInput(srcElements[ i ], destElements[ i ]);
                                }
                            }

                            // Copy the events from the original to the clone
                            if (dataAndEvents) {
                                if (deepDataAndEvents) {
                                    srcElements = srcElements || getAll(elem);
                                    destElements = destElements || getAll(clone);

                                    for (i = 0, l = srcElements.length; i < l; i++) {
                                        cloneCopyEvent(srcElements[ i ], destElements[ i ]);
                                    }
                                } else {
                                    cloneCopyEvent(elem, clone);
                                }
                            }

                            // Preserve script evaluation history
                            destElements = getAll(clone, "script");
                            if (destElements.length > 0) {
                                setGlobalEval(destElements, !inPage && getAll(elem, "script"));
                            }

                            // Return the cloned set
                            return clone;
                        },
                        buildFragment: function(elems, context, scripts, selection) {
                            var elem, tmp, tag, wrap, contains, j,
                              i = 0,
                              l = elems.length,
                              fragment = context.createDocumentFragment(),
                              nodes = [
                            ];

                            for (; i < l; i++) {
                                elem = elems[ i ];

                                if (elem || elem === 0) {

                                    // Add nodes directly
                                    if (jQuery.type(elem) === "object") {
                                        // Support: QtWebKit
                                        // jQuery.merge because core_push.apply(_, arraylike) throws
                                        jQuery.merge(nodes, elem.nodeType ? [
                                            elem
                                        ] : elem);

                                        // Convert non-html into a text node
                                    } else if (!rhtml.test(elem)) {
                                        nodes.push(context.createTextNode(elem));

                                        // Convert html into DOM nodes
                                    } else {
                                        tmp = tmp || fragment.appendChild(context.createElement("div"));

                                        // Deserialize a standard representation
                                        tag = (rtagName.exec(elem) || [
                                            "",
                                            ""
                                        ])[ 1 ].toLowerCase();
                                        wrap = wrapMap[ tag ] || wrapMap._default;
                                        tmp.innerHTML = wrap[ 1 ] + elem.replace(rxhtmlTag, "<$1></$2>") + wrap[ 2 ];

                                        // Descend through wrappers to the right content
                                        j = wrap[ 0 ];
                                        while (j--) {
                                            tmp = tmp.firstChild;
                                        }

                                        // Support: QtWebKit
                                        // jQuery.merge because core_push.apply(_, arraylike) throws
                                        jQuery.merge(nodes, tmp.childNodes);

                                        // Remember the top-level container
                                        tmp = fragment.firstChild;

                                        // Fixes #12346
                                        // Support: Webkit, IE
                                        tmp.textContent = "";
                                    }
                                }
                            }

                            // Remove wrapper from fragment
                            fragment.textContent = "";

                            i = 0;
                            while ((elem = nodes[ i++ ])) {

                                // #4087 - If origin and destination elements are the same, and this is
                                // that element, do not do anything
                                if (selection && jQuery.inArray(elem, selection) !== -1) {
                                    continue;
                                }

                                contains = jQuery.contains(elem.ownerDocument, elem);

                                // Append to fragment
                                tmp = getAll(fragment.appendChild(elem), "script");

                                // Preserve script evaluation history
                                if (contains) {
                                    setGlobalEval(tmp);
                                }

                                // Capture executables
                                if (scripts) {
                                    j = 0;
                                    while ((elem = tmp[ j++ ])) {
                                        if (rscriptType.test(elem.type || "")) {
                                            scripts.push(elem);
                                        }
                                    }
                                }
                            }

                            return fragment;
                        },
                        cleanData: function(elems) {
                            var data, elem, events, type, key, j,
                              special = jQuery.event.special,
                              i = 0;

                            for (; (elem = elems[ i ]) !== undefined; i++) {
                                if (Data.accepts(elem)) {
                                    key = elem[ data_priv.expando ];

                                    if (key && (data = data_priv.cache[ key ])) {
                                        events = Object.keys(data.events || {
                                        });
                                        if (events.length) {
                                            for (j = 0; (type = events[j]) !== undefined; j++) {
                                                if (special[ type ]) {
                                                    jQuery.event.remove(elem, type);

                                                    // This is a shortcut to avoid jQuery.event.remove's overhead
                                                } else {
                                                    jQuery.removeEvent(elem, type, data.handle);
                                                }
                                            }
                                        }
                                        if (data_priv.cache[ key ]) {
                                            // Discard any remaining `private` data
                                            delete data_priv.cache[ key ];
                                        }
                                    }
                                }
                                // Discard any remaining `user` data
                                delete data_user.cache[ elem[ data_user.expando ] ];
                            }
                        },
                        _evalUrl: function(url) {
                            return jQuery.ajax({
                                url: url,
                                type: "GET",
                                dataType: "script",
                                async: false,
                                global: false,
                                "throws": true
                            });
                        }
                    });

// Support: 1.x compatibility
// Manipulating tables requires a tbody
                    function manipulationTarget(elem, content) {
                        return jQuery.nodeName(elem, "table") &&
                          jQuery.nodeName(content.nodeType === 1 ? content : content.firstChild, "tr") ?
                          elem.getElementsByTagName("tbody")[0] ||
                          elem.appendChild(elem.ownerDocument.createElement("tbody")) :
                          elem;
                    }

// Replace/restore the type attribute of script elements for safe DOM manipulation
                    function disableScript(elem) {
                        elem.type = (elem.getAttribute("type") !== null) + "/" + elem.type;
                        return elem;
                    }
                    function restoreScript(elem) {
                        var match = rscriptTypeMasked.exec(elem.type);

                        if (match) {
                            elem.type = match[ 1 ];
                        } else {
                            elem.removeAttribute("type");
                        }

                        return elem;
                    }

// Mark scripts as having already been evaluated
                    function setGlobalEval(elems, refElements) {
                        var l = elems.length,
                          i = 0;

                        for (; i < l; i++) {
                            data_priv.set(
                              elems[ i ], "globalEval", !refElements || data_priv.get(refElements[ i ], "globalEval")
                              );
                        }
                    }

                    function cloneCopyEvent(src, dest) {
                        var i, l, type, pdataOld, pdataCur, udataOld, udataCur, events;

                        if (dest.nodeType !== 1) {
                            return;
                        }

                        // 1. Copy private data: events, handlers, etc.
                        if (data_priv.hasData(src)) {
                            pdataOld = data_priv.access(src);
                            pdataCur = data_priv.set(dest, pdataOld);
                            events = pdataOld.events;

                            if (events) {
                                delete pdataCur.handle;
                                pdataCur.events = {
                                };

                                for (type in events) {
                                    for (i = 0, l = events[ type ].length; i < l; i++) {
                                        jQuery.event.add(dest, type, events[ type ][ i ]);
                                    }
                                }
                            }
                        }

                        // 2. Copy user data
                        if (data_user.hasData(src)) {
                            udataOld = data_user.access(src);
                            udataCur = jQuery.extend({
                            }, udataOld);

                            data_user.set(dest, udataCur);
                        }
                    }


                    function getAll(context, tag) {
                        var ret = context.getElementsByTagName ? context.getElementsByTagName(tag || "*") :
                          context.querySelectorAll ? context.querySelectorAll(tag || "*") :
                          [
                          ];

                        return tag === undefined || tag && jQuery.nodeName(context, tag) ?
                          jQuery.merge([
                            context
                        ], ret) :
                          ret;
                    }

// Support: IE >= 9
                    function fixInput(src, dest) {
                        var nodeName = dest.nodeName.toLowerCase();

                        // Fails to persist the checked state of a cloned checkbox or radio button.
                        if (nodeName === "input" && manipulation_rcheckableType.test(src.type)) {
                            dest.checked = src.checked;

                            // Fails to return the selected option to the default selected state when cloning options
                        } else if (nodeName === "input" || nodeName === "textarea") {
                            dest.defaultValue = src.defaultValue;
                        }
                    }
                    jQuery.fn.extend({
                        wrapAll: function(html) {
                            var wrap;

                            if (jQuery.isFunction(html)) {
                                return this.each(function(i) {
                                    jQuery(this).wrapAll(html.call(this, i));
                                });
                            }

                            if (this[ 0 ]) {

                                // The elements to wrap the target around
                                wrap = jQuery(html, this[ 0 ].ownerDocument).eq(0).clone(true);

                                if (this[ 0 ].parentNode) {
                                    wrap.insertBefore(this[ 0 ]);
                                }

                                wrap.map(function() {
                                    var elem = this;

                                    while (elem.firstElementChild) {
                                        elem = elem.firstElementChild;
                                    }

                                    return elem;
                                }).append(this);
                            }

                            return this;
                        },
                        wrapInner: function(html) {
                            if (jQuery.isFunction(html)) {
                                return this.each(function(i) {
                                    jQuery(this).wrapInner(html.call(this, i));
                                });
                            }

                            return this.each(function() {
                                var self = jQuery(this),
                                  contents = self.contents();

                                if (contents.length) {
                                    contents.wrapAll(html);

                                } else {
                                    self.append(html);
                                }
                            });
                        },
                        wrap: function(html) {
                            var isFunction = jQuery.isFunction(html);

                            return this.each(function(i) {
                                jQuery(this).wrapAll(isFunction ? html.call(this, i) : html);
                            });
                        },
                        unwrap: function() {
                            return this.parent().each(function() {
                                if (!jQuery.nodeName(this, "body")) {
                                    jQuery(this).replaceWith(this.childNodes);
                                }
                            }).end();
                        }
                    });
                    var curCSS, iframe,
                      // swappable if display is none or starts with table except "table", "table-cell", or "table-caption"
                      // see here for display values: https://developer.mozilla.org/en-US/docs/CSS/display
                      rdisplayswap = /^(none|table(?!-c[ea]).+)/,
                      rmargin = /^margin/,
                      rnumsplit = new RegExp("^(" + core_pnum + ")(.*)$", "i"),
                      rnumnonpx = new RegExp("^(" + core_pnum + ")(?!px)[a-z%]+$", "i"),
                      rrelNum = new RegExp("^([+-])=(" + core_pnum + ")", "i"),
                    elemdisplay = {
                      BODY: "block"
                  },
                  cssShow = {
                      position: "absolute",
                      visibility: "hidden",
                      display: "block"
                  },
                  cssNormalTransform = {
                      letterSpacing: 0,
                      fontWeight: 400
                  },
                  cssExpand = [
                      "Top",
                      "Right",
                      "Bottom",
                      "Left"
                  ],
                    cssPrefixes = [
                      "Webkit",
                      "O",
                      "Moz",
                      "ms"
                  ];

// return a css property mapped to a potentially vendor prefixed property
                  function vendorPropName(style, name) {

                      // shortcut for names that are not vendor prefixed
                      if (name in style) {
                          return name;
                      }

                      // check for vendor prefixed names
                      var capName = name.charAt(0).toUpperCase() + name.slice(1),
                        origName = name,
                        i = cssPrefixes.length;

                      while (i--) {
                          name = cssPrefixes[ i ] + capName;
                          if (name in style) {
                              return name;
                          }
                      }

                      return origName;
                  }

                  function isHidden(elem, el) {
                      // isHidden might be called from jQuery#filter function;
                      // in that case, element will be second argument
                      elem = el || elem;
                      return jQuery.css(elem, "display") === "none" || !jQuery.contains(elem.ownerDocument, elem);
                  }

// NOTE: we've included the "window" in window.getComputedStyle
// because jsdom on node.js will break without it.
                  function getStyles(elem) {
                      return window.getComputedStyle(elem, null);
                  }

                  function showHide(elements, show) {
                      var display, elem, hidden,
                        values = [
                      ],
                        index = 0,
                        length = elements.length;

                      for (; index < length; index++) {
                          elem = elements[ index ];
                          if (!elem.style) {
                              continue;
                          }

                          values[ index ] = data_priv.get(elem, "olddisplay");
                          display = elem.style.display;
                          if (show) {
                              // Reset the inline display of this element to learn if it is
                              // being hidden by cascaded rules or not
                              if (!values[ index ] && display === "none") {
                                  elem.style.display = "";
                              }

                              // Set elements which have been overridden with display: none
                              // in a stylesheet to whatever the default browser style is
                              // for such an element
                              if (elem.style.display === "" && isHidden(elem)) {
                                  values[ index ] = data_priv.access(elem, "olddisplay", css_defaultDisplay(elem.nodeName));
                              }
                          } else {

                              if (!values[ index ]) {
                                  hidden = isHidden(elem);

                                  if (display && display !== "none" || !hidden) {
                                      data_priv.set(elem, "olddisplay", hidden ? display : jQuery.css(elem, "display"));
                                  }
                              }
                          }
                      }

                      // Set the display of most of the elements in a second loop
                      // to avoid the constant reflow
                      for (index = 0; index < length; index++) {
                          elem = elements[ index ];
                          if (!elem.style) {
                              continue;
                          }
                          if (!show || elem.style.display === "none" || elem.style.display === "") {
                              elem.style.display = show ? values[ index ] || "" : "none";
                          }
                      }

                      return elements;
                  }

                  jQuery.fn.extend({
                      css: function(name, value) {
                          return jQuery.access(this, function(elem, name, value) {
                              var styles, len,
                                map = {
                              },
                                i = 0;

                              if (jQuery.isArray(name)) {
                                  styles = getStyles(elem);
                                  len = name.length;

                                  for (; i < len; i++) {
                                      map[ name[ i ] ] = jQuery.css(elem, name[ i ], false, styles);
                                  }

                                  return map;
                              }

                              return value !== undefined ?
                                jQuery.style(elem, name, value) :
                                jQuery.css(elem, name);
                          }, name, value, arguments.length > 1);
                      },
                      show: function() {
                          return showHide(this, true);
                      },
                      hide: function() {
                          return showHide(this);
                      },
                      toggle: function(state) {
                          var bool = typeof state === "boolean";

                          return this.each(function() {
                              if (bool ? state : isHidden(this)) {
                                  jQuery(this).show();
                              } else {
                                  jQuery(this).hide();
                              }
                          });
                      }
                  });

                  jQuery.extend({
                      // Add in style property hooks for overriding the default
                      // behavior of getting and setting a style property
                      cssHooks: {
                          opacity: {
                              get: function(elem, computed) {
                                  if (computed) {
                                      // We should always get a number back from opacity
                                      var ret = curCSS(elem, "opacity");
                                      return ret === "" ? "1" : ret;
                                  }
                              }
                          }
                      },
                      // Don't automatically add "px" to these possibly-unitless properties
                      cssNumber: {
                          "columnCount": true,
                          "fillOpacity": true,
                          "fontWeight": true,
                          "lineHeight": true,
                          "opacity": true,
                          "orphans": true,
                          "widows": true,
                          "zIndex": true,
                          "zoom": true
                      },
                      // Add in properties whose names you wish to fix before
                      // setting or getting the value
                      cssProps: {
                          // normalize float css property
                          "float": "cssFloat"
                      },
                      // Get and set the style property on a DOM Node
                      style: function(elem, name, value, extra) {
                          // Don't set styles on text and comment nodes
                          if (!elem || elem.nodeType === 3 || elem.nodeType === 8 || !elem.style) {
                              return;
                          }

                          // Make sure that we're working with the right name
                          var ret, type, hooks,
                            origName = jQuery.camelCase(name),
                            style = elem.style;

                          name = jQuery.cssProps[ origName ] || (jQuery.cssProps[ origName ] = vendorPropName(style, origName));

                          // gets hook for the prefixed version
                          // followed by the unprefixed version
                          hooks = jQuery.cssHooks[ name ] || jQuery.cssHooks[ origName ];

                          // Check if we're setting a value
                          if (value !== undefined) {
                              type = typeof value;

                              // convert relative number strings (+= or -=) to relative numbers. #7345
                              if (type === "string" && (ret = rrelNum.exec(value))) {
                                  value = (ret[1] + 1) * ret[2] + parseFloat(jQuery.css(elem, name));
                                  // Fixes bug #9237
                                  type = "number";
                              }

                              // Make sure that NaN and null values aren't set. See: #7116
                              if (value == null || type === "number" && isNaN(value)) {
                                  return;
                              }

                              // If a number was passed in, add 'px' to the (except for certain CSS properties)
                              if (type === "number" && !jQuery.cssNumber[ origName ]) {
                                  value += "px";
                              }

                              // Fixes #8908, it can be done more correctly by specifying setters in cssHooks,
                              // but it would mean to define eight (for every problematic property) identical functions
                              if (!jQuery.support.clearCloneStyle && value === "" && name.indexOf("background") === 0) {
                                  style[ name ] = "inherit";
                              }

                              // If a hook was provided, use that value, otherwise just set the specified value
                              if (!hooks || !("set" in hooks) || (value = hooks.set(elem, value, extra)) !== undefined) {
                                  style[ name ] = value;
                              }

                          } else {
                              // If a hook was provided get the non-computed value from there
                              if (hooks && "get" in hooks && (ret = hooks.get(elem, false, extra)) !== undefined) {
                                  return ret;
                              }

                              // Otherwise just get the value from the style object
                              return style[ name ];
                          }
                      },
                      css: function(elem, name, extra, styles) {
                          var val, num, hooks,
                            origName = jQuery.camelCase(name);

                          // Make sure that we're working with the right name
                          name = jQuery.cssProps[ origName ] || (jQuery.cssProps[ origName ] = vendorPropName(elem.style, origName));

                          // gets hook for the prefixed version
                          // followed by the unprefixed version
                          hooks = jQuery.cssHooks[ name ] || jQuery.cssHooks[ origName ];

                          // If a hook was provided get the computed value from there
                          if (hooks && "get" in hooks) {
                              val = hooks.get(elem, true, extra);
                          }

                          // Otherwise, if a way to get the computed value exists, use that
                          if (val === undefined) {
                              val = curCSS(elem, name, styles);
                          }

                          //convert "normal" to computed value
                          if (val === "normal" && name in cssNormalTransform) {
                              val = cssNormalTransform[ name ];
                          }

                          // Return, converting to number if forced or a qualifier was provided and val looks numeric
                          if (extra === "" || extra) {
                              num = parseFloat(val);
                              return extra === true || jQuery.isNumeric(num) ? num || 0 : val;
                          }
                          return val;
                      }
                  });

                  curCSS = function(elem, name, _computed) {
                      var width, minWidth, maxWidth,
                        computed = _computed || getStyles(elem),
                        // Support: IE9
                        // getPropertyValue is only needed for .css('filter') in IE9, see #12537
                        ret = computed ? computed.getPropertyValue(name) || computed[ name ] : undefined,
                        style = elem.style;

                      if (computed) {

                          if (ret === "" && !jQuery.contains(elem.ownerDocument, elem)) {
                              ret = jQuery.style(elem, name);
                          }

                          // Support: Safari 5.1
                          // A tribute to the "awesome hack by Dean Edwards"
                          // Safari 5.1.7 (at least) returns percentage for a larger set of values, but width seems to be reliably pixels
                          // this is against the CSSOM draft spec: http://dev.w3.org/csswg/cssom/#resolved-values
                          if (rnumnonpx.test(ret) && rmargin.test(name)) {

                              // Remember the original values
                              width = style.width;
                              minWidth = style.minWidth;
                              maxWidth = style.maxWidth;

                              // Put in the new values to get a computed value out
                              style.minWidth = style.maxWidth = style.width = ret;
                              ret = computed.width;

                              // Revert the changed values
                              style.width = width;
                              style.minWidth = minWidth;
                              style.maxWidth = maxWidth;
                          }
                      }

                      return ret;
                  };


                  function setPositiveNumber(elem, value, subtract) {
                      var matches = rnumsplit.exec(value);
                      return matches ?
                        // Guard against undefined "subtract", e.g., when used as in cssHooks
                        Math.max(0, matches[ 1 ] - (subtract || 0)) + (matches[ 2 ] || "px") :
                        value;
                  }

                  function augmentWidthOrHeight(elem, name, extra, isBorderBox, styles) {
                      var i = extra === (isBorderBox ? "border" : "content") ?
                        // If we already have the right measurement, avoid augmentation
                        4 :
                        // Otherwise initialize for horizontal or vertical properties
                        name === "width" ? 1 : 0,
                        val = 0;

                      for (; i < 4; i += 2) {
                          // both box models exclude margin, so add it if we want it
                          if (extra === "margin") {
                              val += jQuery.css(elem, extra + cssExpand[ i ], true, styles);
                          }

                          if (isBorderBox) {
                              // border-box includes padding, so remove it if we want content
                              if (extra === "content") {
                                  val -= jQuery.css(elem, "padding" + cssExpand[ i ], true, styles);
                              }

                              // at this point, extra isn't border nor margin, so remove border
                              if (extra !== "margin") {
                                  val -= jQuery.css(elem, "border" + cssExpand[ i ] + "Width", true, styles);
                              }
                          } else {
                              // at this point, extra isn't content, so add padding
                              val += jQuery.css(elem, "padding" + cssExpand[ i ], true, styles);

                              // at this point, extra isn't content nor padding, so add border
                              if (extra !== "padding") {
                                  val += jQuery.css(elem, "border" + cssExpand[ i ] + "Width", true, styles);
                              }
                          }
                      }

                      return val;
                  }

                  function getWidthOrHeight(elem, name, extra) {

                      // Start with offset property, which is equivalent to the border-box value
                      var valueIsBorderBox = true,
                        val = name === "width" ? elem.offsetWidth : elem.offsetHeight,
                        styles = getStyles(elem),
                        isBorderBox = jQuery.support.boxSizing && jQuery.css(elem, "boxSizing", false, styles) === "border-box";

                      // some non-html elements return undefined for offsetWidth, so check for null/undefined
                      // svg - https://bugzilla.mozilla.org/show_bug.cgi?id=649285
                      // MathML - https://bugzilla.mozilla.org/show_bug.cgi?id=491668
                      if (val <= 0 || val == null) {
                          // Fall back to computed then uncomputed css if necessary
                          val = curCSS(elem, name, styles);
                          if (val < 0 || val == null) {
                              val = elem.style[ name ];
                          }

                          // Computed unit is not pixels. Stop here and return.
                          if (rnumnonpx.test(val)) {
                              return val;
                          }

                          // we need the check for style in case a browser which returns unreliable values
                          // for getComputedStyle silently falls back to the reliable elem.style
                          valueIsBorderBox = isBorderBox && (jQuery.support.boxSizingReliable || val === elem.style[ name ]);

                          // Normalize "", auto, and prepare for extra
                          val = parseFloat(val) || 0;
                      }

                      // use the active box-sizing model to add/subtract irrelevant styles
                      return (val +
                        augmentWidthOrHeight(
                        elem,
                        name,
                        extra || (isBorderBox ? "border" : "content"),
                        valueIsBorderBox,
                        styles
                        )
                        ) + "px";
                  }

// Try to determine the default display value of an element
                  function css_defaultDisplay(nodeName) {
                      var doc = document,
                        display = elemdisplay[ nodeName ];

                      if (!display) {
                          display = actualDisplay(nodeName, doc);

                          // If the simple way fails, read from inside an iframe
                          if (display === "none" || !display) {
                              // Use the already-created iframe if possible
                              iframe = (iframe ||
                                jQuery("<iframe frameborder='0' width='0' height='0'/>")
                                .css("cssText", "display:block !important")
                                ).appendTo(doc.documentElement);

                              // Always write a new HTML skeleton so Webkit and Firefox don't choke on reuse
                              doc = (iframe[0].contentWindow || iframe[0].contentDocument).document;
                              doc.write("<!doctype html><html><body>");
                              doc.close();

                              display = actualDisplay(nodeName, doc);
                              iframe.detach();
                          }

                          // Store the correct default display
                          elemdisplay[ nodeName ] = display;
                      }

                      return display;
                  }

// Called ONLY from within css_defaultDisplay
                  function actualDisplay(name, doc) {
                      var elem = jQuery(doc.createElement(name)).appendTo(doc.body),
                        display = jQuery.css(elem[0], "display");
                      elem.remove();
                      return display;
                  }

                  jQuery.each([
                      "height",
                      "width"
                  ], function(i, name) {
                      jQuery.cssHooks[ name ] = {
                          get: function(elem, computed, extra) {
                              if (computed) {
                                  // certain elements can have dimension info if we invisibly show them
                                  // however, it must have a current display style that would benefit from this
                                  return elem.offsetWidth === 0 && rdisplayswap.test(jQuery.css(elem, "display")) ?
                                    jQuery.swap(elem, cssShow, function() {
                                      return getWidthOrHeight(elem, name, extra);
                                  }) :
                                    getWidthOrHeight(elem, name, extra);
                              }
                          },
                          set: function(elem, value, extra) {
                              var styles = extra && getStyles(elem);
                              return setPositiveNumber(elem, value, extra ?
                                augmentWidthOrHeight(
                                elem,
                                name,
                                extra,
                                jQuery.support.boxSizing && jQuery.css(elem, "boxSizing", false, styles) === "border-box",
                                styles
                                ) : 0
                                );
                          }
                      };
                  });

// These hooks cannot be added until DOM ready because the support test
// for it is not run until after DOM ready
                  jQuery(function() {
                      // Support: Android 2.3
                      if (!jQuery.support.reliableMarginRight) {
                          jQuery.cssHooks.marginRight = {
                              get: function(elem, computed) {
                                  if (computed) {
                                      // Support: Android 2.3
                                      // WebKit Bug 13343 - getComputedStyle returns wrong value for margin-right
                                      // Work around by temporarily setting element display to inline-block
                                      return jQuery.swap(elem, {
                                          "display": "inline-block"
                                      },
                                      curCSS, [
                                          elem,
                                          "marginRight"
                                      ]);
                                  }
                              }
                          };
                      }

                      // Webkit bug: https://bugs.webkit.org/show_bug.cgi?id=29084
                      // getComputedStyle returns percent when specified for top/left/bottom/right
                      // rather than make the css module depend on the offset module, we just check for it here
                      if (!jQuery.support.pixelPosition && jQuery.fn.position) {
                          jQuery.each([
                              "top",
                              "left"
                          ], function(i, prop) {
                              jQuery.cssHooks[ prop ] = {
                                  get: function(elem, computed) {
                                      if (computed) {
                                          computed = curCSS(elem, prop);
                                          // if curCSS returns percentage, fallback to offset
                                          return rnumnonpx.test(computed) ?
                                            jQuery(elem).position()[ prop ] + "px" :
                                            computed;
                                      }
                                  }
                              };
                          });
                      }

                  });

                  if (jQuery.expr && jQuery.expr.filters) {
                      jQuery.expr.filters.hidden = function(elem) {
                          // Support: Opera <= 12.12
                          // Opera reports offsetWidths and offsetHeights less than zero on some elements
                          return elem.offsetWidth <= 0 && elem.offsetHeight <= 0;
                      };

                      jQuery.expr.filters.visible = function(elem) {
                          return !jQuery.expr.filters.hidden(elem);
                      };
                  }

// These hooks are used by animate to expand properties
                  jQuery.each({
                      margin: "",
                      padding: "",
                      border: "Width"
                  },
                  function(prefix, suffix) {
                      jQuery.cssHooks[ prefix + suffix ] = {
                          expand: function(value) {
                              var i = 0,
                                expanded = {
                              },
                                // assumes a single number if not a string
                                parts = typeof value === "string" ? value.split(" ") : [
                                  value
                              ];

                              for (; i < 4; i++) {
                                  expanded[ prefix + cssExpand[ i ] + suffix ] =
                                    parts[ i ] || parts[ i - 2 ] || parts[ 0 ];
                              }

                              return expanded;
                          }
                      };

                      if (!rmargin.test(prefix)) {
                          jQuery.cssHooks[ prefix + suffix ].set = setPositiveNumber;
                      }
                  });
                  var r20 = /%20/g,
                    rbracket = /\[\]$/,
                    rCRLF = /\r?\n/g,
                    rsubmitterTypes = /^(?:submit|button|image|reset|file)$/i,
                    rsubmittable = /^(?:input|select|textarea|keygen)/i;

                  jQuery.fn.extend({
                      serialize: function() {
                          return jQuery.param(this.serializeArray());
                      },
                      serializeArray: function() {
                          return this.map(function() {
                              // Can add propHook for "elements" to filter or add form elements
                              var elements = jQuery.prop(this, "elements");
                              return elements ? jQuery.makeArray(elements) : this;
                          })
                            .filter(function() {
                              var type = this.type;
                              // Use .is(":disabled") so that fieldset[disabled] works
                              return this.name && !jQuery(this).is(":disabled") &&
                                rsubmittable.test(this.nodeName) && !rsubmitterTypes.test(type) &&
                                (this.checked || !manipulation_rcheckableType.test(type));
                          })
                            .map(function(i, elem) {
                              var val = jQuery(this).val();

                              return val == null ?
                                null :
                                jQuery.isArray(val) ?
                                jQuery.map(val, function(val) {
                                  return {
                                      name: elem.name,
                                      value: val.replace(rCRLF, "\r\n")
                                  };
                              }) :
                                {
                                    name: elem.name,
                                    value: val.replace(rCRLF, "\r\n")
                                };
                          }).get();
                      }
                  });

//Serialize an array of form elements or a set of
//key/values into a query string
                  jQuery.param = function(a, traditional) {
                      var prefix,
                        s = [
                      ],
                        add = function(key, value) {
                          // If value is a function, invoke it and return its value
                          value = jQuery.isFunction(value) ? value() : (value == null ? "" : value);
                          s[ s.length ] = encodeURIComponent(key) + "=" + encodeURIComponent(value);
                      };

                      // Set traditional to true for jQuery <= 1.3.2 behavior.
                      if (traditional === undefined) {
                          traditional = jQuery.ajaxSettings && jQuery.ajaxSettings.traditional;
                      }

                      // If an array was passed in, assume that it is an array of form elements.
                      if (jQuery.isArray(a) || (a.jquery && !jQuery.isPlainObject(a))) {
                          // Serialize the form elements
                          jQuery.each(a, function() {
                              add(this.name, this.value);
                          });

                      } else {
                          // If traditional, encode the "old" way (the way 1.3.2 or older
                          // did it), otherwise encode params recursively.
                          for (prefix in a) {
                              buildParams(prefix, a[ prefix ], traditional, add);
                          }
                      }

                      // Return the resulting serialization
                      return s.join("&").replace(r20, "+");
                  };

                  function buildParams(prefix, obj, traditional, add) {
                      var name;

                      if (jQuery.isArray(obj)) {
                          // Serialize array item.
                          jQuery.each(obj, function(i, v) {
                              if (traditional || rbracket.test(prefix)) {
                                  // Treat each array item as a scalar.
                                  add(prefix, v);

                              } else {
                                  // Item is non-scalar (array or object), encode its numeric index.
                                  buildParams(prefix + "[" + (typeof v === "object" ? i : "") + "]", v, traditional, add);
                              }
                          });

                      } else if (!traditional && jQuery.type(obj) === "object") {
                          // Serialize object item.
                          for (name in obj) {
                              buildParams(prefix + "[" + name + "]", obj[ name ], traditional, add);
                          }

                      } else {
                          // Serialize scalar item.
                          add(prefix, obj);
                      }
                  }
                  jQuery.each(("blur focus focusin focusout load resize scroll unload click dblclick " +
                    "mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave " +
                    "change select submit keydown keypress keyup error contextmenu").split(" "), function(i, name) {

                      // Handle event binding
                      jQuery.fn[ name ] = function(data, fn) {
                          return arguments.length > 0 ?
                            this.on(name, null, data, fn) :
                            this.trigger(name);
                      };
                  });

                  jQuery.fn.extend({
                      hover: function(fnOver, fnOut) {
                          return this.mouseenter(fnOver).mouseleave(fnOut || fnOver);
                      },
                      bind: function(types, data, fn) {
                          return this.on(types, null, data, fn);
                      },
                      unbind: function(types, fn) {
                          return this.off(types, null, fn);
                      },
                      delegate: function(selector, types, data, fn) {
                          return this.on(types, selector, data, fn);
                      },
                      undelegate: function(selector, types, fn) {
                          // ( namespace ) or ( selector, types [, fn] )
                          return arguments.length === 1 ? this.off(selector, "**") : this.off(types, selector || "**", fn);
                      }
                  });
                  var
                    // Document location
                    ajaxLocParts,
                    ajaxLocation,
                    ajax_nonce = jQuery.now(),
                    ajax_rquery = /\?/,
                    rhash = /#.*$/,
                    rts = /([?&])_=[^&]*/,
                    rheaders = /^(.*?):[ \t]*([^\r\n]*)$/mg,
                    // #7653, #8125, #8152: local protocol detection
                    rlocalProtocol = /^(?:about|app|app-storage|.+-extension|file|res|widget):$/,
                    rnoContent = /^(?:GET|HEAD)$/,
                    rprotocol = /^\/\//,
                    rurl = /^([\w.+-]+:)(?:\/\/([^\/?#:]*)(?::(\d+)|)|)/,
                    // Keep a copy of the old load method
                    _load = jQuery.fn.load,
                    /* Prefilters
                     * 1) They are useful to introduce custom dataTypes (see ajax/jsonp.js for an example)
                     * 2) These are called:
                     *    - BEFORE asking for a transport
                     *    - AFTER param serialization (s.data is a string if s.processData is true)
                     * 3) key is the dataType
                     * 4) the catchall symbol "*" can be used
                     * 5) execution will start with transport dataType and THEN continue down to "*" if needed
                     */
                    prefilters = {
                  },
                    /* Transports bindings
                     * 1) key is the dataType
                     * 2) the catchall symbol "*" can be used
                     * 3) selection will start with transport dataType and THEN go to "*" if needed
                     */
                    transports = {
                  },
                    // Avoid comment-prolog char sequence (#10098); must appease lint and evade compression
                    allTypes = "*/".concat("*");

// #8138, IE may throw an exception when accessing
// a field from window.location if document.domain has been set
                  try {
                      ajaxLocation = location.href;
                  } catch (e) {
                      // Use the href attribute of an A element
                      // since IE will modify it given document.location
                      ajaxLocation = document.createElement("a");
                      ajaxLocation.href = "";
                      ajaxLocation = ajaxLocation.href;
                  }

// Segment location into parts
                  ajaxLocParts = rurl.exec(ajaxLocation.toLowerCase()) || [
                  ];

// Base "constructor" for jQuery.ajaxPrefilter and jQuery.ajaxTransport
                  function addToPrefiltersOrTransports(structure) {

                      // dataTypeExpression is optional and defaults to "*"
                      return function(dataTypeExpression, func) {

                          if (typeof dataTypeExpression !== "string") {
                              func = dataTypeExpression;
                              dataTypeExpression = "*";
                          }

                          var dataType,
                            i = 0,
                            dataTypes = dataTypeExpression.toLowerCase().match(core_rnotwhite) || [
                          ];

                          if (jQuery.isFunction(func)) {
                              // For each dataType in the dataTypeExpression
                              while ((dataType = dataTypes[i++])) {
                                  // Prepend if requested
                                  if (dataType[0] === "+") {
                                      dataType = dataType.slice(1) || "*";
                                      (structure[ dataType ] = structure[ dataType ] || [
                                      ]).unshift(func);

                                      // Otherwise append
                                  } else {
                                      (structure[ dataType ] = structure[ dataType ] || [
                                      ]).push(func);
                                  }
                              }
                          }
                      };
                  }

// Base inspection function for prefilters and transports
                  function inspectPrefiltersOrTransports(structure, options, originalOptions, jqXHR) {

                      var inspected = {
                      },
                        seekingTransport = (structure === transports);

                      function inspect(dataType) {
                          var selected;
                          inspected[ dataType ] = true;
                          jQuery.each(structure[ dataType ] || [
                          ], function(_, prefilterOrFactory) {
                              var dataTypeOrTransport = prefilterOrFactory(options, originalOptions, jqXHR);
                              if (typeof dataTypeOrTransport === "string" && !seekingTransport && !inspected[ dataTypeOrTransport ]) {
                                  options.dataTypes.unshift(dataTypeOrTransport);
                                  inspect(dataTypeOrTransport);
                                  return false;
                              } else if (seekingTransport) {
                                  return !(selected = dataTypeOrTransport);
                              }
                          });
                          return selected;
                      }

                      return inspect(options.dataTypes[ 0 ]) || !inspected[ "*" ] && inspect("*");
                  }

// A special extend for ajax options
// that takes "flat" options (not to be deep extended)
// Fixes #9887
                  function ajaxExtend(target, src) {
                      var key, deep,
                        flatOptions = jQuery.ajaxSettings.flatOptions || {
                      };

                      for (key in src) {
                          if (src[ key ] !== undefined) {
                              (flatOptions[ key ] ? target : (deep || (deep = {
                              })))[ key ] = src[ key ];
                          }
                      }
                      if (deep) {
                          jQuery.extend(true, target, deep);
                      }

                      return target;
                  }

                  jQuery.fn.load = function(url, params, callback) {
                      if (typeof url !== "string" && _load) {
                          return _load.apply(this, arguments);
                      }

                      var selector, type, response,
                        self = this,
                        off = url.indexOf(" ");

                      if (off >= 0) {
                          selector = url.slice(off);
                          url = url.slice(0, off);
                      }

                      // If it's a function
                      if (jQuery.isFunction(params)) {

                          // We assume that it's the callback
                          callback = params;
                          params = undefined;

                          // Otherwise, build a param string
                      } else if (params && typeof params === "object") {
                          type = "POST";
                      }

                      // If we have elements to modify, make the request
                      if (self.length > 0) {
                          jQuery.ajax({
                              url: url,
                              // if "type" variable is undefined, then "GET" method will be used
                              type: type,
                              dataType: "html",
                              data: params
                          }).done(function(responseText) {

                              // Save response for use in complete callback
                              response = arguments;

                              self.html(selector ?
                                // If a selector was specified, locate the right elements in a dummy div
                                // Exclude scripts to avoid IE 'Permission Denied' errors
                                jQuery("<div>").append(jQuery.parseHTML(responseText)).find(selector) :
                                // Otherwise use the full result
                                responseText);

                          }).complete(callback && function(jqXHR, status) {
                              self.each(callback, response || [
                                  jqXHR.responseText,
                                  status,
                                  jqXHR
                              ]);
                          });
                      }

                      return this;
                  };

// Attach a bunch of functions for handling common AJAX events
                  jQuery.each([
                      "ajaxStart",
                      "ajaxStop",
                      "ajaxComplete",
                      "ajaxError",
                      "ajaxSuccess",
                      "ajaxSend"
                  ], function(i, type) {
                      jQuery.fn[ type ] = function(fn) {
                          return this.on(type, fn);
                      };
                  });

                  jQuery.extend({
                      // Counter for holding the number of active queries
                      active: 0,
                      // Last-Modified header cache for next request
                      lastModified: {
                      },
                      etag: {
                      },
                      ajaxSettings: {
                          url: ajaxLocation,
                          type: "GET",
                          isLocal: rlocalProtocol.test(ajaxLocParts[ 1 ]),
                          global: true,
                          processData: true,
                          async: true,
                          contentType: "application/x-www-form-urlencoded; charset=UTF-8",
                          /*
                           timeout: 0,
                           data: null,
                           dataType: null,
                           username: null,
                           password: null,
                           cache: null,
                           throws: false,
                           traditional: false,
                           headers: {},
                           */

                          accepts: {
                              "*": allTypes,
                              text: "text/plain",
                              html: "text/html",
                              xml: "application/xml, text/xml",
                              json: "application/json, text/javascript"
                          },
                          contents: {
                              xml: /xml/,
                              html: /html/,
                              json: /json/
                          },
                          responseFields: {
                              xml: "responseXML",
                              text: "responseText",
                              json: "responseJSON"
                          },
                          // Data converters
                          // Keys separate source (or catchall "*") and destination types with a single space
                          converters: {
                              // Convert anything to text
                              "* text": String,
                              // Text to html (true = no transformation)
                              "text html": true,
                              // Evaluate text as a json expression
                              "text json": jQuery.parseJSON,
                              // Parse text as xml
                              "text xml": jQuery.parseXML
                          },
                          // For options that shouldn't be deep extended:
                          // you can add your own custom options here if
                          // and when you create one that shouldn't be
                          // deep extended (see ajaxExtend)
                          flatOptions: {
                              url: true,
                              context: true
                          }
                      },
                      // Creates a full fledged settings object into target
                      // with both ajaxSettings and settings fields.
                      // If target is omitted, writes into ajaxSettings.
                      ajaxSetup: function(target, settings) {
                          return settings ?
                            // Building a settings object
                            ajaxExtend(ajaxExtend(target, jQuery.ajaxSettings), settings) :
                            // Extending ajaxSettings
                            ajaxExtend(jQuery.ajaxSettings, target);
                      },
                      ajaxPrefilter: addToPrefiltersOrTransports(prefilters),
                      ajaxTransport: addToPrefiltersOrTransports(transports),
                      // Main method
                      ajax: function(url, options) {

                          // If url is an object, simulate pre-1.5 signature
                          if (typeof url === "object") {
                              options = url;
                              url = undefined;
                          }

                          // Force options to be an object
                          options = options || {
                          };

                          var transport,
                            // URL without anti-cache param
                            cacheURL,
                            // Response headers
                            responseHeadersString,
                            responseHeaders,
                            // timeout handle
                            timeoutTimer,
                            // Cross-domain detection vars
                            parts,
                            // To know if global events are to be dispatched
                            fireGlobals,
                            // Loop variable
                            i,
                            // Create the final options object
                            s = jQuery.ajaxSetup({
                          }, options),
                            // Callbacks context
                            callbackContext = s.context || s,
                            // Context for global events is callbackContext if it is a DOM node or jQuery collection
                            globalEventContext = s.context && (callbackContext.nodeType || callbackContext.jquery) ?
                            jQuery(callbackContext) :
                            jQuery.event,
                            // Deferreds
                            deferred = jQuery.Deferred(),
                            completeDeferred = jQuery.Callbacks("once memory"),
                            // Status-dependent callbacks
                            statusCode = s.statusCode || {
                          },
                            // Headers (they are sent all at once)
                            requestHeaders = {
                          },
                            requestHeadersNames = {
                          },
                            // The jqXHR state
                            state = 0,
                            // Default abort message
                            strAbort = "canceled",
                            // Fake xhr
                            jqXHR = {
                              readyState: 0,
                              // Builds headers hashtable if needed
                              getResponseHeader: function(key) {
                                  var match;
                                  if (state === 2) {
                                      if (!responseHeaders) {
                                          responseHeaders = {
                                          };
                                          while ((match = rheaders.exec(responseHeadersString))) {
                                              responseHeaders[ match[1].toLowerCase() ] = match[ 2 ];
                                          }
                                      }
                                      match = responseHeaders[ key.toLowerCase() ];
                                  }
                                  return match == null ? null : match;
                              },
                              // Raw string
                              getAllResponseHeaders: function() {
                                  return state === 2 ? responseHeadersString : null;
                              },
                              // Caches the header
                              setRequestHeader: function(name, value) {
                                  var lname = name.toLowerCase();
                                  if (!state) {
                                      name = requestHeadersNames[ lname ] = requestHeadersNames[ lname ] || name;
                                      requestHeaders[ name ] = value;
                                  }
                                  return this;
                              },
                              // Overrides response content-type header
                              overrideMimeType: function(type) {
                                  if (!state) {
                                      s.mimeType = type;
                                  }
                                  return this;
                              },
                              // Status-dependent callbacks
                              statusCode: function(map) {
                                  var code;
                                  if (map) {
                                      if (state < 2) {
                                          for (code in map) {
                                              // Lazy-add the new callback in a way that preserves old ones
                                              statusCode[ code ] = [
                                                  statusCode[ code ],
                                                  map[ code ]
                                              ];
                                          }
                                      } else {
                                          // Execute the appropriate callbacks
                                          jqXHR.always(map[ jqXHR.status ]);
                                      }
                                  }
                                  return this;
                              },
                              // Cancel the request
                              abort: function(statusText) {
                                  var finalText = statusText || strAbort;
                                  if (transport) {
                                      transport.abort(finalText);
                                  }
                                  done(0, finalText);
                                  return this;
                              }
                          };

                          // Attach deferreds
                          deferred.promise(jqXHR).complete = completeDeferred.add;
                          jqXHR.success = jqXHR.done;
                          jqXHR.error = jqXHR.fail;

                          // Remove hash character (#7531: and string promotion)
                          // Add protocol if not provided (prefilters might expect it)
                          // Handle falsy url in the settings object (#10093: consistency with old signature)
                          // We also use the url parameter if available
                          s.url = ((url || s.url || ajaxLocation) + "").replace(rhash, "")
                            .replace(rprotocol, ajaxLocParts[ 1 ] + "//");

                          // Alias method option to type as per ticket #12004
                          s.type = options.method || options.type || s.method || s.type;

                          // Extract dataTypes list
                          s.dataTypes = jQuery.trim(s.dataType || "*").toLowerCase().match(core_rnotwhite) || [
                              ""
                          ];

                          // A cross-domain request is in order when we have a protocol:host:port mismatch
                          if (s.crossDomain == null) {
                              parts = rurl.exec(s.url.toLowerCase());
                              s.crossDomain = !!(parts &&
                                (parts[ 1 ] !== ajaxLocParts[ 1 ] || parts[ 2 ] !== ajaxLocParts[ 2 ] ||
                                  (parts[ 3 ] || (parts[ 1 ] === "http:" ? "80" : "443")) !==
                                  (ajaxLocParts[ 3 ] || (ajaxLocParts[ 1 ] === "http:" ? "80" : "443")))
                                );
                          }

                          // Convert data if not already a string
                          if (s.data && s.processData && typeof s.data !== "string") {
                              s.data = jQuery.param(s.data, s.traditional);
                          }

                          // Apply prefilters
                          inspectPrefiltersOrTransports(prefilters, s, options, jqXHR);

                          // If request was aborted inside a prefilter, stop there
                          if (state === 2) {
                              return jqXHR;
                          }

                          // We can fire global events as of now if asked to
                          fireGlobals = s.global;

                          // Watch for a new set of requests
                          if (fireGlobals && jQuery.active++ === 0) {
                              jQuery.event.trigger("ajaxStart");
                          }

                          // Uppercase the type
                          s.type = s.type.toUpperCase();

                          // Determine if request has content
                          s.hasContent = !rnoContent.test(s.type);

                          // Save the URL in case we're toying with the If-Modified-Since
                          // and/or If-None-Match header later on
                          cacheURL = s.url;

                          // More options handling for requests with no content
                          if (!s.hasContent) {

                              // If data is available, append data to url
                              if (s.data) {
                                  cacheURL = (s.url += (ajax_rquery.test(cacheURL) ? "&" : "?") + s.data);
                                  // #9682: remove data so that it's not used in an eventual retry
                                  delete s.data;
                              }

                              // Add anti-cache in url if needed
                              if (s.cache === false) {
                                  s.url = rts.test(cacheURL) ?
                                    // If there is already a '_' parameter, set its value
                                    cacheURL.replace(rts, "$1_=" + ajax_nonce++) :
                                    // Otherwise add one to the end
                                    cacheURL + (ajax_rquery.test(cacheURL) ? "&" : "?") + "_=" + ajax_nonce++;
                              }
                          }

                          // Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.
                          if (s.ifModified) {
                              if (jQuery.lastModified[ cacheURL ]) {
                                  jqXHR.setRequestHeader("If-Modified-Since", jQuery.lastModified[ cacheURL ]);
                              }
                              if (jQuery.etag[ cacheURL ]) {
                                  jqXHR.setRequestHeader("If-None-Match", jQuery.etag[ cacheURL ]);
                              }
                          }

                          // Set the correct header, if data is being sent
                          if (s.data && s.hasContent && s.contentType !== false || options.contentType) {
                              jqXHR.setRequestHeader("Content-Type", s.contentType);
                          }

                          // Set the Accepts header for the server, depending on the dataType
                          jqXHR.setRequestHeader(
                            "Accept",
                            s.dataTypes[ 0 ] && s.accepts[ s.dataTypes[0] ] ?
                            s.accepts[ s.dataTypes[0] ] + (s.dataTypes[ 0 ] !== "*" ? ", " + allTypes + "; q=0.01" : "") :
                            s.accepts[ "*" ]
                            );

                          // Check for headers option
                          for (i in s.headers) {
                              jqXHR.setRequestHeader(i, s.headers[ i ]);
                          }

                          // Allow custom headers/mimetypes and early abort
                          if (s.beforeSend && (s.beforeSend.call(callbackContext, jqXHR, s) === false || state === 2)) {
                              // Abort if not done already and return
                              return jqXHR.abort();
                          }

                          // aborting is no longer a cancellation
                          strAbort = "abort";

                          // Install callbacks on deferreds
                          for (i in {
                              success: 1,
                              error: 1,
                              complete: 1
                          }) {
                              jqXHR[ i ](s[ i ]);
                          }

                          // Get transport
                          transport = inspectPrefiltersOrTransports(transports, s, options, jqXHR);

                          // If no transport, we auto-abort
                          if (!transport) {
                              done(-1, "No Transport");
                          } else {
                              jqXHR.readyState = 1;

                              // Send global event
                              if (fireGlobals) {
                                  globalEventContext.trigger("ajaxSend", [
                                      jqXHR,
                                      s
                                  ]);
                              }
                              // Timeout
                              if (s.async && s.timeout > 0) {
                                  timeoutTimer = setTimeout(function() {
                                      jqXHR.abort("timeout");
                                  }, s.timeout);
                              }

                              try {
                                  state = 1;
                                  transport.send(requestHeaders, done);
                              } catch (e) {
                                  // Propagate exception as error if not done
                                  if (state < 2) {
                                      done(-1, e);
                                      // Simply rethrow otherwise
                                  } else {
                                      throw e;
                                  }
                              }
                          }

                          // Callback for when everything is done
                          function done(status, nativeStatusText, responses, headers) {
                              var isSuccess, success, error, response, modified,
                                statusText = nativeStatusText;

                              // Called once
                              if (state === 2) {
                                  return;
                              }

                              // State is "done" now
                              state = 2;

                              // Clear timeout if it exists
                              if (timeoutTimer) {
                                  clearTimeout(timeoutTimer);
                              }

                              // Dereference transport for early garbage collection
                              // (no matter how long the jqXHR object will be used)
                              transport = undefined;

                              // Cache response headers
                              responseHeadersString = headers || "";

                              // Set readyState
                              jqXHR.readyState = status > 0 ? 4 : 0;

                              // Determine if successful
                              isSuccess = status >= 200 && status < 300 || status === 304;

                              // Get response data
                              if (responses) {
                                  response = ajaxHandleResponses(s, jqXHR, responses);
                              }

                              // Convert no matter what (that way responseXXX fields are always set)
                              response = ajaxConvert(s, response, jqXHR, isSuccess);

                              // If successful, handle type chaining
                              if (isSuccess) {

                                  // Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.
                                  if (s.ifModified) {
                                      modified = jqXHR.getResponseHeader("Last-Modified");
                                      if (modified) {
                                          jQuery.lastModified[ cacheURL ] = modified;
                                      }
                                      modified = jqXHR.getResponseHeader("etag");
                                      if (modified) {
                                          jQuery.etag[ cacheURL ] = modified;
                                      }
                                  }

                                  // if no content
                                  if (status === 204 || s.type === "HEAD") {
                                      statusText = "nocontent";

                                      // if not modified
                                  } else if (status === 304) {
                                      statusText = "notmodified";

                                      // If we have data, let's convert it
                                  } else {
                                      statusText = response.state;
                                      success = response.data;
                                      error = response.error;
                                      isSuccess = !error;
                                  }
                              } else {
                                  // We extract error from statusText
                                  // then normalize statusText and status for non-aborts
                                  error = statusText;
                                  if (status || !statusText) {
                                      statusText = "error";
                                      if (status < 0) {
                                          status = 0;
                                      }
                                  }
                              }

                              // Set data for the fake xhr object
                              jqXHR.status = status;
                              jqXHR.statusText = (nativeStatusText || statusText) + "";

                              // Success/Error
                              if (isSuccess) {
                                  deferred.resolveWith(callbackContext, [
                                      success,
                                      statusText,
                                      jqXHR
                                  ]);
                              } else {
                                  deferred.rejectWith(callbackContext, [
                                      jqXHR,
                                      statusText,
                                      error
                                  ]);
                              }

                              // Status-dependent callbacks
                              jqXHR.statusCode(statusCode);
                              statusCode = undefined;

                              if (fireGlobals) {
                                  globalEventContext.trigger(isSuccess ? "ajaxSuccess" : "ajaxError",
                                    [
                                        jqXHR,
                                        s,
                                        isSuccess ? success : error
                                    ]);
                              }

                              // Complete
                              completeDeferred.fireWith(callbackContext, [
                                  jqXHR,
                                  statusText
                              ]);

                              if (fireGlobals) {
                                  globalEventContext.trigger("ajaxComplete", [
                                      jqXHR,
                                      s
                                  ]);
                                  // Handle the global AJAX counter
                                  if (!(--jQuery.active)) {
                                      jQuery.event.trigger("ajaxStop");
                                  }
                              }
                          }

                          return jqXHR;
                      },
                      getJSON: function(url, data, callback) {
                          return jQuery.get(url, data, callback, "json");
                      },
                      getScript: function(url, callback) {
                          return jQuery.get(url, undefined, callback, "script");
                      }
                  });

                  jQuery.each([
                      "get",
                      "post"
                  ], function(i, method) {
                      jQuery[ method ] = function(url, data, callback, type) {
                          // shift arguments if data argument was omitted
                          if (jQuery.isFunction(data)) {
                              type = type || callback;
                              callback = data;
                              data = undefined;
                          }

                          return jQuery.ajax({
                              url: url,
                              type: method,
                              dataType: type,
                              data: data,
                              success: callback
                          });
                      };
                  });

                  /* Handles responses to an ajax request:
                   * - finds the right dataType (mediates between content-type and expected dataType)
                   * - returns the corresponding response
                   */
                  function ajaxHandleResponses(s, jqXHR, responses) {

                      var ct, type, finalDataType, firstDataType,
                        contents = s.contents,
                        dataTypes = s.dataTypes;

                      // Remove auto dataType and get content-type in the process
                      while (dataTypes[ 0 ] === "*") {
                          dataTypes.shift();
                          if (ct === undefined) {
                              ct = s.mimeType || jqXHR.getResponseHeader("Content-Type");
                          }
                      }

                      // Check if we're dealing with a known content-type
                      if (ct) {
                          for (type in contents) {
                              if (contents[ type ] && contents[ type ].test(ct)) {
                                  dataTypes.unshift(type);
                                  break;
                              }
                          }
                      }

                      // Check to see if we have a response for the expected dataType
                      if (dataTypes[ 0 ] in responses) {
                          finalDataType = dataTypes[ 0 ];
                      } else {
                          // Try convertible dataTypes
                          for (type in responses) {
                              if (!dataTypes[ 0 ] || s.converters[ type + " " + dataTypes[0] ]) {
                                  finalDataType = type;
                                  break;
                              }
                              if (!firstDataType) {
                                  firstDataType = type;
                              }
                          }
                          // Or just use first one
                          finalDataType = finalDataType || firstDataType;
                      }

                      // If we found a dataType
                      // We add the dataType to the list if needed
                      // and return the corresponding response
                      if (finalDataType) {
                          if (finalDataType !== dataTypes[ 0 ]) {
                              dataTypes.unshift(finalDataType);
                          }
                          return responses[ finalDataType ];
                      }
                  }

                  /* Chain conversions given the request and the original response
                   * Also sets the responseXXX fields on the jqXHR instance
                   */
                  function ajaxConvert(s, response, jqXHR, isSuccess) {
                      var conv2, current, conv, tmp, prev,
                        converters = {
                      },
                        // Work with a copy of dataTypes in case we need to modify it for conversion
                        dataTypes = s.dataTypes.slice();

                      // Create converters map with lowercased keys
                      if (dataTypes[ 1 ]) {
                          for (conv in s.converters) {
                              converters[ conv.toLowerCase() ] = s.converters[ conv ];
                          }
                      }

                      current = dataTypes.shift();

                      // Convert to each sequential dataType
                      while (current) {

                          if (s.responseFields[ current ]) {
                              jqXHR[ s.responseFields[ current ] ] = response;
                          }

                          // Apply the dataFilter if provided
                          if (!prev && isSuccess && s.dataFilter) {
                              response = s.dataFilter(response, s.dataType);
                          }

                          prev = current;
                          current = dataTypes.shift();

                          if (current) {

                              // There's only work to do if current dataType is non-auto
                              if (current === "*") {

                                  current = prev;

                                  // Convert response if prev dataType is non-auto and differs from current
                              } else if (prev !== "*" && prev !== current) {

                                  // Seek a direct converter
                                  conv = converters[ prev + " " + current ] || converters[ "* " + current ];

                                  // If none found, seek a pair
                                  if (!conv) {
                                      for (conv2 in converters) {

                                          // If conv2 outputs current
                                          tmp = conv2.split(" ");
                                          if (tmp[ 1 ] === current) {

                                              // If prev can be converted to accepted input
                                              conv = converters[ prev + " " + tmp[ 0 ] ] ||
                                                converters[ "* " + tmp[ 0 ] ];
                                              if (conv) {
                                                  // Condense equivalence converters
                                                  if (conv === true) {
                                                      conv = converters[ conv2 ];

                                                      // Otherwise, insert the intermediate dataType
                                                  } else if (converters[ conv2 ] !== true) {
                                                      current = tmp[ 0 ];
                                                      dataTypes.unshift(tmp[ 1 ]);
                                                  }
                                                  break;
                                              }
                                          }
                                      }
                                  }

                                  // Apply converter (if not an equivalence)
                                  if (conv !== true) {

                                      // Unless errors are allowed to bubble, catch and return them
                                      if (conv && s[ "throws" ]) {
                                          response = conv(response);
                                      } else {
                                          try {
                                              response = conv(response);
                                          } catch (e) {
                                              return {
                                                  state: "parsererror",
                                                  error: conv ? e : "No conversion from " + prev + " to " + current
                                              };
                                          }
                                      }
                                  }
                              }
                          }
                      }

                      return {
                          state: "success",
                          data: response
                      };
                  }
// Install script dataType
                  jQuery.ajaxSetup({
                      accepts: {
                          script: "text/javascript, application/javascript, application/ecmascript, application/x-ecmascript"
                      },
                      contents: {
                          script: /(?:java|ecma)script/
                      },
                      converters: {
                          "text script": function(text) {
                              jQuery.globalEval(text);
                              return text;
                          }
                      }
                  });

// Handle cache's special case and crossDomain
                  jQuery.ajaxPrefilter("script", function(s) {
                      if (s.cache === undefined) {
                          s.cache = false;
                      }
                      if (s.crossDomain) {
                          s.type = "GET";
                      }
                  });

// Bind script tag hack transport
                  jQuery.ajaxTransport("script", function(s) {
                      // This transport only deals with cross domain requests
                      if (s.crossDomain) {
                          var script, callback;
                          return {
                              send: function(_, complete) {
                                  script = jQuery("<script>").prop({
                                      async: true,
                                      charset: s.scriptCharset,
                                      src: s.url
                                  }).on(
                                    "load error",
                                    callback = function(evt) {
                                      script.remove();
                                      callback = null;
                                      if (evt) {
                                          complete(evt.type === "error" ? 404 : 200, evt.type);
                                      }
                                  }
                                  );
                                  document.head.appendChild(script[ 0 ]);
                              },
                              abort: function() {
                                  if (callback) {
                                      callback();
                                  }
                              }
                          };
                      }
                  });
                  var oldCallbacks = [
                  ],
                    rjsonp = /(=)\?(?=&|$)|\?\?/;

// Default jsonp settings
                  jQuery.ajaxSetup({
                      jsonp: "callback",
                      jsonpCallback: function() {
                          var callback = oldCallbacks.pop() || (jQuery.expando + "_" + (ajax_nonce++));
                          this[ callback ] = true;
                          return callback;
                      }
                  });

// Detect, normalize options and install callbacks for jsonp requests
                  jQuery.ajaxPrefilter("json jsonp", function(s, originalSettings, jqXHR) {

                      var callbackName, overwritten, responseContainer,
                        jsonProp = s.jsonp !== false && (rjsonp.test(s.url) ?
                        "url" :
                        typeof s.data === "string" && !(s.contentType || "").indexOf("application/x-www-form-urlencoded") && rjsonp.test(s.data) && "data"
                        );

                      // Handle iff the expected data type is "jsonp" or we have a parameter to set
                      if (jsonProp || s.dataTypes[ 0 ] === "jsonp") {

                          // Get callback name, remembering preexisting value associated with it
                          callbackName = s.jsonpCallback = jQuery.isFunction(s.jsonpCallback) ?
                            s.jsonpCallback() :
                            s.jsonpCallback;

                          // Insert callback into url or form data
                          if (jsonProp) {
                              s[ jsonProp ] = s[ jsonProp ].replace(rjsonp, "$1" + callbackName);
                          } else if (s.jsonp !== false) {
                              s.url += (ajax_rquery.test(s.url) ? "&" : "?") + s.jsonp + "=" + callbackName;
                          }

                          // Use data converter to retrieve json after script execution
                          s.converters["script json"] = function() {
                              if (!responseContainer) {
                                  jQuery.error(callbackName + " was not called");
                              }
                              return responseContainer[ 0 ];
                          };

                          // force json dataType
                          s.dataTypes[ 0 ] = "json";

                          // Install callback
                          overwritten = window[ callbackName ];
                          window[ callbackName ] = function() {
                              responseContainer = arguments;
                          };

                          // Clean-up function (fires after converters)
                          jqXHR.always(function() {
                              // Restore preexisting value
                              window[ callbackName ] = overwritten;

                              // Save back as free
                              if (s[ callbackName ]) {
                                  // make sure that re-using the options doesn't screw things around
                                  s.jsonpCallback = originalSettings.jsonpCallback;

                                  // save the callback name for future use
                                  oldCallbacks.push(callbackName);
                              }

                              // Call if it was a function and we have a response
                              if (responseContainer && jQuery.isFunction(overwritten)) {
                                  overwritten(responseContainer[ 0 ]);
                              }

                              responseContainer = overwritten = undefined;
                          });

                          // Delegate to script
                          return "script";
                      }
                  });
                  jQuery.ajaxSettings.xhr = function() {
                      try {
                          return new XMLHttpRequest();
                      } catch (e) {
                      }
                  };

                  var xhrSupported = jQuery.ajaxSettings.xhr(),
                    xhrSuccessStatus = {
                      // file protocol always yields status code 0, assume 200
                      0: 200,
                      // Support: IE9
                      // #1450: sometimes IE returns 1223 when it should be 204
                      1223: 204
                  },
                  // Support: IE9
                  // We need to keep track of outbound xhr and abort them manually
                  // because IE is not smart enough to do it all by itself
                  xhrId = 0,
                    xhrCallbacks = {
                  };

                  if (window.ActiveXObject) {
                      jQuery(window).on("unload", function() {
                          for (var key in xhrCallbacks) {
                              xhrCallbacks[ key ]();
                          }
                          xhrCallbacks = undefined;
                      });
                  }

                  jQuery.support.cors = !!xhrSupported && ("withCredentials" in xhrSupported);
                  jQuery.support.ajax = xhrSupported = !!xhrSupported;

                  jQuery.ajaxTransport(function(options) {
                      var callback;
                      // Cross domain only allowed if supported through XMLHttpRequest
                      if (jQuery.support.cors || xhrSupported && !options.crossDomain) {
                          return {
                              send: function(headers, complete) {
                                  var i, id,
                                    xhr = options.xhr();
                                  xhr.open(options.type, options.url, options.async, options.username, options.password);
                                  // Apply custom fields if provided
                                  if (options.xhrFields) {
                                      for (i in options.xhrFields) {
                                          xhr[ i ] = options.xhrFields[ i ];
                                      }
                                  }
                                  // Override mime type if needed
                                  if (options.mimeType && xhr.overrideMimeType) {
                                      xhr.overrideMimeType(options.mimeType);
                                  }
                                  // X-Requested-With header
                                  // For cross-domain requests, seeing as conditions for a preflight are
                                  // akin to a jigsaw puzzle, we simply never set it to be sure.
                                  // (it can always be set on a per-request basis or even using ajaxSetup)
                                  // For same-domain requests, won't change header if already provided.
                                  if (!options.crossDomain && !headers["X-Requested-With"]) {
                                      headers["X-Requested-With"] = "XMLHttpRequest";
                                  }
                                  // Set headers
                                  for (i in headers) {
                                      xhr.setRequestHeader(i, headers[ i ]);
                                  }
                                  // Callback
                                  callback = function(type) {
                                      return function() {
                                          if (callback) {
                                              delete xhrCallbacks[ id ];
                                              callback = xhr.onload = xhr.onerror = null;
                                              if (type === "abort") {
                                                  xhr.abort();
                                              } else if (type === "error") {
                                                  complete(
                                                    // file protocol always yields status 0, assume 404
                                                    xhr.status || 404,
                                                    xhr.statusText
                                                    );
                                              } else {
                                                  complete(
                                                    xhrSuccessStatus[ xhr.status ] || xhr.status,
                                                    xhr.statusText,
                                                    // Support: IE9
                                                    // #11426: When requesting binary data, IE9 will throw an exception
                                                    // on any attempt to access responseText
                                                    typeof xhr.responseText === "string" ? {
                                                      text: xhr.responseText
                                                  } : undefined,
                                                    xhr.getAllResponseHeaders()
                                                    );
                                              }
                                          }
                                      };
                                  };
                                  // Listen to events
                                  xhr.onload = callback();
                                  xhr.onerror = callback("error");
                                  // Create the abort callback
                                  callback = xhrCallbacks[(id = xhrId++)] = callback("abort");
                                  // Do send the request
                                  // This may raise an exception which is actually
                                  // handled in jQuery.ajax (so no try/catch here)
                                  xhr.send(options.hasContent && options.data || null);
                              },
                              abort: function() {
                                  if (callback) {
                                      callback();
                                  }
                              }
                          };
                      }
                  });
                  var fxNow, timerId,
                    rfxtypes = /^(?:toggle|show|hide)$/,
                    rfxnum = new RegExp("^(?:([+-])=|)(" + core_pnum + ")([a-z%]*)$", "i"),
                    rrun = /queueHooks$/,
                    animationPrefilters = [
                      defaultPrefilter
                  ],
                    tweeners = {
                      "*": [
                          function(prop, value) {
                              var tween = this.createTween(prop, value),
                                target = tween.cur(),
                                parts = rfxnum.exec(value),
                                unit = parts && parts[ 3 ] || (jQuery.cssNumber[ prop ] ? "" : "px"),
                                // Starting value computation is required for potential unit mismatches
                                start = (jQuery.cssNumber[ prop ] || unit !== "px" && +target) &&
                                rfxnum.exec(jQuery.css(tween.elem, prop)),
                                scale = 1,
                                maxIterations = 20;

                              if (start && start[ 3 ] !== unit) {
                                  // Trust units reported by jQuery.css
                                  unit = unit || start[ 3 ];

                                  // Make sure we update the tween properties later on
                                  parts = parts || [
                                  ];

                                  // Iteratively approximate from a nonzero starting point
                                  start = +target || 1;

                                  do {
                                      // If previous iteration zeroed out, double until we get *something*
                                      // Use a string for doubling factor so we don't accidentally see scale as unchanged below
                                      scale = scale || ".5";

                                      // Adjust and apply
                                      start = start / scale;
                                      jQuery.style(tween.elem, prop, start + unit);

                                      // Update scale, tolerating zero or NaN from tween.cur()
                                      // And breaking the loop if scale is unchanged or perfect, or if we've just had enough
                                  } while (scale !== (scale = tween.cur() / target) && scale !== 1 && --maxIterations);
                              }

                              // Update tween properties
                              if (parts) {
                                  start = tween.start = +start || +target || 0;
                                  tween.unit = unit;
                                  // If a +=/-= token was provided, we're doing a relative animation
                                  tween.end = parts[ 1 ] ?
                                    start + (parts[ 1 ] + 1) * parts[ 2 ] :
                                    +parts[ 2 ];
                              }

                              return tween;
                          }
                      ]
                  };

// Animations created synchronously will run synchronously
                  function createFxNow() {
                      setTimeout(function() {
                          fxNow = undefined;
                      });
                      return (fxNow = jQuery.now());
                  }

                  function createTween(value, prop, animation) {
                      var tween,
                        collection = (tweeners[ prop ] || [
                      ]).concat(tweeners[ "*" ]),
                        index = 0,
                        length = collection.length;
                      for (; index < length; index++) {
                          if ((tween = collection[ index ].call(animation, prop, value))) {

                              // we're done with this property
                              return tween;
                          }
                      }
                  }

                  function Animation(elem, properties, options) {
                      var result,
                        stopped,
                        index = 0,
                        length = animationPrefilters.length,
                        deferred = jQuery.Deferred().always(function() {
                          // don't match elem in the :animated selector
                          delete tick.elem;
                      }),
                        tick = function() {
                          if (stopped) {
                              return false;
                          }
                          var currentTime = fxNow || createFxNow(),
                            remaining = Math.max(0, animation.startTime + animation.duration - currentTime),
                            // archaic crash bug won't allow us to use 1 - ( 0.5 || 0 ) (#12497)
                            temp = remaining / animation.duration || 0,
                            percent = 1 - temp,
                            index = 0,
                            length = animation.tweens.length;

                          for (; index < length; index++) {
                              animation.tweens[ index ].run(percent);
                          }

                          deferred.notifyWith(elem, [
                              animation,
                              percent,
                              remaining
                          ]);

                          if (percent < 1 && length) {
                              return remaining;
                          } else {
                              deferred.resolveWith(elem, [
                                  animation
                              ]);
                              return false;
                          }
                      },
                        animation = deferred.promise({
                          elem: elem,
                          props: jQuery.extend({
                          }, properties),
                          opts: jQuery.extend(true, {
                              specialEasing: {
                              }
                          },
                          options),
                          originalProperties: properties,
                          originalOptions: options,
                          startTime: fxNow || createFxNow(),
                          duration: options.duration,
                          tweens: [
                          ],
                          createTween: function(prop, end) {
                              var tween = jQuery.Tween(elem, animation.opts, prop, end,
                                animation.opts.specialEasing[ prop ] || animation.opts.easing);
                              animation.tweens.push(tween);
                              return tween;
                          },
                          stop: function(gotoEnd) {
                              var index = 0,
                                // if we are going to the end, we want to run all the tweens
                                // otherwise we skip this part
                                length = gotoEnd ? animation.tweens.length : 0;
                              if (stopped) {
                                  return this;
                              }
                              stopped = true;
                              for (; index < length; index++) {
                                  animation.tweens[ index ].run(1);
                              }

                              // resolve when we played the last frame
                              // otherwise, reject
                              if (gotoEnd) {
                                  deferred.resolveWith(elem, [
                                      animation,
                                      gotoEnd
                                  ]);
                              } else {
                                  deferred.rejectWith(elem, [
                                      animation,
                                      gotoEnd
                                  ]);
                              }
                              return this;
                          }
                      }),
                      props = animation.props;

                      propFilter(props, animation.opts.specialEasing);

                      for (; index < length; index++) {
                          result = animationPrefilters[ index ].call(animation, elem, props, animation.opts);
                          if (result) {
                              return result;
                          }
                      }

                      jQuery.map(props, createTween, animation);

                      if (jQuery.isFunction(animation.opts.start)) {
                          animation.opts.start.call(elem, animation);
                      }

                      jQuery.fx.timer(
                        jQuery.extend(tick, {
                          elem: elem,
                          anim: animation,
                          queue: animation.opts.queue
                      })
                        );

                      // attach callbacks from options
                      return animation.progress(animation.opts.progress)
                        .done(animation.opts.done, animation.opts.complete)
                        .fail(animation.opts.fail)
                        .always(animation.opts.always);
                  }

                  function propFilter(props, specialEasing) {
                      var index, name, easing, value, hooks;

                      // camelCase, specialEasing and expand cssHook pass
                      for (index in props) {
                          name = jQuery.camelCase(index);
                          easing = specialEasing[ name ];
                          value = props[ index ];
                          if (jQuery.isArray(value)) {
                              easing = value[ 1 ];
                              value = props[ index ] = value[ 0 ];
                          }

                          if (index !== name) {
                              props[ name ] = value;
                              delete props[ index ];
                          }

                          hooks = jQuery.cssHooks[ name ];
                          if (hooks && "expand" in hooks) {
                              value = hooks.expand(value);
                              delete props[ name ];

                              // not quite $.extend, this wont overwrite keys already present.
                              // also - reusing 'index' from above because we have the correct "name"
                              for (index in value) {
                                  if (!(index in props)) {
                                      props[ index ] = value[ index ];
                                      specialEasing[ index ] = easing;
                                  }
                              }
                          } else {
                              specialEasing[ name ] = easing;
                          }
                      }
                  }

                  jQuery.Animation = jQuery.extend(Animation, {
                      tweener: function(props, callback) {
                          if (jQuery.isFunction(props)) {
                              callback = props;
                              props = [
                                  "*"
                              ];
                          } else {
                              props = props.split(" ");
                          }

                          var prop,
                            index = 0,
                            length = props.length;

                          for (; index < length; index++) {
                              prop = props[ index ];
                              tweeners[ prop ] = tweeners[ prop ] || [
                              ];
                              tweeners[ prop ].unshift(callback);
                          }
                      },
                      prefilter: function(callback, prepend) {
                          if (prepend) {
                              animationPrefilters.unshift(callback);
                          } else {
                              animationPrefilters.push(callback);
                          }
                      }
                  });

                  function defaultPrefilter(elem, props, opts) {
                      /* jshint validthis: true */
                      var prop, value, toggle, tween, hooks, oldfire,
                        anim = this,
                        orig = {
                      },
                        style = elem.style,
                        hidden = elem.nodeType && isHidden(elem),
                        dataShow = data_priv.get(elem, "fxshow");

                      // handle queue: false promises
                      if (!opts.queue) {
                          hooks = jQuery._queueHooks(elem, "fx");
                          if (hooks.unqueued == null) {
                              hooks.unqueued = 0;
                              oldfire = hooks.empty.fire;
                              hooks.empty.fire = function() {
                                  if (!hooks.unqueued) {
                                      oldfire();
                                  }
                              };
                          }
                          hooks.unqueued++;

                          anim.always(function() {
                              // doing this makes sure that the complete handler will be called
                              // before this completes
                              anim.always(function() {
                                  hooks.unqueued--;
                                  if (!jQuery.queue(elem, "fx").length) {
                                      hooks.empty.fire();
                                  }
                              });
                          });
                      }

                      // height/width overflow pass
                      if (elem.nodeType === 1 && ("height" in props || "width" in props)) {
                          // Make sure that nothing sneaks out
                          // Record all 3 overflow attributes because IE9-10 do not
                          // change the overflow attribute when overflowX and
                          // overflowY are set to the same value
                          opts.overflow = [
                              style.overflow,
                              style.overflowX,
                              style.overflowY
                          ];

                          // Set display property to inline-block for height/width
                          // animations on inline elements that are having width/height animated
                          if (jQuery.css(elem, "display") === "inline" &&
                            jQuery.css(elem, "float") === "none") {

                              style.display = "inline-block";
                          }
                      }

                      if (opts.overflow) {
                          style.overflow = "hidden";
                          anim.always(function() {
                              style.overflow = opts.overflow[ 0 ];
                              style.overflowX = opts.overflow[ 1 ];
                              style.overflowY = opts.overflow[ 2 ];
                          });
                      }


                      // show/hide pass
                      for (prop in props) {
                          value = props[ prop ];
                          if (rfxtypes.exec(value)) {
                              delete props[ prop ];
                              toggle = toggle || value === "toggle";
                              if (value === (hidden ? "hide" : "show")) {

                                  // If there is dataShow left over from a stopped hide or show and we are going to proceed with show, we should pretend to be hidden
                                  if (value === "show" && dataShow && dataShow[ prop ] !== undefined) {
                                      hidden = true;
                                  } else {
                                      continue;
                                  }
                              }
                              orig[ prop ] = dataShow && dataShow[ prop ] || jQuery.style(elem, prop);
                          }
                      }

                      if (!jQuery.isEmptyObject(orig)) {
                          if (dataShow) {
                              if ("hidden" in dataShow) {
                                  hidden = dataShow.hidden;
                              }
                          } else {
                              dataShow = data_priv.access(elem, "fxshow", {
                              });
                          }

                          // store state if its toggle - enables .stop().toggle() to "reverse"
                          if (toggle) {
                              dataShow.hidden = !hidden;
                          }
                          if (hidden) {
                              jQuery(elem).show();
                          } else {
                              anim.done(function() {
                                  jQuery(elem).hide();
                              });
                          }
                          anim.done(function() {
                              var prop;

                              data_priv.remove(elem, "fxshow");
                              for (prop in orig) {
                                  jQuery.style(elem, prop, orig[ prop ]);
                              }
                          });
                          for (prop in orig) {
                              tween = createTween(hidden ? dataShow[ prop ] : 0, prop, anim);

                              if (!(prop in dataShow)) {
                                  dataShow[ prop ] = tween.start;
                                  if (hidden) {
                                      tween.end = tween.start;
                                      tween.start = prop === "width" || prop === "height" ? 1 : 0;
                                  }
                              }
                          }
                      }
                  }

                  function Tween(elem, options, prop, end, easing) {
                      return new Tween.prototype.init(elem, options, prop, end, easing);
                  }
                  jQuery.Tween = Tween;

                  Tween.prototype = {
                      constructor: Tween,
                      init: function(elem, options, prop, end, easing, unit) {
                          this.elem = elem;
                          this.prop = prop;
                          this.easing = easing || "swing";
                          this.options = options;
                          this.start = this.now = this.cur();
                          this.end = end;
                          this.unit = unit || (jQuery.cssNumber[ prop ] ? "" : "px");
                      },
                      cur: function() {
                          var hooks = Tween.propHooks[ this.prop ];

                          return hooks && hooks.get ?
                            hooks.get(this) :
                            Tween.propHooks._default.get(this);
                      },
                      run: function(percent) {
                          var eased,
                            hooks = Tween.propHooks[ this.prop ];

                          if (this.options.duration) {
                              this.pos = eased = jQuery.easing[ this.easing ](
                                percent, this.options.duration * percent, 0, 1, this.options.duration
                                );
                          } else {
                              this.pos = eased = percent;
                          }
                          this.now = (this.end - this.start) * eased + this.start;

                          if (this.options.step) {
                              this.options.step.call(this.elem, this.now, this);
                          }

                          if (hooks && hooks.set) {
                              hooks.set(this);
                          } else {
                              Tween.propHooks._default.set(this);
                          }
                          return this;
                      }
                  };

                  Tween.prototype.init.prototype = Tween.prototype;

                  Tween.propHooks = {
                      _default: {
                          get: function(tween) {
                              var result;

                              if (tween.elem[ tween.prop ] != null &&
                                (!tween.elem.style || tween.elem.style[ tween.prop ] == null)) {
                                  return tween.elem[ tween.prop ];
                              }

                              // passing an empty string as a 3rd parameter to .css will automatically
                              // attempt a parseFloat and fallback to a string if the parse fails
                              // so, simple values such as "10px" are parsed to Float.
                              // complex values such as "rotate(1rad)" are returned as is.
                              result = jQuery.css(tween.elem, tween.prop, "");
                              // Empty strings, null, undefined and "auto" are converted to 0.
                              return !result || result === "auto" ? 0 : result;
                          },
                          set: function(tween) {
                              // use step hook for back compat - use cssHook if its there - use .style if its
                              // available and use plain properties where available
                              if (jQuery.fx.step[ tween.prop ]) {
                                  jQuery.fx.step[ tween.prop ](tween);
                              } else if (tween.elem.style && (tween.elem.style[ jQuery.cssProps[ tween.prop ] ] != null || jQuery.cssHooks[ tween.prop ])) {
                                  jQuery.style(tween.elem, tween.prop, tween.now + tween.unit);
                              } else {
                                  tween.elem[ tween.prop ] = tween.now;
                              }
                          }
                      }
                  };

// Support: IE9
// Panic based approach to setting things on disconnected nodes

                  Tween.propHooks.scrollTop = Tween.propHooks.scrollLeft = {
                      set: function(tween) {
                          if (tween.elem.nodeType && tween.elem.parentNode) {
                              tween.elem[ tween.prop ] = tween.now;
                          }
                      }
                  };

                  jQuery.each([
                      "toggle",
                      "show",
                      "hide"
                  ], function(i, name) {
                      var cssFn = jQuery.fn[ name ];
                      jQuery.fn[ name ] = function(speed, easing, callback) {
                          return speed == null || typeof speed === "boolean" ?
                            cssFn.apply(this, arguments) :
                            this.animate(genFx(name, true), speed, easing, callback);
                      };
                  });

                  jQuery.fn.extend({
                      fadeTo: function(speed, to, easing, callback) {

                          // show any hidden elements after setting opacity to 0
                          return this.filter(isHidden).css("opacity", 0).show()

                            // animate to the value specified
                            .end().animate({
                              opacity: to
                          },
                          speed, easing, callback);
                      },
                      animate: function(prop, speed, easing, callback) {
                          var empty = jQuery.isEmptyObject(prop),
                            optall = jQuery.speed(speed, easing, callback),
                            doAnimation = function() {
                              // Operate on a copy of prop so per-property easing won't be lost
                              var anim = Animation(this, jQuery.extend({
                              }, prop), optall);

                              // Empty animations, or finishing resolves immediately
                              if (empty || data_priv.get(this, "finish")) {
                                  anim.stop(true);
                              }
                          };
                          doAnimation.finish = doAnimation;

                          return empty || optall.queue === false ?
                            this.each(doAnimation) :
                            this.queue(optall.queue, doAnimation);
                      },
                      stop: function(type, clearQueue, gotoEnd) {
                          var stopQueue = function(hooks) {
                              var stop = hooks.stop;
                              delete hooks.stop;
                              stop(gotoEnd);
                          };

                          if (typeof type !== "string") {
                              gotoEnd = clearQueue;
                              clearQueue = type;
                              type = undefined;
                          }
                          if (clearQueue && type !== false) {
                              this.queue(type || "fx", [
                              ]);
                          }

                          return this.each(function() {
                              var dequeue = true,
                                index = type != null && type + "queueHooks",
                                timers = jQuery.timers,
                                data = data_priv.get(this);

                              if (index) {
                                  if (data[ index ] && data[ index ].stop) {
                                      stopQueue(data[ index ]);
                                  }
                              } else {
                                  for (index in data) {
                                      if (data[ index ] && data[ index ].stop && rrun.test(index)) {
                                          stopQueue(data[ index ]);
                                      }
                                  }
                              }

                              for (index = timers.length; index--; ) {
                                  if (timers[ index ].elem === this && (type == null || timers[ index ].queue === type)) {
                                      timers[ index ].anim.stop(gotoEnd);
                                      dequeue = false;
                                      timers.splice(index, 1);
                                  }
                              }

                              // start the next in the queue if the last step wasn't forced
                              // timers currently will call their complete callbacks, which will dequeue
                              // but only if they were gotoEnd
                              if (dequeue || !gotoEnd) {
                                  jQuery.dequeue(this, type);
                              }
                          });
                      },
                      finish: function(type) {
                          if (type !== false) {
                              type = type || "fx";
                          }
                          return this.each(function() {
                              var index,
                                data = data_priv.get(this),
                                queue = data[ type + "queue" ],
                                hooks = data[ type + "queueHooks" ],
                                timers = jQuery.timers,
                                length = queue ? queue.length : 0;

                              // enable finishing flag on private data
                              data.finish = true;

                              // empty the queue first
                              jQuery.queue(this, type, [
                              ]);

                              if (hooks && hooks.stop) {
                                  hooks.stop.call(this, true);
                              }

                              // look for any active animations, and finish them
                              for (index = timers.length; index--; ) {
                                  if (timers[ index ].elem === this && timers[ index ].queue === type) {
                                      timers[ index ].anim.stop(true);
                                      timers.splice(index, 1);
                                  }
                              }

                              // look for any animations in the old queue and finish them
                              for (index = 0; index < length; index++) {
                                  if (queue[ index ] && queue[ index ].finish) {
                                      queue[ index ].finish.call(this);
                                  }
                              }

                              // turn off finishing flag
                              delete data.finish;
                          });
                      }
                  });

// Generate parameters to create a standard animation
                  function genFx(type, includeWidth) {
                      var which,
                        attrs = {
                          height: type
                      },
                      i = 0;

                      // if we include width, step value is 1 to do all cssExpand values,
                      // if we don't include width, step value is 2 to skip over Left and Right
                      includeWidth = includeWidth ? 1 : 0;
                      for (; i < 4; i += 2 - includeWidth) {
                          which = cssExpand[ i ];
                          attrs[ "margin" + which ] = attrs[ "padding" + which ] = type;
                      }

                      if (includeWidth) {
                          attrs.opacity = attrs.width = type;
                      }

                      return attrs;
                  }

// Generate shortcuts for custom animations
                  jQuery.each({
                      slideDown: genFx("show"),
                      slideUp: genFx("hide"),
                      slideToggle: genFx("toggle"),
                      fadeIn: {
                          opacity: "show"
                      },
                      fadeOut: {
                          opacity: "hide"
                      },
                      fadeToggle: {
                          opacity: "toggle"
                      }
                  },
                  function(name, props) {
                      jQuery.fn[ name ] = function(speed, easing, callback) {
                          return this.animate(props, speed, easing, callback);
                      };
                  });

                  jQuery.speed = function(speed, easing, fn) {
                      var opt = speed && typeof speed === "object" ? jQuery.extend({
                      }, speed) : {
                          complete: fn || !fn && easing ||
                            jQuery.isFunction(speed) && speed,
                          duration: speed,
                          easing: fn && easing || easing && !jQuery.isFunction(easing) && easing
                      };

                      opt.duration = jQuery.fx.off ? 0 : typeof opt.duration === "number" ? opt.duration :
                        opt.duration in jQuery.fx.speeds ? jQuery.fx.speeds[ opt.duration ] : jQuery.fx.speeds._default;

                      // normalize opt.queue - true/undefined/null -> "fx"
                      if (opt.queue == null || opt.queue === true) {
                          opt.queue = "fx";
                      }

                      // Queueing
                      opt.old = opt.complete;

                      opt.complete = function() {
                          if (jQuery.isFunction(opt.old)) {
                              opt.old.call(this);
                          }

                          if (opt.queue) {
                              jQuery.dequeue(this, opt.queue);
                          }
                      };

                      return opt;
                  };

                  jQuery.easing = {
                      linear: function(p) {
                          return p;
                      },
                      swing: function(p) {
                          return 0.5 - Math.cos(p * Math.PI) / 2;
                      }
                  };

                  jQuery.timers = [
                  ];
                  jQuery.fx = Tween.prototype.init;
                  jQuery.fx.tick = function() {
                      var timer,
                        timers = jQuery.timers,
                        i = 0;

                      fxNow = jQuery.now();

                      for (; i < timers.length; i++) {
                          timer = timers[ i ];
                          // Checks the timer has not already been removed
                          if (!timer() && timers[ i ] === timer) {
                              timers.splice(i--, 1);
                          }
                      }

                      if (!timers.length) {
                          jQuery.fx.stop();
                      }
                      fxNow = undefined;
                  };

                  jQuery.fx.timer = function(timer) {
                      if (timer() && jQuery.timers.push(timer)) {
                          jQuery.fx.start();
                      }
                  };

                  jQuery.fx.interval = 13;

                  jQuery.fx.start = function() {
                      if (!timerId) {
                          timerId = setInterval(jQuery.fx.tick, jQuery.fx.interval);
                      }
                  };

                  jQuery.fx.stop = function() {
                      clearInterval(timerId);
                      timerId = null;
                  };

                  jQuery.fx.speeds = {
                      slow: 600,
                      fast: 200,
                      // Default speed
                      _default: 400
                  };

// Back Compat <1.8 extension point
                  jQuery.fx.step = {
                  };

                  if (jQuery.expr && jQuery.expr.filters) {
                      jQuery.expr.filters.animated = function(elem) {
                          return jQuery.grep(jQuery.timers, function(fn) {
                              return elem === fn.elem;
                          }).length;
                      };
                  }
                  jQuery.fn.offset = function(options) {
                      if (arguments.length) {
                          return options === undefined ?
                            this :
                            this.each(function(i) {
                              jQuery.offset.setOffset(this, options, i);
                          });
                      }

                      var docElem, win,
                        elem = this[ 0 ],
                        box = {
                          top: 0,
                          left: 0
                      },
                      doc = elem && elem.ownerDocument;

                      if (!doc) {
                          return;
                      }

                      docElem = doc.documentElement;

                      // Make sure it's not a disconnected DOM node
                      if (!jQuery.contains(docElem, elem)) {
                          return box;
                      }

                      // If we don't have gBCR, just use 0,0 rather than error
                      // BlackBerry 5, iOS 3 (original iPhone)
                      if (typeof elem.getBoundingClientRect !== core_strundefined) {
                          box = elem.getBoundingClientRect();
                      }
                      win = getWindow(doc);
                      return {
                          top: box.top + win.pageYOffset - docElem.clientTop,
                          left: box.left + win.pageXOffset - docElem.clientLeft
                      };
                  };

                  jQuery.offset = {
                      setOffset: function(elem, options, i) {
                          var curPosition, curLeft, curCSSTop, curTop, curOffset, curCSSLeft, calculatePosition,
                            position = jQuery.css(elem, "position"),
                            curElem = jQuery(elem),
                            props = {
                          };

                          // Set position first, in-case top/left are set even on static elem
                          if (position === "static") {
                              elem.style.position = "relative";
                          }

                          curOffset = curElem.offset();
                          curCSSTop = jQuery.css(elem, "top");
                          curCSSLeft = jQuery.css(elem, "left");
                          calculatePosition = (position === "absolute" || position === "fixed") && (curCSSTop + curCSSLeft).indexOf("auto") > -1;

                          // Need to be able to calculate position if either top or left is auto and position is either absolute or fixed
                          if (calculatePosition) {
                              curPosition = curElem.position();
                              curTop = curPosition.top;
                              curLeft = curPosition.left;

                          } else {
                              curTop = parseFloat(curCSSTop) || 0;
                              curLeft = parseFloat(curCSSLeft) || 0;
                          }

                          if (jQuery.isFunction(options)) {
                              options = options.call(elem, i, curOffset);
                          }

                          if (options.top != null) {
                              props.top = (options.top - curOffset.top) + curTop;
                          }
                          if (options.left != null) {
                              props.left = (options.left - curOffset.left) + curLeft;
                          }

                          if ("using" in options) {
                              options.using.call(elem, props);

                          } else {
                              curElem.css(props);
                          }
                      }
                  };


                  jQuery.fn.extend({
                      position: function() {
                          if (!this[ 0 ]) {
                              return;
                          }

                          var offsetParent, offset,
                            elem = this[ 0 ],
                            parentOffset = {
                              top: 0,
                              left: 0
                          };

                          // Fixed elements are offset from window (parentOffset = {top:0, left: 0}, because it is it's only offset parent
                          if (jQuery.css(elem, "position") === "fixed") {
                              // We assume that getBoundingClientRect is available when computed position is fixed
                              offset = elem.getBoundingClientRect();

                          } else {
                              // Get *real* offsetParent
                              offsetParent = this.offsetParent();

                              // Get correct offsets
                              offset = this.offset();
                              if (!jQuery.nodeName(offsetParent[ 0 ], "html")) {
                                  parentOffset = offsetParent.offset();
                              }

                              // Add offsetParent borders
                              parentOffset.top += jQuery.css(offsetParent[ 0 ], "borderTopWidth", true);
                              parentOffset.left += jQuery.css(offsetParent[ 0 ], "borderLeftWidth", true);
                          }

                          // Subtract parent offsets and element margins
                          return {
                              top: offset.top - parentOffset.top - jQuery.css(elem, "marginTop", true),
                              left: offset.left - parentOffset.left - jQuery.css(elem, "marginLeft", true)
                          };
                      },
                      offsetParent: function() {
                          return this.map(function() {
                              var offsetParent = this.offsetParent || docElem;

                              while (offsetParent && (!jQuery.nodeName(offsetParent, "html") && jQuery.css(offsetParent, "position") === "static")) {
                                  offsetParent = offsetParent.offsetParent;
                              }

                              return offsetParent || docElem;
                          });
                      }
                  });


// Create scrollLeft and scrollTop methods
                  jQuery.each({
                      scrollLeft: "pageXOffset",
                      scrollTop: "pageYOffset"
                  },
                  function(method, prop) {
                      var top = "pageYOffset" === prop;

                      jQuery.fn[ method ] = function(val) {
                          return jQuery.access(this, function(elem, method, val) {
                              var win = getWindow(elem);

                              if (val === undefined) {
                                  return win ? win[ prop ] : elem[ method ];
                              }

                              if (win) {
                                  win.scrollTo(
                                    !top ? val : window.pageXOffset,
                                    top ? val : window.pageYOffset
                                    );

                              } else {
                                  elem[ method ] = val;
                              }
                          }, method, val, arguments.length, null);
                      };
                  });

                  function getWindow(elem) {
                      return jQuery.isWindow(elem) ? elem : elem.nodeType === 9 && elem.defaultView;
                  }
// Create innerHeight, innerWidth, height, width, outerHeight and outerWidth methods
                  jQuery.each({
                      Height: "height",
                      Width: "width"
                  },
                  function(name, type) {
                      jQuery.each({
                          padding: "inner" + name,
                          content: type,
                          "": "outer" + name
                      },
                      function(defaultExtra, funcName) {
                          // margin is only for outerHeight, outerWidth
                          jQuery.fn[ funcName ] = function(margin, value) {
                              var chainable = arguments.length && (defaultExtra || typeof margin !== "boolean"),
                                extra = defaultExtra || (margin === true || value === true ? "margin" : "border");

                              return jQuery.access(this, function(elem, type, value) {
                                  var doc;

                                  if (jQuery.isWindow(elem)) {
                                      // As of 5/8/2012 this will yield incorrect results for Mobile Safari, but there
                                      // isn't a whole lot we can do. See pull request at this URL for discussion:
                                      // https://github.com/jquery/jquery/pull/764
                                      return elem.document.documentElement[ "client" + name ];
                                  }

                                  // Get document width or height
                                  if (elem.nodeType === 9) {
                                      doc = elem.documentElement;

                                      // Either scroll[Width/Height] or offset[Width/Height] or client[Width/Height],
                                      // whichever is greatest
                                      return Math.max(
                                        elem.body[ "scroll" + name ], doc[ "scroll" + name ],
                                        elem.body[ "offset" + name ], doc[ "offset" + name ],
                                        doc[ "client" + name ]
                                        );
                                  }

                                  return value === undefined ?
                                    // Get width or height on the element, requesting but not forcing parseFloat
                                    jQuery.css(elem, type, extra) :
                                    // Set width or height on the element
                                    jQuery.style(elem, type, value, extra);
                              }, type, chainable ? margin : undefined, chainable, null);
                          };
                      });
                  });
// Limit scope pollution from any deprecated API
// (function() {

// The number of elements contained in the matched element set
                  jQuery.fn.size = function() {
                      return this.length;
                  };

                  jQuery.fn.andSelf = jQuery.fn.addBack;

// })();
                  if (typeof module === "object" && module && typeof module.exports === "object") {
                      // Expose jQuery as module.exports in loaders that implement the Node
                      // module pattern (including browserify). Do not create the global, since
                      // the user will be storing it themselves locally, and globals are frowned
                      // upon in the Node module world.
                      module.exports = jQuery;
                  } else {
                      // Register as a named AMD module, since jQuery can be concatenated with other
                      // files that may use define, but not via a proper concatenation script that
                      // understands anonymous AMD modules. A named AMD is safest and most robust
                      // way to register. Lowercase jquery is used because AMD module names are
                      // derived from file names, and jQuery is normally delivered in a lowercase
                      // file name. Do this after creating the global so that if an AMD module wants
                      // to call noConflict to hide this version of jQuery, it will work.
                      if (typeof define === "function" && define.amd) {
                          define("jquery", [
                          ], function() {
                              return jQuery;
                          });
                      }
                  }

// If there is a window object, that at least has a document property,
// define jQuery and $ identifiers
                  if (typeof window === "object" && typeof window.document === "object") {
                      window.jQuery = window.$ = jQuery;
                  }

              })(window);

//fgnass.github.com/spin.js#v1.3

/**
 * Copyright (c) 2011-2013 Felix Gnass
 * Licensed under the MIT license
 */
(function(root, factory) {

  /* CommonJS */
  if (typeof exports == 'object')  module.exports = factory()

  /* AMD module */
  else if (typeof define == 'function' && define.amd) define(factory)

  /* Browser global */
  else root.Spinner = factory()
}
(this, function() {
  "use strict";

  var prefixes = ['webkit', 'Moz', 'ms', 'O'] /* Vendor prefixes */
    , animations = {} /* Animation rules keyed by their name */
    , useCssAnimations /* Whether to use CSS animations or setTimeout */

  /**
   * Utility function to create elements. If no tag name is given,
   * a DIV is created. Optionally properties can be passed.
   */
  function createEl(tag, prop) {
    var el = document.createElement(tag || 'div')
      , n

    for(n in prop) el[n] = prop[n]
    return el
  }

  /**
   * Appends children and returns the parent.
   */
  function ins(parent /* child1, child2, ...*/) {
    for (var i=1, n=arguments.length; i<n; i++)
      parent.appendChild(arguments[i])

    return parent
  }

  /**
   * Insert a new stylesheet to hold the @keyframe or VML rules.
   */
  var sheet = (function() {
    var el = createEl('style', {type : 'text/css'})
    ins(document.getElementsByTagName('head')[0], el)
    return el.sheet || el.styleSheet
  }())

  /**
   * Creates an opacity keyframe animation rule and returns its name.
   * Since most mobile Webkits have timing issues with animation-delay,
   * we create separate rules for each line/segment.
   */
  function addAnimation(alpha, trail, i, lines) {
    var name = ['opacity', trail, ~~(alpha*100), i, lines].join('-')
      , start = 0.01 + i/lines * 100
      , z = Math.max(1 - (1-alpha) / trail * (100-start), alpha)
      , prefix = useCssAnimations.substring(0, useCssAnimations.indexOf('Animation')).toLowerCase()
      , pre = prefix && '-' + prefix + '-' || ''

    if (!animations[name]) {
      sheet.insertRule(
        '@' + pre + 'keyframes ' + name + '{' +
        '0%{opacity:' + z + '}' +
        start + '%{opacity:' + alpha + '}' +
        (start+0.01) + '%{opacity:1}' +
        (start+trail) % 100 + '%{opacity:' + alpha + '}' +
        '100%{opacity:' + z + '}' +
        '}', sheet.cssRules.length)

      animations[name] = 1
    }

    return name
  }

  /**
   * Tries various vendor prefixes and returns the first supported property.
   */
  function vendor(el, prop) {
    var s = el.style
      , pp
      , i

    if(s[prop] !== undefined) return prop
    prop = prop.charAt(0).toUpperCase() + prop.slice(1)
    for(i=0; i<prefixes.length; i++) {
      pp = prefixes[i]+prop
      if(s[pp] !== undefined) return pp
    }
  }

  /**
   * Sets multiple style properties at once.
   */
  function css(el, prop) {
    for (var n in prop)
      el.style[vendor(el, n)||n] = prop[n]

    return el
  }

  /**
   * Fills in default values.
   */
  function merge(obj) {
    for (var i=1; i < arguments.length; i++) {
      var def = arguments[i]
      for (var n in def)
        if (obj[n] === undefined) obj[n] = def[n]
    }
    return obj
  }

  /**
   * Returns the absolute page-offset of the given element.
   */
  function pos(el) {
    var o = { x:el.offsetLeft, y:el.offsetTop }
    while((el = el.offsetParent))
      o.x+=el.offsetLeft, o.y+=el.offsetTop

    return o
  }

  // Built-in defaults

  var defaults = {
    lines: 12,            // The number of lines to draw
    length: 7,            // The length of each line
    width: 5,             // The line thickness
    radius: 10,           // The radius of the inner circle
    rotate: 0,            // Rotation offset
    corners: 1,           // Roundness (0..1)
    color: '#000',        // #rgb or #rrggbb
    direction: 1,         // 1: clockwise, -1: counterclockwise
    speed: 1,             // Rounds per second
    trail: 100,           // Afterglow percentage
    opacity: 1/4,         // Opacity of the lines
    fps: 20,              // Frames per second when using setTimeout()
    zIndex: 2e9,          // Use a high z-index by default
    className: 'spinner', // CSS class to assign to the element
    top: 'auto',          // center vertically
    left: 'auto',         // center horizontally
    position: 'relative'  // element position
  }

  /** The constructor */
  function Spinner(o) {
    if (typeof this == 'undefined') return new Spinner(o)
    this.opts = merge(o || {}, Spinner.defaults, defaults)
  }

  // Global defaults that override the built-ins:
  Spinner.defaults = {}

  merge(Spinner.prototype, {

    /**
     * Adds the spinner to the given target element. If this instance is already
     * spinning, it is automatically removed from its previous target b calling
     * stop() internally.
     */
    spin: function(target) {
      this.stop()

      var self = this
        , o = self.opts
        , el = self.el = css(createEl(0, {className: o.className}), {position: o.position, width: 0, zIndex: o.zIndex})
        , mid = o.radius+o.length+o.width
        , ep // element position
        , tp // target position

      if (target) {
        target.insertBefore(el, target.firstChild||null)
        tp = pos(target)
        ep = pos(el)
        css(el, {
          left: (o.left == 'auto' ? tp.x-ep.x + (target.offsetWidth >> 1) : parseInt(o.left, 10) + mid) + 'px',
          top: (o.top == 'auto' ? tp.y-ep.y + (target.offsetHeight >> 1) : parseInt(o.top, 10) + mid)  + 'px'
        })
      }

      el.setAttribute('role', 'progressbar')
      self.lines(el, self.opts)

      if (!useCssAnimations) {
        // No CSS animation support, use setTimeout() instead
        var i = 0
          , start = (o.lines - 1) * (1 - o.direction) / 2
          , alpha
          , fps = o.fps
          , f = fps/o.speed
          , ostep = (1-o.opacity) / (f*o.trail / 100)
          , astep = f/o.lines

        ;(function anim() {
          i++;
          for (var j = 0; j < o.lines; j++) {
            alpha = Math.max(1 - (i + (o.lines - j) * astep) % f * ostep, o.opacity)

            self.opacity(el, j * o.direction + start, alpha, o)
          }
          self.timeout = self.el && setTimeout(anim, ~~(1000/fps))
        })()
      }
      return self
    },

    /**
     * Stops and removes the Spinner.
     */
    stop: function() {
      var el = this.el
      if (el) {
        clearTimeout(this.timeout)
        if (el.parentNode) el.parentNode.removeChild(el)
        this.el = undefined
      }
      return this
    },

    /**
     * Internal method that draws the individual lines. Will be overwritten
     * in VML fallback mode below.
     */
    lines: function(el, o) {
      var i = 0
        , start = (o.lines - 1) * (1 - o.direction) / 2
        , seg

      function fill(color, shadow) {
        return css(createEl(), {
          position: 'absolute',
          width: (o.length+o.width) + 'px',
          height: o.width + 'px',
          background: color,
          boxShadow: shadow,
          transformOrigin: 'left',
          transform: 'rotate(' + ~~(360/o.lines*i+o.rotate) + 'deg) translate(' + o.radius+'px' +',0)',
          borderRadius: (o.corners * o.width>>1) + 'px'
        })
      }

      for (; i < o.lines; i++) {
        seg = css(createEl(), {
          position: 'absolute',
          top: 1+~(o.width/2) + 'px',
          transform: o.hwaccel ? 'translate3d(0,0,0)' : '',
          opacity: o.opacity,
          animation: useCssAnimations && addAnimation(o.opacity, o.trail, start + i * o.direction, o.lines) + ' ' + 1/o.speed + 's linear infinite'
        })

        if (o.shadow) ins(seg, css(fill('#000', '0 0 4px ' + '#000'), {top: 2+'px'}))

        ins(el, ins(seg, fill(o.color, '0 0 1px rgba(0,0,0,.1)')))
      }
      return el
    },

    /**
     * Internal method that adjusts the opacity of a single line.
     * Will be overwritten in VML fallback mode below.
     */
    opacity: function(el, i, val) {
      if (i < el.childNodes.length) el.childNodes[i].style.opacity = val
    }

  })


  function initVML() {

    /* Utility function to create a VML tag */
    function vml(tag, attr) {
      return createEl('<' + tag + ' xmlns="urn:schemas-microsoft.com:vml" class="spin-vml">', attr)
    }

    // No CSS transforms but VML support, add a CSS rule for VML elements:
    sheet.addRule('.spin-vml', 'behavior:url(#default#VML)')

    Spinner.prototype.lines = function(el, o) {
      var r = o.length+o.width
        , s = 2*r

      function grp() {
        return css(
          vml('group', {
            coordsize: s + ' ' + s,
            coordorigin: -r + ' ' + -r
          }),
          { width: s, height: s }
        )
      }

      var margin = -(o.width+o.length)*2 + 'px'
        , g = css(grp(), {position: 'absolute', top: margin, left: margin})
        , i

      function seg(i, dx, filter) {
        ins(g,
          ins(css(grp(), {rotation: 360 / o.lines * i + 'deg', left: ~~dx}),
            ins(css(vml('roundrect', {arcsize: o.corners}), {
                width: r,
                height: o.width,
                left: o.radius,
                top: -o.width>>1,
                filter: filter
              }),
              vml('fill', {color: o.color, opacity: o.opacity}),
              vml('stroke', {opacity: 0}) // transparent stroke to fix color bleeding upon opacity change
            )
          )
        )
      }

      if (o.shadow)
        for (i = 1; i <= o.lines; i++)
          seg(i, -2, 'progid:DXImageTransform.Microsoft.Blur(pixelradius=2,makeshadow=1,shadowopacity=.3)')

      for (i = 1; i <= o.lines; i++) seg(i)
      return ins(el, g)
    }

    Spinner.prototype.opacity = function(el, i, val, o) {
      var c = el.firstChild
      o = o.shadow && o.lines || 0
      if (c && i+o < c.childNodes.length) {
        c = c.childNodes[i+o]; c = c && c.firstChild; c = c && c.firstChild
        if (c) c.opacity = val
      }
    }
  }

  var probe = css(createEl('group'), {behavior: 'url(#default#VML)'})

  if (!vendor(probe, 'transform') && probe.adj) initVML()
  else useCssAnimations = vendor(probe, 'animation')

  return Spinner

}));

/**
 * Copyright (c) 2011-2013 Felix Gnass
 * Licensed under the MIT license
 */

/*

Basic Usage:
============

$('#el').spin(); // Creates a default Spinner using the text color of #el.
$('#el').spin({ ... }); // Creates a Spinner using the provided options.

$('#el').spin(false); // Stops and removes the spinner.

Using Presets:
==============

$('#el').spin('small'); // Creates a 'small' Spinner using the text color of #el.
$('#el').spin('large', '#fff'); // Creates a 'large' white Spinner.

Adding a custom preset:
=======================

$.fn.spin.presets.flower = {
  lines: 9
  length: 10
  width: 20
  radius: 0
}

$('#el').spin('flower', 'red');

*/

(function(factory) {

  if (typeof exports == 'object') {
    // CommonJS
    factory(require('jquery'), require('spin'))
  }
  else if (typeof define == 'function' && define.amd) {
    // AMD, register as anonymous module
    define(['jquery', 'spin'], factory)
  }
  else {
    // Browser globals
    if (!window.Spinner) throw new Error('Spin.js not present')
    factory(window.jQuery, window.Spinner)
  }

}(function($, Spinner) {

  $.fn.spin = function(opts, color) {

    return this.each(function() {
      var $this = $(this),
        data = $this.data();

      if (data.spinner) {
        data.spinner.stop();
        delete data.spinner;
      }
      if (opts !== false) {
        opts = $.extend(
          { color: color || $this.css('color') },
          $.fn.spin.presets[opts] || opts
        )
        data.spinner = new Spinner(opts).spin(this)
      }
    })
  }

  $.fn.spin.presets = {
    tiny: { lines: 8, length: 2, width: 2, radius: 3 },
    small: { lines: 8, length: 4, width: 3, radius: 5 },
    large: { lines: 10, length: 8, width: 4, radius: 8 }
  }

}));

/*! Copyright (c) 2013 Brandon Aaron (http://brandonaaron.net)
 * Licensed under the MIT License (LICENSE.txt).
 *
 * Thanks to: http://adomas.org/javascript-mouse-wheel/ for some pointers.
 * Thanks to: Mathias Bank(http://www.mathias-bank.de) for a scope bug fix.
 * Thanks to: Seamus Leahy for adding deltaX and deltaY
 *
 * Version: 3.1.3
 *
 * Requires: 1.2.2+
 */

(function (factory) {
    if ( typeof define === 'function' && define.amd ) {
        // AMD. Register as an anonymous module.
        define(['jquery'], factory);
    } else if (typeof exports === 'object') {
        // Node/CommonJS style for Browserify
        module.exports = factory;
    } else {
        // Browser globals
        factory(jQuery);
    }
}(function ($) {

    var toFix = ['wheel', 'mousewheel', 'DOMMouseScroll', 'MozMousePixelScroll'];
    var toBind = 'onwheel' in document || document.documentMode >= 9 ? ['wheel'] : ['mousewheel', 'DomMouseScroll', 'MozMousePixelScroll'];
    var lowestDelta, lowestDeltaXY;

    if ( $.event.fixHooks ) {
        for ( var i = toFix.length; i; ) {
            $.event.fixHooks[ toFix[--i] ] = $.event.mouseHooks;
        }
    }

    $.event.special.mousewheel = {
        setup: function() {
            if ( this.addEventListener ) {
                for ( var i = toBind.length; i; ) {
                    this.addEventListener( toBind[--i], handler, false );
                }
            } else {
                this.onmousewheel = handler;
            }
        },

        teardown: function() {
            if ( this.removeEventListener ) {
                for ( var i = toBind.length; i; ) {
                    this.removeEventListener( toBind[--i], handler, false );
                }
            } else {
                this.onmousewheel = null;
            }
        }
    };

    $.fn.extend({
        mousewheel: function(fn) {
            return fn ? this.bind("mousewheel", fn) : this.trigger("mousewheel");
        },

        unmousewheel: function(fn) {
            return this.unbind("mousewheel", fn);
        }
    });


    function handler(event) {
        var orgEvent = event || window.event,
            args = [].slice.call(arguments, 1),
            delta = 0,
            deltaX = 0,
            deltaY = 0,
            absDelta = 0,
            absDeltaXY = 0,
            fn;
        event = $.event.fix(orgEvent);
        event.type = "mousewheel";

        // Old school scrollwheel delta
        if ( orgEvent.wheelDelta ) { delta = orgEvent.wheelDelta; }
        if ( orgEvent.detail )     { delta = orgEvent.detail * -1; }

        // New school wheel delta (wheel event)
        if ( orgEvent.deltaY ) {
            deltaY = orgEvent.deltaY * -1;
            delta  = deltaY;
        }
        if ( orgEvent.deltaX ) {
            deltaX = orgEvent.deltaX;
            delta  = deltaX * -1;
        }

        // Webkit
        if ( orgEvent.wheelDeltaY !== undefined ) { deltaY = orgEvent.wheelDeltaY; }
        if ( orgEvent.wheelDeltaX !== undefined ) { deltaX = orgEvent.wheelDeltaX * -1; }

        // Look for lowest delta to normalize the delta values
        absDelta = Math.abs(delta);
        if ( !lowestDelta || absDelta < lowestDelta ) { lowestDelta = absDelta; }
        absDeltaXY = Math.max(Math.abs(deltaY), Math.abs(deltaX));
        if ( !lowestDeltaXY || absDeltaXY < lowestDeltaXY ) { lowestDeltaXY = absDeltaXY; }

        // Get a whole value for the deltas
        fn = delta > 0 ? 'floor' : 'ceil';
        delta  = Math[fn](delta / lowestDelta);
        deltaX = Math[fn](deltaX / lowestDeltaXY);
        deltaY = Math[fn](deltaY / lowestDeltaXY);

        // Add event and delta to the front of the arguments
        args.unshift(event, delta, deltaX, deltaY);

        return ($.event.dispatch || $.event.handle).apply(this, args);
    }

}));

/*
 * jQuery Hotkeys Plugin
 * Copyright 2010, John Resig
 * Dual licensed under the MIT or GPL Version 2 licenses.
 *
 * Based upon the plugin by Tzury Bar Yochay:
 * http://github.com/tzuryby/hotkeys
 *
 * Original idea by:
 * Binny V A, http://www.openjs.com/scripts/events/keyboard_shortcuts/
*/

(function(jQuery){
	
	jQuery.hotkeys = {
		version: "0.8",

		specialKeys: {
			8: "backspace", 9: "tab", 13: "return", 16: "shift", 17: "ctrl", 18: "alt", 19: "pause",
			20: "capslock", 27: "esc", 32: "space", 33: "pageup", 34: "pagedown", 35: "end", 36: "home",
			37: "left", 38: "up", 39: "right", 40: "down", 45: "insert", 46: "del", 
			96: "0", 97: "1", 98: "2", 99: "3", 100: "4", 101: "5", 102: "6", 103: "7",
			104: "8", 105: "9", 106: "*", 107: "+", 109: "-", 187: "plus", 189: "minus", 110: ".", 111 : "/", 
			112: "f1", 113: "f2", 114: "f3", 115: "f4", 116: "f5", 117: "f6", 118: "f7", 119: "f8", 
			120: "f9", 121: "f10", 122: "f11", 123: "f12", 144: "numlock", 145: "scroll", 191: "/", 224: "meta"
		},
	
		shiftNums: {
			"`": "~", "1": "!", "2": "@", "3": "#", "4": "$", "5": "%", "6": "^", "7": "&", 
			"8": "*", "9": "(", "0": ")", "-": "_", "=": "+", ";": ": ", "'": "\"", ",": "<", 
			".": ">",  "/": "?",  "\\": "|"
		}
	};

	function keyHandler( handleObj ) {
		// Only care when a possible input has been specified
		if ( typeof handleObj.data !== "string" ) {
			return;
		}
		
		var origHandler = handleObj.handler,
			keys = handleObj.data.toLowerCase().split(" "),
			textAcceptingInputTypes = ["text", "password", "number", "email", "url", "range", "date", "month", "week", "time", "datetime", "datetime-local", "search", "color"];
	
		handleObj.handler = function( event ) {
			// Don't fire in text-accepting inputs that we didn't directly bind to
			if ( this !== event.target && (/textarea|select/i.test( event.target.nodeName ) ||
				jQuery.inArray(event.target.type, textAcceptingInputTypes) > -1 ) ) {
				return;
			}
			
			// Keypress represents characters, not special keys
			var special = event.type !== "keypress" && jQuery.hotkeys.specialKeys[ event.which ],
				character = String.fromCharCode( event.which ).toLowerCase(),
				key, modif = "", possible = {};

			// check combinations (alt|ctrl|shift+anything)
			if ( event.altKey && special !== "alt" ) {
				modif += "alt+";
			}

			if ( event.ctrlKey && special !== "ctrl" ) {
				modif += "ctrl+";
			}
			
			// TODO: Need to make sure this works consistently across platforms
			if ( event.metaKey && !event.ctrlKey && special !== "meta" ) {
				modif += "meta+";
			}

			if ( event.shiftKey && special !== "shift" ) {
				modif += "shift+";
			}

			if ( special ) {
				possible[ modif + special ] = true;

			} else {
				possible[ modif + character ] = true;
				possible[ modif + jQuery.hotkeys.shiftNums[ character ] ] = true;

				// "$" can be triggered as "Shift+4" or "Shift+$" or just "$"
				if ( modif === "shift+" ) {
					possible[ jQuery.hotkeys.shiftNums[ character ] ] = true;
				}
			}

			for ( var i = 0, l = keys.length; i < l; i++ ) {
				if ( possible[ keys[i] ] ) {
					return origHandler.apply( this, arguments );
				}
			}
		};
	}

	jQuery.each([ "keydown", "keyup", "keypress" ], function() {
		jQuery.event.special[ this ] = { add: keyHandler };
	});

})( jQuery );

/*

jQuery Browser Plugin
	* Version 2.3
	* 2008-09-17 19:27:05
	* URL: http://jquery.thewikies.com/browser
	* Description: jQuery Browser Plugin extends browser detection capabilities and can assign browser selectors to CSS classes.
	* Author: Nate Cavanaugh, Minhchau Dang, & Jonathan Neal
	* Copyright: Copyright (c) 2008 Jonathan Neal under dual MIT/GPL license.
	* JSLint: This javascript file passes JSLint verification.
*//*jslint
		bitwise: true,
		browser: true,
		eqeqeq: true,
		forin: true,
		nomen: true,
		plusplus: true,
		undef: true,
		white: true
*//*global
		jQuery
*/

(function ($) {
	$.browserTest = function (a, z) {
		var u = 'unknown', x = 'X', m = function (r, h) {
			for (var i = 0; i < h.length; i = i + 1) {
				r = r.replace(h[i][0], h[i][1]);
			}

			return r;
		}, c = function (i, a, b, c) {
			var r = {
                            getName: function () { return this.name},
                              getVersion: function () { return this.version},
				name: m((a.exec(i) || [u, u])[1], b)
			};

			r[r.name] = true;

			r.version = (c.exec(i) || [x, x, x, x])[3];

			if (r.name.match(/safari/) && r.version > 400) {
				r.version = '2.0';
			}

			if (r.name === 'presto') {
				r.version = ($.browser.version > 9.27) ? 'futhark' : 'linear_b';
			}
			r.versionNumber = parseFloat(r.version, 10) || 0;
			r.versionX = (r.version !== x) ? (r.version + '').substr(0, 1) : x;
			r.className = r.name + r.versionX;

			return r;
		};

		a = (a.match(/Opera|Navigator|Minefield|KHTML|Chrome/) ? m(a, [
			[/(Firefox|MSIE|KHTML,\slike\sGecko|Konqueror)/, ''],
			['Chrome Safari', 'Chrome'],
			['KHTML', 'Konqueror'],
			['Minefield', 'Firefox'],
			['Navigator', 'Netscape']
		]) : a).toLowerCase();

		$.browser = $.extend((!z) ? $.browser : {}, c(a, /(camino|chrome|firefox|netscape|konqueror|lynx|msie|opera|safari)/, [], /(camino|chrome|firefox|netscape|netscape6|opera|version|konqueror|lynx|msie|safari)(\/|\s)([a-z0-9\.\+]*?)(\;|dev|rel|\s|$)/));

		$.layout = c(a, /(gecko|konqueror|msie|opera|webkit)/, [
			['konqueror', 'khtml'],
			['msie', 'trident'],
			['opera', 'presto']
		], /(applewebkit|rv|konqueror|msie)(\:|\/|\s)([a-z0-9\.]*?)(\;|\)|\s)/);

		$.os = {
			name: (/(win|mac|linux|sunos|solaris|iphone)/.exec(navigator.platform.toLowerCase()) || [u])[0].replace('sunos', 'solaris')
		};

		if (!z) {
			$('html').addClass([$.os.name, $.browser.name, $.browser.className, $.layout.name, $.layout.className].join(' '));
		}
	};

	$.browserTest(navigator.userAgent);
})(jQuery);

(function(a){
/*
       * aw.DWT [Drawing-Tool]
       * @author Sino Boeckmann <sino.boeckmann@aufwind.cc>
       * @copyright 2013-2015 Werbeagentur aufwind. GmbH
       */
a.fn.dwt=function(aM){if(this.length<=0){return a.error('Element "'+this["selector"]+'" does not exists in your DOM!')}var az=Math.PI;var C="undefined";var z="function";var aS="string";var r="object";var l=1;var am=2;var aG=0;var aV=3;var I="top";var aw="bottom";var af="#f00";var T="black";var aJ="#000";var a2="#fff";var aU="transparent";var aI="chrome";var ak="firefox";var aW="safari";var au="webkitMovement";var w="mozMovement";var e="crosshair";var G="pointer";var a0="overlayContainer";var k="dwt";var h="canvas";var p="radialGradiant";var x="shadow-container";var i=null;var aQ=null;var v=null;var F=null;var an=null;var aF=null;var aY=null;var ay=a.browser;var a1=null;var J=null;var Z=new Object;var j={top:0,left:0,getTop:function(){return this["top"]},getLeft:function(){return this["left"]}};var V=null;var ba=0;var aN=0;var g=0;var aC=0;var at=true;var o=false;var ah=true;var m=false;var ai=0;var aT=false;var aL=1;var aH={width:0,height:0,scale:1,scaleMin:0.25,scaleMax:5,scrollSpeed:1,strokeColor:aJ,fontFamily:"Helvetica Neue, Arial, Verdana, sans-serif, sans",debug:false,debugLevel:0,rounding:0,lineWidth:1,delayBetweenTwoClicks:250,importFromJson:"{}",gridBlockWidth:20,gridBlockWidthMin:10,gridBlockWidthMax:200,maximizeZoomPadding:100,angleSnapTolerance:1.5,allowAngleSnap:false,gridSnapTolerance:0.05,allowGridSnap:true,conversionValue:10,translateDrawing:false,showGrid:true,showLegend:false,useLabel:true,showLabel:false,allowDragableLabel:false,useAlphabeticLabel:false,labelMinLengthVisible:5,useLabelScaleAutoScaling:false,labelScaleFactorManual:1,labelScaleFactorManualMinIncrease:0.1,labelScaleFactorManualMinDecrease:0.1,labelScaleFactor:1.5,labelScaleMax:0.75,labelScaleMin:1.5,useAngleIndicator:true,showAngleIndicator:false,useAngleIndicatorAutoScaling:false,angleIndicatorScaleFactorManual:1,angleIndicatorScaleFactorManualMinIncrease:0.1,angleIndicatorScaleFactorManualMinDecrease:0.1,angleIndicatorScaleFactor:0.75,angleIndicatorScaleMax:1.15,angleIndicatorScaleMin:1.5,angleIndicatorMinRadius:7,angleIndicatorMaxRadius:13,visibleSide:I,allowPlausibilityCheck:true,allowLineIntersectionCheck:true,lineIntersectionCheckTollerance:10,allowLabelCollisionTest:false,allowZooming:false,allowScrolling:false,allowDrawing:false,allowEnvelopes:false,envelopeSizeBig:10,envelopeSizeSmall:3,envelopeRadiiBig:15,envelopeRadiiSmall:5,unitOfMeasurement:"mm",showUnitOfMeasurement:false,useVisibleSideArrow:true,showVisibleSideArrow:false,visibleSideArrowImageSource:"images/arrow.png",showVisibleSideArrowAtPoint:1,restrictions:{cut:0,volume:0},useRouteDistinction:true,routeDistinctionColor:"#00a495",routeDistinctionLineWidth:1,spinnerJsConfig:{color:"#000",lines:11,length:0,width:4,radius:10,corners:0,rotate:0,trail:100,speed:1,direction:1,top:"25px",left:"25px"},I18n:{de_DE:{Error_Restriction_Volume:"Fehler: Das berechnete Volumen ist zu gro!",Error_Restriction_Cut:"Fehler: Die Lnge berschreitet das Maxium (%s %s)",Legend_Total_Volume:"Gesamt-Volumen: %s Liter\n",Legend_Total_Length:"Gesamt-Lnge: %s %s\n",Legend_Conversion:"Umrechung: 1px ~ %s %s\n",Legend_Grid:"Raster: %s x %s %s",Options_Title:"Optionen",Options_Angle_Snap:"Winkel einrasten lassen",Options_Grid_Snap:"Strecke am Raster einrasten lassen",Options_Grid_Size:"Rastergre",Options_Vector_Translation:"Mastabsgetreue Zeichnung ausschalten",Help_Title:"Hilfe",Help_Event_New_Vector_Point:"Zeichen/ Punkt setzen",Help_Event_Move_Workspace:"Arbeitsflche verschieben",Help_Event_Cancel_Drawing:"Aktuellen Zeichenvorgang abbrechen",Help_Event_Undo:"Zeichenvorgang abbrechen; Letzten Schritt rckgngig",Help_Event_Zoom:"Zoom-Stufe umstellen",Help_Event_Enable_Disable_Grid:"Grid ein-/ausschalten",Help_Event_Reset_Scale:"Skalierungsfaktor zurcksetzen",Help_Event_Show_Options:"Optionen einblenden. u.A. Snap ein-/ ausschalten",Help_Event_Clear_Workspace_New_Vector:"Arbeitsflche leeren/ Neues Projekt starten",Help_Event_Show_Help:"Zeigt diese Hilfe an",Confirm_Start_New_Drawing:"Wollen Sie wirklich eine neue Zeichnung starten? Die aktuelle wird dabei unwiderruflich gelscht.",Error_Line_Intersection_Detected:"Fehler: Die Linien drfen sich nicht schneiden!",Error_Line_Too_Short:"Fehler: Ihre Linie (%s %s) ist zu kurz. Diese muss mindestens %s %s lang sein!",Error_Line_C_Shorter_B:"Fehler: Linie %s %s muss grer sein als Linie %s %s!",Okay:"OK",Close:"Schlieen"}},get:function(L){if(this.hasOwnProperty(L)){return this[L]}else{if(this.get("debug")===true&&this.get("debugLevel")>2){console.warn('Konfigurationseintrag "'+L+'" wurde nicht gefunden!')}}return null},set:function(bb,L){if(this.hasOwnProperty(bb)){return this[bb]=L}return null}};var N=function(L,bb){return(Z||new Object)[L]=bb};var y=function(L){return delete (Z||new Object)[L]};var H=function(){var bc=0;var L=(L||new Object);for(var bb in L){if(L.hasOwnProperty(bb)){bc++}}return(bc<=0?false:true)};var u=function(){return Z=new Object};var f=function(){var bd="";var bc=0;var L=0;for(var bb in Z){if(Z.hasOwnProperty(bb)){bc++}}for(var bb in Z){L++;bd+=(Z[bb]+(L<bc?"\n":""))}return bd};var ap=function(bf){var L=aH.get("I18n");if(typeof(L)===C){if(aH.get("debug")&&aH.get("debugLevel")>=0){console.warn("No translation entry in config object found!")}return bf.toString().toUpperCase()}var be=(L[aH.get("language")]||new Object)[bf];if(typeof(be)===C){if(aH.get("debug")&&aH.get("debugLevel")>=0){console.warn('No translation entry found for key "'+bf+'"')}return bf.toString().toUpperCase()}var bb=new Array(),bd=0;for(var bc in arguments){bd++;if(bd<=1){continue}bb.push(arguments[bc])}return vsprintf(be.toString(),bb)};var aX=function(){i.clear();i.removeChildren();if(aH.get("showLegend")===true){v=U();i.add(v)}if(aH.get("showGrid")===true){aQ=W();i.add(aQ);aQ.position({x:a1.getX()*ba,y:a1.getY()*ba});aQ.scale({x:ba,y:ba});aQ.drawScene()}t(true);an=q();i.add(an);return i};var U=function(){var be=((aH.get("gridBlockWidth"))/aH.get("conversionValue"));var bg=new Kinetic.Layer();var L=new Kinetic.Rect({x:10,y:0,width:100,height:50,strokeWidth:0.5,stroke:"rgba(0,0,0,0.1)",fill:"rgba(0,0,0,0.075)"});var bb=parseFloat((g*1)).toFixed(aH.get("rounding")).toLocaleString();var bf=parseFloat((aN/aH.get("conversionValue"))*1).toFixed(aH.get("rounding"));var bc=parseFloat((aH.get("conversionValue")/ba)*1).toFixed(aH.get("rounding"));var bd=new Kinetic.Text({x:20,y:0,text:(function(){var bh=[ap("Legend_Total_Volume",bb),ap("Legend_Total_Length",bf,(aH.get("showUnitOfMeasurement")===true?aH.get("unitOfMeasurement"):"")),"\n",ap("Legend_Conversion",bc,(aH.get("showUnitOfMeasurement")===true?aH.get("unitOfMeasurement"):"")),ap("Legend_Grid",be,be,(aH.get("showUnitOfMeasurement")===true?aH.get("unitOfMeasurement"):""))];return bh.join("")})(),lineHeight:1.5,fontSize:12,fontFamily:aH.get("fontFamily"),fill:aJ});bd.setY(i.getHeight()-bd.getHeight()-10);L.setWidth(bd.getWidth()+20);L.setHeight(bd.getHeight()+15);L.setY(i.getHeight()-bd.getHeight()-20);bg.add(L);bg.add(bd);bg.on("mouseenter",function(){var bh=i.getHeight()-L.getHeight();var bi=(i.getHeight()/2<L.getY());L.move({x:0,y:(bi?-(bh-15):(bh-15))});bd.move({x:0,y:(bi?-(bh-10):(bh-10))});this.draw()});return bg};var q=function(){var bc=new Kinetic.Layer({opacity:m===true?1:0});var L=new Kinetic.Rect({x:0,y:0,width:i.getWidth(),height:50,fill:"rgba(158,0,0,0.9)"});var bb=new Kinetic.Text({x:10,y:10,text:f(),lineHeight:1.5,fontSize:13,fontFamily:aH.get("fontFamily"),fill:"#fff"});L.setHeight(bb.getHeight()+15);bc.add(L);bc.add(bb);bc.getObjectRect=function(){return this.getChildren()[0]};bc.getObjectText=function(){return this.getChildren()[1]};return bc};var W=function(){var bb=aH.get("gridBlockWidth");var bi=i.getWidth()/ba;var bf=i.getHeight()/ba;var bd=a1.getX();var bc=a1.getY();var be=new Kinetic.Layer();for(var bh=Math.round(-bd/bb);bh<=Math.floor((-bd+bi)/bb);bh++){var L=new Kinetic.Line({points:[bh*bb,-bf,bh*bb,-bc+bf],stroke:"rgba(0,0,0,0.1)",strokeWidth:1});be.add(L)}for(var bg=Math.ceil(-bc/bb);bg<=Math.floor((-bc+bf)/bb);bg++){var L=new Kinetic.Line({points:[-bi,bg*bb,-bd+bi,bg*bb],stroke:"rgba(0,0,0,0.1)",strokeWidth:1});be.add(L)}return be};var K=function(bb){if(bb.which===aV){J.setX(bb.offsetX);J.setY(bb.offsetY);if(o){ax()}return false}else{if(bb.timeStamp-ai<aH.get("delayBetweenTwoClicks")||at===false){return false}ai=bb.timeStamp;if(aF!==null){aZ()}o=true;if(aF===null){var bc=ad("x",bb);var L=ad("y",bb);aF=Y(bc,L);aK(aF)}return true}};var P=function(L){a(i.getContainer()).css("cursor",e)};var D=function(bb){if(!o){return}var bd=aF.getPointAt(aC);if(bd===null){return}var bc=ad("x",bb);var be=ad("y",bb);bd.setX2(bc);bd.setY2(be);var L=aO(bd);var bg=parseInt(Math.abs(bd.getRelativeAngle()));debugger;if(aH.get("allowEnvelopes")===true&&aC>aG&&bg<=aH.get("envelopeRadiiBig")){if(bd.getSemiCircle()===null){bd.createSemiCircle({lineWeight:aH.get("lineWidth"),listener:{update:aD}});bd.setUseSemiCircle(true)}}else{if(bd.getSemiCircle()!==null){bd.removeSemiCircle()}}if(bd.getUseSemiCircle()){var bf=aF.getPointAt(bd.getStep()-1);if(bf instanceof Kinetic.Point!==false){bd.setAngle(bf.getAngle()+180)}}else{bd.setAngle(parseInt(L.angle))}bd.setLength(parseInt(L.length));bd.setTranslatedLength(parseInt(L.length));bd.setRelativeAngle(parseInt(a4(L.angleDiff)));aF.updatePoint(aC,bd);if(aH.get("useRouteDistinction")===true){ab(bd)}t()};var ae=function(bc){if(!aH.get("allowScrolling")){return false}var bh=aH.get("width")/ba;var be=aH.get("height")/ba;var bd="";if(ay.getName()===aW){var bg=J.getX()-bc.offsetX;var bf=J.getY()-bc.offsetY;J.setX(bc.offsetX);J.setY(bc.offsetY)}else{switch(ay.getName()){case aI:bd=au;break;case ak:bd=w;break}var bg=bc.originalEvent[bd+"X"];var bf=bc.originalEvent[bd+"Y"]}var bb=a1.getX()+(bg*aH.get("scrollSpeed")/ba);var L=a1.getY()+(bf*aH.get("scrollSpeed")/ba);if(bb>bh){bb=bh}if(L>be){L=be}a1.setX(bb);a1.setY(L);aX();return true};var Y=function(bb,L){var bc=new Kinetic.Vector({lineWidth:aH.get("lineWidth"),stroke:aH.get("strokeColor"),strokeWidth:aH.get("lineWidth")-1,translated:aH.get("translateDrawing"),initX:bb,initY:L,points:[n(bb,L)],listening:true});return bc};var n=function(bd,bb,L,bf){var bc={layer:F,visibleSideArrowSource:aH.get("visibleSideArrowImageSource"),lineWidth:aH.get("lineWidth"),useLabel:aH.get("useLabel"),useAngleIndicator:aH.get("useAngleIndicator"),labelConfig:{draggable:aH.get("allowDragableLabel"),offset:-5,textConfig:{fontFamily:aH.get("fontFamily"),padding:5},tagConfig:{shadowColor:"#000",shadowBlur:5,shadowOffset:[1,1],shadowOpacity:0.4,pointerDirection:"up",pointerWidth:10,pointerHeight:5},jointLabel:{circleEnd:{listener:{update:function(){if(aH.get("allowDragableLabel")===false){return false}var bh=this.getRefPoint();var bg=bh.getRefPoint();if(this.getParent() instanceof Kinetic.Layer!==false){this.setZIndex(1)}if(ba!==aH.get("scale")){this.setScale(aH.get("scale")/bc)}this.setX(bg.getX());this.setY(bg.getY()-5)}}},listener:{update:function(){if(aH.get("allowDragableLabel")===false){return false}var bg=this.getRefPoint();if(this.getParent() instanceof Kinetic.Layer!==false){this.setZIndex(1)}if(ba!==aH.get("scale")){this.setScale(aH.get("scale")/bc)}this.getPoints()[2]=bg.getX();this.getPoints()[3]=bg.getY()-5}}},listener:{update:aE,click:ag,mouseover:function(){if(!o&&this.getVisible()===true){a(i.getContainer()).css("cursor",G);var bh=this.getText();var bg=this.getTag();if(bh.getFill()!==af){bh.setFill(T);bg.setShadowOpacity(0.8)}t()}},mouseout:function(){if(!o&&this.getVisible()===true){a(i.getContainer()).css("cursor",e);var bh=this.getText();var bg=this.getTag();if(bh.getFill()!==af){bh.setFill(aJ);bg.setShadowOpacity(0.4)}t()}}}},angleIndicatorConfig:{stroke:T,labelConfig:{text:{fontFamily:aH.get("fontFamily"),fontSize:10,fill:T}},lineConfig:{stroke:T},listener:{update:aB,click:a9,mouseover:function(){if(!o&&this.getLabel().getVisible()===true){a(i.getContainer()).css("cursor",G);if(this instanceof Kinetic.Text===false){this.setStrokeWidth(aH.get("lineWidth")+1)}this.getLabel().getText().setFontStyle("bold");this.getLabel().getLine().setStrokeWidth(aH.get("lineWidth")+1);t()}},mouseout:function(){if(!o&&this.getLabel().getVisible()===true){a(i.getContainer()).css("cursor",e);if(this instanceof Kinetic.Text===false){this.setStrokeWidth(aH.get("lineWidth"))}this.getLabel().getText().setFontStyle("normal");this.getLabel().getLine().setStrokeWidth(aH.get("lineWidth"));t()}}}},useVisibleSideArrow:aH.get("useVisibleSideArrow"),visibleSideArrowConfig:{visible:aH.get("showVisibleSideArrow"),listener:{update:ao,click:aq,mouseover:function(){if(!o&&this.getVisible()===true){a(i.getContainer()).css("cursor",G)}},mouseout:function(){if(!o&&this.getVisible()===true){a(i.getContainer()).css("cursor",e)}}}}};if(typeof(L)!==C){a.extend(true,bc,L);bc.layer=F;bc.visibleSideArrowSource=aH.get("visibleSideArrowImageSource")}var be=new Kinetic.Point(bc);if((bf||false)===false){if((bd||0)>0||(bb||0)>0){be.setX1(bd);be.setY1(bb);be.setX2(bd);be.setY2(bb);be.setX3(bd);be.setY3(bb)}be.setStep(aC)}return be};var Q=function(){if(aF===null||aH.get("allowPlausibilityCheck")===false){return}var bc=parseFloat((bc*1)).toFixed(aH.get("rounding")).toLocaleString();var L=parseFloat((aN/aH.get("conversionValue"))*1).toFixed(aH.get("rounding"));if(bc>=aH.get("restrictions")["volume"]){m=true;N("Error_Restriction_Volume",ap("Error_Restriction_Volume"))}else{m=false;y("Error_Restriction_Volume")}if(L>=aH.get("restrictions")["length"]){m=true;N("Error_Restriction_Cut",ap("Error_Restriction_Cut",aH.get("restrictions")["length"],(aH.get("showUnitOfMeasurement")===true?aH.get("unitOfMeasurement"):"")))}else{m=false;y("Error_Restriction_Cut")}if(aH.get("allowLineIntersectionCheck")===true){m=c();if(m===true){N("Error_Line_Intersection_Detected",ap("Error_Line_Intersection_Detected"))}else{y("Error_Line_Intersection_Detected")}}if(m===false&&!H()){u()}if(an!==null){if(H()||m===true){an.setOpacity(1);var bd=an.getObjectRect();var bb=an.getObjectText();bb.setText(f());bd.setHeight(bb.getHeight()+15)}else{an.setOpacity(0)}an.draw()}aF.setStroke(m===true?af:((aH.get("strokeColor")||"").length>0?aH.get("strokeColor"):aJ))};var aK=function(L){try{if(F===null){F=new Kinetic.Layer({listening:true});i.add(F)}if(F.getChildren().length<=0){F.add(L)}L.setLayer(F);return true}catch(bb){if(aH.get("debug")&&aH.get("debugLevel")>=4){console.warn(bb)}return false}};var aZ=function(){if(aF===null){return false}a6();if(o){aC++}aF.addPointAt(aC,n());var bb=aF.getPointAt(aC-1);if(bb!==null&&typeof(bb)!==C){var L=aF.getPointAt(aC);L.setX1(bb.getX2());L.setY1(bb.getY2());L.setX3(bb.getX1());L.setY3(bb.getY1());if(bb.getRelativeAngle()!==bb.getRelativeAngleCorrected()){bb.setWasRelativeAngleCorrected(true);bb.setRelativeAngle(bb.getRelativeAngleCorrected())}aF.updatePoint(aC,L);if(o){aN+=bb.getTranslatedLength()}aX()}return true};var ax=function(){try{if(aF===null){return false}if(aH.get("useRouteDistinction")===true&&aY!==null&&o===true){ab(false)}if(!o){aC-=1;aN-=aF.getPointAt(aC).getTranslatedLength()}aF.removePointAt(aC);i.fire("Automatic:LabelUpdate",{index:aC,vectorPoints:av(aC)});a6();Q();o=false;if(aC<=aG){aC=aG;F.removeChildren();aF=null;aY=null;aa();if(aH.get("debug")&&aH.get("debugLevel")>=1){console.debug("Vector deleted!")}}aX()}catch(L){if(aH.get("debug")&&aH.get("debugLevel")>=4){console.warn(L)}}return false};var ab=function(L){var bc=null;if(L===null){return null}if(L===false&&aY!==null){aY.setPoints(new Array);return aY}if(L.getStep()!==aG){bc=aF.getPointAt(L.getStep()-1)}if(aY===null){aY=new Kinetic.ExtendedLine({points:[L.getX1(),L.getY1(),L.getX2(),L.getY2()],fill:aH.get("routeDistinctionColor"),stroke:aH.get("routeDistinctionColor"),strokeWidth:aH.get("routeDistinctionLineWidth")})}else{var be=0;var bd=0;if(bc!==null){be=bc.getX();bd=bc.getY()}else{be=L.getX1();bd=L.getY1()}if(L.getSemiCircleAdded()===true){var bb=L.getSemiCircle();if(bb!==null){be=bb.getMoveX();bd=bb.getMoveY()}}aY.setPoints([be,bd,L.getX(),L.getY()])}return aY};var ad=function(L,bb){var bd=bb.offsetX;var bc=bb.offsetY;if(ay.getName()===ak){bd=bb.originalEvent["layerX"];bc=bb.originalEvent["layerY"]}switch(L){case"x":return(bd-j.getLeft())/ba-a1.getX();case"y":return(bc-j.getTop())/ba-a1.getY()}};var S=function(bb){var bc=new Array("ne","e","se","s","sw","w","nw","n");var L=bb.getAngle()-22.5;if(L<0){L+=360}L=parseInt(L/45);return bc[L]};var aO=function(bk){var bd=bk.getX1();var bj=bk.getY1();var bb=bk.getX2();var bi=bk.getY2();var L=bk.getX3();var bh=bk.getY3();if(aH.get("debug")===true&&aH.get("debugLevel")>=5){console.debug("--- [Vector.Point ["+aC+"]] ---");console.debug("x1: "+bd+" / y1: "+bj);console.debug("x2: "+bb+" / y2: "+bi);console.debug("x3: "+L+" / y3: "+bh);console.debug("--- [End] ---")}var be=Math.atan2(bb-bd,bj-bi);var bf=be-(Math.atan2(bd-L,bh-bj));be=s(be);bf=s(bf);var bl=be*180/az;var bc=bf*180/az;bc=(bc<0?(bc+180):(bc-180));var bg=Math.sqrt(Math.pow((bd-bb),2)+Math.pow((bj-bi),2));if(aH.get("allowAngleSnap")===true){bl=a4(bl)}if(aH.get("allowGridSnap")===true){bg=aj(bg,bl)}return{radian:be,radianDiff:bf,angle:bl,angleDiff:bc,length:bg}};var a6=function(bj){if(aF===null){return new Object}var L=aF.getPoints();var bg=null;var bc=null;var be=null;var bb=null;for(var bd=0,bk=L.length;bd<bk;bd++){var bh=aF.getPointAt(bd);if(bh instanceof Kinetic.Point!==true){continue}if(bg===null&&bc===null){bg=bh.getX1();bc=bh.getX2()}if(be===null&&bb===null){be=bh.getY1();bb=bh.getY2()}if(bh.getX1()<bg){bg=bh.getX1()}if(bh.getX2()<bg){bg=bh.getX2()}if(bh.getX1()>bc){bc=bh.getX1()}if(bh.getX2()>bc){bc=bh.getX2()}if(bh.getY1()<be){be=bh.getY1()}if(bh.getY2()<be){be=bh.getY2()}if(bh.getY1()>bb){bb=bh.getY1()}if(bh.getY2()>bb){bb=bh.getY2()}}var bl=Math.sqrt(Math.pow((bg-bc),2))/aH.get("conversionValue");var bf=Math.sqrt(Math.pow((be-bb),2))/aH.get("conversionValue");var bi=bj||0;g=(function(){var bn=((bl<100?100:bl)/1000);var bm=((bf<100?100:bf)/1000);var bo=((bi<100?100:bi)/1000);return parseFloat(bn*bm*bo)*1000})();return{width:parseFloat(bl),height:parseFloat(bf),length:parseFloat(bi),volume:g,coordinates:{min:{x:bg,y:be,getX:function(){return this["x"]},getY:function(){return this["y"]}},max:{x:bc,y:bb,getX:function(){return this["x"]},getY:function(){return this["y"]}},getMin:function(){return this["min"]},getMax:function(){return this["max"]}}}};var s=function(L){if(L<-az){L+=2*az}else{if(L>az){L-=2*az}}return L};var a4=function(L){if(aH.get("allowAngleSnap")!==true){return L}var bb=Math.round(L/45)*45;if(L>=(bb-aH.get("angleSnapTolerance"))&&L<=(bb+aH.get("angleSnapTolerance"))){L=bb}return L};var aj=function(bh,L){var be=aH.get("gridBlockWidth")/ba;var bd=Math.tan(Math.abs(L)*az/180);if(bd>=0.99998&&bd<=1.00001){be=Math.sqrt(Math.pow(be,2)*2)}var bc=((bh/ba)/be);var bf=Math.round(bc);var bg=Math.abs(bc-bf);if(bg<=aH.get("gridSnapTolerance")){bc=bf}var bb=(bc*ba)*be;return bb};var t=function(bb){if(aF!==null){var L=aF.getPointAt(aC);if(L instanceof Kinetic.Point===true&&L.getLength()>aH.get("lineIntersectionCheckTollerance")){Q()}}if(F!==null){if(bb===true){i.add(F)}if(F.getChildren().length<=0&&aF!==null){F.add(aF)}if(aH.get("useRouteDistinction")===true){if(aY instanceof Kinetic.ExtendedLine===true&&aY.getAdded()===false){F.add(aY);aY.setAdded(true)}}F.position({x:a1.getX()*ba,y:a1.getY()*ba});F.scale({x:ba,y:ba});F.draw()}};var X=function(){var L=ba;L+=0.1;return aR(L)};var ac=function(){var L=ba;L-=0.1;return aR(L)};var aP=function(bb,be){if(o||!aH.get("allowZooming")){return}var L=(be>0?l:am);var bd=be/10;var bc=ba;bc+=(L===l?(bd/bc):(bd*bc));return aR(bc)};var aR=function(bc){bc=Math.max(aH.get("scaleMin"),Math.min((bc||0),aH.get("scaleMax")));var bb=a1.getX();var L=a1.getY();bb+=(0.5*i.getWidth()*(1/bc-1/ba));L+=(0.5*i.getHeight()*(1/bc-1/ba));a1.setX(bb);a1.setY(L);ba=bc;aX();return ba};var M=function(){return aR(aH.get("scale"))};var d=function(){var L=confirm(ap("Confirm_Start_New_Drawing"));if(L===true){aa();aC=aG;if(aF!==null){aF.removeAllPoints()}aF=null;aY=null;F=null;aX();M()}return L};var aa=function(){aN=0;g=0};var ag=function(){if(this.getVisible()===false){return}var bg=a(i.getContainer());var bf=bg.attr("id");var bd=aH.get("translateDrawing");var bc=0;bg.off("mousedown");bg.spin(aH.get("spinnerJsConfig"));var bb=this.getRefPoint();if(bd===true){bc=bb.getLength()}else{bc=bb.getTranslatedLength()}var L=bb.getLabel().position();V.html((function(){var bh=['<div class="'+x+'" style="width: 175px; top: '+L.y+"px; left: "+L.x+'px">','<input class="'+bf+" input value-"+bb.getStep()+'" type="text" value="'+parseFloat(bc/aH.get("conversionValue")).toFixed(aH.get("rounding"))+'" size="8" />',"&nbsp;"+aH.get("unitOfMeasurement"),'<button class="'+bf+' button" data-step="'+bb.getStep()+'">'+ap("Okay")+"</button>","</div>"];return bh.join("")})());var be=function(){var bh=a("."+bf+".button").attr("data-step");var bi=a("."+bf+".input.value-"+bh).val();E(bh,(bi*aH.get("conversionValue")),function(){V.hide(50,function(){bg.on("mousedown",K)})})};a("."+bf+".button").on("click",be);a("."+bf+".input.value-"+bb.getStep()).bind("keydown","return",be);V.addClass(p);V.show(50,function(){bg.spin(false);a("."+bf+".input.value-"+bb.getStep()).select()})};var aE=function(bj){if(this.getDragged()!==false&&aH.get("useAlphabeticLabel")===false){this.getText().text((function(){var bk=[(bj.getAngle()>=0?" ":" "),a7(parseFloat(bj.getTranslatedLength()/aH.get("conversionValue")).toFixed(aH.get("rounding")).toString()),(aH.get("showUnitOfMeasurement")===true?(" "+aH.get("unitOfMeasurement")):"")];return bk.join("")})());return}if(ba!==aH.get("scale")){var bh=aH.get("labelScaleFactorManual");if(aH.get("useLabelScaleAutoScaling")===true){bh=ba*aH.get("labelScaleFactor");if(bh>aH.get("labelScaleMax")){if(aH.get("labelScaleMax")>aH.get("labelScaleFactor")){bh=aH.get("labelScaleFactor")/aH.get("labelScaleMax")*aH.get("labelScaleMin")}else{bh=aH.get("labelScaleMax")}}}this.scale({x:bh,y:bh})}var bi=0;var bf=0;var L=(bj.getAngle()*(az/180))-(az/2);var be=bj.getLength();var bd=this.height()/5;var bb=0;if(bj.getAngle()>=0){bb=0.5*(be+this.width())-(this.width()/2);bi=(bj.getX()-bb*Math.cos(L)-(bd*-1)*Math.sin(L));bf=(bj.getY()-bb*Math.sin(L)+(bd*-1)*Math.cos(L))}else{bb=0.5*(be-this.getWidth())+(this.getWidth()/2);bi=(bj.getX()-bb*Math.cos(L)+bd*Math.sin(L));bf=(bj.getY()-bb*Math.sin(L)-bd*Math.cos(L))}this.x(parseInt(bi));this.y(parseInt(bf));if(bj.getUseSemiCircle()===true){this.rotation(((bj.getAngle()>0&&bj.getAngle()<180)?bj.getAngle()-90:bj.getAngle()+90))}else{this.rotation((bj.getAngle()>0?bj.getAngle()-270:bj.getAngle()+90))}var bc=this.getText();bc.text((function(){var bk=[(bj.getAngle()>=0?" ":" "),(function(){if(aH.get("useAlphabeticLabel")===true){return b(bj)}else{return[a7(parseFloat(bj.getTranslatedLength()/aH.get("conversionValue")).toFixed(aH.get("rounding")).toString()),(aH.get("showUnitOfMeasurement")===true?(" "+aH.get("unitOfMeasurement")):"")].join("")}})()];return bk.join("")})());if(this.rotation()===(bj.getAngle()-270)){bc.setRotation(180);bc.offsetX(bc.width());bc.offsetY(bc.height())}else{bc.setRotation(0);bc.offsetX(0);bc.offsetY(0)}if(aH.get("allowLabelCollisionTest")===true){var bg=B(this);if(bg!==false){this.rotation(this.rotation()+180);bc.rotation(180);bc.offsetX(bc.width());bc.offsetY(bc.height())}}if(aH.get("showLabel")===false||bj.getLength()<aH.get("labelMinLengthVisible")){this.visible(false)}else{if(this.getVisible()===false){this.visible(true)}}};var E=function(bb,bd,be){var bh=aF.getPointAt(bb);var bc=aH.get("translateDrawing");if(bc===true){bh.setLength(bd);bh.setTranslatedLength(bd);aF.updatePoint(bb,bh);var L=aF.getPoints();for(var bg=bb,bf=L.length;bg<bf;bg++){var bi=L[bg];if(bi instanceof Kinetic.Point!==true){continue}bi.setRecalc(true);aF.updatePoint(bg,bi)}}else{bh.setTranslatedLength(bd);aF.updatePoint(bb,bh)}aN=0;var L=aF.getPoints();for(var bg=0;bg<L.length;bg++){var bi=L[bg];if(bi instanceof Kinetic.Point!==true){continue}aN+=bi.getTranslatedLength()}t();if(typeof(be)===z){be(bb,bd,bh)}i.fire("Automatic:LabelUpdate",{index:parseInt(bb),vectorPoints:av(bb)})};var B=function(be){var bf=aF.getPoints();for(var bc in bf){var bd=bf[bc];if(bd instanceof Kinetic.Point===false||typeof(bd)===C){continue}var bb=bd.getLabel();if(bb.getId()===be.getId()){continue}var L=A(be,bb);if(L===true){return bb}}return false};var aB=function(bn){if(bn.getStep()<=aG){return}var bg=0;var bh=!(bn.getUseSemiCircle()===true&&bn.getSemiCircle()!==null);this.setVisible(bh);if(aH.get("showAngleIndicator")===false){bh=false}var bm=this.getLabel();var bb=bm.getCircleTag();if(ba!==aH.get("scale")){var bl=aH.get("angleIndicatorScaleFactorManual");if(aH.get("useAngleIndicatorAutoScaling")===true){bl=ba*aH.get("angleIndicatorScaleFactor");if(bl>aH.get("angleIndicatorScaleMax")){if(aH.get("angleIndicatorScaleMax")>aH.get("angleIndicatorScaleFactor")){bl=aH.get("angleIndicatorScaleFactor")/aH.get("angleIndicatorScaleMax")*aH.get("angleIndicatorScaleMin")}else{bl=aH.get("angleIndicatorScaleMax")}}}bm.scale({x:bl,y:bl});bb.scale(bm.scale())}var bi=aF.getPointAt(bn.getStep()-1);var bo=aO(bi);var bp=aH.get("angleIndicatorMinRadius");var bk=aH.get("angleIndicatorMaxRadius");this.radius(parseInt(Math.max(bp,Math.min(bn.getLength()/az,bk))));this.x(bi.getX());this.y(bi.getY());if(bi.getUseSemiCircle()===true&&bi.getSemiCircle()!==null&&bn.getWasRelativeAngleCorrected()===false){var be=bi.getSemiCircle().getRadius();bg=Math.atan((be*2)/bi.getTranslatedLength())*180/az;bn.setRelativeAngleCorrectionValue(parseInt(bg))}var bj=bn.getRelativeAngle();if(bj<0){bj=bj+bg}else{bj=bj-bg}bn.setRelativeAngleCorrected(bj);this.angle(parseInt(a4(Math.abs(bj))));if(bj>=0&&bj<=180){this.rotation(parseInt(bo.angle-270-(parseInt(bn.getRelativeAngleCorrectionValue())/2)))}else{this.rotation(parseInt(360+bo.angle+bj+90-parseInt(bn.getRelativeAngleCorrectionValue())))}bm.getText().text(a7(parseFloat(Math.abs(this.angle())).toFixed(aH.get("rounding")).toString())+"");var L=bn.getAngle();if(L<=bi.getAngle()){L+=360}var bf=(0.5*(bi.getAngle()+L)+360)%360;var bd=this.x()-35*Math.cos(bf*az/180);var bc=this.y()-35*Math.sin(bf*az/180);bm.x(parseInt((bd-10)-0.2*bm.width()));bm.y(parseInt((bc-10)-0.2*bm.height()));bb.x(parseInt(bm.width()/2));bb.y(parseInt(bm.height()/2));bb.fill(T);bm.getLine().points([parseInt(this.x()-5*Math.cos(bf*az/180)),parseInt(this.y()-5*Math.sin(bf*az/180)),parseInt(this.x()-35*Math.cos(bf*az/180)),parseInt(this.y()-35*Math.sin(bf*az/180))]);bm.getText().fill(a2);bm.getLine().stroke(T);bm.getText().visible(bh);bm.getLine().visible(bh);bm.visible(bh);bb.visible(bh)};var ar=function(bb,bf,bi){var bj=aF.getPointAt(bb);var bd=parseFloat(bf);var be=0;if(bj.getRelativeAngle()<0&&(bd>bj.getRelativeAngle()&&bd<(Math.abs(bj.getRelativeAngle())-1))){be=(Math.abs(bj.getRelativeAngle())+bd)*-1}else{be=Math.abs(bj.getRelativeAngle()-bd)}var bc=bj.getRelativeAngle();bj.setRelativeAngle(a4(bd));var L=aF.getPoints();for(var bh=0;bh<L.length;bh++){var bg=L[bh];if(bg instanceof Kinetic.Point!==true){continue}if(bh>=bb){if(Math.abs(bc)<=bj.getRelativeAngle()){bg.setAngle(bg.getAngle()+be)}else{bg.setAngle(bg.getAngle()-be)}}bg.setRecalc(true);aF.updatePoint(bh,bg)}t();if(typeof(bi)===z){bi(bb,bf,bj)}i.fire("Automatic:AngleUpdate",{index:aC,vectorPoints:av(bb)})};var a9=function(bd){if(this.getVisible()===false||this.getLabel().getVisible()===false){return}var bf=a(i.getContainer());var be=bf.attr("id");bf.off("mousedown");bf.spin(aH.get("spinnerJsConfig"));var bc=this.getRefPoint();var bb=bc.getAngleIndicator().getLabel().position();V.html((function(){var bg=parseFloat(bc.getRelativeAngle()*1).toFixed(aH.get("rounding"));var bh=['<div class="'+x+'" style="width: 175px; top: '+bb.y+"px; left: "+bb.x+'px">','<input class="'+be+" input value-"+bc.getStep()+'" type="number" min="0" max="180" step="1" data-negative-value="'+(bg<0?"yes":"no")+'" value="'+Math.abs(bg)+'" style="width:100px;" />',"&nbsp;&deg;",'<button class="'+be+' button" data-step="'+bc.getStep()+'">'+ap("Okay")+"</button>","</div>"];return bh.join("")})());var L=function(){var bg=parseInt(a("."+be+".button").attr("data-step"));var bh=a("."+be+".input.value-"+bg).val();if(a("."+be+".input.value-"+bg).attr("data-negative-value")==="yes"){bh*=-1}ar(bg,bh,function(){V.hide(50,function(){bf.on("mousedown",K)})})};a("."+be+".button").on("click",L);a("."+be+".input.value-"+bc.getStep()).bind("keydown","return",L);a("."+be+".input.value-"+bc.getStep()).on("keyup",function(){var bg=a(this).val();if(bg>180){return a(this).val(180)}});V.addClass(p);V.show(50,function(){bf.spin(false);a("."+be+".input.value-"+bc.getStep()).select()})};var ao=function(){var bf=this.getRefPoint();var bd=aO(bf);this.setVisible(false);if(ba!==aH.get("scale")){this.setScale(aH.get("scale")/aM)}var bc=(bf.getAngle()*(az/180))-(az/2);var bg=bf.getLength();var L=0;if(aH.get("visibleSide")===I){L=(bg+this.getWidth())/1.5}else{L=(bg-this.getWidth())/1.5}var be=bf.getX()-(L*Math.cos(bc));var bb=bf.getY()-(L*Math.sin(bc));this.rotation((function(){if(aH.get("visibleSide")===I){return Kinetic.Util._radToDeg(1.5*az-bd.radian*-1)}else{return Kinetic.Util._radToDeg(0.5*az-bd.radian*-1)}})());this.setX(be);this.setY(bb);if(bf.getStep()===(aH.get("showVisibleSideArrowAtPoint")-1)){this.setVisible(aH.get("showVisibleSideArrow"))}};var aq=function(){if(this.getVisible()===false){return}aH.set("visibleSide",(aH.get("visibleSide")===I?aw:I));aF.setVisibleSide(aH.get("visibleSide"));t()};var aD=function(bd){var bh=aF.getPointAt(bd.getStep()-1);var bf=aO(bh);var bb=bf.radian;var bg=Math.abs(bd.getRelativeAngle());var be=(function(){if(bg<=aH.get("envelopeRadiiSmall")){return aH.get("envelopeSizeSmall")}else{return aH.get("envelopeSizeBig")}})();this.setRadius(be);this.setStartAngle(bb+az);this.setEndAngle(bb);var bc=be*Math.cos(bb);var L=be*Math.sin(bb);if(bd.getRelativeAngle()>0){this.setX((bh.getX()-bc)/2);this.setY((bh.getY()-L)/2);this.setMoveX(bh.getX()-2*bc);this.setMoveY(bh.getY()-2*L)}else{this.setX((bh.getX()+bc)/2);this.setY((bh.getY()+L)/2);this.setMoveX(bh.getX()+2*bc);this.setMoveY(bh.getY()+2*L)}};var c=function(){var be=aF.getPoints();var bc=be[aC];if(typeof(bc)===C){bc=be[aC-1]}if(typeof(bc)===C){return m}for(var bg=0,bf=be.length;bg<bf;bg++){var bd=be[bg];if(bd instanceof Kinetic.Point!==true){continue}var bb=false;for(var L=0,bf=be.length;L<bf;L++){bb=O(bd,be[L]);if(bb===true){break}}if(bb===true){return true}}return false};var O=function(bq,bg){if(bg instanceof Kinetic.Point!==true){return false}if(bg.getLength()<aH.get("lineIntersectionCheckTollerance")){return false}var bf=bq.getX1();var bd=bq.getY1();var bi=bq.getX2();var bh=bq.getY2();var bm=bg.getX1();var bl=bg.getY1();var be=bg.getX2();var bc=bg.getY2();var bp=0;var bo=0;var bk=0;var bj=0;var bb=false;var L=false;var bn=((bc-bl)*(bi-bf))-((be-bm)*(bh-bd));if(bn===0){return false}bp=bd-bl;bo=bf-bm;bk=((be-bm)*bp)-((bc-bl)*bo);bj=((bi-bf)*bp)-((bh-bd)*bo);bp=bk/bn;bo=bj/bn;if(bp>0&&bp<1){bb=true}if(bo>0&&bo<1){L=true}if(bb===true&&L===true){return true}return false};var A=function(be,bd){if(be===null||typeof(be)===C||bd===null||typeof(bd)===C){return false}var L=(bd.getX()>be.getX()+be.getWidth());var bf=(bd.getX()+bd.getWidth()<be.getX());var bc=(bd.getY()>be.getY()+be.getHeight());var bb=(bd.getY()+bd.getHeight()<be.getY());return !(L||bf||bc||bb)};var al=function(){if(aF===null){return""}var L=aF.toJSON(function(bb,bc){if(bb==="refPoint"||bb==="layer"){return C}return bc});aF.resetJsonOperations();return L};var aA=function(){var L=null;if(typeof aH.get("importFromJson")===aS){L=JSON.parse(aH.get("importFromJson"))}else{if(typeof aH.get("importFromJson")===r){L=aH.get("importFromJson")}}var be=new Array();if(L.hasOwnProperty("attrs")===false){return}for(var bf=0;bf<L.attrs["points"].length;bf++){var bc=L.attrs["points"][bf];if(typeof(bc)===C||bc===null){continue}var bd=n(-1,-1,bc,true);if(bd.getUseSemiCircle()){var bb=bd.getSemiCircle();if(bb!==null&&bb instanceof Kinetic.SemiCircle===true){bb.on("update",aD)}}be.push(bd)}L.attrs["points"]=be;aF=new Kinetic.Vector(L.attrs);aH.set("visibleSide",aF.getVisibleSide());aC=aF.getPoints().length;aK(aF)};var a8=function(){var L=aH.get("translateDrawing");if(aF!==null){aF.setTranslated(L);var bc=aF.getPoints();for(var bd=0;bd<bc.length;bd++){var bb=bc[bd];if(bb instanceof Kinetic.Point!==true){continue}if(L===true){bb.setBeforeTranslationLength(bb.getLength());bb.setLength(bb.getTranslatedLength())}else{bb.setLength(bb.getBeforeTranslationLength()>0?bb.getBeforeTranslationLength():bb.getTranslatedLength())}bb.setRecalc(true);aF.updatePoint(bd,bb)}aX();Q()}return L};var a5=function(){if(aT===true){return false}var bf=a1.getX()+i.getWidth();var be=a1.getY()+i.getHeight();var L=a6();var bd=L.coordinates;var bc=bd.getMax();var bb=bd.getMin();var bn=(bc.getX()-bb.getX());var bl=(bc.getY()-bb.getY());var bj=bb.getX()+(bn/2);var bh=bb.getY()+(bl/2);var bi=bf/2;var bg=be/2;var bp=bi-bj;var bm=bg-bh;a1.setX(bp);a1.setY(bm);var bq=bn+aH.get("maximizeZoomPadding");var bs=bl+aH.get("maximizeZoomPadding");var bo=i.getWidth()/bq;var bk=i.getHeight()/bs;var br=bo<bk?bo:bk;aT=true;return aR(br)};var b=function(be){var bc=25;var bf=65;var bd=90;var bb=48;var L=57;var bg="";if(bb+aL>L){return bg}if(bf+be.getStep()<=bd){bg=String.fromCharCode(bf+be.getStep())}else{bg=String.fromCharCode(bf+(be.getStep()-(aL*bc))-1)}if(bf+be.getStep()>bd){aL=parseInt(be.getStep()/bc%bc);bg=bg+""+String.fromCharCode(bb+aL)}return bg};var av=function(bb){if(aF===null){return null}var L=new Array;var bf=aF.getPoints();if((bb||-1)>0){var bf=[aF.getPointAt(bb)]}for(var bc in bf){var bd=bf[bc];if(bd instanceof Kinetic.Point!==true){continue}var be={alphabetOrder:(function(){return b(bd)})(),index:bd.getStep(),length:parseFloat((bd.getTranslatedLength()>0?bd.getTranslatedLength():bd.getLength())/aH.get("conversionValue")).toFixed(aH.get("rounding")),angle:(function(){if((bd.getUseSemiCircle()===true&&bd.getSemiCircle()!==null)||bd.getStep()<=0){return -1}return parseFloat(bd.getRelativeAngle()*1).toFixed(aH.get("rounding"))})(),get:function(bg){return this[bg]}};L.push(be)}return L};var R=function(bb,L){aH.set(bb,L);aX()};var a7=function(L){var bb=L.split("");var bc=new Array();a.each(bb,function(be,bd){if(bd==="6"){bd="6\u0332"}bc.push(bd)});return bc.join("")};var a3=this;a.extend(true,aH,aM||new Object());a(this).addClass(h).width(aH.get("width")).height(aH.get("height")).parent().addClass(k);V=a('<div class="'+a0+'"></div>');a(this).parent().prepend(V);V.width(aH.get("width")).height(aH.get("height"));ba=aH.get("scale");at=aH.get("allowDrawing");i=new Kinetic.Stage({container:a(this).attr("id"),width:aH.get("width"),height:aH.get("height")});a1=new Kinetic.Point();J=new Kinetic.Point();if(aH.get("importFromJson")!==null){aA()}this.paint=aX;this.getVector=function(){return aF};this.getConfig=function(){return aH};this.getTotalLength=function(){if(aF.getPoints().length>1&&aN<=0){var bc=aF.getPoints();for(var L=0;L<bc.length;L++){var bb=bc[L];if(bb instanceof Kinetic.Point!==true){continue}aN+=bb.getTranslatedLength()}}return parseFloat((aN/aH.get("conversionValue"))*1).toFixed(aH.get("rounding"))};this.getTotalSize=a6;this.setStroke=function(L){if(aF!==null){aF.setStroke(L)}return aH.set("strokeColor",L)};this.toImage=function(L){return i.toDataURL({callback:L||null})};this.toJson=al;this.zoomIn=X;this.zoomOut=ac;this.maximize=a5;this.clear=d;this.getVectorPointsForOutdoorUse=av;this.undo=ax;this.enableDrawingTranslation=function(){aH.set("translateDrawing",true);a8()};this.disableDrawingTranslation=function(){aH.set("translateDrawing",false);a8()};this.enableVisibleSideArrow=function(){R("showVisibleSideArrow",true)};this.disableVisibleSideArrow=function(){R("showVisibleSideArrow",false)};this.enableGrid=function(){R("showGrid",true)};this.disableGrid=function(){R("showGrid",false)};this.enableLabel=function(){R("showLabel",true)};this.disableLabel=function(){R("showLabel",false)};this.enableAlphabeticLabel=function(){R("useAlphabeticLabel",true)};this.disableAlphabeticLabel=function(){R("useAlphabeticLabel",false)};this.enableDragableLabel=function(){aH.set("allowDragableLabel",true);if(aF!==null){var bb=aF.getPoints();for(var L in bb){bb[L].getLabel().setDraggable(true)}}};this.disableDragableLabel=function(){aH.set("allowDragableLabel",false);if(aF!==null){var bb=aF.getPoints();for(var L in bb){bb[L].getLabel().setDraggable(false)}}};this.enableAngleIndicator=function(){R("showAngleIndicator",true)};this.disableAngleIndicator=function(){R("showAngleIndicator",false)};this.enableZooming=function(){aH.set("allowZooming",true)};this.disableZooming=function(){aH.set("allowZooming",false)};this.enableScrolling=function(){aH.set("allowScrolling",true)};this.disableScrolling=function(){aH.set("allowScrolling",false)};this.enableDrawing=function(){at=aH.set("allowDrawing",true)};this.disableDrawing=function(){if(o){ax()}at=aH.set("allowDrawing",false)};this.increaseLabelSize=function(){R("labelScaleFactorManual",aH.get("labelScaleFactorManual")+aH.get("labelScaleFactorManualMinIncrease"))};this.decreaseLabelSize=function(){R("labelScaleFactorManual",aH.get("labelScaleFactorManual")-aH.get("labelScaleFactorManualMinDecrease"))};this.setLabelSize=function(L){R("labelScaleFactorManual",parseFloat(L))};this.increaseAngleIndicatorSize=function(){R("angleIndicatorScaleFactorManual",aH.get("angleIndicatorScaleFactorManual")+aH.get("angleIndicatorScaleFactorManualMinIncrease"))};this.decreaseAngleIndicatorSize=function(){R("angleIndicatorScaleFactorManual",aH.get("angleIndicatorScaleFactorManual")-aH.get("angleIndicatorScaleFactorManualMinDecrease"))};this.setAngleIndicatorSize=function(L){R("angleIndicatorScaleFactorManual",parseFloat(L))};a(this).on("angleUpdate",function(L,bb){var bf=bb.index;if(aF!==null&&bf>0&&a.isPlainObject(bb)){var be=bb.value;var bd=bb.callback;var bc=aF.getPointAt(bf);if(bc!==null&&bc instanceof Kinetic.Point===true){if(bc.getUseAngleIndicator()===true&&bc.getAngleIndicatorAdded()===true&&aH.get("showAngleIndicator")===true&&bc.getAngleIndicator()!==null){if((be||-1)>=0){return ar(bf,be,bd)}return bc.getAngleIndicator().fire("click")}}else{if(aH.get("debug")===true&&aH.get("debugLevel")>=2){console.warn('Event "labelUpdate": No Kinetic.Vector found at given Index #'+bf)}}}});a(this).on("labelUpdate",function(L,bb){if(aF!==null&&a.isPlainObject(bb)){var bf=bb.index;var be=bb.value;var bd=bb.callback;var bc=aF.getPointAt(bf);if(bc!==null&&bc instanceof Kinetic.Point===true){if(bc.getUseLabel()===true&&bc.getLabelAdded()===true&&aH.get("showLabel")===true&&bc.getLabel()!==null){if((be||-1)>=0){return E(bf,(be/aH.get("conversionValue")),bd)}return bc.getLabel().fire("click")}}else{if(aH.get("debug")===true&&aH.get("debugLevel")>=2){console.warn('Event "labelUpdate": No Kinetic.Vector found at given Index #'+bf)}}}});i.on("Automatic:LabelUpdate",function(L){a(a3).trigger("labelUpdateNotification",L)});i.on("Automatic:AngleUpdate",function(L){a(a3).trigger("angleUpdateNotification",L)});a(this).on("mousedown",function(L){a(a3).trigger("stageMouseDown",L);K(L)});a(this).on("mouseup",function(L){a(a3).trigger("stageMouseUp",L);P(L)});a(this).on("mousemove",function(L){a(a3).trigger("stageMouseMove",L);if(L.which===aV&&ah===true){return ae(L)}return D(L)});a(this).on("contextmenu",false);a(this).on("mousewheel",aP);a(document).bind("keydown","backspace",ax);a(document).bind("keydown","esc return",function(L){if(o){ax()}});return this}})(jQuery);

(function(a){
/*
       * aw.3Dwt [Drawing-Tool (3D Part)]
       * @author Sino Boeckmann <sino.boeckmann@aufwind.cc>
       * @copyright 2013-2014 Werbeagentur aufwind. GmbH
       */
a.fn.dreiDwt=function(C,g){if(this.length<=0){return a.error("Element "+this["selector"]+" does not exists in your DOM!")}if(!a.isArray(C)){return a.error("Vector(s) can not be null and must be an Array!")}var h="top";var B="bottom";var y="dreiDwt";var d="undefined";var p="function";var D=160;var c=null;var l=null;var e=null;var k=null;var z=null;var w=null;var A=null;var n=null;var t=false;var o={far:10000,useControllSettingOrbit:true,useControllSettingTrackball:false,useOrthographicCamera:false,usePerspectiveCamera:true,useWebGl:true,useWireframe:true,wireframeLinewidth:2,wireframeLineColor:"#797979",depthScaleFactor:1.5,visibleSide:h,controls:{rotateSpeed:4,zoomSpeed:0.5,noZoom:false,noPan:false,staticMoving:false,dynamicDampingFactor:0.3},webGlRenderConfig:{antialias:true,precision:"highp",stencil:false,preserveDrawingBuffer:true,alpha:true},material:{strength:0,depth:0,texture:"images/blank.gif",textureVisibleSide:"images/blank.gif"},sceneOptions:{clearColor:"#f7f7f7",transparentBackground:false},get:function(F){if(this.hasOwnProperty(F)){return this[F]}return null},set:function(G,F){if(this.hasOwnProperty(G)){return this[G]=F}return null}};var j=function(){return e=new THREE.Scene()};var s=function(){var G=o.get("width");var F=o.get("height");if(o.get("useOrthographicCamera")===true){k=new THREE.OrthographicCamera(G/-2,G/2,F/2,F/-2,1,o.get("far"))}if(o.get("usePerspectiveCamera")===true){k=new THREE.PerspectiveCamera(75,G/F,1,o.get("far"))}return k};var v=function(){if(e===null){return false}var F=new THREE.AmbientLight(16777215);var G=new THREE.DirectionalLight(16579836);G.position.set(1,1,1).normalize();e.add(F);e.add(G);return true};var f=function(H,I){var G=(function(){var J=new THREE.ImageUtils.loadTexture(I);J.wrapS=THREE.RepeatWrapping;J.wrapT=THREE.RepeatWrapping;J.repeat.set(1,1);return J})();var F=new THREE.MeshLambertMaterial({map:G,side:H});return F};var m=function(){var F=n.slice(0,1)[0];if(F===null||typeof(F)===d){return null}k.lookAt(F);k.position.set(-100,200,400);return F};var b=function(){var P=c.getPoints();if(t===true){var R=l.getPoints()}var L=(o.get("useWireframe")===true);var I=new Array();var N=o.get("material")["strength"];var J=0.5*N;var af=o.get("material")["depth"]/(parseFloat(o.get("depthScaleFactor"))<=0?1e-8:o.get("depthScaleFactor"));var O=new THREE.Geometry();if(L){var Q=new THREE.Geometry()}for(var K=0,X=0;K<P.length;K++){var Y=P[K];if(t===true){var G=R[K]}if(Y instanceof Kinetic.Point!==true){continue}if(t===true&&G instanceof Kinetic.Point!==true){continue}var U=Y.getTranslatedX1();var ae=Y.getTranslatedY1();var S=Y.getTranslatedX2();var ac=Y.getTranslatedY2();if(t===true){var aa=G.getTranslatedX1();var H=G.getTranslatedY1();var Z=G.getTranslatedX2();var F=G.getTranslatedY2()}if(t===false){O.vertices.push(new THREE.Vector3(U,ae+J,0),new THREE.Vector3(S,ac+J,0),new THREE.Vector3(S,ac-J,0),new THREE.Vector3(U,ae-J,0),new THREE.Vector3(U,ae-J,af),new THREE.Vector3(S,ac-J,af),new THREE.Vector3(S,ac+J,af),new THREE.Vector3(U,ae+J,af))}else{O.vertices.push(new THREE.Vector3(U,ae+J,0),new THREE.Vector3(S,ac+J,0),new THREE.Vector3(S,ac-J,0),new THREE.Vector3(U,ae-J,0),new THREE.Vector3(aa,H-J,af),new THREE.Vector3(Z,F-J,af),new THREE.Vector3(Z,F+J,af),new THREE.Vector3(aa,H+J,af))}if(L){if(t===false){Q.vertices.push(new THREE.Vector3(U,ae+J,0),new THREE.Vector3(S,ac+J,0),new THREE.Vector3(S,ac+J,af),new THREE.Vector3(U,ae+J,af),new THREE.Vector3(U,ae+J,0))}else{Q.vertices.push(new THREE.Vector3(U,ae+J,0),new THREE.Vector3(S,ac+J,0),new THREE.Vector3(Z,F+J,af),new THREE.Vector3(aa,H+J,af),new THREE.Vector3(U,ae+J,0))}}O.faces.push(new THREE.Face3(X+3,X+2,X+5),new THREE.Face3(X+5,X+4,X+3),new THREE.Face3(X+0,X+1,X+6),new THREE.Face3(X+6,X+7,X+0),new THREE.Face3(X+0,X+1,X+2),new THREE.Face3(X+2,X+3,X+0),new THREE.Face3(X+6,X+7,X+4),new THREE.Face3(X+4,X+5,X+6),new THREE.Face3(X+1,X+6,X+5),new THREE.Face3(X+5,X+2,X+1),new THREE.Face3(X+7,X+0,X+3),new THREE.Face3(X+3,X+4,X+7));X+=8}for(var ab=0;K<O.faces.length;K++){O.faceVertexUvs[0].push([new THREE.Vector2(0,0),new THREE.Vector2(0,1),new THREE.Vector2(1,1),new THREE.Vector2(1,0)])}O.computeFaceNormals();O.computeVertexNormals();THREE.GeometryUtils.center(O);if(L){THREE.GeometryUtils.center(Q)}var M=O.clone();var V=o.get("visibleSide");var ad=new THREE.Mesh(O,f((V===h?THREE.FrontSide:THREE.BackSide),o.get("material")["texture"]));var T=new THREE.Mesh(M,f((V===h?THREE.BackSide:THREE.FrontSide),o.get("material")["textureVisibleSide"]));if(typeof(ad.rotation)!==d){ad.rotation["x"]-=D}if(typeof(T.rotation)!==d){T.rotation["x"]-=D}I.push(ad);I.push(T);if(L){var W=new THREE.Line(Q,new THREE.LineBasicMaterial({color:o.get("wireframeLineColor"),linewidth:o.get("wireframeLinewidth")}));if(typeof(W.rotation)!==d){W.rotation["x"]-=D}I.push(W)}return I};var E=function(){j();s();v();if(o.get("useWebGl")===true){A=new THREE.Detector();z=A.isWebGlSupport()?new THREE.WebGLRenderer(o.get("webGlRenderConfig")||new Object()):new THREE.CanvasRenderer()}else{z=new THREE.CanvasRenderer()}z.setSize(o.get("width"),o.get("height"));a(this).html(z.domElement);n=b();for(var F in n){e.add(n[F])}m();if(o.get("useControllSettingOrbit")===true){w=new THREE.OrbitControls(k,z.domElement)}if(o.get("useControllSettingTrackball")===true){w=new THREE.TrackballControls(k,z.domElement)}a.extend(true,w,o.get("controls"));z.setClearColor(o.get("sceneOptions")["clearColor"],(o.get("sceneOptions")["transparentBackground"]===true?0:1));z.render(e,k)};var x=function(){if(e===null){return false}for(var F in n){e.remove(n[F])}n=b();for(var F in n){e.add(n[F])}m();return true};var u=function(F){if(w===null){return false}w.update();z.render(e,k)};var i=function(F){return o.material["depth"]=F};var r=function(F){if(e===null||k===null){return false}z.setClearColor(F,1);z.render(e,k);return F};var q=function(){if(w===null||z===null||e===null||k===null||o.get("useControllSettingTrackball")===true){return}w.reset();z.render(e,k)};a.extend(true,o,g);if(a.isArray(C)){if(C[0] instanceof Kinetic.Vector===true){c=C[0];c.fullReCalculation()}if(C[1] instanceof Kinetic.Vector===true){l=C[1];l.fullReCalculation();t=true}}a(this).addClass(y);this.paint=E;this.repaint=x;this.setDepth=i;this.setClearColor=r;this.resetZoom=q;this.toggleVisibleSide=function(){return o.set("visibleSide",o.get("visibleSide")===B?h:B)};this.toImage=function(F){if(typeof F===p){F(z.domElement.toDataURL())}};this.enableWireframe=function(){return o.set("useWireframe",true)};this.disableWireframe=function(){return o.set("useWireframe",false)};a(this).on("mousemove",u);a(this).on("contextmenu",false);return this}})(jQuery);

  /*
   * KineticJS JavaScript Framework v5.0.1
   * http://www.kineticjs.com/
   * Copyright 2013, Eric Rowell
   * Licensed under the MIT or GPL Version 2 licenses.
   * Date: 2014-01-21
   *
   * Copyright (C) 2011 - 2013 by Eric Rowell
   *
   * Permission is hereby granted, free of charge, to any person obtaining a copy
   * of this software and associated documentation files (the "Software"), to deal
   * in the Software without restriction, including without limitation the rights
   * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
   * copies of the Software, and to permit persons to whom the Software is
   * furnished to do so, subject to the following conditions:
   *
   * The above copyright notice and this permission notice shall be included in
   * all copies or substantial portions of the Software.
   *
   * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
   * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
   * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
   * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
   * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
   * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
   * THE SOFTWARE.
   */
  /**
   * @namespace Kinetic
   */
  var Kinetic = {
  };
  (function () {
      Kinetic = {
          // public
          version: '5.0.1',
          // private
          stages: [
          ],
          idCounter: 0,
          ids: {
          },
          names: {
          },
          shapes: {
          },
          listenClickTap: false,
          inDblClickWindow: false,
          // configurations
          enableTrace: false,
          traceArrMax: 100,
          dblClickWindow: 400,
          pixelRatio: undefined,
          // user agent
          UA: (function () {
              var ua = navigator.userAgent.toLowerCase(),
                // jQuery UA regex
                match = /(chrome)[ \/]([\w.]+)/.exec(ua) ||
                /(webkit)[ \/]([\w.]+)/.exec(ua) ||
                /(opera)(?:.*version|)[ \/]([\w.]+)/.exec(ua) ||
                /(msie) ([\w.]+)/.exec(ua) ||
                ua.indexOf("compatible") < 0 && /(mozilla)(?:.*? rv:([\w.]+)|)/.exec(ua) ||
                [
                ];

              return {
                  browser: match[ 1 ] || '',
                  version: match[ 2 ] || '0'
              };
          })(),
          /**
           * @namespace Filters
           * @memberof Kinetic
           */
          Filters: {
          },
          /**
           * Node constructor. Nodes are entities that can be transformed, layered,
           * and have bound events. The stage, layers, groups, and shapes all extend Node.
           * @constructor
           * @memberof Kinetic
           * @abstract
           * @param {Object} config
           * @param {Number} [config.x]
           * @param {Number} [config.y]
           * @param {Number} [config.width]
           * @param {Number} [config.height]
           * @param {Boolean} [config.visible]
           * @param {Boolean} [config.listening] whether or not the node is listening for events
           * @param {String} [config.id] unique id
           * @param {String} [config.name] non-unique name
           * @param {Number} [config.opacity] determines node opacity.  Can be any number between 0 and 1
           * @param {Object} [config.scale] set scale
           * @param {Number} [config.scaleX] set scale x
           * @param {Number} [config.scaleY] set scale y
           * @param {Number} [config.rotation] rotation in degrees
           * @param {Object} [config.offset] offset from center point and rotation point
           * @param {Number} [config.offsetX] set offset x
           * @param {Number} [config.offsetY] set offset y
           * @param {Boolean} [config.draggable] makes the node draggable.  When stages are draggable, you can drag and drop
           *  the entire stage by dragging any portion of the stage
           * @param {Function} [config.dragBoundFunc]
           */
          Node: function (config) {
              this._init(config);
          },
          /**
           * Shape constructor.  Shapes are primitive objects such as rectangles,
           *  circles, text, lines, etc.
           * @constructor
           * @memberof Kinetic
           * @augments Kinetic.Node
           * @param {Object} config
           * @param {String} [config.fill] fill color
           * @param {Integer} [config.fillRed] set fill red component
           * @param {Integer} [config.fillGreen] set fill green component
           * @param {Integer} [config.fillBlue] set fill blue component
           * @param {Integer} [config.fillAlpha] set fill alpha component
           * @param {Image} [config.fillPatternImage] fill pattern image
           * @param {Number} [config.fillPatternX]
           * @param {Number} [config.fillPatternY]
           * @param {Object} [config.fillPatternOffset] object with x and y component
           * @param {Number} [config.fillPatternOffsetX]
           * @param {Number} [config.fillPatternOffsetY]
           * @param {Object} [config.fillPatternScale] object with x and y component
           * @param {Number} [config.fillPatternScaleX]
           * @param {Number} [config.fillPatternScaleY]
           * @param {Number} [config.fillPatternRotation]
           * @param {String} [config.fillPatternRepeat] can be "repeat", "repeat-x", "repeat-y", or "no-repeat".  The default is "no-repeat"
           * @param {Object} [config.fillLinearGradientStartPoint] object with x and y component
           * @param {Number} [config.fillLinearGradientStartPointX]
           * @param {Number} [config.fillLinearGradientStartPointY]
           * @param {Object} [config.fillLinearGradientEndPoint] object with x and y component
           * @param {Number} [config.fillLinearGradientEndPointX]
           * @param {Number} [config.fillLinearGradientEndPointY]
           * @param {Array} [config.fillLinearGradientColorStops] array of color stops
           * @param {Object} [config.fillRadialGradientStartPoint] object with x and y component
           * @param {Number} [config.fillRadialGradientStartPointX]
           * @param {Number} [config.fillRadialGradientStartPointY]
           * @param {Object} [config.fillRadialGradientEndPoint] object with x and y component
           * @param {Number} [config.fillRadialGradientEndPointX]
           * @param {Number} [config.fillRadialGradientEndPointY]
           * @param {Number} [config.fillRadialGradientStartRadius]
           * @param {Number} [config.fillRadialGradientEndRadius]
           * @param {Array} [config.fillRadialGradientColorStops] array of color stops
           * @param {Boolean} [config.fillEnabled] flag which enables or disables the fill.  The default value is true
           * @param {String} [config.fillPriority] can be color, linear-gradient, radial-graident, or pattern.  The default value is color.  The fillPriority property makes it really easy to toggle between different fill types.  For example, if you want to toggle between a fill color style and a fill pattern style, simply set the fill property and the fillPattern properties, and then use setFillPriority('color') to render the shape with a color fill, or use setFillPriority('pattern') to render the shape with the pattern fill configuration
           * @param {String} [config.stroke] stroke color
           * @param {Integer} [config.strokeRed] set stroke red component
           * @param {Integer} [config.strokeGreen] set stroke green component
           * @param {Integer} [config.strokeBlue] set stroke blue component
           * @param {Integer} [config.strokeAlpha] set stroke alpha component
           * @param {Number} [config.strokeWidth] stroke width
           * @param {Boolean} [config.strokeScaleEnabled] flag which enables or disables stroke scale.  The default is true
           * @param {Boolean} [config.strokeEnabled] flag which enables or disables the stroke.  The default value is true
           * @param {String} [config.lineJoin] can be miter, round, or bevel.  The default
           *  is miter
           * @param {String} [config.lineCap] can be butt, round, or sqare.  The default
           *  is butt
           * @param {String} [config.shadowColor]
           * @param {Integer} [config.shadowColorRed] set shadow color red component
           * @param {Integer} [config.shadowColorGreen] set shadow color green component
           * @param {Integer} [config.shadowColorBlue] set shadow color blue component
           * @param {Integer} [config.shadowColorAlpha] set shadow color alpha component
           * @param {Number} [config.shadowBlur]
           * @param {Object} [config.shadowOffset] object with x and y component
           * @param {Number} [config.shadowOffsetX]
           * @param {Number} [config.shadowOffsetY]
           * @param {Number} [config.shadowOpacity] shadow opacity.  Can be any real number
           *  between 0 and 1
           * @param {Boolean} [config.shadowEnabled] flag which enables or disables the shadow.  The default value is true
           * @param {Array} [config.dash]
           * @param {Boolean} [config.dashEnabled] flag which enables or disables the dashArray.  The default value is true
           * @param {Number} [config.x]
           * @param {Number} [config.y]
           * @param {Number} [config.width]
           * @param {Number} [config.height]
           * @param {Boolean} [config.visible]
           * @param {Boolean} [config.listening] whether or not the node is listening for events
           * @param {String} [config.id] unique id
           * @param {String} [config.name] non-unique name
           * @param {Number} [config.opacity] determines node opacity.  Can be any number between 0 and 1
           * @param {Object} [config.scale] set scale
           * @param {Number} [config.scaleX] set scale x
           * @param {Number} [config.scaleY] set scale y
           * @param {Number} [config.rotation] rotation in degrees
           * @param {Object} [config.offset] offset from center point and rotation point
           * @param {Number} [config.offsetX] set offset x
           * @param {Number} [config.offsetY] set offset y
           * @param {Boolean} [config.draggable] makes the node draggable.  When stages are draggable, you can drag and drop
           *  the entire stage by dragging any portion of the stage
           * @param {Function} [config.dragBoundFunc]
           * @example
           * var customShape = new Kinetic.Shape({<br>
           *   x: 5,<br>
           *   y: 10,<br>
           *   fill: 'red',<br>
           *   // a Kinetic.Canvas renderer is passed into the drawFunc function<br>
           *   drawFunc: function(context) {<br>
           *     context.beginPath();<br>
           *     context.moveTo(200, 50);<br>
           *     context.lineTo(420, 80);<br>
           *     context.quadraticCurveTo(300, 100, 260, 170);<br>
           *     context.closePath();<br>
           *     context.fillStrokeShape(this);<br>
           *   }<br>
           *});
           */
          Shape: function (config) {
              this.__init(config);
          },
          /**
           * Container constructor.&nbsp; Containers are used to contain nodes or other containers
           * @constructor
           * @memberof Kinetic
           * @augments Kinetic.Node
           * @abstract
           * @param {Object} config
           * @param {Number} [config.x]
           * @param {Number} [config.y]
           * @param {Number} [config.width]
           * @param {Number} [config.height]
           * @param {Boolean} [config.visible]
           * @param {Boolean} [config.listening] whether or not the node is listening for events
           * @param {String} [config.id] unique id
           * @param {String} [config.name] non-unique name
           * @param {Number} [config.opacity] determines node opacity.  Can be any number between 0 and 1
           * @param {Object} [config.scale] set scale
           * @param {Number} [config.scaleX] set scale x
           * @param {Number} [config.scaleY] set scale y
           * @param {Number} [config.rotation] rotation in degrees
           * @param {Object} [config.offset] offset from center point and rotation point
           * @param {Number} [config.offsetX] set offset x
           * @param {Number} [config.offsetY] set offset y
           * @param {Boolean} [config.draggable] makes the node draggable.  When stages are draggable, you can drag and drop
           *  the entire stage by dragging any portion of the stage
           * @param {Function} [config.dragBoundFunc]
           * @param {Function} [config.clipFunc] clipping function

           */
          Container: function (config) {
              this.__init(config);
          },
          /**
           * Stage constructor.  A stage is used to contain multiple layers
           * @constructor
           * @memberof Kinetic
           * @augments Kinetic.Container
           * @param {Object} config
           * @param {String|DomElement} config.container Container id or DOM element
           * @param {Number} [config.x]
           * @param {Number} [config.y]
           * @param {Number} [config.width]
           * @param {Number} [config.height]
           * @param {Boolean} [config.visible]
           * @param {Boolean} [config.listening] whether or not the node is listening for events
           * @param {String} [config.id] unique id
           * @param {String} [config.name] non-unique name
           * @param {Number} [config.opacity] determines node opacity.  Can be any number between 0 and 1
           * @param {Object} [config.scale] set scale
           * @param {Number} [config.scaleX] set scale x
           * @param {Number} [config.scaleY] set scale y
           * @param {Number} [config.rotation] rotation in degrees
           * @param {Object} [config.offset] offset from center point and rotation point
           * @param {Number} [config.offsetX] set offset x
           * @param {Number} [config.offsetY] set offset y
           * @param {Boolean} [config.draggable] makes the node draggable.  When stages are draggable, you can drag and drop
           *  the entire stage by dragging any portion of the stage
           * @param {Function} [config.dragBoundFunc]
           * @param {Function} [config.clipFunc] clipping function

           * @example
           * var stage = new Kinetic.Stage({<br>
           *   width: 500,<br>
           *   height: 800,<br>
           *   container: 'containerId'<br>
           * });
           */
          Stage: function (config) {
              this.___init(config);
          },
          /**
           * Layer constructor.  Layers are tied to their own canvas element and are used
           * to contain groups or shapes
           * @constructor
           * @memberof Kinetic
           * @augments Kinetic.Container
           * @param {Object} config
           * @param {Boolean} [config.clearBeforeDraw] set this property to false if you don't want
           * to clear the canvas before each layer draw.  The default value is true.
           * @param {Number} [config.x]
           * @param {Number} [config.y]
           * @param {Number} [config.width]
           * @param {Number} [config.height]
           * @param {Boolean} [config.visible]
           * @param {Boolean} [config.listening] whether or not the node is listening for events
           * @param {String} [config.id] unique id
           * @param {String} [config.name] non-unique name
           * @param {Number} [config.opacity] determines node opacity.  Can be any number between 0 and 1
           * @param {Object} [config.scale] set scale
           * @param {Number} [config.scaleX] set scale x
           * @param {Number} [config.scaleY] set scale y
           * @param {Number} [config.rotation] rotation in degrees
           * @param {Object} [config.offset] offset from center point and rotation point
           * @param {Number} [config.offsetX] set offset x
           * @param {Number} [config.offsetY] set offset y
           * @param {Boolean} [config.draggable] makes the node draggable.  When stages are draggable, you can drag and drop
           *  the entire stage by dragging any portion of the stage
           * @param {Function} [config.dragBoundFunc]
           * @param {Function} [config.clipFunc] clipping function

           * @example
           * var layer = new Kinetic.Layer();
           */
          Layer: function (config) {
              this.___init(config);
          },
          /**
           * Group constructor.  Groups are used to contain shapes or other groups.
           * @constructor
           * @memberof Kinetic
           * @augments Kinetic.Container
           * @param {Object} config
           * @param {Number} [config.x]
           * @param {Number} [config.y]
           * @param {Number} [config.width]
           * @param {Number} [config.height]
           * @param {Boolean} [config.visible]
           * @param {Boolean} [config.listening] whether or not the node is listening for events
           * @param {String} [config.id] unique id
           * @param {String} [config.name] non-unique name
           * @param {Number} [config.opacity] determines node opacity.  Can be any number between 0 and 1
           * @param {Object} [config.scale] set scale
           * @param {Number} [config.scaleX] set scale x
           * @param {Number} [config.scaleY] set scale y
           * @param {Number} [config.rotation] rotation in degrees
           * @param {Object} [config.offset] offset from center point and rotation point
           * @param {Number} [config.offsetX] set offset x
           * @param {Number} [config.offsetY] set offset y
           * @param {Boolean} [config.draggable] makes the node draggable.  When stages are draggable, you can drag and drop
           *  the entire stage by dragging any portion of the stage
           * @param {Function} [config.dragBoundFunc]
           * @param {Function} [config.clipFunc] clipping function

           * @example
           * var group = new Kinetic.Group();
           */
          Group: function (config) {
              this.___init(config);
          },
          /**
           * returns whether or not drag and drop is currently active
           * @method
           * @memberof Kinetic
           */
          isDragging: function () {
              var dd = Kinetic.DD;

              // if DD is not included with the build, then
              // drag and drop is not even possible
              if (!dd) {
                  return false;
              }
              // if DD is included with the build
              else {
                  return dd.isDragging;
              }
          },
          /**
           * returns whether or not a drag and drop operation is ready, but may
           *  not necessarily have started
           * @method
           * @memberof Kinetic
           */
          isDragReady: function () {
              var dd = Kinetic.DD;

              // if DD is not included with the build, then
              // drag and drop is not even possible
              if (!dd) {
                  return false;
              }
              // if DD is included with the build
              else {
                  return !!dd.node;
              }
          },
          _addId: function (node, id) {
              if (id !== undefined) {
                  this.ids[id] = node;
              }
          },
          _removeId: function (id) {
              if (id !== undefined) {
                  delete this.ids[id];
              }
          },
          _addName: function (node, name) {
              if (name !== undefined) {
                  if (this.names[name] === undefined) {
                      this.names[name] = [
                      ];
                  }
                  this.names[name].push(node);
              }
          },
          _removeName: function (name, _id) {
              if (name !== undefined) {
                  var nodes = this.names[name];
                  if (nodes !== undefined) {
                      for (var n = 0; n < nodes.length; n++) {
                          var no = nodes[n];
                          if (no._id === _id) {
                              nodes.splice(n, 1);
                          }
                      }
                      if (nodes.length === 0) {
                          delete this.names[name];
                      }
                  }
              }
          }
      };
  })();

// Uses Node, AMD or browser globals to create a module.

// If you want something that will work in other stricter CommonJS environments,
// or if you need to create a circular dependency, see commonJsStrict.js

// Defines a module "returnExports" that depends another module called "b".
// Note that the name of the module is implied by the file name. It is best
// if the file name and the exported global have matching names.

// If the 'b' module also uses this type of boilerplate, then
// in the browser, it will create a global .b that is used below.

// If you do not want to support the browser global path, then you
// can remove the `root` use and the passing `this` as the first arg to
// the top function.

// if the module has no dependencies, the above pattern can be simplified to
  (function (root, factory) {
      if (typeof exports === 'object') {
          // Node. Does not work with strict CommonJS, but
          // only CommonJS-like enviroments that support module.exports,
          // like Node.
          module.exports = factory();
      }
      else if (typeof define === 'function' && define.amd) {
          // AMD. Register as an anonymous module.
          define(factory);
      }
      else {
          // Browser globals (root is window)
          root.returnExports = factory();
      }
  }(this, function () {

      // Just return a value to define the module export.
      // This example returns an object, but the module
      // can return a function as the exported value.
      return Kinetic;
  }));
  ;
  (function () {
      /**
       * Collection constructor.  Collection extends
       *  Array.  This class is used in conjunction with {@link Kinetic.Container#get}
       * @constructor
       * @memberof Kinetic
       */
      Kinetic.Collection = function () {
          var args = [
          ].slice.call(arguments), length = args.length, i = 0;

          this.length = length;
          for (; i < length; i++) {
              this[i] = args[i];
          }
          return this;
      };
      Kinetic.Collection.prototype = [
      ];
      /**
       * iterate through node array and run a function for each node.
       *  The node and index is passed into the function
       * @method
       * @memberof Kinetic.Collection.prototype
       * @param {Function} func
       * @example
       * // get all nodes with name foo inside layer, and set x to 10 for each
       * layer.get('.foo').each(function(shape, n) {<br>
       *   shape.setX(10);<br>
       * });
       */
      Kinetic.Collection.prototype.each = function (func) {
          for (var n = 0; n < this.length; n++) {
              func(this[n], n);
          }
      };
      /**
       * convert collection into an array
       * @method
       * @memberof Kinetic.Collection.prototype
       */
      Kinetic.Collection.prototype.toArray = function () {
          var arr = [
          ],
            len = this.length,
            n;

          for (n = 0; n < len; n++) {
              arr.push(this[n]);
          }
          return arr;
      };
      /**
       * convert array into a collection
       * @method
       * @memberof Kinetic.Collection
       * @param {Array} arr
       */
      Kinetic.Collection.toCollection = function (arr) {
          var collection = new Kinetic.Collection(),
            len = arr.length,
            n;

          for (n = 0; n < len; n++) {
              collection.push(arr[n]);
          }
          return collection;
      };

      Kinetic.Collection.mapMethods = function (constructor) {
          var prot = constructor.prototype,
            key;

          for (key in prot) {
              // induce scope
              (function (methodName) {
                  Kinetic.Collection.prototype[methodName] = function () {
                      var len = this.length,
                        i;

                      args = [
                      ].slice.call(arguments);
                      for (i = 0; i < len; i++) {
                          this[i][methodName].apply(this[i], args);
                      }

                      return this;
                  };
              })(key);
          }
      };

      /*
       * Last updated November 2011
       * By Simon Sarris
       * www.simonsarris.com
       * sarris@acm.org
       *
       * Free to use and distribute at will
       * So long as you are nice to people, etc
       */

      /*
       * The usage of this class was inspired by some of the work done by a forked
       * project, KineticJS-Ext by Wappworks, which is based on Simon's Transform
       * class.  Modified by Eric Rowell
       */

      /**
       * Transform constructor
       * @constructor
       * @memberof Kinetic
       */
      Kinetic.Transform = function () {
          this.m = [
              1,
              0,
              0,
              1,
              0,
              0
          ];
      };

      Kinetic.Transform.prototype = {
          /**
           * Apply translation
           * @method
           * @memberof Kinetic.Transform.prototype
           * @param {Number} x
           * @param {Number} y
           */
          translate: function (x, y) {
              this.m[4] += this.m[0] * x + this.m[2] * y;
              this.m[5] += this.m[1] * x + this.m[3] * y;
          },
          /**
           * Apply scale
           * @method
           * @memberof Kinetic.Transform.prototype
           * @param {Number} sx
           * @param {Number} sy
           */
          scale: function (sx, sy) {
              this.m[0] *= sx;
              this.m[1] *= sx;
              this.m[2] *= sy;
              this.m[3] *= sy;
          },
          /**
           * Apply rotation
           * @method
           * @memberof Kinetic.Transform.prototype
           * @param {Number} rad  Angle in radians
           */
          rotate: function (rad) {
              var c = Math.cos(rad);
              var s = Math.sin(rad);
              var m11 = this.m[0] * c + this.m[2] * s;
              var m12 = this.m[1] * c + this.m[3] * s;
              var m21 = this.m[0] * -s + this.m[2] * c;
              var m22 = this.m[1] * -s + this.m[3] * c;
              this.m[0] = m11;
              this.m[1] = m12;
              this.m[2] = m21;
              this.m[3] = m22;
          },
          /**
           * Returns the translation
           * @method
           * @memberof Kinetic.Transform.prototype
           * @returns {Object} 2D point(x, y)
           */
          getTranslation: function () {
              return {
                  x: this.m[4],
                  y: this.m[5]
              };
          },
          /**
           * Apply skew
           * @method
           * @memberof Kinetic.Transform.prototype
           * @param {Number} sx
           * @param {Number} sy
           */
          skew: function (sx, sy) {
              var m11 = this.m[0] + this.m[2] * sy;
              var m12 = this.m[1] + this.m[3] * sy;
              var m21 = this.m[2] + this.m[0] * sx;
              var m22 = this.m[3] + this.m[1] * sx;
              this.m[0] = m11;
              this.m[1] = m12;
              this.m[2] = m21;
              this.m[3] = m22;
          },
          /**
           * Transform multiplication
           * @method
           * @memberof Kinetic.Transform.prototype
           * @param {Kinetic.Transform} matrix
           */
          multiply: function (matrix) {
              var m11 = this.m[0] * matrix.m[0] + this.m[2] * matrix.m[1];
              var m12 = this.m[1] * matrix.m[0] + this.m[3] * matrix.m[1];

              var m21 = this.m[0] * matrix.m[2] + this.m[2] * matrix.m[3];
              var m22 = this.m[1] * matrix.m[2] + this.m[3] * matrix.m[3];

              var dx = this.m[0] * matrix.m[4] + this.m[2] * matrix.m[5] + this.m[4];
              var dy = this.m[1] * matrix.m[4] + this.m[3] * matrix.m[5] + this.m[5];

              this.m[0] = m11;
              this.m[1] = m12;
              this.m[2] = m21;
              this.m[3] = m22;
              this.m[4] = dx;
              this.m[5] = dy;
          },
          /**
           * Invert the matrix
           * @method
           * @memberof Kinetic.Transform.prototype
           */
          invert: function () {
              var d = 1 / (this.m[0] * this.m[3] - this.m[1] * this.m[2]);
              var m0 = this.m[3] * d;
              var m1 = -this.m[1] * d;
              var m2 = -this.m[2] * d;
              var m3 = this.m[0] * d;
              var m4 = d * (this.m[2] * this.m[5] - this.m[3] * this.m[4]);
              var m5 = d * (this.m[1] * this.m[4] - this.m[0] * this.m[5]);
              this.m[0] = m0;
              this.m[1] = m1;
              this.m[2] = m2;
              this.m[3] = m3;
              this.m[4] = m4;
              this.m[5] = m5;
          },
          /**
           * return matrix
           * @method
           * @memberof Kinetic.Transform.prototype
           */
          getMatrix: function () {
              return this.m;
          },
          /**
           * set to absolute position via translation
           * @method
           * @memberof Kinetic.Transform.prototype
           * @author ericdrowell
           */
          setAbsolutePosition: function (x, y) {
              var m0 = this.m[0],
                m1 = this.m[1],
                m2 = this.m[2],
                m3 = this.m[3],
                m4 = this.m[4],
                m5 = this.m[5],
                yt = ((m0 * (y - m5)) - (m1 * (x - m4))) / ((m0 * m3) - (m1 * m2)),
                xt = (x - m4 - (m2 * yt)) / m0;

              this.translate(xt, yt);
          }
      };

      // CONSTANTS
      var CANVAS = 'canvas',
        CONTEXT_2D = '2d',
        OBJECT_ARRAY = '[object Array]',
        OBJECT_NUMBER = '[object Number]',
        OBJECT_STRING = '[object String]',
        PI_OVER_DEG180 = Math.PI / 180,
        DEG180_OVER_PI = 180 / Math.PI,
        HASH = '#',
        EMPTY_STRING = '',
        ZERO = '0',
        KINETIC_WARNING = 'Kinetic warning: ',
        KINETIC_ERROR = 'Kinetic error: ',
        RGB_PAREN = 'rgb(',
        COLORS = {
          aqua: [
              0,
              255,
              255
          ],
          lime: [
              0,
              255,
              0
          ],
          silver: [
              192,
              192,
              192
          ],
          black: [
              0,
              0,
              0
          ],
          maroon: [
              128,
              0,
              0
          ],
          teal: [
              0,
              128,
              128
          ],
          blue: [
              0,
              0,
              255
          ],
          navy: [
              0,
              0,
              128
          ],
          white: [
              255,
              255,
              255
          ],
          fuchsia: [
              255,
              0,
              255
          ],
          olive: [
              128,
              128,
              0
          ],
          yellow: [
              255,
              255,
              0
          ],
          orange: [
              255,
              165,
              0
          ],
          gray: [
              128,
              128,
              128
          ],
          purple: [
              128,
              0,
              128
          ],
          green: [
              0,
              128,
              0
          ],
          red: [
              255,
              0,
              0
          ],
          pink: [
              255,
              192,
              203
          ],
          cyan: [
              0,
              255,
              255
          ],
          transparent: [
              255,
              255,
              255,
              0
          ]
      },
      RGB_REGEX = /rgb\((\d{1,3}),(\d{1,3}),(\d{1,3})\)/;

      /**
       * @namespace Util
       * @memberof Kinetic
       */
      Kinetic.Util = {
          /*
           * cherry-picked utilities from underscore.js
           */
          _isElement: function (obj) {
              return !!(obj && obj.nodeType == 1);
          },
          _isFunction: function (obj) {
              return !!(obj && obj.constructor && obj.call && obj.apply);
          },
          _isObject: function (obj) {
              return (!!obj && obj.constructor == Object);
          },
          _isArray: function (obj) {
              return Object.prototype.toString.call(obj) == OBJECT_ARRAY;
          },
          _isNumber: function (obj) {
              return Object.prototype.toString.call(obj) == OBJECT_NUMBER;
          },
          _isString: function (obj) {
              return Object.prototype.toString.call(obj) == OBJECT_STRING;
          },
          /*
           * other utils
           */
          _hasMethods: function (obj) {
              var names = [
              ],
                key;

              for (key in obj) {
                  if (this._isFunction(obj[key])) {
                      names.push(key);
                  }
              }
              return names.length > 0;
          },
          _isInDocument: function (el) {
              while (el = el.parentNode) {
                  if (el == document) {
                      return true;
                  }
              }
              return false;
          },
          _simplifyArray: function (arr) {
              var retArr = [
              ],
                len = arr.length,
                util = Kinetic.Util,
                n, val;

              for (n = 0; n < len; n++) {
                  val = arr[n];
                  if (util._isNumber(val)) {
                      val = Math.round(val * 1000) / 1000;
                  }
                  else if (!util._isString(val)) {
                      val = val.toString();
                  }

                  retArr.push(val);
              }

              return retArr;
          },
          /*
           * arg can be an image object or image data
           */
          _getImage: function (arg, callback) {
              var imageObj, canvas, context, dataUrl;

              // if arg is null or undefined
              if (!arg) {
                  callback(null);
              }

              // if arg is already an image object
              else if (this._isElement(arg)) {
                  callback(arg);
              }

              // if arg is a string, then it's a data url
              else if (this._isString(arg)) {
                  imageObj = new Image();
                  imageObj.onload = function () {
                      callback(imageObj);
                  };
                  imageObj.src = arg;
              }

              //if arg is an object that contains the data property, it's an image object
              else if (arg.data) {
                  canvas = document.createElement(CANVAS);
                  canvas.width = arg.width;
                  canvas.height = arg.height;
                  _context = canvas.getContext(CONTEXT_2D);
                  _context.putImageData(arg, 0, 0);
                  this._getImage(canvas.toDataURL(), callback);
              }
              else {
                  callback(null);
              }
          },
          _getRGBAString: function (obj) {
              var red = obj.red || 0,
                green = obj.green || 0,
                blue = obj.blue || 0,
                alpha = obj.alpha || 1;

              return [
                  'rgba(',
                  red,
                  ',',
                  green,
                  ',',
                  blue,
                  ',',
                  alpha,
                  ')'
              ].join(EMPTY_STRING);
          },
          _rgbToHex: function (r, g, b) {
              return ((1 << 24) + (r << 16) + (g << 8) + b).toString(16).slice(1);
          },
          _hexToRgb: function (hex) {
              hex = hex.replace(HASH, EMPTY_STRING);
              var bigint = parseInt(hex, 16);
              return {
                  r: (bigint >> 16) & 255,
                  g: (bigint >> 8) & 255,
                  b: bigint & 255
              };
          },
          /**
           * return random hex color
           * @method
           * @memberof Kinetic.Util.prototype
           */
          getRandomColor: function () {
              var randColor = (Math.random() * 0xFFFFFF << 0).toString(16);
              while (randColor.length < 6) {
                  randColor = ZERO + randColor;
              }
              return HASH + randColor;
          },
          /**
           * return value with default fallback
           * @method
           * @memberof Kinetic.Util.prototype
           */
          get: function (val, def) {
              if (val === undefined) {
                  return def;
              }
              else {
                  return val;
              }
          },
          /**
           * get RGB components of a color
           * @method
           * @memberof Kinetic.Util.prototype
           * @param {String} color
           * @example
           * // each of the following examples return {r:0, g:0, b:255}<br>
           * var rgb = Kinetic.Util.getRGB('blue');<br>
           * var rgb = Kinetic.Util.getRGB('#0000ff');<br>
           * var rgb = Kinetic.Util.getRGB('rgb(0,0,255)');
           */
          getRGB: function (color) {
              var rgb;
              // color string
              if (color in COLORS) {
                  rgb = COLORS[color];
                  return {
                      r: rgb[0],
                      g: rgb[1],
                      b: rgb[2]
                  };
              }
              // hex
              else if (color[0] === HASH) {
                  return this._hexToRgb(color.substring(1));
              }
              // rgb string
              else if (color.substr(0, 4) === RGB_PAREN) {
                  rgb = RGB_REGEX.exec(color.replace(/ /g, ''));
                  return {
                      r: parseInt(rgb[1], 10),
                      g: parseInt(rgb[2], 10),
                      b: parseInt(rgb[3], 10)
                  };
              }
              // default
              else {
                  return {
                      r: 0,
                      g: 0,
                      b: 0
                  };
              }
          },
          // o1 takes precedence over o2
          _merge: function (o1, o2) {
              if (!this.hasOwnProperty('_clone')) {
                  var retObj = this.cloneObject(o2);
              }
              else {
                  var retObj = this._clone(o2);
              }

              for (var key in o1) {
                  if (this._isObject(o1[key])) {
                      retObj[key] = this._merge(o1[key], retObj[key]);
                  }
                  else {
                      retObj[key] = o1[key];
                  }
              }
              return retObj;
          },
          cloneObject: function (obj) {
              var retObj = {
              };
              for (var key in obj) {
                  if (this._isObject(obj[key]) && this.hasOwnProperty('_clone')) {
                      retObj[key] = this._clone(obj[key]);
                  }
                  else {
                      retObj[key] = obj[key];
                  }
              }
              return retObj;
          },
          cloneArray: function (arr) {
              return arr.slice(0);
          },
          _degToRad: function (deg) {
              return deg * PI_OVER_DEG180;
          },
          _radToDeg: function (rad) {
              return rad * DEG180_OVER_PI;
          },
          _capitalize: function (str) {
              return str.charAt(0).toUpperCase() + str.slice(1);
          },
          error: function (str) {
              throw new Error(KINETIC_ERROR + str);
          },
          warn: function (str) {
              /*
               * IE9 on Windows7 64bit will throw a JS error
               * if we don't use window.console in the conditional
               */
              if (window.console && console.warn) {
                  console.warn(KINETIC_WARNING + str);
              }
          },
          extend: function (c1, c2) {
              for (var key in c2.prototype) {
                  if (!(key in c1.prototype)) {
                      c1.prototype[key] = c2.prototype[key];
                  }
              }
          },
          /**
           * adds methods to a constructor prototype
           * @method
           * @memberof Kinetic.Util.prototype
           * @param {Function} constructor
           * @param {Object} methods
           */
          addMethods: function (constructor, methods) {
              var key;

              for (key in methods) {
                  constructor.prototype[key] = methods[key];
              }
          },
          _getControlPoints: function (x0, y0, x1, y1, x2, y2, t) {
              var d01 = Math.sqrt(Math.pow(x1 - x0, 2) + Math.pow(y1 - y0, 2)),
                d12 = Math.sqrt(Math.pow(x2 - x1, 2) + Math.pow(y2 - y1, 2)),
                fa = t * d01 / (d01 + d12),
                fb = t * d12 / (d01 + d12),
                p1x = x1 - fa * (x2 - x0),
                p1y = y1 - fa * (y2 - y0),
                p2x = x1 + fb * (x2 - x0),
                p2y = y1 + fb * (y2 - y0);

              return [
                  p1x,
                  p1y,
                  p2x,
                  p2y
              ];
          },
          _expandPoints: function (p, tension) {
              var len = p.length,
                allPoints = [
              ],
                n, cp;

              for (n = 2; n < len - 2; n += 2) {
                  cp = Kinetic.Util._getControlPoints(p[n - 2], p[n - 1], p[n], p[n + 1], p[n + 2], p[n + 3], tension);
                  allPoints.push(cp[0]);
                  allPoints.push(cp[1]);
                  allPoints.push(p[n]);
                  allPoints.push(p[n + 1]);
                  allPoints.push(cp[2]);
                  allPoints.push(cp[3]);
              }

              return allPoints;
          },
          _removeLastLetter: function (str) {
              return str.substring(0, str.length - 1);
          }
      };
  })();
  ;
  (function () {
      // calculate pixel ratio
      var canvas = document.createElement('canvas'),
        context = canvas.getContext('2d'),
        devicePixelRatio = window.devicePixelRatio || 1,
        backingStoreRatio = context.webkitBackingStorePixelRatio
        || context.mozBackingStorePixelRatio
        || context.msBackingStorePixelRatio
        || context.oBackingStorePixelRatio
        || context.backingStorePixelRatio
        || 1,
        _pixelRatio = devicePixelRatio / backingStoreRatio;

      /**
       * Canvas Renderer constructor
       * @constructor
       * @abstract
       * @memberof Kinetic
       * @param {Number} width
       * @param {Number} height
       * @param {Number} pixelRatio KineticJS automatically handles pixel ratio adustments in order to render crisp drawings
       *  on all devices. Most desktops, low end tablets, and low end phones, have device pixel ratios
       *  of 1.  Some high end tablets and phones, like iPhones and iPads (not the mini) have a device pixel ratio
       *  of 2.  Some Macbook Pros, and iMacs also have a device pixel ratio of 2.  Some high end Android devices have pixel
       *  ratios of 2 or 3.  Some browsers like Firefox allow you to configure the pixel ratio of the viewport.  Unless otherwise
       *  specificed, the pixel ratio will be defaulted to the actual device pixel ratio.  You can override the device pixel
       *  ratio for special situations, or, if you don't want the pixel ratio to be taken into account, you can set it to 1.
       */
      Kinetic.Canvas = function (config) {
          this.init(config);
      };

      Kinetic.Canvas.prototype = {
          init: function (config) {
              config = config || {
              };

              var pixelRatio = config.pixelRatio || Kinetic.pixelRatio || _pixelRatio;

              this.pixelRatio = pixelRatio;
              this._canvas = document.createElement('canvas');

              // set inline styles
              this._canvas.style.padding = 0;
              this._canvas.style.margin = 0;
              this._canvas.style.border = 0;
              this._canvas.style.background = 'transparent';
              this._canvas.style.position = 'absolute';
              this._canvas.style.top = 0;
              this._canvas.style.left = 0;
          },
          /**
           * get canvas context
           * @method
           * @memberof Kinetic.Canvas.prototype
           * @returns {CanvasContext} context
           */
          getContext: function () {
              return this.context;
          },
          /**
           * get pixel ratio
           * @method
           * @memberof Kinetic.Canvas.prototype
           * @returns {Number} pixel ratio
           */
          getPixelRatio: function () {
              return this.pixelRatio;
          },
          /**
           * get pixel ratio
           * @method
           * @memberof Kinetic.Canvas.prototype
           * @param {Number} pixelRatio KineticJS automatically handles pixel ratio adustments in order to render crisp drawings
           *  on all devices. Most desktops, low end tablets, and low end phones, have device pixel ratios
           *  of 1.  Some high end tablets and phones, like iPhones and iPads (not the mini) have a device pixel ratio
           *  of 2.  Some Macbook Pros, and iMacs also have a device pixel ratio of 2.  Some high end Android devices have pixel
           *  ratios of 2 or 3.  Some browsers like Firefox allow you to configure the pixel ratio of the viewport.  Unless otherwise
           *  specificed, the pixel ratio will be defaulted to the actual device pixel ratio.  You can override the device pixel
           *  ratio for special situations, or, if you don't want the pixel ratio to be taken into account, you can set it to 1.
           */
          setPixelRatio: function (pixelRatio) {
              this.pixelRatio = pixelRatio;
              this.setSize(this.getWidth(), this.getHeight());
          },
          /**
           * set width
           * @method
           * @memberof Kinetic.Canvas.prototype
           * @param {Number} width
           */
          setWidth: function (width) {
              // take into account pixel ratio
              this.width = this._canvas.width = width * this.pixelRatio;
              this._canvas.style.width = width + 'px';
          },
          /**
           * set height
           * @method
           * @memberof Kinetic.Canvas.prototype
           * @param {Number} height
           */
          setHeight: function (height) {
              // take into account pixel ratio
              this.height = this._canvas.height = height * this.pixelRatio;
              this._canvas.style.height = height + 'px';
          },
          /**
           * get width
           * @method
           * @memberof Kinetic.Canvas.prototype
           * @returns {Number} width
           */
          getWidth: function () {
              return this.width;
          },
          /**
           * get height
           * @method
           * @memberof Kinetic.Canvas.prototype
           * @returns {Number} height
           */
          getHeight: function () {
              return this.height;
          },
          /**
           * set size
           * @method
           * @memberof Kinetic.Canvas.prototype
           * @param {Number} width
           * @param {Number} height
           */
          setSize: function (width, height) {
              this.setWidth(width);
              this.setHeight(height);
          },
          /**
           * to data url
           * @method
           * @memberof Kinetic.Canvas.prototype
           * @param {String} mimeType
           * @param {Number} quality between 0 and 1 for jpg mime types
           * @returns {String} data url string
           */
          toDataURL: function (mimeType, quality) {
              try {
                  // If this call fails (due to browser bug, like in Firefox 3.6),
                  // then revert to previous no-parameter image/png behavior
                  return this._canvas.toDataURL(mimeType, quality);
              }
              catch (e) {
                  try {
                      return this._canvas.toDataURL();
                  }
                  catch (err) {
                      Kinetic.Util.warn('Unable to get data URL. ' + err.message);
                      return '';
                  }
              }
          }
      };

      Kinetic.SceneCanvas = function (config) {
          config = config || {
          };
          var width = config.width || 0,
            height = config.height || 0;

          Kinetic.Canvas.call(this, config);
          this.context = new Kinetic.SceneContext(this);
          this.setSize(width, height);
      };

      Kinetic.SceneCanvas.prototype = {
          setWidth: function (width) {
              var pixelRatio = this.pixelRatio,
                _context = this.getContext()._context;

              Kinetic.Canvas.prototype.setWidth.call(this, width);
              _context.scale(pixelRatio, pixelRatio);
          },
          setHeight: function (height) {
              var pixelRatio = this.pixelRatio,
                _context = this.getContext()._context;

              Kinetic.Canvas.prototype.setHeight.call(this, height);
              _context.scale(pixelRatio, pixelRatio);
          }
      };
      Kinetic.Util.extend(Kinetic.SceneCanvas, Kinetic.Canvas);

      Kinetic.HitCanvas = function (config) {
          config = config || {
          };
          var width = config.width || 0,
            height = config.height || 0;

          Kinetic.Canvas.call(this, config);
          this.context = new Kinetic.HitContext(this);
          this.setSize(width, height);
      };
      Kinetic.Util.extend(Kinetic.HitCanvas, Kinetic.Canvas);

  })();
  ;
  (function () {
      var COMMA = ',',
        OPEN_PAREN = '(',
        CLOSE_PAREN = ')',
        OPEN_PAREN_BRACKET = '([',
        CLOSE_BRACKET_PAREN = '])',
        SEMICOLON = ';',
        DOUBLE_PAREN = '()',
        EMPTY_STRING = '',
        EQUALS = '=',
        SET = 'set',
        CONTEXT_METHODS = [
          'arc',
          'arcTo',
          'beginPath',
          'bezierCurveTo',
          'clearRect',
          'clip',
          'closePath',
          'createLinearGradient',
          'createPattern',
          'createRadialGradient',
          'drawImage',
          'fill',
          'fillText',
          'getImageData',
          'createImageData',
          'lineTo',
          'moveTo',
          'putImageData',
          'quadraticCurveTo',
          'rect',
          'restore',
          'rotate',
          'save',
          'scale',
          'setLineDash',
          'setTransform',
          'stroke',
          'strokeText',
          'transform',
          'translate'
      ];

      /**
       * Canvas Context constructor
       * @constructor
       * @abstract
       * @memberof Kinetic
       */
      Kinetic.Context = function (canvas) {
          this.init(canvas);
      };

      Kinetic.Context.prototype = {
          init: function (canvas) {
              this.canvas = canvas;
              this._context = canvas._canvas.getContext('2d');

              if (Kinetic.enableTrace) {
                  this.traceArr = [
                  ];
                  this._enableTrace();
              }
          },
          /**
           * fill shape
           * @method
           * @memberof Kinetic.Context.prototype
           * @param {Kinetic.Shape} shape
           */
          fillShape: function (shape) {
              if (shape.getFillEnabled()) {
                  this._fill(shape);
              }
          },
          /**
           * stroke shape
           * @method
           * @memberof Kinetic.Context.prototype
           * @param {Kinetic.Shape} shape
           */
          strokeShape: function (shape) {
              if (shape.getStrokeEnabled()) {
                  this._stroke(shape);
              }
          },
          /**
           * fill then stroke
           * @method
           * @memberof Kinetic.Context.prototype
           * @param {Kinetic.Shape} shape
           */
          fillStrokeShape: function (shape) {
              var fillEnabled = shape.getFillEnabled();
              if (fillEnabled) {
                  this._fill(shape);
              }
              if (shape.getStrokeEnabled()) {
                  this._stroke(shape);
              }
          },
          /**
           * get context trace if trace is enabled
           * @method
           * @memberof Kinetic.Context.prototype
           * @param {Boolean} relaxed if false, return strict context trace, which includes method names, method parameters
           *  properties, and property values.  If true, return relaxed context trace, which only returns method names and
           *  properites.
           * @returns {String}
           */
          getTrace: function (relaxed) {
              var traceArr = this.traceArr,
                len = traceArr.length,
                str = '',
                n, trace, method, args;

              for (n = 0; n < len; n++) {
                  trace = traceArr[n];
                  method = trace.method;

                  // methods
                  if (method) {
                      args = trace.args;
                      str += method;
                      if (relaxed) {
                          str += DOUBLE_PAREN;
                      }
                      else {
                          if (Kinetic.Util._isArray(args[0])) {
                              str += OPEN_PAREN_BRACKET + args.join(COMMA) + CLOSE_BRACKET_PAREN;
                          }
                          else {
                              str += OPEN_PAREN + args.join(COMMA) + CLOSE_PAREN;
                          }
                      }
                  }
                  // properties
                  else {
                      str += trace.property;
                      if (!relaxed) {
                          str += EQUALS + trace.val;
                      }
                  }

                  str += SEMICOLON;
              }

              return str;
          },
          /**
           * clear trace if trace is enabled
           * @method
           * @memberof Kinetic.Context.prototype
           */
          clearTrace: function () {
              this.traceArr = [
              ];
          },
          _trace: function (str) {
              var traceArr = this.traceArr,
                len;

              traceArr.push(str);
              len = traceArr.length;

              if (len >= Kinetic.traceArrMax) {
                  traceArr.shift();
              }
          },
          /**
           * reset canvas context transform
           * @method
           * @memberof Kinetic.Context.prototype
           */
          reset: function () {
              var pixelRatio = this.getCanvas().getPixelRatio();
              this.setTransform(1 * pixelRatio, 0, 0, 1 * pixelRatio, 0, 0);
          },
          /**
           * get canvas
           * @method
           * @memberof Kinetic.Context.prototype
           * @returns {Kinetic.Canvas}
           */
          getCanvas: function () {
              return this.canvas;
          },
          /**
           * clear canvas
           * @method
           * @memberof Kinetic.Context.prototype
           * @param {Object} [bounds]
           * @param {Number} [bounds.x]
           * @param {Number} [bounds.y]
           * @param {Number} [bounds.width]
           * @param {Number} [bounds.height]
           */
          clear: function (bounds) {
              var canvas = this.getCanvas(),
                pos, size;

              if (bounds) {
                  this.clearRect(bounds.x || 0, bounds.y || 0, bounds.width || 0, bounds.height || 0);
              }
              else {
                  this.clearRect(0, 0, canvas.getWidth(), canvas.getHeight());
              }
          },
          _applyLineCap: function (shape) {
              var lineCap = shape.getLineCap();
              if (lineCap) {
                  this.setAttr('lineCap', lineCap);
              }
          },
          _applyOpacity: function (shape) {
              var absOpacity = shape.getAbsoluteOpacity();
              if (absOpacity !== 1) {
                  this.setAttr('globalAlpha', absOpacity);
              }
          },
          _applyLineJoin: function (shape) {
              var lineJoin = shape.getLineJoin();
              if (lineJoin) {
                  this.setAttr('lineJoin', lineJoin);
              }
          },
          _applyTransform: function (shape) {
              var transformsEnabled = shape.getTransformsEnabled(),
                m;

              if (transformsEnabled === 'all') {
                  m = shape.getAbsoluteTransform().getMatrix();
                  this.transform(m[0], m[1], m[2], m[3], m[4], m[5]);
              }
              else if (transformsEnabled === 'position') {
                  // best performance for position only transforms
                  this.translate(shape.getX(), shape.getY());
              }
          },
          setAttr: function (attr, val) {
              this._context[attr] = val;
          },
          // context pass through methods
          arc: function () {
              var a = arguments;
              this._context.arc(a[0], a[1], a[2], a[3], a[4], a[5]);
          },
          beginPath: function () {
              this._context.beginPath();
          },
          bezierCurveTo: function () {
              var a = arguments;
              this._context.bezierCurveTo(a[0], a[1], a[2], a[3], a[4], a[5]);
          },
          clearRect: function () {
              var a = arguments;
              this._context.clearRect(a[0], a[1], a[2], a[3]);
          },
          clip: function () {
              this._context.clip();
          },
          closePath: function () {
              this._context.closePath();
          },
          createImageData: function () {
              var a = arguments;
              if (a.length === 2) {
                  return this._context.createImageData(a[0], a[1]);
              }
              else if (a.length === 1) {
                  return this._context.createImageData(a[0]);
              }
          },
          createLinearGradient: function () {
              var a = arguments;
              return this._context.createLinearGradient(a[0], a[1], a[2], a[3]);
          },
          createPattern: function () {
              var a = arguments;
              return this._context.createPattern(a[0], a[1]);
          },
          createRadialGradient: function () {
              var a = arguments;
              return this._context.createRadialGradient(a[0], a[1], a[2], a[3], a[4], a[5]);
          },
          drawImage: function () {
              var a = arguments,
                _context = this._context;

              if (a.length === 3) {
                  _context.drawImage(a[0], a[1], a[2]);
              }
              else if (a.length === 5) {
                  _context.drawImage(a[0], a[1], a[2], a[3], a[4]);
              }
              else if (a.length === 9) {
                  _context.drawImage(a[0], a[1], a[2], a[3], a[4], a[5], a[6], a[7], a[8]);
              }
          },
          fill: function () {
              this._context.fill();
          },
          fillText: function () {
              var a = arguments;
              this._context.fillText(a[0], a[1], a[2]);
          },
          getImageData: function () {
              var a = arguments;
              return this._context.getImageData(a[0], a[1], a[2], a[3]);
          },
          lineTo: function () {
              var a = arguments;
              this._context.lineTo(a[0], a[1]);
          },
          moveTo: function () {
              var a = arguments;
              this._context.moveTo(a[0], a[1]);
          },
          rect: function () {
              var a = arguments;
              this._context.rect(a[0], a[1], a[2], a[3]);
          },
          putImageData: function () {
              var a = arguments;
              this._context.putImageData(a[0], a[1], a[2]);
          },
          quadraticCurveTo: function () {
              var a = arguments;
              this._context.quadraticCurveTo(a[0], a[1], a[2], a[3]);
          },
          restore: function () {
              this._context.restore();
          },
          rotate: function () {
              var a = arguments;
              this._context.rotate(a[0]);
          },
          save: function () {
              this._context.save();
          },
          scale: function () {
              var a = arguments;
              this._context.scale(a[0], a[1]);
          },
          setLineDash: function () {
              var a = arguments,
                _context = this._context;

              // works for Chrome and IE11
              if (this._context.setLineDash) {
                  _context.setLineDash(a[0]);
              }
              // verified that this works in firefox
              else if ('mozDash' in _context) {
                  _context.mozDash = a[0];
              }
              // does not currently work for Safari
              else if ('webkitLineDash' in _context) {
                  _context.webkitLineDash = a[0];
              }

              // no support for IE9 and IE10
          },
          setTransform: function () {
              var a = arguments;
              this._context.setTransform(a[0], a[1], a[2], a[3], a[4], a[5]);
          },
          stroke: function () {
              this._context.stroke();
          },
          strokeText: function () {
              var a = arguments;
              this._context.strokeText(a[0], a[1], a[2]);
          },
          transform: function () {
              var a = arguments;
              this._context.transform(a[0], a[1], a[2], a[3], a[4], a[5]);
          },
          translate: function () {
              var a = arguments;
              this._context.translate(a[0], a[1]);
          },
          _enableTrace: function () {
              var that = this,
                len = CONTEXT_METHODS.length,
                _simplifyArray = Kinetic.Util._simplifyArray,
                origSetter = this.setAttr,
                n, args;

              // methods
              for (n = 0; n < len; n++) {
                  (function (methodName) {
                      var origMethod = that[methodName],
                        ret;

                      that[methodName] = function () {
                          args = _simplifyArray(Array.prototype.slice.call(arguments, 0));
                          ret = origMethod.apply(that, arguments);

                          that._trace({
                              method: methodName,
                              args: args
                          });

                          return ret;
                      };
                  })(CONTEXT_METHODS[n]);
              }

              // attrs
              that.setAttr = function () {
                  origSetter.apply(that, arguments);
                  that._trace({
                      property: arguments[0],
                      val: arguments[1]
                  });
              };
          }
      };

      Kinetic.SceneContext = function (canvas) {
          Kinetic.Context.call(this, canvas);
      };

      Kinetic.SceneContext.prototype = {
          _fillColor: function (shape) {
              var fill = shape.fill()
                || Kinetic.Util._getRGBAString({
                  red: shape.fillRed(),
                  green: shape.fillGreen(),
                  blue: shape.fillBlue(),
                  alpha: shape.fillAlpha()
              });

              this.setAttr('fillStyle', fill);
              shape._fillFunc(this);
          },
          _fillPattern: function (shape) {
              var fillPatternImage = shape.getFillPatternImage(),
                fillPatternX = shape.getFillPatternX(),
                fillPatternY = shape.getFillPatternY(),
                fillPatternScale = shape.getFillPatternScale(),
                fillPatternRotation = shape.getFillPatternRotation(),
                fillPatternOffset = shape.getFillPatternOffset(),
                fillPatternRepeat = shape.getFillPatternRepeat();

              if (fillPatternX || fillPatternY) {
                  this.translate(fillPatternX || 0, fillPatternY || 0);
              }
              if (fillPatternRotation) {
                  this.rotate(fillPatternRotation);
              }
              if (fillPatternScale) {
                  this.scale(fillPatternScale.x, fillPatternScale.y);
              }
              if (fillPatternOffset) {
                  this.translate(-1 * fillPatternOffset.x, -1 * fillPatternOffset.y);
              }

              this.setAttr('fillStyle', this.createPattern(fillPatternImage, fillPatternRepeat || 'repeat'));
              this.fill();
          },
          _fillLinearGradient: function (shape) {
              var start = shape.getFillLinearGradientStartPoint(),
                end = shape.getFillLinearGradientEndPoint(),
                colorStops = shape.getFillLinearGradientColorStops(),
                grd = this.createLinearGradient(start.x, start.y, end.x, end.y);

              if (colorStops) {
                  // build color stops
                  for (var n = 0; n < colorStops.length; n += 2) {
                      grd.addColorStop(colorStops[n], colorStops[n + 1]);
                  }
                  this.setAttr('fillStyle', grd);
                  this.fill();
              }
          },
          _fillRadialGradient: function (shape) {
              var start = shape.getFillRadialGradientStartPoint(),
                end = shape.getFillRadialGradientEndPoint(),
                startRadius = shape.getFillRadialGradientStartRadius(),
                endRadius = shape.getFillRadialGradientEndRadius(),
                colorStops = shape.getFillRadialGradientColorStops(),
                grd = this.createRadialGradient(start.x, start.y, startRadius, end.x, end.y, endRadius);

              // build color stops
              for (var n = 0; n < colorStops.length; n += 2) {
                  grd.addColorStop(colorStops[n], colorStops[n + 1]);
              }
              this.setAttr('fillStyle', grd);
              this.fill();
          },
          _fill: function (shape) {
              var hasColor = shape.fill() || shape.fillRed() || shape.fillGreen() || shape.fillBlue(),
                hasPattern = shape.getFillPatternImage(),
                hasLinearGradient = shape.getFillLinearGradientColorStops(),
                hasRadialGradient = shape.getFillRadialGradientColorStops(),
                fillPriority = shape.getFillPriority();

              // priority fills
              if (hasColor && fillPriority === 'color') {
                  this._fillColor(shape);
              }
              else if (hasPattern && fillPriority === 'pattern') {
                  this._fillPattern(shape);
              }
              else if (hasLinearGradient && fillPriority === 'linear-gradient') {
                  this._fillLinearGradient(shape);
              }
              else if (hasRadialGradient && fillPriority === 'radial-gradient') {
                  this._fillRadialGradient(shape);
              }
              // now just try and fill with whatever is available
              else if (hasColor) {
                  this._fillColor(shape);
              }
              else if (hasPattern) {
                  this._fillPattern(shape);
              }
              else if (hasLinearGradient) {
                  this._fillLinearGradient(shape);
              }
              else if (hasRadialGradient) {
                  this._fillRadialGradient(shape);
              }
          },
          _stroke: function (shape) {
              var dash = shape.dash(),
                strokeScaleEnabled = shape.getStrokeScaleEnabled();

              if (shape.hasStroke()) {
                  if (!strokeScaleEnabled) {
                      this.save();
                      this.setTransform(1, 0, 0, 1, 0, 0);
                  }

                  this._applyLineCap(shape);
                  if (dash && shape.dashEnabled()) {
                      this.setLineDash(dash);
                  }

                  this.setAttr('lineWidth', shape.strokeWidth());
                  this.setAttr('strokeStyle', shape.stroke()
                    || Kinetic.Util._getRGBAString({
                      red: shape.strokeRed(),
                      green: shape.strokeGreen(),
                      blue: shape.strokeBlue(),
                      alpha: shape.strokeAlpha()
                  }));

                  shape._strokeFunc(this);

                  if (!strokeScaleEnabled) {
                      this.restore();
                  }
              }
          },
          _applyShadow: function (shape) {
              var util = Kinetic.Util,
                absOpacity = shape.getAbsoluteOpacity(),
                color = util.get(shape.getShadowColor(), 'black'),
                blur = util.get(shape.getShadowBlur(), 5),
                shadowOpacity = util.get(shape.getShadowOpacity(), 0),
                offset = util.get(shape.getShadowOffset(), {
                  x: 0,
                  y: 0
              });

              if (shadowOpacity) {
                  this.setAttr('globalAlpha', shadowOpacity * absOpacity);
              }

              this.setAttr('shadowColor', color);
              this.setAttr('shadowBlur', blur);
              this.setAttr('shadowOffsetX', offset.x);
              this.setAttr('shadowOffsetY', offset.y);

          }
      };
      Kinetic.Util.extend(Kinetic.SceneContext, Kinetic.Context);

      Kinetic.HitContext = function (canvas) {
          Kinetic.Context.call(this, canvas);
      };

      Kinetic.HitContext.prototype = {
          _fill: function (shape) {
              this.save();
              this.setAttr('fillStyle', shape.colorKey);
              shape._fillFuncHit(this);
              this.restore();
          },
          _stroke: function (shape) {
              if (shape.hasStroke()) {
                  this._applyLineCap(shape);
                  this.setAttr('lineWidth', shape.strokeWidth());
                  this.setAttr('strokeStyle', shape.colorKey);
                  shape._strokeFuncHit(this);
              }
          }
      };
      Kinetic.Util.extend(Kinetic.HitContext, Kinetic.Context);
  })();
  ;
  (function () {
      // CONSTANTS
      var ABSOLUTE_OPACITY = 'absoluteOpacity',
        ABSOLUTE_TRANSFORM = 'absoluteTransform',
        ADD = 'add',
        B = 'b',
        BEFORE = 'before',
        BLACK = 'black',
        CHANGE = 'Change',
        CHILDREN = 'children',
        DEG = 'Deg',
        DOT = '.',
        EMPTY_STRING = '',
        G = 'g',
        GET = 'get',
        HASH = '#',
        ID = 'id',
        KINETIC = 'kinetic',
        LISTENING = 'listening',
        MOUSEENTER = 'mouseenter',
        MOUSELEAVE = 'mouseleave',
        NAME = 'name',
        OFF = 'off',
        ON = 'on',
        PRIVATE_GET = '_get',
        R = 'r',
        RGB = 'RGB',
        SET = 'set',
        SHAPE = 'Shape',
        SPACE = ' ',
        STAGE = 'Stage',
        TRANSFORM = 'transform',
        UPPER_B = 'B',
        UPPER_G = 'G',
        UPPER_HEIGHT = 'Height',
        UPPER_R = 'R',
        UPPER_WIDTH = 'Width',
        UPPER_X = 'X',
        UPPER_Y = 'Y',
        VISIBLE = 'visible',
        X = 'x',
        Y = 'y';

      Kinetic.Factory = {
          addGetterSetter: function (constructor, attr, def, validator, after) {
              this.addGetter(constructor, attr, def);
              this.addSetter(constructor, attr, validator, after);
              this.addOverloadedGetterSetter(constructor, attr);
          },
          addGetter: function (constructor, attr, def) {
              var that = this,
                method = GET + Kinetic.Util._capitalize(attr);

              constructor.prototype[method] = function () {
                  var val = this.attrs[attr];
                  return val === undefined ? def : val;
              };
          },
          addSetter: function (constructor, attr, validator, after) {
              var method = SET + Kinetic.Util._capitalize(attr);

              constructor.prototype[method] = function (val) {
                  if (validator) {
                      val = validator.call(this, val);
                  }

                  this._setAttr(attr, val);

                  if (after) {
                      after.call(this);
                  }

                  return this;
              };
          },
          addComponentsGetterSetter: function (constructor, attr, components, validator, after) {
              var len = components.length,
                capitalize = Kinetic.Util._capitalize,
                getter = GET + capitalize(attr),
                setter = SET + capitalize(attr),
                n, component;

              // getter
              constructor.prototype[getter] = function () {
                  var ret = {
                  };

                  for (n = 0; n < len; n++) {
                      component = components[n];
                      ret[component] = this.getAttr(attr + capitalize(component));
                  }

                  return ret;
              };

              // setter
              constructor.prototype[setter] = function (val) {
                  var oldVal = this.attrs[attr],
                    key;

                  if (validator) {
                      val = validator.call(this, val);
                  }

                  for (key in val) {
                      this._setAttr(attr + capitalize(key), val[key]);
                  }

                  this._fireChangeEvent(attr, oldVal, val);

                  if (after) {
                      after.call(this);
                  }

                  return this;
              };

              this.addOverloadedGetterSetter(constructor, attr);
          },
          addOverloadedGetterSetter: function (constructor, attr) {
              var that = this,
                capitalizedAttr = Kinetic.Util._capitalize(attr),
                setter = SET + capitalizedAttr,
                getter = GET + capitalizedAttr;

              constructor.prototype[attr] = function () {
                  // setting
                  if (arguments.length) {
                      this[setter](arguments[0]);
                      return this;
                  }
                  // getting
                  else {
                      return this[getter]();
                  }
              }
          },
          backCompat: function (constructor, methods) {
              var key;

              for (key in methods) {
                  constructor.prototype[key] = constructor.prototype[methods[key]];
              }
          },
          afterSetFilter: function () {
              this._filterUpToDate = false;
          }
      };

      Kinetic.Validators = {
          RGBComponent: function (val) {
              if (val > 255) {
                  return 255;
              }
              else if (val < 0) {
                  return 0;
              }
              else {
                  return Math.round(val);
              }
          },
          alphaComponent: function (val) {
              if (val > 1) {
                  return 1;
              }
              // chrome does not honor alpha values of 0
              else if (val < 0.0001) {
                  return 0.0001;
              }
              else {
                  return val;
              }
          }
      };
  })();
  ;
  (function () {
      // CONSTANTS
      var ABSOLUTE_OPACITY = 'absoluteOpacity',
        ABSOLUTE_TRANSFORM = 'absoluteTransform',
        BEFORE = 'before',
        CHANGE = 'Change',
        CHILDREN = 'children',
        DOT = '.',
        EMPTY_STRING = '',
        GET = 'get',
        ID = 'id',
        KINETIC = 'kinetic',
        LISTENING = 'listening',
        //LISTENING_ENABLED = 'listeningEnabled',
        MOUSEENTER = 'mouseenter',
        MOUSELEAVE = 'mouseleave',
        NAME = 'name',
        SET = 'set',
        SHAPE = 'Shape',
        SPACE = ' ',
        STAGE = 'stage',
        TRANSFORM = 'transform',
        UPPER_STAGE = 'Stage',
        VISIBLE = 'visible',
        TRANSFORM_CHANGE_STR = [
          'xChange.kinetic',
          'yChange.kinetic',
          'scaleXChange.kinetic',
          'scaleYChange.kinetic',
          'skewXChange.kinetic',
          'skewYChange.kinetic',
          'rotationChange.kinetic',
          'offsetXChange.kinetic',
          'offsetYChange.kinetic',
          'transformsEnabledChange.kinetic'
      ].join(SPACE);

      Kinetic.Util.addMethods(Kinetic.Node, {
          _init: function (config) {
              var that = this;
              this._id = Kinetic.idCounter++;
              this.eventListeners = {
              };
              this.attrs = {
              };
              this._cache = {
              };
              this._filterUpToDate = false;
              this.setAttrs(config);

              // event bindings for cache handling
              this.on(TRANSFORM_CHANGE_STR, function () {
                  this._clearCache(TRANSFORM);
                  that._clearSelfAndDescendantCache(ABSOLUTE_TRANSFORM);
              });
              this.on('visibleChange.kinetic', function () {
                  that._clearSelfAndDescendantCache(VISIBLE);
              });
              this.on('listeningChange.kinetic', function () {
                  that._clearSelfAndDescendantCache(LISTENING);
              });
              this.on('opacityChange.kinetic', function () {
                  that._clearSelfAndDescendantCache(ABSOLUTE_OPACITY);
              });
          },
          _clearCache: function (attr) {
              if (attr) {
                  delete this._cache[attr];
              }
              else {
                  this._cache = {
                  };
              }
          },
          _getCache: function (attr, privateGetter) {
              var cache = this._cache[attr];

              // if not cached, we need to set it using the private getter method.
              if (cache === undefined) {
                  this._cache[attr] = privateGetter.call(this);
              }

              return this._cache[attr];
          },
          /*
           * when the logic for a cached result depends on ancestor propagation, use this
           * method to clear self and children cache
           */
          _clearSelfAndDescendantCache: function (attr) {
              this._clearCache(attr);

              if (this.children) {
                  this.getChildren().each(function (node) {
                      node._clearSelfAndDescendantCache(attr);
                  });
              }
          },
          /**
           * clear cached canvas
           * @method
           * @memberof Kinetic.Node.prototype
           * @returns {Kinetic.Node}
           * @example
           * node.clearCache();
           */
          clearCache: function () {
              delete this._cache.canvas;
              this._filterUpToDate = false;
              return this;
          },
          /**
           * cache node to improve drawing performance, apply filters, or create more accurate
           *  hit regions
           * @method
           * @memberof Kinetic.Node.prototype
           * @param {Object} config
           * @param {Number} [config.x]
           * @param {Number} [config.y]
           * @param {Number} [config.width]
           * @param {Number} [config.height]
           * @param {Boolean} [config.showBorder] when set to true, a red border will be drawn around the cached
           *  region for debugging purposes
           * @returns {Kinetic.Node}
           * @example
           * // cache a shape with the x,y position of the bounding box at the center and<br>
           * // the width and height of the bounding box equal to the width and height of<br>
           * // the shape obtained from shape.width() and shape.height()<br>
           * image.cache();<br><br>
           *
           * // cache a node and define the bounding box position and size<br>
           * node.cache({<br>
           *   x: -30,<br>
           *   y: -30,<br>
           *   width: 100,<br>
           *   height: 200<br>
           * });<br><br>
           *
           * // cache a node and draw a red border around the bounding box<br>
           * // for debugging purposes<br>
           * node.cache({<br>
           *   x: -30,<br>
           *   y: -30,<br>
           *   width: 100,<br>
           *   height: 200,<br>
           *   drawBorder: true<br>
           * });
           */
          cache: function (config) {
              var conf = config || {
              },
                x = conf.x || 0,
                y = conf.y || 0,
                width = conf.width || this.width(),
                height = conf.height || this.height(),
                drawBorder = conf.drawBorder || false,
                cachedSceneCanvas = new Kinetic.SceneCanvas({
                  pixelRatio: 1,
                  width: width,
                  height: height
              }),
              cachedFilterCanvas = new Kinetic.SceneCanvas({
                  pixelRatio: 1,
                  width: width,
                  height: height
              }),
              cachedHitCanvas = new Kinetic.HitCanvas({
                  width: width,
                  height: height
              }),
              origTransEnabled = this.transformsEnabled(),
                origX = this.x(),
                origY = this.y(),
                sceneContext;

              this.clearCache();

              this.transformsEnabled('position');
              this.x(x * -1);
              this.y(y * -1);

              this.drawScene(cachedSceneCanvas);
              this.drawHit(cachedHitCanvas);

              // this will draw a red border around the cached box for
              // debugging purposes
              if (drawBorder) {
                  sceneContext = cachedSceneCanvas.getContext();
                  sceneContext.save();
                  sceneContext.beginPath();
                  sceneContext.rect(0, 0, width, height);
                  sceneContext.closePath();
                  sceneContext.setAttr('strokeStyle', 'red');
                  sceneContext.setAttr('lineWidth', 5);
                  sceneContext.stroke();
                  sceneContext.restore();
              }

              this.x(origX);
              this.y(origY);
              this.transformsEnabled(origTransEnabled);

              this._cache.canvas = {
                  scene: cachedSceneCanvas,
                  filter: cachedFilterCanvas,
                  hit: cachedHitCanvas
              };

              return this;
          },
          _drawCachedSceneCanvas: function (context) {
              context.save();
              context._applyTransform(this);
              context.drawImage(this._getCachedSceneCanvas()._canvas, 0, 0);
              context.restore();
          },
          _getCachedSceneCanvas: function () {
              var filters = this.filters(),
                cachedCanvas = this._cache.canvas,
                sceneCanvas = cachedCanvas.scene,
                filterCanvas = cachedCanvas.filter,
                filterContext = filterCanvas.getContext(),
                len, imageData, n, filter;

              if (filters) {
                  if (!this._filterUpToDate) {
                      try {
                          len = filters.length;
                          filterContext.clear();
                          // copy cached canvas onto filter context
                          filterContext.drawImage(sceneCanvas._canvas, 0, 0);
                          imageData = filterContext.getImageData(0, 0, filterCanvas.getWidth(), filterCanvas.getHeight());

                          // apply filters to filter context
                          for (n = 0; n < len; n++) {
                              filter = filters[n];
                              filter.call(this, imageData);
                              filterContext.putImageData(imageData, 0, 0);
                          }
                      }
                      catch (e) {
                          Kinetic.Util.warn('Unable to apply filter. ' + e.message);
                      }

                      this._filterUpToDate = true;
                  }

                  return filterCanvas;
              }
              else {
                  return sceneCanvas;
              }
          },
          _drawCachedHitCanvas: function (context) {
              var cachedCanvas = this._cache.canvas,
                hitCanvas = cachedCanvas.hit;

              context.save();
              context._applyTransform(this);
              context.drawImage(hitCanvas._canvas, 0, 0);
              context.restore();
          },
          /**
           * bind events to the node. KineticJS supports mouseover, mousemove,
           *  mouseout, mouseenter, mouseleave, mousedown, mouseup, click, dblclick, touchstart, touchmove,
           *  touchend, tap, dbltap, dragstart, dragmove, and dragend events. The Kinetic Stage supports
           *  contentMouseover, contentMousemove, contentMouseout, contentMousedown, contentMouseup,
           *  contentClick, contentDblclick, contentTouchstart, contentTouchmove, contentTouchend, contentTap,
           *  and contentDblTap.  Pass in a string of events delimmited by a space to bind multiple events at once
           *  such as 'mousedown mouseup mousemove'. Include a namespace to bind an
           *  event by name such as 'click.foobar'.
           * @method
           * @memberof Kinetic.Node.prototype
           * @param {String} evtStr e.g. 'click', 'mousedown touchstart', 'mousedown.foo touchstart.foo'
           * @param {Function} handler The handler function is passed an event object
           * @returns {Kinetic.Node}
           * @example
           * // add click listener<br>
           * node.on('click', function() {<br>
           *   console.log('you clicked me!');<br>
           * });<br><br>
           *
           * // get the target node<br>
           * node.on('click', function(evt) {<br>
           *   console.log(evt.targetNode);<br>
           * });<br><br>
           *
           * // stop event propagation<br>
           * node.on('click', function(evt) {<br>
           *   evt.cancelBubble = true;<br>
           * });<br><br>
           *
           * // bind multiple listeners<br>
           * node.on('click touchstart', function() {<br>
           *   console.log('you clicked/touched me!');<br>
           * });<br><br>
           *
           * // namespace listener<br>
           * node.on('click.foo', function() {<br>
           *   console.log('you clicked/touched me!');<br>
           * });
           */
          on: function (evtStr, handler) {
              var events = evtStr.split(SPACE),
                len = events.length,
                n, event, parts, baseEvent, name;

              /*
               * loop through types and attach event listeners to
               * each one.  eg. 'click mouseover.namespace mouseout'
               * will create three event bindings
               */
              for (n = 0; n < len; n++) {
                  event = events[n];
                  parts = event.split(DOT);
                  baseEvent = parts[0];
                  name = parts[1] || EMPTY_STRING;

                  // create events array if it doesn't exist
                  if (!this.eventListeners[baseEvent]) {
                      this.eventListeners[baseEvent] = [
                      ];
                  }

                  this.eventListeners[baseEvent].push({
                      name: name,
                      handler: handler
                  });

                  // NOTE: this flag is set to true when any event handler is added, even non
                  // mouse or touch gesture events.  This improves performance for most
                  // cases where users aren't using events, but is still very light weight.
                  // To ensure perfect accuracy, devs can explicitly set listening to false.
                  /*
                   if (name !== KINETIC) {
                   this._listeningEnabled = true;
                   this._clearSelfAndAncestorCache(LISTENING_ENABLED);
                   }
                   */
              }

              return this;
          },
          /**
           * remove event bindings from the node. Pass in a string of
           *  event types delimmited by a space to remove multiple event
           *  bindings at once such as 'mousedown mouseup mousemove'.
           *  include a namespace to remove an event binding by name
           *  such as 'click.foobar'. If you only give a name like '.foobar',
           *  all events in that namespace will be removed.
           * @method
           * @memberof Kinetic.Node.prototype
           * @param {String} evtStr e.g. 'click', 'mousedown touchstart', '.foobar'
           * @returns {Kinetic.Node}
           * @example
           * // remove listener<br>
           * node.off('click');<br><br>
           *
           * // remove multiple listeners<br>
           * node.off('click touchstart');<br><br>
           *
           * // remove listener by name<br>
           * node.off('click.foo');
           */
          off: function (evtStr) {
              var events = evtStr.split(SPACE),
                len = events.length,
                n, t, event, parts, baseEvent, name;

              for (n = 0; n < len; n++) {
                  event = events[n];
                  parts = event.split(DOT);
                  baseEvent = parts[0];
                  name = parts[1];

                  if (baseEvent) {
                      if (this.eventListeners[baseEvent]) {
                          this._off(baseEvent, name);
                      }
                  }
                  else {
                      for (t in this.eventListeners) {
                          this._off(t, name);
                      }
                  }
              }
              return this;
          },
          /**
           * remove self from parent, but don't destroy
           * @method
           * @memberof Kinetic.Node.prototype
           * @returns {Kinetic.Node}
           * @example
           * node.remove();
           */
          remove: function () {
              var parent = this.getParent();

              if (parent && parent.children) {
                  parent.children.splice(this.index, 1);
                  parent._setChildrenIndices();
                  delete this.parent;
              }

              // every cached attr that is calculated via node tree
              // traversal must be cleared when removing a node
              this._clearSelfAndDescendantCache(STAGE);
              this._clearSelfAndDescendantCache(ABSOLUTE_TRANSFORM);
              this._clearSelfAndDescendantCache(VISIBLE);
              this._clearSelfAndDescendantCache(LISTENING);
              this._clearSelfAndDescendantCache(ABSOLUTE_OPACITY);

              return this;
          },
          /**
           * remove and destroy self
           * @method
           * @memberof Kinetic.Node.prototype
           * @example
           * node.destroy();
           */
          destroy: function () {
              // remove from ids and names hashes
              Kinetic._removeId(this.getId());
              Kinetic._removeName(this.getName(), this._id);

              this.remove();
          },
          /**
           * get attr
           * @method
           * @memberof Kinetic.Node.prototype
           * @param {String} attr
           * @returns {Integer|String|Object|Array}
           * @example
           * var x = node.getAttr('x');
           */
          getAttr: function (attr) {
              var method = GET + Kinetic.Util._capitalize(attr);
              if (Kinetic.Util._isFunction(this[method])) {
                  return this[method]();
              }
              // otherwise get directly
              else {
                  return this.attrs[attr];
              }
          },
          /**
           * get ancestors
           * @method
           * @memberof Kinetic.Node.prototype
           * @returns {Kinetic.Collection}
           * @example
           * shape.getAncestors().each(function(node) {
           *   console.log(node.getId());
           * })
           */
          getAncestors: function () {
              var parent = this.getParent(),
                ancestors = new Kinetic.Collection();

              while (parent) {
                  ancestors.push(parent);
                  parent = parent.getParent();
              }

              return ancestors;
          },
          /**
           * get attrs object literal
           * @method
           * @memberof Kinetic.Node.prototype
           * @returns {Object}
           */
          getAttrs: function () {
              return this.attrs || {
              };
          },
          /**
           * set multiple attrs at once using an object literal
           * @method
           * @memberof Kinetic.Node.prototype
           * @param {Object} config object containing key value pairs
           * @returns {Kinetic.Node}
           * @example
           * node.setAttrs({<br>
           *   x: 5,<br>
           *   fill: 'red'<br>
           * });<br>
           */
          setAttrs: function (config) {
              var key, method;

              if (config) {
                  for (key in config) {
                      if (key === CHILDREN) {

                      }
                      else {
                          method = SET + Kinetic.Util._capitalize(key);
                          // use setter if available
                          if (Kinetic.Util._isFunction(this[method])) {
                              this[method](config[key]);
                          }
                          // otherwise set directly
                          else {
                              this._setAttr(key, config[key]);
                          }
                      }
                  }
              }
              return this;
          },
          /**
           * determine if node is listening for events by taking into account ancestors.
           *
           * Parent    | Self      | isListening
           * listening | listening |
           * ----------+-----------+------------
           * T         | T         | T
           * T         | F         | F
           * F         | T         | T
           * F         | F         | F
           * ----------+-----------+------------
           * T         | I         | T
           * F         | I         | F
           * I         | I         | T
           *
           * @method
           * @memberof Kinetic.Node.prototype
           * @returns {Boolean}
           */
          isListening: function () {
              return this._getCache(LISTENING, this._isListening);
          },
          _isListening: function () {
              var listening = this.getListening(),
                parent = this.getParent();

              // the following conditions are a simplification of the truth table above.
              // please modify carefully
              if (listening === 'inherit') {
                  if (parent) {
                      return parent.isListening();
                  }
                  else {
                      return true;
                  }
              }
              else {
                  return listening;
              }
          },
          /**
           * determine if node is visible by taking into account ancestors.
           *
           * Parent    | Self      | isVisible
           * visible   | visible   |
           * ----------+-----------+------------
           * T         | T         | T
           * T         | F         | F
           * F         | T         | T
           * F         | F         | F
           * ----------+-----------+------------
           * T         | I         | T
           * F         | I         | F
           * I         | I         | T

           * @method
           * @memberof Kinetic.Node.prototype
           * @returns {Boolean}
           */
          isVisible: function () {
              return this._getCache(VISIBLE, this._isVisible);
          },
          _isVisible: function () {
              var visible = this.getVisible(),
                parent = this.getParent();

              // the following conditions are a simplification of the truth table above.
              // please modify carefully
              if (visible === 'inherit') {
                  if (parent) {
                      return parent.isVisible();
                  }
                  else {
                      return true;
                  }
              }
              else {
                  return visible;
              }
          },
          /**
           * determine if listening is enabled by taking into account descendants.  If self or any children
           * have _isListeningEnabled set to true, then self also has listening enabled.
           * @method
           * @memberof Kinetic.Node.prototype
           * @returns {Boolean}
           */
          shouldDrawHit: function () {
              var layer = this.getLayer();
              return  layer && layer.hitGraphEnabled() && this.isListening() && this.isVisible() && !Kinetic.isDragging();
          },
          /**
           * show node
           * @method
           * @memberof Kinetic.Node.prototype
           * @returns {Kinetic.Node}
           */
          show: function () {
              this.setVisible(true);
              return this;
          },
          /**
           * hide node.  Hidden nodes are no longer detectable
           * @method
           * @memberof Kinetic.Node.prototype
           * @returns {Kinetic.Node}
           */
          hide: function () {
              this.setVisible(false);
              return this;
          },
          /**
           * get zIndex relative to the node's siblings who share the same parent
           * @method
           * @memberof Kinetic.Node.prototype
           * @returns {Integer}
           */
          getZIndex: function () {
              return this.index || 0;
          },
          /**
           * get absolute z-index which takes into account sibling
           *  and ancestor indices
           * @method
           * @memberof Kinetic.Node.prototype
           * @returns {Integer}
           */
          getAbsoluteZIndex: function () {
              var depth = this.getDepth(),
                that = this,
                index = 0,
                nodes, len, n, child;

              function addChildren (children) {
                  nodes = [
                  ];
                  len = children.length;
                  for (n = 0; n < len; n++) {
                      child = children[n];
                      index++;

                      if (child.nodeType !== SHAPE) {
                          nodes = nodes.concat(child.getChildren().toArray());
                      }

                      if (child._id === that._id) {
                          n = len;
                      }
                  }

                  if (nodes.length > 0 && nodes[0].getDepth() <= depth) {
                      addChildren(nodes);
                  }
              }
              if (that.nodeType !== UPPER_STAGE) {
                  addChildren(that.getStage().getChildren());
              }

              return index;
          },
          /**
           * get node depth in node tree.  Returns an integer.<br><br>
           *  e.g. Stage depth will always be 0.  Layers will always be 1.  Groups and Shapes will always
           *  be >= 2
           * @method
           * @memberof Kinetic.Node.prototype
           * @returns {Integer}
           */
          getDepth: function () {
              var depth = 0,
                parent = this.parent;

              while (parent) {
                  depth++;
                  parent = parent.parent;
              }
              return depth;
          },
          setPosition: function (pos) {
              this.setX(pos.x);
              this.setY(pos.y);
              return this;
          },
          getPosition: function () {
              return {
                  x: this.getX(),
                  y: this.getY()
              };
          },
          /**
           * get absolute position relative to the top left corner of the stage container div
           * @method
           * @memberof Kinetic.Node.prototype
           * @returns {Object}
           */
          getAbsolutePosition: function () {
              var absoluteMatrix = this.getAbsoluteTransform().getMatrix(),
                absoluteTransform = new Kinetic.Transform(),
                offset = this.offset();

              // clone the matrix array
              absoluteTransform.m = absoluteMatrix.slice();
              absoluteTransform.translate(offset.x, offset.y);

              return absoluteTransform.getTranslation();
          },
          /**
           * set absolute position
           * @method
           * @memberof Kinetic.Node.prototype
           * @param {Object} pos
           * @param {Number} pos.x
           * @param {Number} pos.y
           * @returns {Kinetic.Node}
           */
          setAbsolutePosition: function (pos) {
              var origTrans = this._clearTransform(),
                it;

              // don't clear translation
              this.attrs.x = origTrans.x;
              this.attrs.y = origTrans.y;
              delete origTrans.x;
              delete origTrans.y;

              // unravel transform
              it = this.getAbsoluteTransform();

              it.invert();
              it.translate(pos.x, pos.y);
              pos = {
                  x: this.attrs.x + it.getTranslation().x,
                  y: this.attrs.y + it.getTranslation().y
              };

              this.setPosition({
                  x: pos.x,
                  y: pos.y
              });
              this._setTransform(origTrans);

              return this;
          },
          _setTransform: function (trans) {
              var key;

              for (key in trans) {
                  this.attrs[key] = trans[key];
              }

              this._clearCache(TRANSFORM);
              this._clearSelfAndDescendantCache(ABSOLUTE_TRANSFORM);
          },
          _clearTransform: function () {
              var trans = {
                  x: this.getX(),
                  y: this.getY(),
                  rotation: this.getRotation(),
                  scaleX: this.getScaleX(),
                  scaleY: this.getScaleY(),
                  offsetX: this.getOffsetX(),
                  offsetY: this.getOffsetY(),
                  skewX: this.getSkewX(),
                  skewY: this.getSkewY()
              };

              this.attrs.x = 0;
              this.attrs.y = 0;
              this.attrs.rotation = 0;
              this.attrs.scaleX = 1;
              this.attrs.scaleY = 1;
              this.attrs.offsetX = 0;
              this.attrs.offsetY = 0;
              this.attrs.skewX = 0;
              this.attrs.skewY = 0;

              this._clearCache(TRANSFORM);
              this._clearSelfAndDescendantCache(ABSOLUTE_TRANSFORM);

              // return original transform
              return trans;
          },
          /**
           * move node by an amount relative to its current position
           * @method
           * @memberof Kinetic.Node.prototype
           * @param {Object} change
           * @param {Number} change.x
           * @param {Number} change.y
           * @returns {Kinetic.Node}
           * @example
           * // move node in x direction by 1px and y direction by 2px<br>
           * node.move({<br>
           *   x: 1,<br>
           *   y: 2)<br>
           * });
           */
          move: function (change) {
              var changeX = change.x,
                changeY = change.y,
                x = this.getX(),
                y = this.getY();

              if (changeX !== undefined) {
                  x += changeX;
              }

              if (changeY !== undefined) {
                  y += changeY;
              }

              this.setPosition({
                  x: x,
                  y: y
              });
              return this;
          },
          _eachAncestorReverse: function (func, includeSelf) {
              var family = [
              ],
                parent = this.getParent(),
                len, n;

              // build family by traversing ancestors
              if (includeSelf) {
                  family.unshift(this);
              }
              while (parent) {
                  family.unshift(parent);
                  parent = parent.parent;
              }

              len = family.length;
              for (n = 0; n < len; n++) {
                  func(family[n]);
              }
          },
          /**
           * rotate node by an amount in degrees relative to its current rotation
           * @method
           * @memberof Kinetic.Node.prototype
           * @param {Number} theta
           * @returns {Kinetic.Node}
           */
          rotate: function (theta) {
              this.setRotation(this.getRotation() + theta);
              return this;
          },
          /**
           * move node to the top of its siblings
           * @method
           * @memberof Kinetic.Node.prototype
           * @returns {Boolean}
           */
          moveToTop: function () {
              var index = this.index;
              this.parent.children.splice(index, 1);
              this.parent.children.push(this);
              this.parent._setChildrenIndices();
              return true;
          },
          /**
           * move node up
           * @method
           * @memberof Kinetic.Node.prototype
           * @returns {Boolean}
           */
          moveUp: function () {
              var index = this.index,
                len = this.parent.getChildren().length;
              if (index < len - 1) {
                  this.parent.children.splice(index, 1);
                  this.parent.children.splice(index + 1, 0, this);
                  this.parent._setChildrenIndices();
                  return true;
              }
              return false;
          },
          /**
           * move node down
           * @method
           * @memberof Kinetic.Node.prototype
           * @returns {Boolean}
           */
          moveDown: function () {
              var index = this.index;
              if (index > 0) {
                  this.parent.children.splice(index, 1);
                  this.parent.children.splice(index - 1, 0, this);
                  this.parent._setChildrenIndices();
                  return true;
              }
              return false;
          },
          /**
           * move node to the bottom of its siblings
           * @method
           * @memberof Kinetic.Node.prototype
           * @returns {Boolean}
           */
          moveToBottom: function () {
              var index = this.index;
              if (index > 0) {
                  this.parent.children.splice(index, 1);
                  this.parent.children.unshift(this);
                  this.parent._setChildrenIndices();
                  return true;
              }
              return false;
          },
          /**
           * set zIndex relative to siblings
           * @method
           * @memberof Kinetic.Node.prototype
           * @param {Integer} zIndex
           * @returns {Kinetic.Node}
           */
          setZIndex: function (zIndex) {
              var index = this.index;
              this.parent.children.splice(index, 1);
              this.parent.children.splice(zIndex, 0, this);
              this.parent._setChildrenIndices();
              return this;
          },
          /**
           * get absolute opacity
           * @method
           * @memberof Kinetic.Node.prototype
           * @returns {Number}
           */
          getAbsoluteOpacity: function () {
              return this._getCache(ABSOLUTE_OPACITY, this._getAbsoluteOpacity);
          },
          _getAbsoluteOpacity: function () {
              var absOpacity = this.getOpacity();
              if (this.getParent()) {
                  absOpacity *= this.getParent().getAbsoluteOpacity();
              }
              return absOpacity;
          },
          /**
           * move node to another container
           * @method
           * @memberof Kinetic.Node.prototype
           * @param {Container} newContainer
           * @returns {Kinetic.Node}
           * @example
           * // move node from current layer into layer2<br>
           * node.moveTo(layer2);
           */
          moveTo: function (newContainer) {
              Kinetic.Node.prototype.remove.call(this);
              newContainer.add(this);
              return this;
          },
          /**
           * @CUSTOM
           * @author Sino Boeckmann
           * Damit wir wissen ob wir dieses Element bereits durchlaufen haben lassen
           */
          jsonLooped: false,
          /**
           * @CUSTOM
           * @author Sino Boeckmann
           * Damit wir wissen ob wir dieses Element bereits zu einem String formiert haben
           */
          jsonAlreadyStringify: false,
          /**
           * @CUSTOM
           * @author Sino Boeckmann
           * Darin speichern wir unser fr JSON vorbereitetes Objekt
           */
          jsonObject: null,
          /**
           * @CUSTOM
           * @author Sino Boeckmann
           *
           * convert Node into an object for serialization.  Returns an object.
           * @method
           * @memberof Kinetic.Node.prototype
           * @returns {Object}
           */
          toObject: function () {
              var type = Kinetic.Util,
                obj = new Object,
                attrs = this.getAttrs(),
                key, val, getter, defaultValue;

              obj.attrs = new Object;

              // serialize only attributes that are not function, image, DOM, or objects with methods
              for (key in attrs) {
                  val = attrs[key];
                  if (!type._isFunction(val) && !type._isElement(val) && !(type._isObject(val) && type._hasMethods(val))) {
                      getter = this[key];
                      // remove attr value so that we can extract the default value from the getter
                      delete attrs[key];
                      defaultValue = getter ? getter.call(this) : null;
                      // restore attr value
                      attrs[key] = val;
                      if (defaultValue !== val) {
                          obj.attrs[key] = val;
                      }
                  }
              }

              obj.className = this.getClassName();

              //Wir merken uns den Durchlauf
              this.jsonLooped = true;
              //Und das Objekt
              this.jsonObject = obj;

              return obj;
          },
          /**
           * @CUSTOM
           * @author Sino Boeckmann
           *
           * convert Node into a JSON string.  Returns a JSON string.
           * @method
           * @memberof Kinetic.Node.prototype
           * @returns {String}}
           */
          toJSON: function (functionReplacer) {
              if (this.jsonAlreadyStringify === true)
                  return;

              var objectPrepared = new Object;
              if (this.jsonLooped === true) {
                  objectPrepared = this.jsonObject;
              }
              else {
                  objectPrepared = this.toObject();
                  this.jsonAlreadyStringify = true;
              }

              return JSON.stringify(objectPrepared, functionReplacer || function () {
              });
          },
          /**
           * @CUSTOM
           * @author Sino Boeckmann
           * Damit setzen wir die Informationen wieder auf  den Ursprung
           */
          resetJsonOperations: function () {
              this.jsonLooped = false;
              this.jsonAlreadyStringify = false;
              this.jsonObject = null;
          },
          /**
           * get parent container
           * @method
           * @memberof Kinetic.Node.prototype
           * @returns {Kinetic.Node}
           */
          getParent: function () {
              return this.parent;
          },
          /**
           * get layer ancestor
           * @method
           * @memberof Kinetic.Node.prototype
           * @returns {Kinetic.Layer}
           */
          getLayer: function () {
              var parent = this.getParent();
              return parent ? parent.getLayer() : null;
          },
          /**
           * get stage ancestor
           * @method
           * @memberof Kinetic.Node.prototype
           * @returns {Kinetic.Stage}
           */
          getStage: function () {
              return this._getCache(STAGE, this._getStage);
          },
          _getStage: function () {
              var parent = this.getParent();
              if (parent) {
                  return parent.getStage();
              }
              else {
                  return undefined;
              }
          },
          /**
           * fire event
           * @method
           * @memberof Kinetic.Node.prototype
           * @param {String} eventType event type.  can be a regular event, like click, mouseover, or mouseout, or it can be a custom event, like myCustomEvent
           * @param {EventObject} [evt] event object
           * @param {Boolean} [bubble] setting the value to false, or leaving it undefined, will result in the event
           *  not bubbling.  Setting the value to true will result in the event bubbling.
           * @returns {Kinetic.Node}
           * @example
           * // manually fire click event<br>
           * node.fire('click');<br><br>
           *
           * // fire custom event<br>
           * node.fire('foo');<br><br>
           *
           * // fire custom event with custom event object<br>
           * node.fire('foo', {<br>
           *   bar: 10<br>
           * });<br><br>
           *
           * // fire click event that bubbles<br>
           * node.fire('click', null, true);
           */
          fire: function (eventType, evt, bubble) {
              // bubble
              if (bubble) {
                  this._fireAndBubble(eventType, evt || {
                  });
              }
              // no bubble
              else {
                  this._fire(eventType, evt || {
                  });
              }
              return this;
          },
          /**
           * get absolute transform of the node which takes into
           *  account its ancestor transforms
           * @method
           * @memberof Kinetic.Node.prototype
           * @returns {Kinetic.Transform}
           */
          getAbsoluteTransform: function () {
              return this._getCache(ABSOLUTE_TRANSFORM, this._getAbsoluteTransform);
          },
          _getAbsoluteTransform: function () {
              var at = new Kinetic.Transform(),
                transformsEnabled, trans;

              // start with stage and traverse downwards to self
              this._eachAncestorReverse(function (node) {
                  transformsEnabled = node.transformsEnabled();
                  trans = node.getTransform();

                  if (transformsEnabled === 'all') {
                      at.multiply(trans);
                  }
                  else if (transformsEnabled === 'position') {
                      at.translate(node.x(), node.y());
                  }
              }, true);
              return at;
          },
          /**
           * get transform of the node
           * @method
           * @memberof Kinetic.Node.prototype
           * @returns {Kinetic.Transform}
           */
          getTransform: function () {
              return this._getCache(TRANSFORM, this._getTransform);
          },
          _getTransform: function () {
              var m = new Kinetic.Transform(),
                x = this.getX(),
                y = this.getY(),
                rotation = this.getRotation() * Math.PI / 180,
                scaleX = this.getScaleX(),
                scaleY = this.getScaleY(),
                skewX = this.getSkewX(),
                skewY = this.getSkewY(),
                offsetX = this.getOffsetX(),
                offsetY = this.getOffsetY();

              if (x !== 0 || y !== 0) {
                  m.translate(x, y);
              }
              if (rotation !== 0) {
                  m.rotate(rotation);
              }
              if (skewX !== 0 || skewY !== 0) {
                  m.skew(skewX, skewY);
              }
              if (scaleX !== 1 || scaleY !== 1) {
                  m.scale(scaleX, scaleY);
              }
              if (offsetX !== 0 || offsetY !== 0) {
                  m.translate(-1 * offsetX, -1 * offsetY);
              }

              return m;
          },
          /**
           * clone node.  Returns a new Node instance with identical attributes.  You can also override
           *  the node properties with an object literal, enabling you to use an existing node as a template
           *  for another node
           * @method
           * @memberof Kinetic.Node.prototype
           * @param {Object} attrs override attrs
           * @returns {Kinetic.Node}
           * @example
           * // simple clone<br>
           * var clone = node.clone();<br><br>
           *
           * // clone a node and override the x position<br>
           * var clone = rect.clone({<br>
           *   x: 5<br>
           * });
           */
          clone: function (obj) {
              // instantiate new node
              var className = this.getClassName(),
                node = new Kinetic[className](this.attrs),
                key, allListeners, len, n, listener;

              // copy over listeners
              for (key in this.eventListeners) {
                  allListeners = this.eventListeners[key];
                  len = allListeners.length;
                  for (n = 0; n < len; n++) {
                      listener = allListeners[n];
                      /*
                       * don't include kinetic namespaced listeners because
                       *  these are generated by the constructors
                       */
                      if (listener.name.indexOf(KINETIC) < 0) {
                          // if listeners array doesn't exist, then create it
                          if (!node.eventListeners[key]) {
                              node.eventListeners[key] = [
                              ];
                          }
                          node.eventListeners[key].push(listener);
                      }
                  }
              }

              // apply attr overrides
              node.setAttrs(obj);
              return node;
          },
          /**
           * Creates a composite data URL. If MIME type is not
           * specified, then "image/png" will result. For "image/jpeg", specify a quality
           * level as quality (range 0.0 - 1.0)
           * @method
           * @memberof Kinetic.Node.prototype
           * @param {Object} config
           * @param {String} [config.mimeType] can be "image/png" or "image/jpeg".
           *  "image/png" is the default
           * @param {Number} [config.x] x position of canvas section
           * @param {Number} [config.y] y position of canvas section
           * @param {Number} [config.width] width of canvas section
           * @param {Number} [config.height] height of canvas section
           * @param {Number} [config.quality] jpeg quality.  If using an "image/jpeg" mimeType,
           *  you can specify the quality from 0 to 1, where 0 is very poor quality and 1
           *  is very high quality
           * @returns {String}
           */
          toDataURL: function (config) {
              config = config || {
              };

              var mimeType = config.mimeType || null,
                quality = config.quality || null,
                stage = this.getStage(),
                x = config.x || 0,
                y = config.y || 0,
                canvas = new Kinetic.SceneCanvas({
                  width: config.width || this.getWidth() || (stage ? stage.getWidth() : 0),
                  height: config.height || this.getHeight() || (stage ? stage.getHeight() : 0),
                  pixelRatio: 1
              }),
              context = canvas.getContext();

              context.save();

              if (x || y) {
                  context.translate(-1 * x, -1 * y);
              }

              this.drawScene(canvas);
              context.restore();

              return canvas.toDataURL(mimeType, quality);
          },
          /**
           * converts node into an image.  Since the toImage
           *  method is asynchronous, a callback is required.  toImage is most commonly used
           *  to cache complex drawings as an image so that they don't have to constantly be redrawn
           * @method
           * @memberof Kinetic.Node.prototype
           * @param {Object} config
           * @param {Function} config.callback function executed when the composite has completed
           * @param {String} [config.mimeType] can be "image/png" or "image/jpeg".
           *  "image/png" is the default
           * @param {Number} [config.x] x position of canvas section
           * @param {Number} [config.y] y position of canvas section
           * @param {Number} [config.width] width of canvas section
           * @param {Number} [config.height] height of canvas section
           * @param {Number} [config.quality] jpeg quality.  If using an "image/jpeg" mimeType,
           *  you can specify the quality from 0 to 1, where 0 is very poor quality and 1
           *  is very high quality
           * @example
           * var image = node.toImage({<br>
           *   callback: function(img) {<br>
           *     // do stuff with img<br>
           *   }<br>
           * });
           */
          toImage: function (config) {
              Kinetic.Util._getImage(this.toDataURL(config), function (img) {
                  config.callback(img);
              });
          },
          /**
           * set size
           * @method
           * @memberof Kinetic.Node.prototype
           * @param {Object} size
           * @param {Number} width
           * @param {Number} height
           * @returns {Kinetic.Node}
           */
          setSize: function (size) {
              this.setWidth(size.width);
              this.setHeight(size.height);
              return this;
          },
          /**
           * get size
           * @method
           * @memberof Kinetic.Node.prototype
           * @returns {Object}
           */
          getSize: function () {
              return {
                  width: this.getWidth(),
                  height: this.getHeight()
              };
          },
          /**
           * get width
           * @method
           * @memberof Kinetic.Node.prototype
           * @returns {Integer}
           */
          getWidth: function () {
              return this.attrs.width || 0;
          },
          /**
           * get height
           * @method
           * @memberof Kinetic.Node.prototype
           * @returns {Integer}
           */
          getHeight: function () {
              return this.attrs.height || 0;
          },
          /**
           * get class name, which may return Stage, Layer, Group, or shape class names like Rect, Circle, Text, etc.
           * @method
           * @memberof Kinetic.Node.prototype
           * @returns {String}
           */
          getClassName: function () {
              return this.className || this.nodeType;
          },
          /**
           * get the node type, which may return Stage, Layer, Group, or Node
           * @method
           * @memberof Kinetic.Node.prototype
           * @returns {String}
           */
          getType: function () {
              return this.nodeType;
          },
          _get: function (selector) {
              return this.nodeType === selector ? [
                  this
              ] : [
              ];
          },
          _off: function (type, name) {
              var evtListeners = this.eventListeners[type],
                i, evtName;

              for (i = 0; i < evtListeners.length; i++) {
                  evtName = evtListeners[i].name;
                  // the following two conditions must be true in order to remove a handler:
                  // 1) the current event name cannot be kinetic unless the event name is kinetic
                  //    this enables developers to force remove a kinetic specific listener for whatever reason
                  // 2) an event name is not specified, or if one is specified, it matches the current event name
                  if ((evtName !== 'kinetic' || name === 'kinetic') && (!name || evtName === name)) {
                      evtListeners.splice(i, 1);
                      if (evtListeners.length === 0) {
                          delete this.eventListeners[type];
                          break;
                      }
                      i--;
                  }
              }
          },
          _fireBeforeChangeEvent: function (attr, oldVal, newVal) {
              this._fire([
                  BEFORE,
                  Kinetic.Util._capitalize(attr),
                  CHANGE
              ].join(EMPTY_STRING), {
                  oldVal: oldVal,
                  newVal: newVal
              });
          },
          _fireChangeEvent: function (attr, oldVal, newVal) {
              this._fire(attr + CHANGE, {
                  oldVal: oldVal,
                  newVal: newVal
              });
          },
          /**
           * set id
           * @method
           * @memberof Kinetic.Node.prototype
           * @param {String} id
           * @returns {Kinetic.Node}
           */
          setId: function (id) {
              var oldId = this.getId();

              Kinetic._removeId(oldId);
              Kinetic._addId(this, id);
              this._setAttr(ID, id);
              return this;
          },
          setName: function (name) {
              var oldName = this.getName();

              Kinetic._removeName(oldName, this._id);
              Kinetic._addName(this, name);
              this._setAttr(NAME, name);
              return this;
          },
          /**
           * set attr
           * @method
           * @memberof Kinetic.Node.prototype
           * @param {String} attr
           * @param {*} val
           * @returns {Kinetic.Node}
           * @example
           * node.setAttr('x', 5);
           */
          setAttr: function () {
              var args = Array.prototype.slice.call(arguments),
                attr = args[0],
                val = args[1],
                method = SET + Kinetic.Util._capitalize(attr),
                func = this[method];

              if (Kinetic.Util._isFunction(func)) {
                  func.call(this, val);
              }
              // otherwise set directly
              else {
                  this._setAttr(attr, val);
              }
              return this;
          },
          _setAttr: function (key, val) {
              var oldVal;
              if (val !== undefined) {
                  oldVal = this.attrs[key];
                  this.attrs[key] = val;
                  this._fireChangeEvent(key, oldVal, val);
              }
          },
          _setComponentAttr: function (key, component, val) {
              var oldVal;
              if (val !== undefined) {
                  oldVal = this.attrs[key];

                  if (!oldVal) {
                      // set value to default value using getAttr
                      this.attrs[key] = this.getAttr(key);
                  }

                  //this._fireBeforeChangeEvent(key, oldVal, val);
                  this.attrs[key][component] = val;
                  this._fireChangeEvent(key, oldVal, val);
              }
          },
          _fireAndBubble: function (eventType, evt, compareShape) {
              var okayToRun = true;

              if (evt && this.nodeType === SHAPE) {
                  evt.targetNode = this;
              }

              if (eventType === MOUSEENTER && compareShape && this._id === compareShape._id) {
                  okayToRun = false;
              }
              else if (eventType === MOUSELEAVE && compareShape && this._id === compareShape._id) {
                  okayToRun = false;
              }

              if (okayToRun) {
                  this._fire(eventType, evt);

                  // simulate event bubbling
                  if (evt && !evt.cancelBubble && this.parent) {
                      if (compareShape && compareShape.parent) {
                          this._fireAndBubble.call(this.parent, eventType, evt, compareShape.parent);
                      }
                      else {
                          this._fireAndBubble.call(this.parent, eventType, evt);
                      }
                  }
              }
          },
          _fire: function (eventType, evt) {
              var events = this.eventListeners[eventType],
                i;

              if (events) {
                  for (i = 0; i < events.length; i++) {
                      events[i].handler.call(this, evt);
                  }
              }
          },
          /**
           * draw both scene and hit graphs.  If the node being drawn is the stage, all of the layers will be cleared and redrawn
           * @method
           * @memberof Kinetic.Node.prototype
           * @returns {Kinetic.Node}
           */
          draw: function () {
              this.drawScene();
              this.drawHit();
              return this;
          }
      });

      /**
       * create node with JSON string.  De-serializtion does not generate custom
       *  shape drawing functions, images, or event handlers (this would make the
       *  serialized object huge).  If your app uses custom shapes, images, and
       *  event handlers (it probably does), then you need to select the appropriate
       *  shapes after loading the stage and set these properties via on(), setDrawFunc(),
       *  and setImage() methods
       * @method
       * @memberof Kinetic.Node
       * @param {String} JSON string
       * @param {DomElement} [container] optional container dom element used only if you're
       *  creating a stage node
       */
      Kinetic.Node.create = function (json, container) {
          return this._createNode(JSON.parse(json), container);
      };
      Kinetic.Node._createNode = function (obj, container) {
          var className = Kinetic.Node.prototype.getClassName.call(obj),
            children = obj.children,
            no, len, n;

          // if container was passed in, add it to attrs
          if (container) {
              obj.attrs.container = container;
          }

          no = new Kinetic[className](obj.attrs);
          if (children) {
              len = children.length;
              for (n = 0; n < len; n++) {
                  no.add(this._createNode(children[n]));
              }
          }

          return no;
      };


      // =========================== add getters setters ===========================

      Kinetic.Factory.addOverloadedGetterSetter(Kinetic.Node, 'position');
      /**
       * get/set node position relative to parent
       * @name position
       * @method
       * @memberof Kinetic.Node.prototype
       * @param {Object} pos
       * @param {Number} pos.x
       * @param {Nubmer} pos.y
       * @returns {Object}
       * @example
       * // get position<br>
       * var position = node.position();<br><br>
       *
       * // set position<br>
       * node.position({<br>
       *   x: 5<br>
       *   y: 10<br>
       * });
       */

      Kinetic.Factory.addGetterSetter(Kinetic.Node, 'x', 0);

      /**
       * get/set x position
       * @name x
       * @method
       * @memberof Kinetic.Node.prototype
       * @param {Number} x
       * @returns {Object}
       * @example
       * // get x<br>
       * var x = node.x();<br><br>
       *
       * // set x<br>
       * node.x(5);
       */

      Kinetic.Factory.addGetterSetter(Kinetic.Node, 'y', 0);

      /**
       * get/set y position
       * @name y
       * @method
       * @memberof Kinetic.Node.prototype
       * @param {Number} y
       * @returns {Integer}
       * @example
       * // get y<br>
       * var y = node.y();<br><br>
       *
       * // set y<br>
       * node.y(5);
       */

      Kinetic.Factory.addGetterSetter(Kinetic.Node, 'opacity', 1);

      /**
       * get/set opacity.  Opacity values range from 0 to 1.
       *  A node with an opacity of 0 is fully transparent, and a node
       *  with an opacity of 1 is fully opaque
       * @name opacity
       * @method
       * @memberof Kinetic.Node.prototype
       * @param {Object} opacity
       * @returns {Number}
       * @example
       * // get opacity<br>
       * var opacity = node.opacity();<br><br>
       *
       * // set opacity<br>
       * node.opacity(0.5);
       */

      Kinetic.Factory.addGetter(Kinetic.Node, 'name');
      Kinetic.Factory.addOverloadedGetterSetter(Kinetic.Node, 'name');

      /**
       * get/set name
       * @name name
       * @method
       * @memberof Kinetic.Node.prototype
       * @param {String} name
       * @returns {String}
       * @example
       * // get name<br>
       * var name = node.name();<br><br>
       *
       * // set name<br>
       * node.name('foo');
       */

      Kinetic.Factory.addGetter(Kinetic.Node, 'id');
      Kinetic.Factory.addOverloadedGetterSetter(Kinetic.Node, 'id');

      /**
       * get/set id
       * @name id
       * @method
       * @memberof Kinetic.Node.prototype
       * @param {String} id
       * @returns {String}
       * @example
       * // get id<br>
       * var name = node.id();<br><br>
       *
       * // set id<br>
       * node.id('foo');
       */

      Kinetic.Factory.addGetterSetter(Kinetic.Node, 'rotation', 0);

      /**
       * get/set rotation in degrees
       * @name rotation
       * @method
       * @memberof Kinetic.Node.prototype
       * @param {Number} rotation
       * @returns {Number}
       * @example
       * // get rotation in degrees<br>
       * var rotation = node.rotation();<br><br>
       *
       * // set rotation in degrees<br>
       * node.rotation(45);
       */

      Kinetic.Factory.addComponentsGetterSetter(Kinetic.Node, 'scale', [
          'x',
          'y'
      ]);

      /**
       * get/set scale
       * @name scale
       * @param {Object} scale
       * @param {Number} scale.x
       * @param {Number} scale.y
       * @method
       * @memberof Kinetic.Node.prototype
       * @returns {Object}
       * @example
       * // get scale<br>
       * var scale = node.scale();<br><br>
       *
       * // set scale <br>
       * shape.scale({<br>
       *   x: 2<br>
       *   y: 3<br>
       * });
       */

      Kinetic.Factory.addGetterSetter(Kinetic.Node, 'scaleX', 1);

      /**
       * get/set scale x
       * @name scaleX
       * @param {Number} x
       * @method
       * @memberof Kinetic.Node.prototype
       * @returns {Number}
       * @example
       * // get scale x<br>
       * var scaleX = node.scaleX();<br><br>
       *
       * // set scale x<br>
       * node.scaleX(2);
       */

      Kinetic.Factory.addGetterSetter(Kinetic.Node, 'scaleY', 1);

      /**
       * get/set scale y
       * @name scaleY
       * @param {Number} y
       * @method
       * @memberof Kinetic.Node.prototype
       * @returns {Number}
       * @example
       * // get scale y<br>
       * var scaleY = node.scaleY();<br><br>
       *
       * // set scale y<br>
       * node.scaleY(2);
       */

      Kinetic.Factory.addComponentsGetterSetter(Kinetic.Node, 'skew', [
          'x',
          'y'
      ]);

      /**
       * get/set skew
       * @name skew
       * @param {Object} skew
       * @param {Number} skew.x
       * @param {Number} skew.y
       * @method
       * @memberof Kinetic.Node.prototype
       * @returns {Object}
       * @example
       * // get skew<br>
       * var skew = node.skew();<br><br>
       *
       * // set skew <br>
       * node.skew({<br>
       *   x: 20<br>
       *   y: 10
       * });
       */

      Kinetic.Factory.addGetterSetter(Kinetic.Node, 'skewX', 0);

      /**
       * get/set skew x
       * @name skewX
       * @param {Number} x
       * @method
       * @memberof Kinetic.Node.prototype
       * @returns {Number}
       * @example
       * // get skew x<br>
       * var skewX = node.skewX();<br><br>
       *
       * // set skew x<br>
       * node.skewX(3);
       */

      Kinetic.Factory.addGetterSetter(Kinetic.Node, 'skewY', 0);

      /**
       * get/set skew y
       * @name skewY
       * @param {Number} y
       * @method
       * @memberof Kinetic.Node.prototype
       * @returns {Number}
       * @example
       * // get skew y<br>
       * var skewY = node.skewY();<br><br>
       *
       * // set skew y<br>
       * node.skewY(3);
       */

      Kinetic.Factory.addComponentsGetterSetter(Kinetic.Node, 'offset', [
          'x',
          'y'
      ]);

      /**
       * get/set offset.  Offsets the default position and rotation point
       * @method
       * @memberof Kinetic.Node.prototype
       * @param {Object} offset
       * @param {Number} offset.x
       * @param {Number} offset.y
       * @returns {Object}
       * @example
       * // get offset<br>
       * var offset = node.offset();<br><br>
       *
       * // set offset<br>
       * node.offset({<br>
       *   x: 20<br>
       *   y: 10<br>
       * });
       */

      Kinetic.Factory.addGetterSetter(Kinetic.Node, 'offsetX', 0);

      /**
       * get/set offset x
       * @name offsetX
       * @memberof Kinetic.Node.prototype
       * @param {Number} x
       * @returns {Number}
       * @example
       * // get offset x<br>
       * var offsetX = node.offsetX();<br><br>
       *
       * // set offset x<br>
       * node.offsetX(3);
       */

      Kinetic.Factory.addGetterSetter(Kinetic.Node, 'offsetY', 0);

      /**
       * get/set offset y
       * @name offsetY
       * @method
       * @memberof Kinetic.Node.prototype
       * @param {Number} y
       * @returns {Number}
       * @example
       * // get offset y<br>
       * var offsetY = node.offsetY();<br><br>
       *
       * // set offset y<br>
       * node.offsetY(3);
       */

      Kinetic.Factory.addSetter(Kinetic.Node, 'width', 0);
      Kinetic.Factory.addOverloadedGetterSetter(Kinetic.Node, 'width');
      /**
       * get/set width
       * @name width
       * @method
       * @memberof Kinetic.Node.prototype
       * @param {Number} width
       * @returns {Number}
       * @example
       * // get width<br>
       * var width = node.width();<br><br>
       *
       * // set width<br>
       * node.width(100);
       */

      Kinetic.Factory.addSetter(Kinetic.Node, 'height', 0);
      Kinetic.Factory.addOverloadedGetterSetter(Kinetic.Node, 'height');
      /**
       * get/set height
       * @name height
       * @method
       * @memberof Kinetic.Node.prototype
       * @param {Number} height
       * @returns {Number}
       * @example
       * // get height<br>
       * var height = node.height();<br><br>
       *
       * // set height<br>
       * node.height(100);
       */

      Kinetic.Factory.addGetterSetter(Kinetic.Node, 'listening', 'inherit');
      /**
       * get/set listenig attr.  If you need to determine if a node is listening or not
       *   by taking into account its parents, use the isListening() method
       * @name listening
       * @method
       * @memberof Kinetic.Node.prototype
       * @param {Boolean|String} listening Can be "inherit", true, or false.  The default is "inherit".
       * @returns {Boolean|String}
       * @example
       * // get listening attr<br>
       * var listening = node.listening();<br><br>
       *
       * // stop listening for events<br>
       * node.listening(false);<br><br>
       *
       * // listen for events<br>
       * node.listening(true);<br><br>
       *
       * // listen to events according to the parent<br>
       * node.listening('inherit');
       */

      Kinetic.Factory.addGetterSetter(Kinetic.Node, 'filters', undefined, function (val) {
          this._filterUpToDate = false;
          return val;
      });
      /**
       * get/set filters.  Filters are applied to cached canvases
       * @name filters
       * @method
       * @memberof Kinetic.Node.prototype
       * @param {Array} filters array of filters
       * @returns {Array}
       * @example
       * // get filters<br>
       * var filters = node.filters();<br><br>
       *
       * // set a single filter<br>
       * node.cache();<br>
       * node.filters([Kinetic.Filters.Blur]);<br><br>
       *
       * // set multiple filters<br>
       * node.cache();<br>
       * node.filters([<br>
       *   Kinetic.Filters.Blur,<br>
       *   Kinetic.Filters.Sepia,<br>
       *   Kinetic.Filters.Invert<br>
       * ]);
       */

      Kinetic.Factory.addGetterSetter(Kinetic.Node, 'visible', 'inherit');
      /**
       * get/set visible attr.  Can be "inherit", true, or false.  The default is "inherit".
       *   If you need to determine if a node is visible or not
       *   by taking into account its parents, use the isVisible() method
       * @name visible
       * @method
       * @memberof Kinetic.Node.prototype
       * @param {Boolean|String} visible
       * @returns {Boolean|String}
       * @example
       * // get visible attr<br>
       * var visible = node.visible();<br><br>
       *
       * // make invisible<br>
       * node.visible(false);<br><br>
       *
       * // make visible<br>
       * node.visible(true);<br><br>
       *
       * // make visible according to the parent<br>
       * node.visible('inherit');
       */

      Kinetic.Factory.addGetterSetter(Kinetic.Node, 'transformsEnabled', 'all');

      /**
       * get/set transforms that are enabled.  Can be "all", "none", or "position".  The default
       *  is "all"
       * @name transformsEnabled
       * @method
       * @memberof Kinetic.Node.prototype
       * @param {String} enabled
       * @returns {String}
       * @example
       * // enable position transform only to improve draw performance<br>
       * node.transformsEnabled('position');<br><br>
       *
       * // enable all transforms<br>
       * node.transformsEnabled('all');
       */

      Kinetic.Factory.backCompat(Kinetic.Node, {
          rotateDeg: 'rotate',
          setRotationDeg: 'setRotation',
          getRotationDeg: 'getRotation'
      });

      Kinetic.Collection.mapMethods(Kinetic.Node);
  })();
  ;
  (function () {
      /**
       * Grayscale Filter
       * @function
       * @memberof Kinetic.Filters
       * @param {Object} imageData
       */
      Kinetic.Filters.Grayscale = function (imageData) {
          var data = imageData.data,
            len = data.length,
            i, brightness;

          for (i = 0; i < len; i += 4) {
              brightness = 0.34 * data[i] + 0.5 * data[i + 1] + 0.16 * data[i + 2];
              // red
              data[i] = brightness;
              // green
              data[i + 1] = brightness;
              // blue
              data[i + 2] = brightness;
          }
      };
  })();
  ;
  (function () {
      /**
       * Brighten Filter.
       * @function
       * @memberof Kinetic.Filters
       * @param {Object} imageData
       */
      Kinetic.Filters.Brighten = function (imageData) {
          var brightness = this.brightness() * 255,
            data = imageData.data,
            len = data.length,
            i;

          for (i = 0; i < len; i += 4) {
              // red
              data[i] += brightness;
              // green
              data[i + 1] += brightness;
              // blue
              data[i + 2] += brightness;
          }
      };

      Kinetic.Factory.addGetterSetter(Kinetic.Node, 'brightness', 0, null, Kinetic.Factory.afterSetFilter);
      /**
       * get/set filter brightness.  The brightness is a number between -1 and 1.&nbsp; Positive values
       *  brighten the pixels and negative values darken them.
       * @name brightness
       * @method
       * @memberof Kinetic.Image.prototype
       * @param {Number} brightness value between -1 and 1
       * @returns {Number}
       */

  })();
  ;
  (function () {
      /**
       * Invert Filter
       * @function
       * @memberof Kinetic.Filters
       * @param {Object} imageData
       */
      Kinetic.Filters.Invert = function (imageData) {
          var data = imageData.data,
            len = data.length,
            i;

          for (i = 0; i < len; i += 4) {
              // red
              data[i] = 255 - data[i];
              // green
              data[i + 1] = 255 - data[i + 1];
              // blue
              data[i + 2] = 255 - data[i + 2];
          }
      };
  })();
  ;/*
   the Gauss filter
   master repo: https://github.com/pavelpower/kineticjsGaussFilter/
   */
  (function () {
      /*

       StackBlur - a fast almost Gaussian Blur For Canvas

       Version:   0.5
       Author:    Mario Klingemann
       Contact:   mario@quasimondo.com
       Website:   http://www.quasimondo.com/StackBlurForCanvas
       Twitter:   @quasimondo

       In case you find this class useful - especially in commercial projects -
       I am not totally unhappy for a small donation to my PayPal account
       mario@quasimondo.de

       Or support me on flattr:
       https://flattr.com/thing/72791/StackBlur-a-fast-almost-Gaussian-Blur-Effect-for-CanvasJavascript

       Copyright (c) 2010 Mario Klingemann

       Permission is hereby granted, free of charge, to any person
       obtaining a copy of this software and associated documentation
       files (the "Software"), to deal in the Software without
       restriction, including without limitation the rights to use,
       copy, modify, merge, publish, distribute, sublicense, and/or sell
       copies of the Software, and to permit persons to whom the
       Software is furnished to do so, subject to the following
       conditions:

       The above copyright notice and this permission notice shall be
       included in all copies or substantial portions of the Software.

       THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
       EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
       OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
       NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
       HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
       WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
       FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
       OTHER DEALINGS IN THE SOFTWARE.
       */

      function BlurStack () {
          this.r = 0;
          this.g = 0;
          this.b = 0;
          this.a = 0;
          this.next = null;
      }

      var mul_table = [
          512,
          512,
          456,
          512,
          328,
          456,
          335,
          512,
          405,
          328,
          271,
          456,
          388,
          335,
          292,
          512,
          454,
          405,
          364,
          328,
          298,
          271,
          496,
          456,
          420,
          388,
          360,
          335,
          312,
          292,
          273,
          512,
          482,
          454,
          428,
          405,
          383,
          364,
          345,
          328,
          312,
          298,
          284,
          271,
          259,
          496,
          475,
          456,
          437,
          420,
          404,
          388,
          374,
          360,
          347,
          335,
          323,
          312,
          302,
          292,
          282,
          273,
          265,
          512,
          497,
          482,
          468,
          454,
          441,
          428,
          417,
          405,
          394,
          383,
          373,
          364,
          354,
          345,
          337,
          328,
          320,
          312,
          305,
          298,
          291,
          284,
          278,
          271,
          265,
          259,
          507,
          496,
          485,
          475,
          465,
          456,
          446,
          437,
          428,
          420,
          412,
          404,
          396,
          388,
          381,
          374,
          367,
          360,
          354,
          347,
          341,
          335,
          329,
          323,
          318,
          312,
          307,
          302,
          297,
          292,
          287,
          282,
          278,
          273,
          269,
          265,
          261,
          512,
          505,
          497,
          489,
          482,
          475,
          468,
          461,
          454,
          447,
          441,
          435,
          428,
          422,
          417,
          411,
          405,
          399,
          394,
          389,
          383,
          378,
          373,
          368,
          364,
          359,
          354,
          350,
          345,
          341,
          337,
          332,
          328,
          324,
          320,
          316,
          312,
          309,
          305,
          301,
          298,
          294,
          291,
          287,
          284,
          281,
          278,
          274,
          271,
          268,
          265,
          262,
          259,
          257,
          507,
          501,
          496,
          491,
          485,
          480,
          475,
          470,
          465,
          460,
          456,
          451,
          446,
          442,
          437,
          433,
          428,
          424,
          420,
          416,
          412,
          408,
          404,
          400,
          396,
          392,
          388,
          385,
          381,
          377,
          374,
          370,
          367,
          363,
          360,
          357,
          354,
          350,
          347,
          344,
          341,
          338,
          335,
          332,
          329,
          326,
          323,
          320,
          318,
          315,
          312,
          310,
          307,
          304,
          302,
          299,
          297,
          294,
          292,
          289,
          287,
          285,
          282,
          280,
          278,
          275,
          273,
          271,
          269,
          267,
          265,
          263,
          261,
          259
      ];

      var shg_table = [
          9,
          11,
          12,
          13,
          13,
          14,
          14,
          15,
          15,
          15,
          15,
          16,
          16,
          16,
          16,
          17,
          17,
          17,
          17,
          17,
          17,
          17,
          18,
          18,
          18,
          18,
          18,
          18,
          18,
          18,
          18,
          19,
          19,
          19,
          19,
          19,
          19,
          19,
          19,
          19,
          19,
          19,
          19,
          19,
          19,
          20,
          20,
          20,
          20,
          20,
          20,
          20,
          20,
          20,
          20,
          20,
          20,
          20,
          20,
          20,
          20,
          20,
          20,
          21,
          21,
          21,
          21,
          21,
          21,
          21,
          21,
          21,
          21,
          21,
          21,
          21,
          21,
          21,
          21,
          21,
          21,
          21,
          21,
          21,
          21,
          21,
          21,
          21,
          21,
          21,
          22,
          22,
          22,
          22,
          22,
          22,
          22,
          22,
          22,
          22,
          22,
          22,
          22,
          22,
          22,
          22,
          22,
          22,
          22,
          22,
          22,
          22,
          22,
          22,
          22,
          22,
          22,
          22,
          22,
          22,
          22,
          22,
          22,
          22,
          22,
          22,
          22,
          23,
          23,
          23,
          23,
          23,
          23,
          23,
          23,
          23,
          23,
          23,
          23,
          23,
          23,
          23,
          23,
          23,
          23,
          23,
          23,
          23,
          23,
          23,
          23,
          23,
          23,
          23,
          23,
          23,
          23,
          23,
          23,
          23,
          23,
          23,
          23,
          23,
          23,
          23,
          23,
          23,
          23,
          23,
          23,
          23,
          23,
          23,
          23,
          23,
          23,
          23,
          23,
          23,
          23,
          24,
          24,
          24,
          24,
          24,
          24,
          24,
          24,
          24,
          24,
          24,
          24,
          24,
          24,
          24,
          24,
          24,
          24,
          24,
          24,
          24,
          24,
          24,
          24,
          24,
          24,
          24,
          24,
          24,
          24,
          24,
          24,
          24,
          24,
          24,
          24,
          24,
          24,
          24,
          24,
          24,
          24,
          24,
          24,
          24,
          24,
          24,
          24,
          24,
          24,
          24,
          24,
          24,
          24,
          24,
          24,
          24,
          24,
          24,
          24,
          24,
          24,
          24,
          24,
          24,
          24,
          24,
          24,
          24,
          24,
          24,
          24,
          24,
          24
      ];

      function filterGaussBlurRGBA (imageData, radius) {

          var pixels = imageData.data,
            width = imageData.width,
            height = imageData.height;

          var x, y, i, p, yp, yi, yw, r_sum, g_sum, b_sum, a_sum,
            r_out_sum, g_out_sum, b_out_sum, a_out_sum,
            r_in_sum, g_in_sum, b_in_sum, a_in_sum,
            pr, pg, pb, pa, rbs;

          var div = radius + radius + 1,
            widthMinus1 = width - 1,
            heightMinus1 = height - 1,
            radiusPlus1 = radius + 1,
            sumFactor = radiusPlus1 * (radiusPlus1 + 1) / 2,
            stackStart = new BlurStack(),
            stackEnd = null,
            stack = stackStart,
            stackIn = null,
            stackOut = null,
            mul_sum = mul_table[radius],
            shg_sum = shg_table[radius];

          for (i = 1; i < div; i++) {
              stack = stack.next = new BlurStack();
              if (i == radiusPlus1)
                  stackEnd = stack;
          }

          stack.next = stackStart;

          yw = yi = 0;

          for (y = 0; y < height; y++)
          {
              r_in_sum = g_in_sum = b_in_sum = a_in_sum = r_sum = g_sum = b_sum = a_sum = 0;

              r_out_sum = radiusPlus1 * (pr = pixels[yi]);
              g_out_sum = radiusPlus1 * (pg = pixels[yi + 1]);
              b_out_sum = radiusPlus1 * (pb = pixels[yi + 2]);
              a_out_sum = radiusPlus1 * (pa = pixels[yi + 3]);

              r_sum += sumFactor * pr;
              g_sum += sumFactor * pg;
              b_sum += sumFactor * pb;
              a_sum += sumFactor * pa;

              stack = stackStart;

              for (i = 0; i < radiusPlus1; i++)
              {
                  stack.r = pr;
                  stack.g = pg;
                  stack.b = pb;
                  stack.a = pa;
                  stack = stack.next;
              }

              for (i = 1; i < radiusPlus1; i++)
              {
                  p = yi + ((widthMinus1 < i ? widthMinus1 : i) << 2);
                  r_sum += (stack.r = (pr = pixels[p])) * (rbs = radiusPlus1 - i);
                  g_sum += (stack.g = (pg = pixels[p + 1])) * rbs;
                  b_sum += (stack.b = (pb = pixels[p + 2])) * rbs;
                  a_sum += (stack.a = (pa = pixels[p + 3])) * rbs;

                  r_in_sum += pr;
                  g_in_sum += pg;
                  b_in_sum += pb;
                  a_in_sum += pa;

                  stack = stack.next;
              }


              stackIn = stackStart;
              stackOut = stackEnd;
              for (x = 0; x < width; x++)
              {
                  pixels[yi + 3] = pa = (a_sum * mul_sum) >> shg_sum;
                  if (pa !== 0)
                  {
                      pa = 255 / pa;
                      pixels[yi] = ((r_sum * mul_sum) >> shg_sum) * pa;
                      pixels[yi + 1] = ((g_sum * mul_sum) >> shg_sum) * pa;
                      pixels[yi + 2] = ((b_sum * mul_sum) >> shg_sum) * pa;
                  } else {
                      pixels[yi] = pixels[yi + 1] = pixels[yi + 2] = 0;
                  }

                  r_sum -= r_out_sum;
                  g_sum -= g_out_sum;
                  b_sum -= b_out_sum;
                  a_sum -= a_out_sum;

                  r_out_sum -= stackIn.r;
                  g_out_sum -= stackIn.g;
                  b_out_sum -= stackIn.b;
                  a_out_sum -= stackIn.a;

                  p = (yw + ((p = x + radius + 1) < widthMinus1 ? p : widthMinus1)) << 2;

                  r_in_sum += (stackIn.r = pixels[p]);
                  g_in_sum += (stackIn.g = pixels[p + 1]);
                  b_in_sum += (stackIn.b = pixels[p + 2]);
                  a_in_sum += (stackIn.a = pixels[p + 3]);

                  r_sum += r_in_sum;
                  g_sum += g_in_sum;
                  b_sum += b_in_sum;
                  a_sum += a_in_sum;

                  stackIn = stackIn.next;

                  r_out_sum += (pr = stackOut.r);
                  g_out_sum += (pg = stackOut.g);
                  b_out_sum += (pb = stackOut.b);
                  a_out_sum += (pa = stackOut.a);

                  r_in_sum -= pr;
                  g_in_sum -= pg;
                  b_in_sum -= pb;
                  a_in_sum -= pa;

                  stackOut = stackOut.next;

                  yi += 4;
              }
              yw += width;
          }


          for (x = 0; x < width; x++)
          {
              g_in_sum = b_in_sum = a_in_sum = r_in_sum = g_sum = b_sum = a_sum = r_sum = 0;

              yi = x << 2;
              r_out_sum = radiusPlus1 * (pr = pixels[yi]);
              g_out_sum = radiusPlus1 * (pg = pixels[yi + 1]);
              b_out_sum = radiusPlus1 * (pb = pixels[yi + 2]);
              a_out_sum = radiusPlus1 * (pa = pixels[yi + 3]);

              r_sum += sumFactor * pr;
              g_sum += sumFactor * pg;
              b_sum += sumFactor * pb;
              a_sum += sumFactor * pa;

              stack = stackStart;

              for (i = 0; i < radiusPlus1; i++)
              {
                  stack.r = pr;
                  stack.g = pg;
                  stack.b = pb;
                  stack.a = pa;
                  stack = stack.next;
              }

              yp = width;

              for (i = 1; i <= radius; i++)
              {
                  yi = (yp + x) << 2;

                  r_sum += (stack.r = (pr = pixels[yi])) * (rbs = radiusPlus1 - i);
                  g_sum += (stack.g = (pg = pixels[yi + 1])) * rbs;
                  b_sum += (stack.b = (pb = pixels[yi + 2])) * rbs;
                  a_sum += (stack.a = (pa = pixels[yi + 3])) * rbs;

                  r_in_sum += pr;
                  g_in_sum += pg;
                  b_in_sum += pb;
                  a_in_sum += pa;

                  stack = stack.next;

                  if (i < heightMinus1)
                  {
                      yp += width;
                  }
              }

              yi = x;
              stackIn = stackStart;
              stackOut = stackEnd;
              for (y = 0; y < height; y++)
              {
                  p = yi << 2;
                  pixels[p + 3] = pa = (a_sum * mul_sum) >> shg_sum;
                  if (pa > 0)
                  {
                      pa = 255 / pa;
                      pixels[p] = ((r_sum * mul_sum) >> shg_sum) * pa;
                      pixels[p + 1] = ((g_sum * mul_sum) >> shg_sum) * pa;
                      pixels[p + 2] = ((b_sum * mul_sum) >> shg_sum) * pa;
                  } else {
                      pixels[p] = pixels[p + 1] = pixels[p + 2] = 0;
                  }

                  r_sum -= r_out_sum;
                  g_sum -= g_out_sum;
                  b_sum -= b_out_sum;
                  a_sum -= a_out_sum;

                  r_out_sum -= stackIn.r;
                  g_out_sum -= stackIn.g;
                  b_out_sum -= stackIn.b;
                  a_out_sum -= stackIn.a;

                  p = (x + (((p = y + radiusPlus1) < heightMinus1 ? p : heightMinus1) * width)) << 2;

                  r_sum += (r_in_sum += (stackIn.r = pixels[p]));
                  g_sum += (g_in_sum += (stackIn.g = pixels[p + 1]));
                  b_sum += (b_in_sum += (stackIn.b = pixels[p + 2]));
                  a_sum += (a_in_sum += (stackIn.a = pixels[p + 3]));

                  stackIn = stackIn.next;

                  r_out_sum += (pr = stackOut.r);
                  g_out_sum += (pg = stackOut.g);
                  b_out_sum += (pb = stackOut.b);
                  a_out_sum += (pa = stackOut.a);

                  r_in_sum -= pr;
                  g_in_sum -= pg;
                  b_in_sum -= pb;
                  a_in_sum -= pa;

                  stackOut = stackOut.next;

                  yi += width;
              }
          }
      }

      /**
       * Blur Filter
       * @function
       * @memberof Kinetic.Filters
       * @param {Object} imageData
       */
      Kinetic.Filters.Blur = function (imageData) {
          var radius = this.blurRadius() | 0;

          if (radius > 0) {
              filterGaussBlurRGBA(imageData, radius);
          }
      };

      Kinetic.Factory.addGetterSetter(Kinetic.Node, 'blurRadius', 0, null, Kinetic.Factory.afterSetFilter);

      /**
       * get/set blur radius
       * @name blurRadius
       * @method
       * @memberof Kinetic.Node.prototype
       * @param {Integer} radius
       * @returns {Integer}
       */
  })();
  ;
  (function () {

      function pixelAt (idata, x, y) {
          var idx = (y * idata.width + x) * 4;
          var d = [
          ];
          d.push(idata.data[idx++], idata.data[idx++], idata.data[idx++], idata.data[idx++]);
          return d;
      }

      function rgbDistance (p1, p2) {
          return Math.sqrt(Math.pow(p1[0] - p2[0], 2) + Math.pow(p1[1] - p2[1], 2) + Math.pow(p1[2] - p2[2], 2));
      }

      function rgbMean (pTab) {
          var m = [
              0,
              0,
              0
          ];

          for (var i = 0; i < pTab.length; i++) {
              m[0] += pTab[i][0];
              m[1] += pTab[i][1];
              m[2] += pTab[i][2];
          }

          m[0] /= pTab.length;
          m[1] /= pTab.length;
          m[2] /= pTab.length;

          return m;
      }

      function backgroundMask (idata, threshold) {
          var rgbv_no = pixelAt(idata, 0, 0);
          var rgbv_ne = pixelAt(idata, idata.width - 1, 0);
          var rgbv_so = pixelAt(idata, 0, idata.height - 1);
          var rgbv_se = pixelAt(idata, idata.width - 1, idata.height - 1);


          var thres = threshold || 10;
          if (rgbDistance(rgbv_no, rgbv_ne) < thres && rgbDistance(rgbv_ne, rgbv_se) < thres && rgbDistance(rgbv_se, rgbv_so) < thres && rgbDistance(rgbv_so, rgbv_no) < thres) {

              // Mean color
              var mean = rgbMean([
                  rgbv_ne,
                  rgbv_no,
                  rgbv_se,
                  rgbv_so
              ]);

              // Mask based on color distance
              var mask = [
              ];
              for (var i = 0; i < idata.width * idata.height; i++) {
                  var d = rgbDistance(mean, [
                      idata.data[i * 4],
                      idata.data[i * 4 + 1],
                      idata.data[i * 4 + 2]
                  ]);
                  mask[i] = (d < thres) ? 0 : 255;
              }

              return mask;
          }
      }

      function applyMask (idata, mask) {
          for (var i = 0; i < idata.width * idata.height; i++) {
              idata.data[4 * i + 3] = mask[i];
          }
      }

      function erodeMask (mask, sw, sh) {

          var weights = [
              1,
              1,
              1,
              1,
              0,
              1,
              1,
              1,
              1
          ];
          var side = Math.round(Math.sqrt(weights.length));
          var halfSide = Math.floor(side / 2);

          var maskResult = [
          ];
          for (var y = 0; y < sh; y++) {
              for (var x = 0; x < sw; x++) {

                  var so = y * sw + x;
                  var a = 0;
                  for (var cy = 0; cy < side; cy++) {
                      for (var cx = 0; cx < side; cx++) {
                          var scy = y + cy - halfSide;
                          var scx = x + cx - halfSide;

                          if (scy >= 0 && scy < sh && scx >= 0 && scx < sw) {

                              var srcOff = scy * sw + scx;
                              var wt = weights[cy * side + cx];

                              a += mask[srcOff] * wt;
                          }
                      }
                  }

                  maskResult[so] = (a === 255 * 8) ? 255 : 0;
              }
          }

          return maskResult;
      }

      function dilateMask (mask, sw, sh) {

          var weights = [
              1,
              1,
              1,
              1,
              1,
              1,
              1,
              1,
              1
          ];
          var side = Math.round(Math.sqrt(weights.length));
          var halfSide = Math.floor(side / 2);

          var maskResult = [
          ];
          for (var y = 0; y < sh; y++) {
              for (var x = 0; x < sw; x++) {

                  var so = y * sw + x;
                  var a = 0;
                  for (var cy = 0; cy < side; cy++) {
                      for (var cx = 0; cx < side; cx++) {
                          var scy = y + cy - halfSide;
                          var scx = x + cx - halfSide;

                          if (scy >= 0 && scy < sh && scx >= 0 && scx < sw) {

                              var srcOff = scy * sw + scx;
                              var wt = weights[cy * side + cx];

                              a += mask[srcOff] * wt;
                          }
                      }
                  }

                  maskResult[so] = (a >= 255 * 4) ? 255 : 0;
              }
          }

          return maskResult;
      }

      function smoothEdgeMask (mask, sw, sh) {

          var weights = [
              1 / 9,
              1 / 9,
              1 / 9,
              1 / 9,
              1 / 9,
              1 / 9,
              1 / 9,
              1 / 9,
              1 / 9
          ];
          var side = Math.round(Math.sqrt(weights.length));
          var halfSide = Math.floor(side / 2);

          var maskResult = [
          ];
          for (var y = 0; y < sh; y++) {
              for (var x = 0; x < sw; x++) {

                  var so = y * sw + x;
                  var a = 0;
                  for (var cy = 0; cy < side; cy++) {
                      for (var cx = 0; cx < side; cx++) {
                          var scy = y + cy - halfSide;
                          var scx = x + cx - halfSide;

                          if (scy >= 0 && scy < sh && scx >= 0 && scx < sw) {

                              var srcOff = scy * sw + scx;
                              var wt = weights[cy * side + cx];

                              a += mask[srcOff] * wt;
                          }
                      }
                  }

                  maskResult[so] = a;
              }
          }

          return maskResult;
      }

      /**
       * Mask Filter
       * @function
       * @memberof Kinetic.Filters
       * @param {Object} imageData
       */
      Kinetic.Filters.Mask = function (imageData) {
          // Detect pixels close to the background color
          var threshold = this.threshold(),
            mask = backgroundMask(imageData, threshold);
          if (mask) {
              // Erode
              mask = erodeMask(mask, imageData.width, imageData.height);

              // Dilate
              mask = dilateMask(mask, imageData.width, imageData.height);

              // Gradient
              mask = smoothEdgeMask(mask, imageData.width, imageData.height);

              // Apply mask
              applyMask(imageData, mask);

              // todo : Update hit region function according to mask
          }

          return imageData;
      };

      Kinetic.Factory.addGetterSetter(Kinetic.Node, 'threshold', 0, null, Kinetic.Factory.afterSetFilter);
  })();
  ;
  (function () {
      /**
       * RGB Filter
       * @function
       * @memberof Kinetic.Filters
       * @param {Object} imageData
       * @author ippo615
       */
      Kinetic.Filters.RGB = function (imageData) {
          var data = imageData.data,
            nPixels = data.length,
            red = this.red(),
            green = this.green(),
            blue = this.blue(),
            i, brightness;

          for (i = 0; i < nPixels; i += 4) {
              brightness = (0.34 * data[i] + 0.5 * data[i + 1] + 0.16 * data[i + 2]) / 255;
              data[i    ] = brightness * red; // r
              data[i + 1] = brightness * green; // g
              data[i + 2] = brightness * blue; // b
              data[i + 3] = data[i + 3]; // alpha
          }
      };

      Kinetic.Factory.addGetterSetter(Kinetic.Node, 'red', 0, function (val) {
          this._filterUpToDate = false;
          if (val > 255) {
              return 255;
          }
          else if (val < 0) {
              return 0;
          }
          else {
              return Math.round(val);
          }
      });
      /**
       * get/set filter red value
       * @name red
       * @method
       * @memberof Kinetic.Node.prototype
       * @param {Integer} red value between 0 and 255
       * @returns {Integer}
       */

      Kinetic.Factory.addGetterSetter(Kinetic.Node, 'green', 0, function (val) {
          this._filterUpToDate = false;
          if (val > 255) {
              return 255;
          }
          else if (val < 0) {
              return 0;
          }
          else {
              return Math.round(val);
          }
      });
      /**
       * get/set filter green value
       * @name green
       * @method
       * @memberof Kinetic.Node.prototype
       * @param {Integer} green value between 0 and 255
       * @returns {Integer}
       */

      Kinetic.Factory.addGetterSetter(Kinetic.Node, 'blue', 0, Kinetic.Validators.RGBComponent, Kinetic.Factory.afterSetFilter);
      /**
       * get/set filter blue value
       * @name blue
       * @method
       * @memberof Kinetic.Node.prototype
       * @param {Integer} blue value between 0 and 255
       * @returns {Integer}
       */
  })();
  ;
  (function () {

      /**
       * HSV Filter. Adjusts the hue, saturation and value
       * @function
       * @memberof Kinetic.Filters
       * @param {Object} imageData
       * @author ippo615
       */

      Kinetic.Filters.HSV = function (imageData) {
          var data = imageData.data,
            nPixels = data.length,
            v = this.value(),
            s = this.saturation(),
            h = Math.abs((this.hue()) + 360) % 360,
            i;

          // Basis for the technique used:
          // http://beesbuzz.biz/code/hsv_color_transforms.php
          // V is the value multiplier (1 for none, 2 for double, 0.5 for half)
          // S is the saturation multiplier (1 for none, 2 for double, 0.5 for half)
          // H is the hue shift in degrees (0 to 360)
          // vsu = V*S*cos(H*PI/180);
          // vsw = V*S*sin(H*PI/180);
          //[ .299V+.701vsu+.168vsw    .587V-.587vsu+.330vsw    .114V-.114vsu-.497vsw ] [R]
          //[ .299V-.299vsu-.328vsw    .587V+.413vsu+.035vsw    .114V-.114vsu+.292vsw ]*[G]
          //[ .299V-.300vsu+1.25vsw    .587V-.588vsu-1.05vsw    .114V+.886vsu-.203vsw ] [B]

          // Precompute the values in the matrix:
          var vsu = v * s * Math.cos(h * Math.PI / 180),
            vsw = v * s * Math.sin(h * Math.PI / 180);
          // (result spot)(source spot)
          var rr = 0.299 * v + 0.701 * vsu + 0.167 * vsw,
            rg = 0.587 * v - 0.587 * vsu + 0.330 * vsw,
            rb = 0.114 * v - 0.114 * vsu - 0.497 * vsw;
          var gr = 0.299 * v - 0.299 * vsu - 0.328 * vsw,
            gg = 0.587 * v + 0.413 * vsu + 0.035 * vsw,
            gb = 0.114 * v - 0.114 * vsu + 0.293 * vsw;
          var br = 0.299 * v - 0.300 * vsu + 1.250 * vsw,
            bg = 0.587 * v - 0.586 * vsu - 1.050 * vsw,
            bb = 0.114 * v + 0.886 * vsu - 0.200 * vsw;

          var r, g, b, a;

          for (i = 0; i < nPixels; i += 4) {
              r = data[i + 0];
              g = data[i + 1];
              b = data[i + 2];
              a = data[i + 3];

              data[i + 0] = rr * r + rg * g + rb * b;
              data[i + 1] = gr * r + gg * g + gb * b;
              data[i + 2] = br * r + bg * g + bb * b;
              data[i + 3] = a; // alpha
          }

      };

      Kinetic.Factory.addGetterSetter(Kinetic.Node, 'hue', 0, null, Kinetic.Factory.afterSetFilter);
      /**
       * get/set hsv hue in degrees
       * @name hue
       * @method
       * @memberof Kinetic.Node.prototype
       * @param {Number} hue value between 0 and 359
       * @returns {Number}
       */

      Kinetic.Factory.addGetterSetter(Kinetic.Node, 'saturation', 1, null, Kinetic.Factory.afterSetFilter);
      /**
       * get/set hsv saturation
       * @name saturation
       * @method
       * @memberof Kinetic.Node.prototype
       * @param {Number} saturation 1 is no change, 0.5 halves the saturation, 2.0 doubles, etc..
       * @returns {Number}
       */

      Kinetic.Factory.addGetterSetter(Kinetic.Node, 'value', 1, null, Kinetic.Factory.afterSetFilter);
      /**
       * get/set hsv value
       * @name value
       * @method
       * @memberof Kinetic.Node.prototype
       * @param {Number} value 1 is no change, 0.5 halves the value, 2.0 doubles, etc..
       * @returns {Number}
       */
  })();
  ;
  (function () {
      /**
       * Emboss Filter
       * @function
       * @memberof Kinetic.Filters
       * @param {Object} imageData
       * Pixastic Lib - Emboss filter - v0.1.0
       * Copyright (c) 2008 Jacob Seidelin, jseidelin@nihilogic.dk, http://blog.nihilogic.dk/
       * License: [http://www.pixastic.com/lib/license.txt]
       */
      Kinetic.Filters.Emboss = function (imageData) {

          // pixastic strength is between 0 and 10.  I want it between 0 and 1
          // pixastic greyLevel is between 0 and 255.  I want it between 0 and 1.  Also,
          // a max value of greyLevel yields a white emboss, and the min value yields a black
          // emboss.  Therefore, I changed greyLevel to whiteLevel
          var strength = this.embossStrength() * 10,
            greyLevel = this.embossWhiteLevel() * 255,
            direction = this.embossDirection(),
            blend = this.embossBlend(),
            dirY = 0,
            dirX = 0,
            data = imageData.data,
            invertAlpha = false,
            w = imageData.width,
            h = imageData.height,
            w4 = w * 4,
            y = h;

          switch (direction) {
              case 'top-left':
                  dirY = -1;
                  dirX = -1;
                  break;
              case 'top':
                  dirY = -1;
                  dirX = 0;
                  break;
              case 'top-right':
                  dirY = -1;
                  dirX = 1;
                  break;
              case 'right':
                  dirY = 0;
                  dirX = 1;
                  break;
              case 'bottom-right':
                  dirY = 1;
                  dirX = 1;
                  break;
              case 'bottom':
                  dirY = 1;
                  dirX = 0;
                  break;
              case 'bottom-left':
                  dirY = 1;
                  dirX = -1;
                  break;
              case 'left':
                  dirY = 0;
                  dirX = -1;
                  break;
          }

          do {
              var offsetY = (y - 1) * w4;

              var otherY = dirY;
              if (y + otherY < 1)
                  otherY = 0;
              if (y + otherY > h)
                  otherY = 0;

              var offsetYOther = (y - 1 + otherY) * w * 4;

              var x = w;
              do {
                  var offset = offsetY + (x - 1) * 4;

                  var otherX = dirX;
                  if (x + otherX < 1)
                      otherX = 0;
                  if (x + otherX > w)
                      otherX = 0;

                  var offsetOther = offsetYOther + (x - 1 + otherX) * 4;

                  var dR = data[offset] - data[offsetOther];
                  var dG = data[offset + 1] - data[offsetOther + 1];
                  var dB = data[offset + 2] - data[offsetOther + 2];

                  var dif = dR;
                  var absDif = dif > 0 ? dif : -dif;

                  var absG = dG > 0 ? dG : -dG;
                  var absB = dB > 0 ? dB : -dB;

                  if (absG > absDif) {
                      dif = dG;
                  }
                  if (absB > absDif) {
                      dif = dB;
                  }

                  dif *= strength;

                  if (blend) {
                      var r = data[offset] + dif;
                      var g = data[offset + 1] + dif;
                      var b = data[offset + 2] + dif;

                      data[offset] = (r > 255) ? 255 : (r < 0 ? 0 : r);
                      data[offset + 1] = (g > 255) ? 255 : (g < 0 ? 0 : g);
                      data[offset + 2] = (b > 255) ? 255 : (b < 0 ? 0 : b);
                  } else {
                      var grey = greyLevel - dif;
                      if (grey < 0) {
                          grey = 0;
                      } else if (grey > 255) {
                          grey = 255;
                      }

                      data[offset] = data[offset + 1] = data[offset + 2] = grey;
                  }

              } while (--x);
          } while (--y);
      };

      Kinetic.Factory.addGetterSetter(Kinetic.Node, 'embossStrength', 0.5, null, Kinetic.Factory.afterSetFilter);
      /**
       * get/set emboss strength
       * @name embossStrength
       * @method
       * @memberof Kinetic.Node.prototype
       * @param {Number} level between 0 and 1.  Default is 0.5
       * @returns {Number}
       */

      Kinetic.Factory.addGetterSetter(Kinetic.Node, 'embossWhiteLevel', 0.5, null, Kinetic.Factory.afterSetFilter);
      /**
       * get/set emboss white level
       * @name embossWhiteLevel
       * @method
       * @memberof Kinetic.Node.prototype
       * @param {Number} embossWhiteLevel between 0 and 1.  Default is 0.5
       * @returns {Number}
       */

      Kinetic.Factory.addGetterSetter(Kinetic.Node, 'embossDirection', 'top-left', null, Kinetic.Factory.afterSetFilter);
      /**
       * get/set emboss direction
       * @name embossDirection
       * @method
       * @memberof Kinetic.Node.prototype
       * @param {String} embossDirection can be top-left, top, top-right, right, bottom-right, bottom, bottom-left or left
       *   The default is top-left
       * @returns {String}
       */

      Kinetic.Factory.addGetterSetter(Kinetic.Node, 'embossBlend', false, null, Kinetic.Factory.afterSetFilter);
      /**
       * get/set emboss blend
       * @name embossBlend
       * @method
       * @memberof Kinetic.Node.prototype
       * @param {Boolean} embossBlend
       * @returns {Boolean}
       */

  })();


  ;
  (function () {
      function remap (fromValue, fromMin, fromMax, toMin, toMax) {
          // Compute the range of the data
          var fromRange = fromMax - fromMin,
            toRange = toMax - toMin,
            toValue;

          // If either range is 0, then the value can only be mapped to 1 value
          if (fromRange === 0) {
              return toMin + toRange / 2;
          }
          if (toRange === 0) {
              return toMin;
          }

          // (1) untranslate, (2) unscale, (3) rescale, (4) retranslate
          toValue = (fromValue - fromMin) / fromRange;
          toValue = (toRange * toValue) + toMin;

          return toValue;
      }


      /**
       * Enhance Filter. Adjusts the colors so that they span the widest
       *  possible range (ie 0-255). Performs w*h pixel reads and w*h pixel
       *  writes.
       * @function
       * @memberof Kinetic.Filters
       * @param {Object} imageData
       * @author ippo615
       */
      Kinetic.Filters.Enhance = function (imageData) {
          var data = imageData.data,
            nSubPixels = data.length,
            rMin = data[0], rMax = rMin, r,
            gMin = data[1], gMax = gMin, g,
            bMin = data[2], bMax = bMin, b,
            aMin = data[3], aMax = aMin, a,
            i;

          // If we are not enhancing anything - don't do any computation
          var enhanceAmount = this.enhance();
          if (enhanceAmount === 0) {
              return;
          }

          // 1st Pass - find the min and max for each channel:
          for (i = 0; i < nSubPixels; i += 4) {
              r = data[i + 0];
              if (r < rMin) {
                  rMin = r;
              } else
              if (r > rMax) {
                  rMax = r;
              }
              g = data[i + 1];
              if (g < gMin) {
                  gMin = g;
              } else
              if (g > gMax) {
                  gMax = g;
              }
              b = data[i + 2];
              if (b < bMin) {
                  bMin = b;
              } else
              if (b > bMax) {
                  bMax = b;
              }
              //a = data[i + 3];
              //if (a < aMin) { aMin = a; } else
              //if (a > aMax) { aMax = a; }
          }

          // If there is only 1 level - don't remap
          if (rMax === rMin) {
              rMax = 255;
              rMin = 0;
          }
          if (gMax === gMin) {
              gMax = 255;
              gMin = 0;
          }
          if (bMax === bMin) {
              bMax = 255;
              bMin = 0;
          }
          if (aMax === aMin) {
              aMax = 255;
              aMin = 0;
          }

          var rMid, rGoalMax, rGoalMin,
            gMid, gGoalMax, gGoalMin,
            bMid, bGoalMax, aGoalMin,
            aMid, aGoalMax, bGoalMin;

          // If the enhancement is positive - stretch the histogram
          if (enhanceAmount > 0) {
              rGoalMax = rMax + enhanceAmount * (255 - rMax);
              rGoalMin = rMin - enhanceAmount * (rMin - 0);
              gGoalMax = gMax + enhanceAmount * (255 - gMax);
              gGoalMin = gMin - enhanceAmount * (gMin - 0);
              bGoalMax = bMax + enhanceAmount * (255 - bMax);
              bGoalMin = bMin - enhanceAmount * (bMin - 0);
              aGoalMax = aMax + enhanceAmount * (255 - aMax);
              aGoalMin = aMin - enhanceAmount * (aMin - 0);
              // If the enhancement is negative - compress the histogram
          } else {
              rMid = (rMax + rMin) * 0.5;
              rGoalMax = rMax + enhanceAmount * (rMax - rMid);
              rGoalMin = rMin + enhanceAmount * (rMin - rMid);
              gMid = (gMax + gMin) * 0.5;
              gGoalMax = gMax + enhanceAmount * (gMax - gMid);
              gGoalMin = gMin + enhanceAmount * (gMin - gMid);
              bMid = (bMax + bMin) * 0.5;
              bGoalMax = bMax + enhanceAmount * (bMax - bMid);
              bGoalMin = bMin + enhanceAmount * (bMin - bMid);
              aMid = (aMax + aMin) * 0.5;
              aGoalMax = aMax + enhanceAmount * (aMax - aMid);
              aGoalMin = aMin + enhanceAmount * (aMin - aMid);
          }

          // Pass 2 - remap everything, except the alpha
          for (i = 0; i < nSubPixels; i += 4) {
              data[i + 0] = remap(data[i + 0], rMin, rMax, rGoalMin, rGoalMax);
              data[i + 1] = remap(data[i + 1], gMin, gMax, gGoalMin, gGoalMax);
              data[i + 2] = remap(data[i + 2], bMin, bMax, bGoalMin, bGoalMax);
              //data[i + 3] = remap(data[i + 3], aMin, aMax, aGoalMin, aGoalMax);
          }
      };

      Kinetic.Factory.addGetterSetter(Kinetic.Node, 'enhance', 0, null, Kinetic.Factory.afterSetFilter);

      /**
       * get/set enhance
       * @name enhance
       * @method
       * @memberof Kinetic.Node.prototype
       * @param {Float} amount
       * @returns {Float}
       */
  })();
  ;
  (function () {

      /**
       * Posterize Filter. Adjusts the channels so that there are no more
       *  than n different values for that channel. This is also applied
       *  to the alpha channel.
       * @function
       * @author ippo615
       * @memberof Kinetic.Filters
       * @param {Object} imageData
       */

      Kinetic.Filters.Posterize = function (imageData) {
          // level must be between 1 and 255
          var levels = Math.round(this.levels() * 254) + 1,
            data = imageData.data,
            len = data.length,
            scale = (255 / levels),
            i;

          for (i = 0; i < len; i += 1) {
              data[i] = Math.floor(data[i] / scale) * scale;
          }
      };

      Kinetic.Factory.addGetterSetter(Kinetic.Node, 'levels', 0.5, null, Kinetic.Factory.afterSetFilter);

      /**
       * get/set levels.  Must be a number between 0 and 1
       * @name levels
       * @method
       * @memberof Kinetic.Node.prototype
       * @param {Number} level between 0 and 1
       * @returns {Number}
       */
  })();
  ;
  (function () {

      /**
       * Noise Filter. Randomly adds or substracts to the color channels
       * @function
       * @memberof Kinetic.Filters
       * @param {Object} imagedata
       * @author ippo615
       */
      Kinetic.Filters.Noise = function (imageData) {
          var amount = this.noise() * 255,
            data = imageData.data,
            nPixels = data.length,
            half = amount / 2,
            i;

          for (i = 0; i < nPixels; i += 4) {
              data[i + 0] += half - 2 * half * Math.random();
              data[i + 1] += half - 2 * half * Math.random();
              data[i + 2] += half - 2 * half * Math.random();
          }
      };

      Kinetic.Factory.addGetterSetter(Kinetic.Node, 'noise', 0.2, null, Kinetic.Factory.afterSetFilter);

      /**
       * get/set noise amount.  Must be a value between 0 and 1
       * @name noise
       * @method
       * @memberof Kinetic.Node.prototype
       * @param {Number} noise
       * @returns {Number}
       */
  })();
  ;
  (function () {

      /**
       * Pixelate Filter. Averages groups of pixels and redraws
       *  them as larger pixels
       * @function
       * @memberof Kinetic.Filters
       * @param {Object} imageData
       * @author ippo615
       */

      Kinetic.Filters.Pixelate = function (imageData) {

          var pixelSize = Math.ceil(this.pixelSize()),
            width = imageData.width,
            height = imageData.height,
            imageData = imageData.data,
            x, y, i,
            pixelsPerBin = pixelSize * pixelSize,
            red, green, blue, alpha,
            nBinsX = Math.ceil(width / pixelSize),
            nBinsY = Math.ceil(height / pixelSize),
            xBinStart, xBinEnd, yBinStart, yBinEnd,
            xBin, yBin, pixelsInBin;

          for (xBin = 0; xBin < nBinsX; xBin += 1) {
              for (yBin = 0; yBin < nBinsY; yBin += 1) {

                  // Initialize the color accumlators to 0
                  red = 0;
                  green = 0;
                  blue = 0;
                  alpha = 0;

                  // Determine which pixels are included in this bin
                  xBinStart = xBin * pixelSize;
                  xBinEnd = xBinStart + pixelSize;
                  yBinStart = yBin * pixelSize;
                  yBinEnd = yBinStart + pixelSize;

                  // Add all of the pixels to this bin!
                  pixelsInBin = 0;
                  for (x = xBinStart; x < xBinEnd; x += 1) {
                      if (x >= width) {
                          continue;
                      }
                      for (y = yBinStart; y < yBinEnd; y += 1) {
                          if (y >= height) {
                              continue;
                          }
                          i = (width * y + x) * 4;
                          red += imageData[i + 0];
                          green += imageData[i + 1];
                          blue += imageData[i + 2];
                          alpha += imageData[i + 3];
                          pixelsInBin += 1;
                      }
                  }

                  // Make sure the channels are between 0-255
                  red = red / pixelsInBin;
                  green = green / pixelsInBin;
                  blue = blue / pixelsInBin;
                  alphas = alpha / pixelsInBin;

                  // Draw this bin
                  for (x = xBinStart; x < xBinEnd; x += 1) {
                      if (x >= width) {
                          continue;
                      }
                      for (y = yBinStart; y < yBinEnd; y += 1) {
                          if (y >= height) {
                              continue;
                          }
                          i = (width * y + x) * 4;
                          imageData[i + 0] = red;
                          imageData[i + 1] = green;
                          imageData[i + 2] = blue;
                          imageData[i + 3] = alpha;
                      }
                  }
              }
          }

      };

      Kinetic.Factory.addGetterSetter(Kinetic.Node, 'pixelSize', 8, null, Kinetic.Factory.afterSetFilter);

      /**
       * get/set pixel size
       * @name pixelSize
       * @method
       * @memberof Kinetic.Node.prototype
       * @param {Integer} pixelSize
       * @returns {Integer}
       */
  })();
  ;
  (function () {

      /**
       * Threshold Filter. Pushes any value above the mid point to
       *  the max and any value below the mid point to the min.
       *  This affects the alpha channel.
       * @function
       * @memberof Kinetic.Filters
       * @param {Object} imageData
       * @author ippo615
       */

      Kinetic.Filters.Threshold = function (imageData) {
          var level = this.threshold() * 255,
            data = imageData.data,
            len = data.length,
            i;

          for (i = 0; i < len; i += 1) {
              data[i] = data[i] < level ? 0 : 255;
          }
      };

      Kinetic.Factory.addGetterSetter(Kinetic.Node, 'threshold', 0.5, null, Kinetic.Factory.afterSetFilter);

      /**
       * get/set threshold.  Must be a value between 0 and 1
       * @name threshold
       * @method
       * @memberof Kinetic.Node.prototype
       * @param {Number} threshold
       * @returns {Number}
       */
  })();
  ;
  (function () {
      /**
       * Sepia Filter
       * Based on: Pixastic Lib - Sepia filter - v0.1.0
       * Copyright (c) 2008 Jacob Seidelin, jseidelin@nihilogic.dk, http://blog.nihilogic.dk/
       * @function
       * @memberof Kinetic.Filters
       * @param {Object} imageData
       * @author Jacob Seidelin <jseidelin@nihilogic.dk>
       * @license MPL v1.1 [http://www.pixastic.com/lib/license.txt]
       */
      Kinetic.Filters.Sepia = function (imageData) {
          var data = imageData.data,
            w = imageData.width,
            y = imageData.height,
            w4 = w * 4,
            offsetY, x, offset, or, og, ob, r, g, b;

          do {
              offsetY = (y - 1) * w4;
              x = w;
              do {
                  offset = offsetY + (x - 1) * 4;

                  or = data[offset];
                  og = data[offset + 1];
                  ob = data[offset + 2];

                  r = or * 0.393 + og * 0.769 + ob * 0.189;
                  g = or * 0.349 + og * 0.686 + ob * 0.168;
                  b = or * 0.272 + og * 0.534 + ob * 0.131;

                  data[offset] = r > 255 ? 255 : r;
                  data[offset + 1] = g > 255 ? 255 : g;
                  data[offset + 2] = b > 255 ? 255 : b;
                  data[offset + 3] = data[offset + 3];
              } while (--x);
          } while (--y);
      };
  })();
  ;
  (function () {
      /**
       * Solarize Filter
       * @function
       * @memberof Kinetic.Filters
       * @param {Object} imageData
       * Pixastic Lib - Solarize filter - v0.1.0
       * Copyright (c) 2008 Jacob Seidelin, jseidelin@nihilogic.dk, http://blog.nihilogic.dk/
       * License: [http://www.pixastic.com/lib/license.txt]
       */
      Kinetic.Filters.Solarize = function (imageData) {
          var data = imageData.data,
            w = imageData.width,
            h = imageData.height,
            w4 = w * 4,
            y = h;

          do {
              var offsetY = (y - 1) * w4;
              var x = w;
              do {
                  var offset = offsetY + (x - 1) * 4;
                  var r = data[offset];
                  var g = data[offset + 1];
                  var b = data[offset + 2];

                  if (r > 127)
                      r = 255 - r;
                  if (g > 127)
                      g = 255 - g;
                  if (b > 127)
                      b = 255 - b;

                  data[offset] = r;
                  data[offset + 1] = g;
                  data[offset + 2] = b;

              } while (--x);
          } while (--y);
      };
  })();


  ;
  (function () {

      /*
       * ToPolar Filter. Converts image data to polar coordinates. Performs
       *  w*h*4 pixel reads and w*h pixel writes. The r axis is placed along
       *  what would be the y axis and the theta axis along the x axis.
       * @function
       * @author ippo615
       * @memberof Kinetic.Filters
       * @param {ImageData} src, the source image data (what will be transformed)
       * @param {ImageData} dst, the destination image data (where it will be saved)
       * @param {Object} opt
       * @param {Number} [opt.polarCenterX] horizontal location for the center of the circle,
       *  default is in the middle
       * @param {Number} [opt.polarCenterY] vertical location for the center of the circle,
       *  default is in the middle
       */

      var ToPolar = function (src, dst, opt) {

          var srcPixels = src.data,
            dstPixels = dst.data,
            xSize = src.width,
            ySize = src.height,
            xMid = opt.polarCenterX || xSize / 2,
            yMid = opt.polarCenterY || ySize / 2,
            i, m, x, y, k, tmp, r = 0, g = 0, b = 0, a = 0;

          // Find the largest radius
          var rad, rMax = Math.sqrt(xMid * xMid + yMid * yMid);
          x = xSize - xMid;
          y = ySize - yMid;
          rad = Math.sqrt(x * x + y * y);
          rMax = (rad > rMax) ? rad : rMax;

          // We'll be uisng y as the radius, and x as the angle (theta=t)
          var rSize = ySize,
            tSize = xSize,
            radius, theta;

          // We want to cover all angles (0-360) and we need to convert to
          // radians (*PI/180)
          var conversion = 360 / tSize * Math.PI / 180, sin, cos;

          var x1, x2, x1i, x2i, y1, y2, y1i, y2i, scale;

          for (theta = 0; theta < tSize; theta += 1) {
              sin = Math.sin(theta * conversion);
              cos = Math.cos(theta * conversion);
              for (radius = 0; radius < rSize; radius += 1) {
                  x = xMid + rMax * radius / rSize * cos;
                  y = yMid + rMax * radius / rSize * sin;
                  if (x <= 1) {
                      x = 1;
                  }
                  if (x >= xSize - 0.5) {
                      x = xSize - 1;
                  }
                  if (y <= 1) {
                      y = 1;
                  }
                  if (y >= ySize - 0.5) {
                      y = ySize - 1;
                  }

                  // Interpolate x and y by going +-0.5 around the pixel's central point
                  // this gives us the 4 nearest pixels to our 1x1 non-aligned pixel.
                  // We average the vaules of those pixels based on how much of our
                  // non-aligned pixel overlaps each of them.
                  x1 = x - 0.5;
                  x2 = x + 0.5;
                  x1i = Math.floor(x1);
                  x2i = Math.floor(x2);
                  y1 = y - 0.5;
                  y2 = y + 0.5;
                  y1i = Math.floor(y1);
                  y2i = Math.floor(y2);

                  scale = (1 - (x1 - x1i)) * (1 - (y1 - y1i));
                  i = (y1i * xSize + x1i) * 4;
                  r = srcPixels[i + 0] * scale;
                  g = srcPixels[i + 1] * scale;
                  b = srcPixels[i + 2] * scale;
                  a = srcPixels[i + 3] * scale;

                  scale = (1 - (x1 - x1i)) * (y2 - y2i);
                  i = (y2i * xSize + x1i) * 4;
                  r += srcPixels[i + 0] * scale;
                  g += srcPixels[i + 1] * scale;
                  b += srcPixels[i + 2] * scale;
                  a += srcPixels[i + 3] * scale;

                  scale = (x2 - x2i) * (y2 - y2i);
                  i = (y2i * xSize + x2i) * 4;
                  r += srcPixels[i + 0] * scale;
                  g += srcPixels[i + 1] * scale;
                  b += srcPixels[i + 2] * scale;
                  a += srcPixels[i + 3] * scale;

                  scale = (x2 - x2i) * (1 - (y1 - y1i));
                  i = (y1i * xSize + x2i) * 4;
                  r += srcPixels[i + 0] * scale;
                  g += srcPixels[i + 1] * scale;
                  b += srcPixels[i + 2] * scale;
                  a += srcPixels[i + 3] * scale;

                  // Store it
                  //i = (theta * xSize + radius) * 4;
                  i = (theta + radius * xSize) * 4;
                  dstPixels[i + 0] = r;
                  dstPixels[i + 1] = g;
                  dstPixels[i + 2] = b;
                  dstPixels[i + 3] = a;

              }
          }
      };

      /*
       * FromPolar Filter. Converts image data from polar coordinates back to rectangular.
       *  Performs w*h*4 pixel reads and w*h pixel writes.
       * @function
       * @author ippo615
       * @memberof Kinetic.Filters
       * @param {ImageData} src, the source image data (what will be transformed)
       * @param {ImageData} dst, the destination image data (where it will be saved)
       * @param {Object} opt
       * @param {Number} [opt.polarCenterX] horizontal location for the center of the circle,
       *  default is in the middle
       * @param {Number} [opt.polarCenterY] vertical location for the center of the circle,
       *  default is in the middle
       * @param {Number} [opt.polarRotation] amount to rotate the image counterclockwis,
       *  0 is no rotation, 360 degrees is a full rotation
       */

      var FromPolar = function (src, dst, opt) {

          var srcPixels = src.data,
            dstPixels = dst.data,
            xSize = src.width,
            ySize = src.height,
            xMid = opt.polarCenterX || xSize / 2,
            yMid = opt.polarCenterY || ySize / 2,
            i, m, x, y, dx, dy, k, tmp, r = 0, g = 0, b = 0, a = 0;


          // Find the largest radius
          var rad, rMax = Math.sqrt(xMid * xMid + yMid * yMid);
          x = xSize - xMid;
          y = ySize - yMid;
          rad = Math.sqrt(x * x + y * y);
          rMax = (rad > rMax) ? rad : rMax;

          // We'll be uisng x as the radius, and y as the angle (theta=t)
          var rSize = ySize,
            tSize = xSize,
            radius, theta,
            phaseShift = opt.polarRotation || 0;

          // We need to convert to degrees and we need to make sure
          // it's between (0-360)
          // var conversion = tSize/360*180/Math.PI;
          var conversion = tSize / 360 * 180 / Math.PI;

          var x1, x2, x1i, x2i, y1, y2, y1i, y2i, scale;

          for (x = 0; x < xSize; x += 1) {
              for (y = 0; y < ySize; y += 1) {
                  dx = x - xMid;
                  dy = y - yMid;
                  radius = Math.sqrt(dx * dx + dy * dy) * rSize / rMax;
                  theta = (Math.atan2(dy, dx) * 180 / Math.PI + 360 + phaseShift) % 360;
                  theta = theta * tSize / 360;

                  // Interpolate x and y by going +-0.5 around the pixel's central point
                  // this gives us the 4 nearest pixels to our 1x1 non-aligned pixel.
                  // We average the vaules of those pixels based on how much of our
                  // non-aligned pixel overlaps each of them.
                  x1 = theta - 0.5;
                  x2 = theta + 0.5;
                  x1i = Math.floor(x1);
                  x2i = Math.floor(x2);
                  y1 = radius - 0.5;
                  y2 = radius + 0.5;
                  y1i = Math.floor(y1);
                  y2i = Math.floor(y2);

                  scale = (1 - (x1 - x1i)) * (1 - (y1 - y1i));
                  i = (y1i * xSize + x1i) * 4;
                  r = srcPixels[i + 0] * scale;
                  g = srcPixels[i + 1] * scale;
                  b = srcPixels[i + 2] * scale;
                  a = srcPixels[i + 3] * scale;

                  scale = (1 - (x1 - x1i)) * (y2 - y2i);
                  i = (y2i * xSize + x1i) * 4;
                  r += srcPixels[i + 0] * scale;
                  g += srcPixels[i + 1] * scale;
                  b += srcPixels[i + 2] * scale;
                  a += srcPixels[i + 3] * scale;

                  scale = (x2 - x2i) * (y2 - y2i);
                  i = (y2i * xSize + x2i) * 4;
                  r += srcPixels[i + 0] * scale;
                  g += srcPixels[i + 1] * scale;
                  b += srcPixels[i + 2] * scale;
                  a += srcPixels[i + 3] * scale;

                  scale = (x2 - x2i) * (1 - (y1 - y1i));
                  i = (y1i * xSize + x2i) * 4;
                  r += srcPixels[i + 0] * scale;
                  g += srcPixels[i + 1] * scale;
                  b += srcPixels[i + 2] * scale;
                  a += srcPixels[i + 3] * scale;

                  // Store it
                  i = (y * xSize + x) * 4;
                  dstPixels[i + 0] = r;
                  dstPixels[i + 1] = g;
                  dstPixels[i + 2] = b;
                  dstPixels[i + 3] = a;
              }
          }

      };

      //Kinetic.Filters.ToPolar = Kinetic.Util._FilterWrapDoubleBuffer(ToPolar);
      //Kinetic.Filters.FromPolar = Kinetic.Util._FilterWrapDoubleBuffer(FromPolar);

      // create a temporary canvas for working - shared between multiple calls
      var tempCanvas = document.createElement('canvas');

      /*
       * Kaleidoscope Filter.
       * @function
       * @author ippo615
       * @memberof Kinetic.Filters
       */
      Kinetic.Filters.Kaleidoscope = function (imageData) {
          var xSize = imageData.width,
            ySize = imageData.height;
          var power = Math.round(this.kaleidoscopePower());
          var angle = Math.round(this.kaleidoscopeAngle());
          var offset = Math.floor(xSize * (angle % 360) / 360);

          if (power < 1) {
              return;
          }

          // Work with our shared buffer canvas
          tempCanvas.width = xSize;
          tempCanvas.height = ySize;
          var scratchData = tempCanvas.getContext('2d').getImageData(0, 0, xSize, ySize);

          // Convert thhe original to polar coordinates
          ToPolar(imageData, scratchData, {
              polarCenterX: xSize / 2,
              polarCenterY: ySize / 2
          });

          // Determine how big each section will be, if it's too small
          // make it bigger
          var minSectionSize = xSize / Math.pow(2, power);
          while (minSectionSize <= 8) {
              minSectionSize = minSectionSize * 2;
              power -= 1;
          }
          minSectionSize = Math.ceil(minSectionSize);
          var sectionSize = minSectionSize;

          // Copy the offset region to 0
          // Depending on the size of filter and location of the offset we may need
          // to copy the section backwards to prevent it from rewriting itself
          var xStart = 0,
            xEnd = sectionSize,
            xDelta = 1;
          if (offset + minSectionSize > xSize) {
              xStart = sectionSize;
              xEnd = 0;
              xDelta = -1;
          }
          for (y = 0; y < ySize; y += 1) {
              for (x = xStart; x !== xEnd; x += xDelta) {
                  xoff = Math.round(x + offset) % xSize;
                  srcPos = (xSize * y + xoff) * 4;
                  r = scratchData.data[srcPos + 0];
                  g = scratchData.data[srcPos + 1];
                  b = scratchData.data[srcPos + 2];
                  a = scratchData.data[srcPos + 3];
                  dstPos = (xSize * y + x) * 4;
                  scratchData.data[dstPos + 0] = r;
                  scratchData.data[dstPos + 1] = g;
                  scratchData.data[dstPos + 2] = b;
                  scratchData.data[dstPos + 3] = a;
              }
          }

          // Perform the actual effect
          var x, y, xoff, i, r, g, b, a, srcPos, dstPos;
          for (y = 0; y < ySize; y += 1) {
              sectionSize = Math.floor(minSectionSize);
              for (i = 0; i < power; i += 1) {
                  for (x = 0; x < sectionSize + 1; x += 1) {
                      srcPos = (xSize * y + x) * 4;
                      r = scratchData.data[srcPos + 0];
                      g = scratchData.data[srcPos + 1];
                      b = scratchData.data[srcPos + 2];
                      a = scratchData.data[srcPos + 3];
                      dstPos = (xSize * y + sectionSize * 2 - x - 1) * 4;
                      scratchData.data[dstPos + 0] = r;
                      scratchData.data[dstPos + 1] = g;
                      scratchData.data[dstPos + 2] = b;
                      scratchData.data[dstPos + 3] = a;
                  }
                  sectionSize *= 2;
              }
          }

          // Convert back from polar coordinates
          FromPolar(scratchData, imageData, {
              polarRotation: 0
          });
      };

      /**
       * get/set kaleidoscope power
       * @name kaleidoscopePower
       * @method
       * @memberof Kinetic.Node.prototype
       * @param {Integer} power of kaleidoscope
       * @returns {Integer}
       */
      Kinetic.Factory.addGetterSetter(Kinetic.Node, 'kaleidoscopePower', 2, null, Kinetic.Factory.afterSetFilter);

      /**
       * get/set kaleidoscope angle
       * @name kaleidoscopeAngle
       * @method
       * @memberof Kinetic.Node.prototype
       * @param {Integer} degrees
       * @returns {Integer}
       */
      Kinetic.Factory.addGetterSetter(Kinetic.Node, 'kaleidoscopeAngle', 0, null, Kinetic.Factory.afterSetFilter);

  })();
  ;
  (function () {
      var BATCH_DRAW_STOP_TIME_DIFF = 500;

      /**
       * Animation constructor.  A stage is used to contain multiple layers and handle
       * @constructor
       * @memberof Kinetic
       * @param {Function} func function executed on each animation frame.  The function is passed a frame object, which contains
       *  timeDiff, lastTime, time, and frameRate properties.  The timeDiff property is the number of milliseconds that have passed
       *  since the last animation frame.  The lastTime property is time in milliseconds that elapsed from the moment the animation started
       *  to the last animation frame.  The time property is the time in milliseconds that ellapsed from the moment the animation started
       *  to the current animation frame.  The frameRate property is the current frame rate in frames / second
       * @param {Kinetic.Layer|Array} [layers] layer(s) to be redrawn on each animation frame. Can be a layer, an array of layers, or null.
       *  Not specifying a node will result in no redraw.
       * @example
       * // move a node to the right at 50 pixels / second<br>
       * var velocity = 50;<br><br>
       *
       * var anim = new Kinetic.Animation(function(frame) {<br>
       *   var dist = velocity * (frame.timeDiff / 1000);<br>
       *   node.move(dist, 0);<br>
       * }, layer);<br><br>
       *
       * anim.start();
       */
      Kinetic.Animation = function (func, layers) {
          this.func = func;
          this.setLayers(layers);
          this.id = Kinetic.Animation.animIdCounter++;
          this.frame = {
              time: 0,
              timeDiff: 0,
              lastTime: new Date().getTime()
          };
      };
      /*
       * Animation methods
       */
      Kinetic.Animation.prototype = {
          /**
           * set layers to be redrawn on each animation frame
           * @method
           * @memberof Kinetic.Animation.prototype
           * @param {Kinetic.Layer|Array} [layers] layer(s) to be redrawn.&nbsp; Can be a layer, an array of layers, or null.  Not specifying a node will result in no redraw.
           */
          setLayers: function (layers) {
              var lays = [
              ];
              // if passing in no layers
              if (!layers) {
                  lays = [
                  ];
              }
              // if passing in an array of Layers
              // NOTE: layers could be an array or Kinetic.Collection.  for simplicity, I'm just inspecting
              // the length property to check for both cases
              else if (layers.length > 0) {
                  lays = layers;
              }
              // if passing in a Layer
              else {
                  lays = [
                      layers
                  ];
              }

              this.layers = lays;
          },
          /**
           * get layers
           * @method
           * @memberof Kinetic.Animation.prototype
           */
          getLayers: function () {
              return this.layers;
          },
          /**
           * add layer.  Returns true if the layer was added, and false if it was not
           * @method
           * @memberof Kinetic.Animation.prototype
           * @param {Kinetic.Layer} layer
           */
          addLayer: function (layer) {
              var layers = this.layers,
                len, n;

              if (layers) {
                  len = layers.length;

                  // don't add the layer if it already exists
                  for (n = 0; n < len; n++) {
                      if (layers[n]._id === layer._id) {
                          return false;
                      }
                  }
              }
              else {
                  this.layers = [
                  ];
              }

              this.layers.push(layer);
              return true;
          },
          /**
           * determine if animation is running or not.  returns true or false
           * @method
           * @memberof Kinetic.Animation.prototype
           */
          isRunning: function () {
              var a = Kinetic.Animation, animations = a.animations;
              for (var n = 0; n < animations.length; n++) {
                  if (animations[n].id === this.id) {
                      return true;
                  }
              }
              return false;
          },
          /**
           * start animation
           * @method
           * @memberof Kinetic.Animation.prototype
           */
          start: function () {
              this.stop();
              this.frame.timeDiff = 0;
              this.frame.lastTime = new Date().getTime();
              Kinetic.Animation._addAnimation(this);
          },
          /**
           * stop animation
           * @method
           * @memberof Kinetic.Animation.prototype
           */
          stop: function () {
              Kinetic.Animation._removeAnimation(this);
          },
          _updateFrameObject: function (time) {
              this.frame.timeDiff = time - this.frame.lastTime;
              this.frame.lastTime = time;
              this.frame.time += this.frame.timeDiff;
              this.frame.frameRate = 1000 / this.frame.timeDiff;
          }
      };
      Kinetic.Animation.animations = [
      ];
      Kinetic.Animation.animIdCounter = 0;
      Kinetic.Animation.animRunning = false;

      Kinetic.Animation._addAnimation = function (anim) {
          this.animations.push(anim);
          this._handleAnimation();
      };
      Kinetic.Animation._removeAnimation = function (anim) {
          var id = anim.id, animations = this.animations, len = animations.length;
          for (var n = 0; n < len; n++) {
              if (animations[n].id === id) {
                  this.animations.splice(n, 1);
                  break;
              }
          }
      };

      Kinetic.Animation._runFrames = function () {
          var layerHash = {
          },
            animations = this.animations,
            anim, layers, func, n, i, layersLen, layer, key;
          /*
           * loop through all animations and execute animation
           *  function.  if the animation object has specified node,
           *  we can add the node to the nodes hash to eliminate
           *  drawing the same node multiple times.  The node property
           *  can be the stage itself or a layer
           */
          /*
           * WARNING: don't cache animations.length because it could change while
           * the for loop is running, causing a JS error
           */
          for (n = 0; n < animations.length; n++) {
              anim = animations[n];
              layers = anim.layers;
              func = anim.func;

              anim._updateFrameObject(new Date().getTime());
              layersLen = layers.length;

              for (i = 0; i < layersLen; i++) {
                  layer = layers[i];
                  if (layer._id !== undefined) {
                      layerHash[layer._id] = layer;
                  }
              }

              // if animation object has a function, execute it
              if (func) {
                  func.call(anim, anim.frame);
              }
          }

          for (key in layerHash) {
              layerHash[key].draw();
          }
      };
      Kinetic.Animation._animationLoop = function () {
          var that = this;
          if (this.animations.length > 0) {
              this._runFrames();
              Kinetic.Animation.requestAnimFrame(function () {
                  that._animationLoop();
              });
          }
          else {
              this.animRunning = false;
          }
      };
      Kinetic.Animation._handleAnimation = function () {
          var that = this;
          if (!this.animRunning) {
              this.animRunning = true;
              that._animationLoop();
          }
      };
      var RAF = (function () {
          return window.requestAnimationFrame
            || window.webkitRequestAnimationFrame
            || window.mozRequestAnimationFrame
            || window.oRequestAnimationFrame
            || window.msRequestAnimationFrame
            || FRAF;
      })();

      function FRAF (callback) {
          window.setTimeout(callback, 1000 / 60);
      }

      Kinetic.Animation.requestAnimFrame = function (callback) {
          var raf = Kinetic.isDragging ? FRAF : RAF;
          raf(callback);
      };

      var moveTo = Kinetic.Node.prototype.moveTo;
      Kinetic.Node.prototype.moveTo = function (container) {
          moveTo.call(this, container);
      };

      /**
       * batch draw
       * @method
       * @memberof Kinetic.Layer.prototype
       */
      Kinetic.Layer.prototype.batchDraw = function () {
          var that = this;

          if (!this.batchAnim) {
              this.batchAnim = new Kinetic.Animation(function () {
                  if (that.lastBatchDrawTime && new Date().getTime() - that.lastBatchDrawTime > BATCH_DRAW_STOP_TIME_DIFF) {
                      that.batchAnim.stop();
                  }
              }, this);
          }

          this.lastBatchDrawTime = new Date().getTime();

          if (!this.batchAnim.isRunning()) {
              this.draw();
              this.batchAnim.start();
          }
      };

      /**
       * batch draw
       * @method
       * @memberof Kinetic.Stage.prototype
       */
      Kinetic.Stage.prototype.batchDraw = function () {
          this.getChildren().each(function (layer) {
              layer.batchDraw();
          });
      };
  })();
  ;
  (function () {
      var blacklist = {
          node: 1,
          duration: 1,
          easing: 1,
          onFinish: 1,
          yoyo: 1
      },
      PAUSED = 1,
        PLAYING = 2,
        REVERSING = 3,
        idCounter = 0;

      /**
       * Tween constructor.  Tweens enable you to animate a node between the current state and a new state.
       *  You can play, pause, reverse, seek, reset, and finish tweens.  By default, tweens are animated using
       *  a linear easing.  For more tweening options, check out {@link Kinetic.Easings}
       * @constructor
       * @memberof Kinetic
       * @example
       * // instantiate new tween which fully rotates a node in 1 second
       * var tween = new Kinetic.Tween({<br>
       *   node: node,<br>
       *   rotationDeg: 360,<br>
       *   duration: 1,<br>
       *   easing: Kinetic.Easings.EaseInOut<br>
       * });<br><br>
       *
       * // play tween<br>
       * tween.play();<br><br>
       *
       * // pause tween<br>
       * tween.pause();
       */
      Kinetic.Tween = function (config) {
          var that = this,
            node = config.node,
            nodeId = node._id,
            duration = config.duration || 1,
            easing = config.easing || Kinetic.Easings.Linear,
            yoyo = !!config.yoyo,
            key, tween, start, tweenId;

          this.node = node;
          this._id = idCounter++;

          this.anim = new Kinetic.Animation(function () {
              that.tween.onEnterFrame();
          }, node.getLayer() || node.getLayers());

          this.tween = new Tween(key, function (i) {
              that._tweenFunc(i);
          }, easing, 0, 1, duration * 1000, yoyo);

          this._addListeners();

          // init attrs map
          if (!Kinetic.Tween.attrs[nodeId]) {
              Kinetic.Tween.attrs[nodeId] = {
              };
          }
          if (!Kinetic.Tween.attrs[nodeId][this._id]) {
              Kinetic.Tween.attrs[nodeId][this._id] = {
              };
          }
          // init tweens map
          if (!Kinetic.Tween.tweens[nodeId]) {
              Kinetic.Tween.tweens[nodeId] = {
              };
          }

          for (key in config) {
              if (blacklist[key] === undefined) {
                  this._addAttr(key, config[key]);
              }
          }

          this.reset();

          // callbacks
          this.onFinish = config.onFinish;
          this.onReset = config.onReset;
      };

      // start/diff object = attrs.nodeId.tweenId.attr
      Kinetic.Tween.attrs = {
      };
      // tweenId = tweens.nodeId.attr
      Kinetic.Tween.tweens = {
      };

      Kinetic.Tween.prototype = {
          _addAttr: function (key, end) {
              var node = this.node,
                nodeId = node._id,
                start, diff, tweenId, n, len, startVal, endVal;

              // remove conflict from tween map if it exists
              tweenId = Kinetic.Tween.tweens[nodeId][key];

              if (tweenId) {
                  delete Kinetic.Tween.attrs[nodeId][tweenId][key];
              }

              // add to tween map
              start = node.getAttr(key);

              if (Kinetic.Util._isArray(end)) {
                  diff = [
                  ];
                  len = end.length;
                  for (n = 0; n < len; n++) {
                      diff.push(end[n] - start[n]);
                  }

              }
              else {
                  diff = end - start;
              }

              Kinetic.Tween.attrs[nodeId][this._id][key] = {
                  start: start,
                  diff: diff
              };
              Kinetic.Tween.tweens[nodeId][key] = this._id;
          },
          _tweenFunc: function (i) {
              var node = this.node,
                attrs = Kinetic.Tween.attrs[node._id][this._id],
                key, attr, start, diff, newVal, n, len, startVal, diffVal;

              for (key in attrs) {
                  attr = attrs[key];
                  start = attr.start;
                  diff = attr.diff;

                  if (Kinetic.Util._isArray(start)) {
                      newVal = [
                      ];
                      len = start.length;
                      for (n = 0; n < len; n++) {
                          newVal.push(start[n] + (diff[n] * i));
                      }
                  }
                  else {
                      newVal = start + (diff * i);
                  }

                  node.setAttr(key, newVal);
              }
          },
          _addListeners: function () {
              var that = this;

              // start listeners
              this.tween.onPlay = function () {
                  that.anim.start();
              };
              this.tween.onReverse = function () {
                  that.anim.start();
              };

              // stop listeners
              this.tween.onPause = function () {
                  that.anim.stop();
              };
              this.tween.onFinish = function () {
                  if (that.onFinish) {
                      that.onFinish();
                  }
              };
              this.tween.onReset = function () {
                  if (that.onReset) {
                      that.onReset();
                  }
              };
          },
          /**
           * play
           * @method
           * @memberof Kinetic.Tween.prototype
           * @returns {Tween}
           */
          play: function () {
              this.tween.play();
              return this;
          },
          /**
           * reverse
           * @method
           * @memberof Kinetic.Tween.prototype
           * @returns {Tween}
           */
          reverse: function () {
              this.tween.reverse();
              return this;
          },
          /**
           * reset
           * @method
           * @memberof Kinetic.Tween.prototype
           * @returns {Tween}
           */
          reset: function () {
              var node = this.node;
              this.tween.reset();
              (node.getLayer() || node.getLayers()).draw();
              return this;
          },
          /**
           * seek
           * @method
           * @memberof Kinetic.Tween.prototype
           * @param {Integer} t time in seconds between 0 and the duration
           * @returns {Tween}
           */
          seek: function (t) {
              var node = this.node;
              this.tween.seek(t * 1000);
              (node.getLayer() || node.getLayers()).draw();
              return this;
          },
          /**
           * pause
           * @method
           * @memberof Kinetic.Tween.prototype
           * @returns {Tween}
           */
          pause: function () {
              this.tween.pause();
              return this;
          },
          /**
           * finish
           * @method
           * @memberof Kinetic.Tween.prototype
           * @returns {Tween}
           */
          finish: function () {
              var node = this.node;
              this.tween.finish();
              (node.getLayer() || node.getLayers()).draw();
              return this;
          },
          /**
           * destroy
           * @method
           * @memberof Kinetic.Tween.prototype
           */
          destroy: function () {
              var nodeId = this.node._id,
                thisId = this._id,
                attrs = Kinetic.Tween.tweens[nodeId],
                key;

              this.pause();

              for (key in attrs) {
                  delete Kinetic.Tween.tweens[nodeId][key];
              }

              delete Kinetic.Tween.attrs[nodeId][thisId];
          }
      };

      var Tween = function (prop, propFunc, func, begin, finish, duration, yoyo) {
          this.prop = prop;
          this.propFunc = propFunc;
          this.begin = begin;
          this._pos = begin;
          this.duration = duration;
          this._change = 0;
          this.prevPos = 0;
          this.yoyo = yoyo;
          this._time = 0;
          this._position = 0;
          this._startTime = 0;
          this._finish = 0;
          this.func = func;
          this._change = finish - this.begin;
          this.pause();
      };
      /*
       * Tween methods
       */
      Tween.prototype = {
          fire: function (str) {
              var handler = this[str];
              if (handler) {
                  handler();
              }
          },
          setTime: function (t) {
              if (t > this.duration) {
                  if (this.yoyo) {
                      this._time = this.duration;
                      this.reverse();
                  }
                  else {
                      this.finish();
                  }
              }
              else if (t < 0) {
                  if (this.yoyo) {
                      this._time = 0;
                      this.play();
                  }
                  else {
                      this.reset();
                  }
              }
              else {
                  this._time = t;
                  this.update();
              }
          },
          getTime: function () {
              return this._time;
          },
          setPosition: function (p) {
              this.prevPos = this._pos;
              this.propFunc(p);
              this._pos = p;
          },
          getPosition: function (t) {
              if (t === undefined) {
                  t = this._time;
              }
              return this.func(t, this.begin, this._change, this.duration);
          },
          play: function () {
              this.state = PLAYING;
              this._startTime = this.getTimer() - this._time;
              this.onEnterFrame();
              this.fire('onPlay');
          },
          reverse: function () {
              this.state = REVERSING;
              this._time = this.duration - this._time;
              this._startTime = this.getTimer() - this._time;
              this.onEnterFrame();
              this.fire('onReverse');
          },
          seek: function (t) {
              this.pause();
              this._time = t;
              this.update();
              this.fire('onSeek');
          },
          reset: function () {
              this.pause();
              this._time = 0;
              this.update();
              this.fire('onReset');
          },
          finish: function () {
              this.pause();
              this._time = this.duration;
              this.update();
              this.fire('onFinish');
          },
          update: function () {
              this.setPosition(this.getPosition(this._time));
          },
          onEnterFrame: function () {
              var t = this.getTimer() - this._startTime;
              if (this.state === PLAYING) {
                  this.setTime(t);
              }
              else if (this.state === REVERSING) {
                  this.setTime(this.duration - t);
              }
          },
          pause: function () {
              this.state = PAUSED;
              this.fire('onPause');
          },
          getTimer: function () {
              return new Date().getTime();
          }
      };

      /*
       * These eases were ported from an Adobe Flash tweening library to JavaScript
       * by Xaric
       */

      /**
       * @namespace Easings
       * @memberof Kinetic
       */
      Kinetic.Easings = {
          /**
           * back ease in
           * @function
           * @memberof Kinetic.Easings
           */
          'BackEaseIn': function (t, b, c, d, a, p) {
              var s = 1.70158;
              return c * (t /= d) * t * ((s + 1) * t - s) + b;
          },
          /**
           * back ease out
           * @function
           * @memberof Kinetic.Easings
           */
          'BackEaseOut': function (t, b, c, d, a, p) {
              var s = 1.70158;
              return c * ((t = t / d - 1) * t * ((s + 1) * t + s) + 1) + b;
          },
          /**
           * back ease in out
           * @function
           * @memberof Kinetic.Easings
           */
          'BackEaseInOut': function (t, b, c, d, a, p) {
              var s = 1.70158;
              if ((t /= d / 2) < 1) {
                  return c / 2 * (t * t * (((s *= (1.525)) + 1) * t - s)) + b;
              }
              return c / 2 * ((t -= 2) * t * (((s *= (1.525)) + 1) * t + s) + 2) + b;
          },
          /**
           * elastic ease in
           * @function
           * @memberof Kinetic.Easings
           */
          'ElasticEaseIn': function (t, b, c, d, a, p) {
              // added s = 0
              var s = 0;
              if (t === 0) {
                  return b;
              }
              if ((t /= d) == 1) {
                  return b + c;
              }
              if (!p) {
                  p = d * 0.3;
              }
              if (!a || a < Math.abs(c)) {
                  a = c;
                  s = p / 4;
              }
              else {
                  s = p / (2 * Math.PI) * Math.asin(c / a);
              }
              return -(a * Math.pow(2, 10 * (t -= 1)) * Math.sin((t * d - s) * (2 * Math.PI) / p)) + b;
          },
          /**
           * elastic ease out
           * @function
           * @memberof Kinetic.Easings
           */
          'ElasticEaseOut': function (t, b, c, d, a, p) {
              // added s = 0
              var s = 0;
              if (t === 0) {
                  return b;
              }
              if ((t /= d) == 1) {
                  return b + c;
              }
              if (!p) {
                  p = d * 0.3;
              }
              if (!a || a < Math.abs(c)) {
                  a = c;
                  s = p / 4;
              }
              else {
                  s = p / (2 * Math.PI) * Math.asin(c / a);
              }
              return (a * Math.pow(2, -10 * t) * Math.sin((t * d - s) * (2 * Math.PI) / p) + c + b);
          },
          /**
           * elastic ease in out
           * @function
           * @memberof Kinetic.Easings
           */
          'ElasticEaseInOut': function (t, b, c, d, a, p) {
              // added s = 0
              var s = 0;
              if (t === 0) {
                  return b;
              }
              if ((t /= d / 2) == 2) {
                  return b + c;
              }
              if (!p) {
                  p = d * (0.3 * 1.5);
              }
              if (!a || a < Math.abs(c)) {
                  a = c;
                  s = p / 4;
              }
              else {
                  s = p / (2 * Math.PI) * Math.asin(c / a);
              }
              if (t < 1) {
                  return -0.5 * (a * Math.pow(2, 10 * (t -= 1)) * Math.sin((t * d - s) * (2 * Math.PI) / p)) + b;
              }
              return a * Math.pow(2, -10 * (t -= 1)) * Math.sin((t * d - s) * (2 * Math.PI) / p) * 0.5 + c + b;
          },
          /**
           * bounce ease out
           * @function
           * @memberof Kinetic.Easings
           */
          'BounceEaseOut': function (t, b, c, d) {
              if ((t /= d) < (1 / 2.75)) {
                  return c * (7.5625 * t * t) + b;
              }
              else if (t < (2 / 2.75)) {
                  return c * (7.5625 * (t -= (1.5 / 2.75)) * t + 0.75) + b;
              }
              else if (t < (2.5 / 2.75)) {
                  return c * (7.5625 * (t -= (2.25 / 2.75)) * t + 0.9375) + b;
              }
              else {
                  return c * (7.5625 * (t -= (2.625 / 2.75)) * t + 0.984375) + b;
              }
          },
          /**
           * bounce ease in
           * @function
           * @memberof Kinetic.Easings
           */
          'BounceEaseIn': function (t, b, c, d) {
              return c - Kinetic.Easings.BounceEaseOut(d - t, 0, c, d) + b;
          },
          /**
           * bounce ease in out
           * @function
           * @memberof Kinetic.Easings
           */
          'BounceEaseInOut': function (t, b, c, d) {
              if (t < d / 2) {
                  return Kinetic.Easings.BounceEaseIn(t * 2, 0, c, d) * 0.5 + b;
              }
              else {
                  return Kinetic.Easings.BounceEaseOut(t * 2 - d, 0, c, d) * 0.5 + c * 0.5 + b;
              }
          },
          /**
           * ease in
           * @function
           * @memberof Kinetic.Easings
           */
          'EaseIn': function (t, b, c, d) {
              return c * (t /= d) * t + b;
          },
          /**
           * ease out
           * @function
           * @memberof Kinetic.Easings
           */
          'EaseOut': function (t, b, c, d) {
              return -c * (t /= d) * (t - 2) + b;
          },
          /**
           * ease in out
           * @function
           * @memberof Kinetic.Easings
           */
          'EaseInOut': function (t, b, c, d) {
              if ((t /= d / 2) < 1) {
                  return c / 2 * t * t + b;
              }
              return -c / 2 * ((--t) * (t - 2) - 1) + b;
          },
          /**
           * strong ease in
           * @function
           * @memberof Kinetic.Easings
           */
          'StrongEaseIn': function (t, b, c, d) {
              return c * (t /= d) * t * t * t * t + b;
          },
          /**
           * strong ease out
           * @function
           * @memberof Kinetic.Easings
           */
          'StrongEaseOut': function (t, b, c, d) {
              return c * ((t = t / d - 1) * t * t * t * t + 1) + b;
          },
          /**
           * strong ease in out
           * @function
           * @memberof Kinetic.Easings
           */
          'StrongEaseInOut': function (t, b, c, d) {
              if ((t /= d / 2) < 1) {
                  return c / 2 * t * t * t * t * t + b;
              }
              return c / 2 * ((t -= 2) * t * t * t * t + 2) + b;
          },
          /**
           * linear
           * @function
           * @memberof Kinetic.Easings
           */
          'Linear': function (t, b, c, d) {
              return c * t / d + b;
          }
      };
  })();
  ;
  (function () {
      Kinetic.DD = {
          // properties
          anim: new Kinetic.Animation(),
          isDragging: false,
          offset: {
              x: 0,
              y: 0
          },
          node: null,
          // methods
          _drag: function (evt) {
              var dd = Kinetic.DD,
                node = dd.node;

              if (node) {
                  node._setDragPosition(evt);

                  if (!dd.isDragging) {
                      dd.isDragging = true;
                      node.fire('dragstart', evt, true);
                  }

                  // execute ondragmove if defined
                  node.fire('dragmove', evt, true);
              }
          },
          _endDragBefore: function (evt) {
              var dd = Kinetic.DD,
                node = dd.node,
                nodeType, layer;

              if (node) {
                  nodeType = node.nodeType,
                    layer = node.getLayer();
                  dd.anim.stop();

                  // only fire dragend event if the drag and drop
                  // operation actually started.
                  if (dd.isDragging) {
                      dd.isDragging = false;
                      Kinetic.listenClickTap = false;

                      if (evt) {
                          evt.dragEndNode = node;
                      }
                  }

                  delete dd.node;

                  (layer || node).draw();
              }
          },
          _endDragAfter: function (evt) {
              evt = evt || {
              };

              var dragEndNode = evt.dragEndNode;

              if (evt && dragEndNode) {
                  dragEndNode.fire('dragend', evt, true);
              }
          }
      };

      // Node extenders

      /**
       * initiate drag and drop
       * @method
       * @memberof Kinetic.Node.prototype
       */
      Kinetic.Node.prototype.startDrag = function () {
          var dd = Kinetic.DD,
            stage = this.getStage(),
            layer = this.getLayer(),
            pos = stage.getPointerPosition(),
            ap = this.getAbsolutePosition();

          if (pos) {
              if (dd.node) {
                  dd.node.stopDrag();
              }

              dd.node = this;
              dd.offset.x = pos.x - ap.x;
              dd.offset.y = pos.y - ap.y;
              dd.anim.setLayers(layer || this.getLayers());
              dd.anim.start();

              this._setDragPosition();
          }
      };

      Kinetic.Node.prototype._setDragPosition = function (evt) {
          var dd = Kinetic.DD,
            pos = this.getStage().getPointerPosition(),
            dbf = this.getDragBoundFunc(),
            newNodePos = {
              x: pos.x - dd.offset.x,
              y: pos.y - dd.offset.y
          };

          if (dbf !== undefined) {
              newNodePos = dbf.call(this, newNodePos, evt);
          }

          this.setAbsolutePosition(newNodePos);
      };

      /**
       * stop drag and drop
       * @method
       * @memberof Kinetic.Node.prototype
       */
      Kinetic.Node.prototype.stopDrag = function () {
          var dd = Kinetic.DD,
            evt = {
          };
          dd._endDragBefore(evt);
          dd._endDragAfter(evt);
      };

      Kinetic.Node.prototype.setDraggable = function (draggable) {
          this._setAttr('draggable', draggable);
          this._dragChange();
      };

      var origDestroy = Kinetic.Node.prototype.destroy;

      Kinetic.Node.prototype.destroy = function () {
          var dd = Kinetic.DD;

          // stop DD
          if (dd.node && dd.node._id === this._id) {

              this.stopDrag();
          }

          origDestroy.call(this);
      };

      /**
       * determine if node is currently in drag and drop mode
       * @method
       * @memberof Kinetic.Node.prototype
       */
      Kinetic.Node.prototype.isDragging = function () {
          var dd = Kinetic.DD;
          return dd.node && dd.node._id === this._id && dd.isDragging;
      };

      Kinetic.Node.prototype._listenDrag = function () {
          var that = this;

          this._dragCleanup();

          if (this.getClassName() === 'Stage') {
              this.on('contentMousedown.kinetic contentTouchstart.kinetic', function (evt) {
                  if (!Kinetic.DD.node) {
                      that.startDrag(evt);
                  }
              });
          }
          else {
              this.on('mousedown.kinetic touchstart.kinetic', function (evt) {
                  if (!Kinetic.DD.node) {
                      that.startDrag(evt);
                  }
              });
          }

          // listening is required for drag and drop
          /*
           this._listeningEnabled = true;
           this._clearSelfAndAncestorCache('listeningEnabled');
           */
      };

      Kinetic.Node.prototype._dragChange = function () {
          if (this.attrs.draggable) {
              this._listenDrag();
          }
          else {
              // remove event listeners
              this._dragCleanup();

              /*
               * force drag and drop to end
               * if this node is currently in
               * drag and drop mode
               */
              var stage = this.getStage();
              var dd = Kinetic.DD;
              if (stage && dd.node && dd.node._id === this._id) {
                  dd.node.stopDrag();
              }
          }
      };

      Kinetic.Node.prototype._dragCleanup = function () {
          if (this.getClassName() === 'Stage') {
              this.off('contentMousedown.kinetic');
              this.off('contentTouchstart.kinetic');
          } else {
              this.off('mousedown.kinetic');
              this.off('touchstart.kinetic');
          }
      };

      Kinetic.Factory.addGetterSetter(Kinetic.Node, 'dragBoundFunc');

      /**
       * get/set drag bound function.  This is used to override the default
       *  drag and drop position
       * @name dragBoundFunc
       * @method
       * @memberof Kinetic.Node.prototype
       * @param {Function} dragBoundFunc
       * @returns {Function}
       * @example
       * // get drag bound function<br>
       * var dragBoundFunc = node.dragBoundFunc();<br><br>
       *
       * // create vertical drag and drop<br>
       * node.dragBoundFunc(function(){<br>
       *   return {<br>
       *     x: this.getAbsolutePosition().x,<br>
       *     y: pos.y<br>
       *   };<br>
       * });
       */

      Kinetic.Factory.addGetter(Kinetic.Node, 'draggable', false);
      Kinetic.Factory.addOverloadedGetterSetter(Kinetic.Node, 'draggable');

      /**
       * get/set draggable flag
       * @name draggable
       * @method
       * @memberof Kinetic.Node.prototype
       * @param {Boolean} draggable
       * @returns {Boolean}
       * @example
       * // get draggable flag<br>
       * var draggable = node.draggable();<br><br>
       *
       * // enable drag and drop<br>
       * node.draggable(true);<br><br>
       *
       * // disable drag and drop<br>
       * node.draggable(false);
       */

      var html = document.documentElement;
      html.addEventListener('mouseup', Kinetic.DD._endDragBefore, true);
      html.addEventListener('touchend', Kinetic.DD._endDragBefore, true);

      html.addEventListener('mouseup', Kinetic.DD._endDragAfter, false);
      html.addEventListener('touchend', Kinetic.DD._endDragAfter, false);

  })();
  ;
  (function () {
      Kinetic.Util.addMethods(Kinetic.Container, {
          __init: function (config) {
              this.children = new Kinetic.Collection();
              Kinetic.Node.call(this, config);
          },
          /**
           * returns a {@link Kinetic.Collection} of direct descendant nodes
           * @method
           * @memberof Kinetic.Container.prototype
           */
          getChildren: function () {
              return this.children;
          },
          /**
           * determine if node has children
           * @method
           * @memberof Kinetic.Container.prototype
           * @returns {Boolean}
           */
          hasChildren: function () {
              return this.getChildren().length > 0;
          },
          /**
           * remove all children
           * @method
           * @memberof Kinetic.Container.prototype
           */
          removeChildren: function (recursive) {
              var children = this.children,
                child;

              while (children.length > 0) {
                  child = children[0];
                  if (child.hasChildren() && (recursive || false) === true) {
                      child.removeChildren();
                  }
                  child.remove();
              }

              return this;
          },
          /**
           * destroy all children
           * @method
           * @memberof Kinetic.Container.prototype
           */
          destroyChildren: function () {
              var children = this.children;
              while (children.length > 0) {
                  children[0].destroy();
              }
              return this;
          },
          /**
           * add node to container
           * @method
           * @memberof Kinetic.Container.prototype
           * @param {Node} child
           * @returns {Container}
           */
          add: function (child) {
              var children = this.children;

              this._validateAdd(child);
              child.index = children.length;
              child.parent = this;
              children.push(child);
              this._fire('add', {
                  child: child
              });

              // chainable
              return this;
          },
          destroy: function () {
              // destroy children
              if (this.hasChildren()) {
                  this.destroyChildren();
              }
              // then destroy self
              Kinetic.Node.prototype.destroy.call(this);
          },
          /**
           * return a {@link Kinetic.Collection} of nodes that match the selector.  Use '#' for id selections
           * and '.' for name selections.  You can also select by type or class name. Pass multiple selectors
           * separated by a space.
           * @method
           * @memberof Kinetic.Container.prototype
           * @param {String} selector
           * @returns {Collection}
           * @example
           * // select node with id foo<br>
           * var node = stage.find('#foo');<br><br>
           *
           * // select nodes with name bar inside layer<br>
           * var nodes = layer.find('.bar');<br><br>
           *
           * // select all groups inside layer<br>
           * var nodes = layer.find('Group');<br><br>
           *
           * // select all rectangles inside layer<br>
           * var nodes = layer.find('Rect');<br><br>
           *
           * // select node with an id of foo or a name of bar inside layer<br>
           * var nodes = layer.find('#foo, .bar');
           */
          find: function (selector) {
              var retArr = [
              ],
                selectorArr = selector.replace(/ /g, '').split(','),
                len = selectorArr.length,
                n, i, sel, arr, node, children, clen;

              for (n = 0; n < len; n++) {
                  sel = selectorArr[n];

                  // id selector
                  if (sel.charAt(0) === '#') {
                      node = this._getNodeById(sel.slice(1));
                      if (node) {
                          retArr.push(node);
                      }
                  }
                  // name selector
                  else if (sel.charAt(0) === '.') {
                      arr = this._getNodesByName(sel.slice(1));
                      retArr = retArr.concat(arr);
                  }
                  // unrecognized selector, pass to children
                  else {
                      children = this.getChildren();
                      clen = children.length;
                      for (i = 0; i < clen; i++) {
                          retArr = retArr.concat(children[i]._get(sel));
                      }
                  }
              }

              return Kinetic.Collection.toCollection(retArr);
          },
          _getNodeById: function (key) {
              var node = Kinetic.ids[key];

              if (node !== undefined && this.isAncestorOf(node)) {
                  return node;
              }
              return null;
          },
          _getNodesByName: function (key) {
              var arr = Kinetic.names[key] || [
              ];
              return this._getDescendants(arr);
          },
          _get: function (selector) {
              var retArr = Kinetic.Node.prototype._get.call(this, selector);
              var children = this.getChildren();
              var len = children.length;
              for (var n = 0; n < len; n++) {
                  retArr = retArr.concat(children[n]._get(selector));
              }
              return retArr;
          },
          // extenders
          toObject: function () {
              var obj = Kinetic.Node.prototype.toObject.call(this);

              obj.children = [
              ];

              var children = this.getChildren();
              var len = children.length;
              for (var n = 0; n < len; n++) {
                  var child = children[n];
                  obj.children.push(child.toObject());
              }

              return obj;
          },
          _getDescendants: function (arr) {
              var retArr = [
              ];
              var len = arr.length;
              for (var n = 0; n < len; n++) {
                  var node = arr[n];
                  if (this.isAncestorOf(node)) {
                      retArr.push(node);
                  }
              }

              return retArr;
          },
          /**
           * determine if node is an ancestor
           * of descendant
           * @method
           * @memberof Kinetic.Container.prototype
           * @param {Kinetic.Node} node
           */
          isAncestorOf: function (node) {
              var parent = node.getParent();
              while (parent) {
                  if (parent._id === this._id) {
                      return true;
                  }
                  parent = parent.getParent();
              }

              return false;
          },
          clone: function (obj) {
              // call super method
              var node = Kinetic.Node.prototype.clone.call(this, obj);

              this.getChildren().each(function (no) {
                  node.add(no.clone());
              });
              return node;
          },
          /**
           * get all shapes that intersect a point.  Note: because this method must clear a temporary
           * canvas and redraw every shape inside the container, it should only be used for special sitations
           * because it performs very poorly.  Please use the {@link Kinetic.Stage#getIntersection} method if at all possible
           * because it performs much better
           * @method
           * @memberof Kinetic.Container.prototype
           * @param {Object} pos
           * @param {Number} pos.x
           * @param {Number} pos.y
           * @returns {Array} array of shapes
           */
          getAllIntersections: function (pos) {
              var arr = [
              ];

              this.find('Shape').each(function (shape) {
                  if (shape.isVisible() && shape.intersects(pos)) {
                      arr.push(shape);
                  }
              });

              return arr;
          },
          _setChildrenIndices: function () {
              this.children.each(function (child, n) {
                  child.index = n;
              });
          },
          drawScene: function (can) {
              var layer = this.getLayer(),
                canvas = can || (layer && layer.getCanvas()),
                context = canvas && canvas.getContext(),
                cachedCanvas = this._cache.canvas,
                cachedSceneCanvas = cachedCanvas && cachedCanvas.scene;

              if (this.isVisible()) {
                  if (cachedSceneCanvas) {
                      this._drawCachedSceneCanvas(context);
                  }
                  else {
                      this._drawChildren(canvas, 'drawScene');
                  }
              }
              return this;
          },
          drawHit: function (can) {
              var layer = this.getLayer(),
                canvas = can || (layer && layer.hitCanvas),
                context = canvas && canvas.getContext(),
                cachedCanvas = this._cache.canvas,
                cachedHitCanvas = cachedCanvas && cachedCanvas.hit;

              if (this.shouldDrawHit()) {
                  if (cachedHitCanvas) {
                      this._drawCachedHitCanvas(context);
                  }
                  else {
                      this._drawChildren(canvas, 'drawHit');
                  }
              }
              return this;
          },
          _drawChildren: function (canvas, drawMethod) {
              var context = canvas && canvas.getContext(),
                clipWidth = this.getClipWidth(),
                clipHeight = this.getClipHeight(),
                hasClip = clipWidth && clipHeight,
                clipX, clipY;

              if (hasClip) {
                  clipX = this.getClipX();
                  clipY = this.getClipY();

                  context.save();
                  context._applyTransform(this);
                  context.beginPath();
                  context.rect(clipX, clipY, clipWidth, clipHeight);
                  context.clip();
                  context.reset();
              }

              this.children.each(function (child) {
                  child[drawMethod](canvas);
              });

              if (hasClip) {
                  context.restore();
              }
          }
      });

      Kinetic.Util.extend(Kinetic.Container, Kinetic.Node);
      // deprecated methods
      Kinetic.Container.prototype.get = Kinetic.Container.prototype.find;

      // add getters setters
      Kinetic.Factory.addComponentsGetterSetter(Kinetic.Container, 'clip', [
          'x',
          'y',
          'width',
          'height'
      ]);
      /**
       * get/set clip
       * @method
       * @name clip
       * @memberof Kinetic.Container.prototype
       * @param {Object} clip
       * @param {Number} clip.x
       * @param {Number} clip.y
       * @param {Number} clip.width
       * @param {Number} clip.height
       * @returns {Object}
       * @example
       * // get clip<br>
       * var clip = container.clip();<br><br>
       *
       * // set clip<br>
       * container.setClip({<br>
       *   x: 20,<br>
       *   y: 20,<br>
       *   width: 20,<br>
       *   height: 20<br>
       * });
       */

      Kinetic.Factory.addGetterSetter(Kinetic.Container, 'clipX');
      /**
       * get/set clip x
       * @name clipX
       * @method
       * @memberof Kinetic.Container.prototype
       * @param {Number} x
       * @returns {Number}
       * @example
       * // get clip x<br>
       * var clipX = container.clipX();<br><br>
       *
       * // set clip x<br>
       * container.clipX(10);
       */

      Kinetic.Factory.addGetterSetter(Kinetic.Container, 'clipY');
      /**
       * get/set clip y
       * @name clipY
       * @method
       * @memberof Kinetic.Container.prototype
       * @param {Number} y
       * @returns {Number}
       * @example
       * // get clip y<br>
       * var clipY = container.clipY();<br><br>
       *
       * // set clip y<br>
       * container.clipY(10);
       */

      Kinetic.Factory.addGetterSetter(Kinetic.Container, 'clipWidth');
      /**
       * get/set clip width
       * @name clipWidth
       * @method
       * @memberof Kinetic.Container.prototype
       * @param {Number} width
       * @returns {Number}
       * @example
       * // get clip width<br>
       * var clipWidth = container.clipWidth();<br><br>
       *
       * // set clip width<br>
       * container.clipWidth(100);
       */

      Kinetic.Factory.addGetterSetter(Kinetic.Container, 'clipHeight');
      /**
       * get/set clip height
       * @name clipHeight
       * @method
       * @memberof Kinetic.Container.prototype
       * @param {Number} height
       * @returns {Number}
       * @example
       * // get clip height<br>
       * var clipHeight = container.clipHeight();<br><br>
       *
       * // set clip height<br>
       * container.clipHeight(100);
       */

      Kinetic.Collection.mapMethods(Kinetic.Container);
  })();
  ;
  (function () {
      var HAS_SHADOW = 'hasShadow';

      function _fillFunc (context) {
          context.fill();
      }
      function _strokeFunc (context) {
          context.stroke();
      }
      function _fillFuncHit (context) {
          context.fill();
      }
      function _strokeFuncHit (context) {
          context.stroke();
      }

      function _clearHasShadowCache () {
          this._clearCache(HAS_SHADOW);
      }

      Kinetic.Util.addMethods(Kinetic.Shape, {
          __init: function (config) {
              this.nodeType = 'Shape';
              this._fillFunc = _fillFunc;
              this._strokeFunc = _strokeFunc;
              this._fillFuncHit = _fillFuncHit;
              this._strokeFuncHit = _strokeFuncHit;

              // set colorKey
              var shapes = Kinetic.shapes;
              var key;

              while (true) {
                  key = Kinetic.Util.getRandomColor();
                  if (key && !(key in shapes)) {
                      break;
                  }
              }

              this.colorKey = key;
              shapes[key] = this;

              // call super constructor
              Kinetic.Node.call(this, config);

              this.on('shadowColorChange.kinetic shadowBlurChange.kinetic shadowOffsetChange.kinetic shadowOpacityChange.kinetic shadowEnabledChanged.kinetic', _clearHasShadowCache);
          },
          hasChildren: function () {
              return false;
          },
          getChildren: function () {
              return [
              ];
          },
          /**
           * get canvas context tied to the layer
           * @method
           * @memberof Kinetic.Shape.prototype
           * @returns {Kinetic.Context}
           */
          getContext: function () {
              return this.getLayer().getContext();
          },
          /**
           * get canvas renderer tied to the layer.  Note that this returns a canvas renderer, not a canvas element
           * @method
           * @memberof Kinetic.Shape.prototype
           * @returns {Kinetic.Canvas}
           */
          getCanvas: function () {
              return this.getLayer().getCanvas();
          },
          /**
           * returns whether or not a shadow will be rendered
           * @method
           * @memberof Kinetic.Shape.prototype
           * @returns {Boolean}
           */
          hasShadow: function () {
              return this._getCache(HAS_SHADOW, this._hasShadow);
          },
          _hasShadow: function () {
              return this.getShadowEnabled() && (this.getShadowOpacity() !== 0 && !!(this.getShadowColor() || this.getShadowBlur() || this.getShadowOffsetX() || this.getShadowOffsetY()));
          },
          /**
           * returns whether or not the shape will be filled
           * @method
           * @memberof Kinetic.Shape.prototype
           * @returns {Boolean}
           */
          hasFill: function () {
              return !!(this.getFill() || this.getFillPatternImage() || this.getFillLinearGradientColorStops() || this.getFillRadialGradientColorStops());
          },
          /**
           * returns whether or not the shape will be stroked
           * @method
           * @memberof Kinetic.Shape.prototype
           * @returns {Boolean}
           */
          hasStroke: function () {
              return !!(this.stroke() || this.strokeRed() || this.strokeGreen() || this.strokeBlue());
          },
          _get: function (selector) {
              return this.className === selector || this.nodeType === selector ? [
                  this
              ] : [
              ];
          },
          /**
           * determines if point is in the shape, regardless if other shapes are on top of it.  Note: because
           *  this method clears a temporary canvas and then redraws the shape, it performs very poorly if executed many times
           *  consecutively.  Please use the {@link Kinetic.Stage#getIntersection} method if at all possible
           *  because it performs much better
           * @method
           * @memberof Kinetic.Shape.prototype
           * @param {Object} point
           * @param {Number} point.x
           * @param {Number} point.y
           * @returns {Boolean}
           */
          intersects: function (pos) {
              var stage = this.getStage(),
                bufferHitCanvas = stage.bufferHitCanvas,
                p;

              bufferHitCanvas.getContext().clear();
              this.drawScene(bufferHitCanvas);
              p = bufferHitCanvas.context.getImageData(pos.x | 0, pos.y | 0, 1, 1).data;
              return p[3] > 0;
          },
          // extends Node.prototype.destroy
          destroy: function () {
              Kinetic.Node.prototype.destroy.call(this);
              delete Kinetic.shapes[this.colorKey];
          },
          _useBufferCanvas: function () {
              return (this.hasShadow() || this.getAbsoluteOpacity() !== 1) && this.hasFill() && this.hasStroke();
          },
          drawScene: function (can) {
              var canvas = can || this.getLayer().getCanvas(),
                context = canvas.getContext(),
                cachedCanvas = this._cache.canvas,
                drawFunc = this.sceneFunc(),
                hasShadow = this.hasShadow(),
                stage, bufferCanvas, bufferContext;

              if (this.isVisible()) {
                  if (cachedCanvas) {
                      this._drawCachedSceneCanvas(context);
                  }
                  else if (drawFunc) {
                      context.save();
                      // if buffer canvas is needed
                      if (this._useBufferCanvas()) {
                          stage = this.getStage();
                          bufferCanvas = stage.bufferCanvas;
                          bufferContext = bufferCanvas.getContext();
                          bufferContext.clear();
                          bufferContext.save();
                          bufferContext._applyLineJoin(this);
                          bufferContext._applyTransform(this);

                          drawFunc.call(this, bufferContext);
                          bufferContext.restore();

                          if (hasShadow) {
                              context.save();
                              context._applyShadow(this);
                              context.drawImage(bufferCanvas._canvas, 0, 0);
                              context.restore();
                          }

                          context._applyOpacity(this);
                          context.drawImage(bufferCanvas._canvas, 0, 0);
                      }
                      // if buffer canvas is not needed
                      else {
                          context._applyLineJoin(this);
                          context._applyTransform(this);

                          if (hasShadow) {
                              context.save();
                              context._applyShadow(this);
                              drawFunc.call(this, context);
                              context.restore();
                          }

                          context._applyOpacity(this);
                          drawFunc.call(this, context);
                      }
                      context.restore();
                  }
              }

              return this;
          },
          drawHit: function (can) {
              var canvas = can || this.getLayer().hitCanvas,
                context = canvas.getContext(),
                drawFunc = this.hitFunc() || this.sceneFunc(),
                cachedCanvas = this._cache.canvas,
                cachedHitCanvas = cachedCanvas && cachedCanvas.hit;

              if (this.shouldDrawHit()) {

                  if (cachedHitCanvas) {
                      this._drawCachedHitCanvas(context);
                  }
                  else if (drawFunc) {
                      context.save();
                      context._applyLineJoin(this);
                      context._applyTransform(this);

                      drawFunc.call(this, context);
                      context.restore();
                  }

              }

              return this;
          },
          /**
           * draw hit graph using the cached scene canvas
           * @method
           * @memberof Kinetic.Shape.prototype
           * @param {Integer} alphaThreshold alpha channel threshold that determines whether or not
           *  a pixel should be drawn onto the hit graph.  Must be a value between 0 and 255.
           *  The default is 0
           * @returns {Kinetic.Shape}
           * @example
           * shape.cache();
           * shape.drawHitFromCache();
           */
          drawHitFromCache: function (alphaThreshold) {
              var threshold = alphaThreshold || 0,
                cachedCanvas = this._cache.canvas,
                sceneCanvas = this._getCachedSceneCanvas(),
                sceneContext = sceneCanvas.getContext(),
                hitCanvas = cachedCanvas.hit,
                hitContext = hitCanvas.getContext(),
                width = sceneCanvas.getWidth(),
                height = sceneCanvas.getHeight(),
                sceneImageData, sceneData, hitImageData, hitData, len, rgbColorKey, i, alpha;

              hitContext.clear();

              try {
                  sceneImageData = sceneContext.getImageData(0, 0, width, height);
                  sceneData = sceneImageData.data;
                  hitImageData = hitContext.getImageData(0, 0, width, height);
                  hitData = hitImageData.data;
                  len = sceneData.length;
                  rgbColorKey = Kinetic.Util._hexToRgb(this.colorKey);

                  // replace non transparent pixels with color key
                  for (i = 0; i < len; i += 4) {
                      alpha = sceneData[i + 3];
                      if (alpha > threshold) {
                          hitData[i] = rgbColorKey.r;
                          hitData[i + 1] = rgbColorKey.g;
                          hitData[i + 2] = rgbColorKey.b;
                          hitData[i + 3] = 255;
                      }
                  }

                  hitContext.putImageData(hitImageData, 0, 0);
              }
              catch (e) {
                  Kinetic.Util.warn('Unable to draw hit graph from cached scene canvas. ' + e.message);
              }

              return this;
          },
      });
      Kinetic.Util.extend(Kinetic.Shape, Kinetic.Node);

      // add getters and setters
      Kinetic.Factory.addGetterSetter(Kinetic.Shape, 'stroke');

      /**
       * get/set stroke color
       * @name stroke
       * @method
       * @memberof Kinetic.Shape.prototype
       * @param {String} color
       * @returns {String}
       * @example
       * // get stroke color<br>
       * var stroke = shape.stroke();<br><br>
       *
       * // set stroke color with color string<br>
       * shape.stroke('green');<br><br>
       *
       * // set stroke color with hex<br>
       * shape.stroke('#00ff00');<br><br>
       *
       * // set stroke color with rgb<br>
       * shape.stroke('rgb(0,255,0)');<br><br>
       *
       * // set stroke color with rgba and make it 50% opaque<br>
       * shape.stroke('rgba(0,255,0,0.5');
       */

      Kinetic.Factory.addGetterSetter(Kinetic.Shape, 'strokeRed', 0, Kinetic.Validators.RGBComponent);

      /**
       * get/set stroke red component
       * @name strokeRed
       * @method
       * @memberof Kinetic.Shape.prototype
       * @param {Integer} red
       * @returns {Integer}
       * @example
       * // get stroke red component<br>
       * var strokeRed = shape.strokeRed();<br><br>
       *
       * // set stroke red component<br>
       * shape.strokeRed(0);
       */

      Kinetic.Factory.addGetterSetter(Kinetic.Shape, 'strokeGreen', 0, Kinetic.Validators.RGBComponent);

      /**
       * get/set stroke green component
       * @name strokeGreen
       * @method
       * @memberof Kinetic.Shape.prototype
       * @param {Integer} green
       * @returns {Integer}
       * @example
       * // get stroke green component<br>
       * var strokeGreen = shape.strokeGreen();<br><br>
       *
       * // set stroke green component<br>
       * shape.strokeGreen(255);
       */

      Kinetic.Factory.addGetterSetter(Kinetic.Shape, 'strokeBlue', 0, Kinetic.Validators.RGBComponent);

      /**
       * get/set stroke blue component
       * @name strokeBlue
       * @method
       * @memberof Kinetic.Shape.prototype
       * @param {Integer} blue
       * @returns {Integer}
       * @example
       * // get stroke blue component<br>
       * var strokeBlue = shape.strokeBlue();<br><br>
       *
       * // set stroke blue component<br>
       * shape.strokeBlue(0);
       */

      Kinetic.Factory.addGetterSetter(Kinetic.Shape, 'strokeAlpha', 1, Kinetic.Validators.alphaComponent);

      /**
       * get/set stroke alpha component.  Alpha is a real number between 0 and 1.  The default
       *  is 1.
       * @name strokeAlpha
       * @method
       * @memberof Kinetic.Shape.prototype
       * @param {Number} alpha
       * @returns {Number}
       * @example
       * // get stroke alpha component<br>
       * var strokeAlpha = shape.strokeAlpha();<br><br>
       *
       * // set stroke alpha component<br>
       * shape.strokeAlpha(0.5);
       */

      Kinetic.Factory.addGetterSetter(Kinetic.Shape, 'strokeWidth', 2);

      /**
       * get/set stroke width
       * @name strokeWidth
       * @method
       * @memberof Kinetic.Shape.prototype
       * @param {Number} strokeWidth
       * @returns {Number}
       * @example
       * // get stroke width<br>
       * var strokeWidth = shape.strokeWidth();<br><br>
       *
       * // set stroke width<br>
       * shape.strokeWidth();
       */

      Kinetic.Factory.addGetterSetter(Kinetic.Shape, 'lineJoin');

      /**
       * get/set line join.  Can be miter, round, or bevel.  The
       *  default is miter
       * @name lineJoin
       * @method
       * @memberof Kinetic.Shape.prototype
       * @param {String} lineJoin
       * @returns {String}
       * @example
       * // get line join<br>
       * var lineJoin = shape.lineJoin();<br><br>
       *
       * // set line join<br>
       * shape.lineJoin('round');
       */

      Kinetic.Factory.addGetterSetter(Kinetic.Shape, 'lineCap');

      /**
       * get/set line cap.  Can be butt, round, or square
       * @name lineCap
       * @method
       * @memberof Kinetic.Shape.prototype
       * @param {String} lineCap
       * @returns {String}
       * @example
       * // get line cap<br>
       * var lineCap = shape.lineCap();<br><br>
       *
       * // set line cap<br>
       * shape.lineCap('round');
       */

      Kinetic.Factory.addGetterSetter(Kinetic.Shape, 'sceneFunc');

      /**
       * get/set scene draw function
       * @name sceneFunc
       * @method
       * @memberof Kinetic.Shape.prototype
       * @param {Function} drawFunc drawing function
       * @returns {Function}
       * @example
       * // get scene draw function<br>
       * var sceneFunc = shape.sceneFunc();<br><br>
       *
       * // set scene draw function<br>
       * shape.sceneFunc(function(context) {<br>
       *   context.beginPath();<br>
       *   context.rect(0, 0, this.width(), this.height());<br>
       *   context.closePath();<br>
       *   context.fillStrokeShape(this);<br>
       * });
       */

      Kinetic.Factory.addGetterSetter(Kinetic.Shape, 'hitFunc');

      /**
       * get/set hit draw function
       * @name hitFunc
       * @method
       * @memberof Kinetic.Shape.prototype
       * @param {Function} drawFunc drawing function
       * @returns {Function}
       * @example
       * // get hit draw function<br>
       * var hitFunc = shape.hitFunc();<br><br>
       *
       * // set hit draw function<br>
       * shape.hitFunc(function(context) {<br>
       *   context.beginPath();<br>
       *   context.rect(0, 0, this.width(), this.height());<br>
       *   context.closePath();<br>
       *   context.fillStrokeShape(this);<br>
       * });
       */

      Kinetic.Factory.addGetterSetter(Kinetic.Shape, 'dash');

      /**
       * get/set dash array for stroke.
       * @name dash
       * @method
       * @memberof Kinetic.Shape.prototype
       * @param {Array} dash
       * @returns {Array}
       * @example
       *  // apply dashed stroke that is 10px long and 5 pixels apart<br>
       *  line.dash([10, 5]);<br><br>
       *
       *  // apply dashed stroke that is made up of alternating dashed<br>
       *  // lines that are 10px long and 20px apart, and dots that have<br>
       *  // a radius of 5px and are 20px apart<br>
       *  line.dash([10, 20, 0.001, 20]);
       */


      Kinetic.Factory.addGetterSetter(Kinetic.Shape, 'shadowColor');

      /**
       * get/set shadow color
       * @name shadowColor
       * @method
       * @memberof Kinetic.Shape.prototype
       * @param {String} color
       * @returns {String}
       * @example
       * // get shadow color<br>
       * var shadow = shape.shadowColor();<br><br>
       *
       * // set shadow color with color string<br>
       * shape.shadowColor('green');<br><br>
       *
       * // set shadow color with hex<br>
       * shape.shadowColor('#00ff00');<br><br>
       *
       * // set shadow color with rgb<br>
       * shape.shadowColor('rgb(0,255,0)');<br><br>
       *
       * // set shadow color with rgba and make it 50% opaque<br>
       * shape.shadowColor('rgba(0,255,0,0.5');
       */

      Kinetic.Factory.addGetterSetter(Kinetic.Shape, 'shadowRed', 0, Kinetic.Validators.RGBComponent);

      /**
       * get/set shadow red component
       * @name shadowRed
       * @method
       * @memberof Kinetic.Shape.prototype
       * @param {Integer} red
       * @returns {Integer}
       * @example
       * // get shadow red component<br>
       * var shadowRed = shape.shadowRed();<br><br>
       *
       * // set shadow red component<br>
       * shape.shadowRed(0);
       */

      Kinetic.Factory.addGetterSetter(Kinetic.Shape, 'shadowGreen', 0, Kinetic.Validators.RGBComponent);

      /**
       * get/set shadow green component
       * @name shadowGreen
       * @method
       * @memberof Kinetic.Shape.prototype
       * @param {Integer} green
       * @returns {Integer}
       * @example
       * // get shadow green component<br>
       * var shadowGreen = shape.shadowGreen();<br><br>
       *
       * // set shadow green component<br>
       * shape.shadowGreen(255);
       */

      Kinetic.Factory.addGetterSetter(Kinetic.Shape, 'shadowBlue', 0, Kinetic.Validators.RGBComponent);

      /**
       * get/set shadow blue component
       * @name shadowBlue
       * @method
       * @memberof Kinetic.Shape.prototype
       * @param {Integer} blue
       * @returns {Integer}
       * @example
       * // get shadow blue component<br>
       * var shadowBlue = shape.shadowBlue();<br><br>
       *
       * // set shadow blue component<br>
       * shape.shadowBlue(0);
       */

      Kinetic.Factory.addGetterSetter(Kinetic.Shape, 'shadowAlpha', 1, Kinetic.Validators.alphaComponent);

      /**
       * get/set shadow alpha component.  Alpha is a real number between 0 and 1.  The default
       *  is 1.
       * @name shadowAlpha
       * @method
       * @memberof Kinetic.Shape.prototype
       * @param {Number} alpha
       * @returns {Number}
       * @example
       * // get shadow alpha component<br>
       * var shadowAlpha = shape.shadowAlpha();<br><br>
       *
       * // set shadow alpha component<br>
       * shape.shadowAlpha(0.5);
       */

      Kinetic.Factory.addGetterSetter(Kinetic.Shape, 'shadowBlur');

      /**
       * get/set shadow blur
       * @name shadowBlur
       * @method
       * @memberof Kinetic.Shape.prototype
       * @param {Number} blur
       * @returns {Number}
       * @example
       * // get shadow blur<br>
       * var shadowBlur = shape.shadowBlur();<br><br>
       *
       * // set shadow blur<br>
       * shape.shadowBlur(10);
       */

      Kinetic.Factory.addGetterSetter(Kinetic.Shape, 'shadowOpacity');

      /**
       * get/set shadow opacity.  must be a value between 0 and 1
       * @name shadowOpacity
       * @method
       * @memberof Kinetic.Shape.prototype
       * @param {Number} opacity
       * @returns {Number}
       * @example
       * // get shadow opacity<br>
       * var shadowOpacity = shape.shadowOpacity();<br><br>
       *
       * // set shadow opacity<br>
       * shape.shadowOpacity(0.5);
       */

      Kinetic.Factory.addComponentsGetterSetter(Kinetic.Shape, 'shadowOffset', [
          'x',
          'y'
      ]);

      /**
       * get/set shadow offset
       * @name shadowOffset
       * @method
       * @memberof Kinetic.Shape.prototype
       * @param {Object} offset
       * @param {Number} offset.x
       * @param {Number} offset.y
       * @returns {Object}
       * @example
       * // get shadow offset<br>
       * var shadowOffset = shape.shadowOffset();<br><br>
       *
       * // set shadow offset<br>
       * shape.shadowOffset({<br>
       *   x: 20<br>
       *   y: 10<br>
       * });
       */

      Kinetic.Factory.addGetterSetter(Kinetic.Shape, 'shadowOffsetX', 0);

      /**
       * get/set shadow offset x
       * @name shadowOffsetX
       * @method
       * @memberof Kinetic.Shape.prototype
       * @param {Number} x
       * @returns {Number}
       * @example
       * // get shadow offset x<br>
       * var shadowOffsetX = shape.shadowOffsetX();<br><br>
       *
       * // set shadow offset x<br>
       * shape.shadowOffsetX(5);
       */

      Kinetic.Factory.addGetterSetter(Kinetic.Shape, 'shadowOffsetY', 0);

      /**
       * get/set shadow offset y
       * @name shadowOffsetY
       * @method
       * @memberof Kinetic.Shape.prototype
       * @param {Number} y
       * @returns {Number}
       * @example
       * // get shadow offset y<br>
       * var shadowOffsetY = shape.shadowOffsetY();<br><br>
       *
       * // set shadow offset y<br>
       * shape.shadowOffsetY(5);
       */

      Kinetic.Factory.addGetterSetter(Kinetic.Shape, 'fillPatternImage');

      /**
       * get/set fill pattern image
       * @name fillPatternImage
       * @method
       * @memberof Kinetic.Shape.prototype
       * @param {Image} image object
       * @returns {Image}
       * @example
       * // get fill pattern image<br>
       * var fillPatternImage = shape.fillPatternImage();<br><br>
       *
       * // set fill pattern image<br>
       * var imageObj = new Image();<br>
       * imageObj.onload = function() {<br>
       *   shape.fillPatternImage(imageObj);<br>
       * };<br>
       * imageObj.src = 'path/to/image/jpg';
       */

      Kinetic.Factory.addGetterSetter(Kinetic.Shape, 'fill');

      /**
       * get/set fill color
       * @name fill
       * @method
       * @memberof Kinetic.Shape.prototype
       * @param {String} color
       * @returns {String}
       * @example
       * // get fill color<br>
       * var fill = shape.fill();<br><br>
       *
       * // set fill color with color string<br>
       * shape.fill('green');<br><br>
       *
       * // set fill color with hex<br>
       * shape.fill('#00ff00');<br><br>
       *
       * // set fill color with rgb<br>
       * shape.fill('rgb(0,255,0)');<br><br>
       *
       * // set fill color with rgba and make it 50% opaque<br>
       * shape.fill('rgba(0,255,0,0.5');
       */

      Kinetic.Factory.addGetterSetter(Kinetic.Shape, 'fillRed', 0, Kinetic.Validators.RGBComponent);

      /**
       * get/set fill red component
       * @name fillRed
       * @method
       * @memberof Kinetic.Shape.prototype
       * @param {Integer} red
       * @returns {Integer}
       * @example
       * // get fill red component<br>
       * var fillRed = shape.fillRed();<br><br>
       *
       * // set fill red component<br>
       * shape.fillRed(0);
       */

      Kinetic.Factory.addGetterSetter(Kinetic.Shape, 'fillGreen', 0, Kinetic.Validators.RGBComponent);

      /**
       * get/set fill green component
       * @name fillGreen
       * @method
       * @memberof Kinetic.Shape.prototype
       * @param {Integer} green
       * @returns {Integer}
       * @example
       * // get fill green component<br>
       * var fillGreen = shape.fillGreen();<br><br>
       *
       * // set fill green component<br>
       * shape.fillGreen(255);
       */

      Kinetic.Factory.addGetterSetter(Kinetic.Shape, 'fillBlue', 0, Kinetic.Validators.RGBComponent);

      /**
       * get/set fill blue component
       * @name fillBlue
       * @method
       * @memberof Kinetic.Shape.prototype
       * @param {Integer} blue
       * @returns {Integer}
       * @example
       * // get fill blue component<br>
       * var fillBlue = shape.fillBlue();<br><br>
       *
       * // set fill blue component<br>
       * shape.fillBlue(0);
       */

      Kinetic.Factory.addGetterSetter(Kinetic.Shape, 'fillAlpha', 1, Kinetic.Validators.alphaComponent);

      /**
       * get/set fill alpha component.  Alpha is a real number between 0 and 1.  The default
       *  is 1.
       * @name fillAlpha
       * @method
       * @memberof Kinetic.Shape.prototype
       * @param {Number} alpha
       * @returns {Number}
       * @example
       * // get fill alpha component<br>
       * var fillAlpha = shape.fillAlpha();<br><br>
       *
       * // set fill alpha component<br>
       * shape.fillAlpha(0.5);
       */


      Kinetic.Factory.addGetterSetter(Kinetic.Shape, 'fillPatternX', 0);

      /**
       * get/set fill pattern x
       * @name fillPatternX
       * @method
       * @memberof Kinetic.Shape.prototype
       * @param {Number} x
       * @returns {Number}
       * @example
       * // get fill pattern x<br>
       * var fillPatternX = shape.fillPatternX();<br><br>
       *
       * // set fill pattern x<br>
       * shape.fillPatternX(20);
       */

      Kinetic.Factory.addGetterSetter(Kinetic.Shape, 'fillPatternY', 0);

      /**
       * get/set fill pattern y
       * @name fillPatternY
       * @method
       * @memberof Kinetic.Shape.prototype
       * @param {Number} y
       * @returns {Number}
       * @example
       * // get fill pattern y<br>
       * var fillPatternY = shape.fillPatternY();<br><br>
       *
       * // set fill pattern y<br>
       * shape.fillPatternY(20);
       */

      Kinetic.Factory.addGetterSetter(Kinetic.Shape, 'fillLinearGradientColorStops');

      /**
       * get/set fill linear gradient color stops
       * @name fillLinearGradientColorStops
       * @method
       * @memberof Kinetic.Shape.prototype
       * @param {Array} colorStops
       * @returns {Array} colorStops
       * @example
       * // get fill linear gradient color stops<br>
       * var colorStops = shape.fillLinearGradientColorStops();<br><br>
       *
       * // create a linear gradient that starts with red, changes to blue <br>
       * // halfway through, and then changes to green<br>
       * shape.fillLinearGradientColorStops(0, 'red', 0.5, 'blue', 1, 'green');
       */

      Kinetic.Factory.addGetterSetter(Kinetic.Shape, 'fillRadialGradientStartRadius', 0);

      /**
       * get/set fill radial gradient start radius
       * @name fillRadialGradientStartRadius
       * @method
       * @memberof Kinetic.Shape.prototype
       * @param {Number} radius
       * @returns {Number}
       * @example
       * // get radial gradient start radius<br>
       * var startRadius = shape.fillRadialGradientStartRadius();<br><br>
       *
       * // set radial gradient start radius<br>
       * shape.fillRadialGradientStartRadius(0);
       */

      Kinetic.Factory.addGetterSetter(Kinetic.Shape, 'fillRadialGradientEndRadius', 0);

      /**
       * get/set fill radial gradient end radius
       * @name fillRadialGradientEndRadius
       * @method
       * @memberof Kinetic.Shape.prototype
       * @param {Number} radius
       * @returns {Number}
       * @example
       * // get radial gradient end radius<br>
       * var endRadius = shape.fillRadialGradientEndRadius();<br><br>
       *
       * // set radial gradient end radius<br>
       * shape.fillRadialGradientEndRadius(100);
       */

      Kinetic.Factory.addGetterSetter(Kinetic.Shape, 'fillRadialGradientColorStops');

      /**
       * get/set fill radial gradient color stops
       * @name fillRadialGradientColorStops
       * @method
       * @memberof Kinetic.Shape.prototype
       * @param {Number} colorStops
       * @returns {Array}
       * @example
       * // get fill radial gradient color stops<br>
       * var colorStops = shape.fillRadialGradientColorStops();<br><br>
       *
       * // create a radial gradient that starts with red, changes to blue <br>
       * // halfway through, and then changes to green<br>
       * shape.fillRadialGradientColorStops(0, 'red', 0.5, 'blue', 1, 'green');
       */

      Kinetic.Factory.addGetterSetter(Kinetic.Shape, 'fillPatternRepeat', 'repeat');

      /**
       * get/set fill pattern repeat.  Can be 'repeat', 'repeat-x', 'repeat-y', or 'no-repeat'.  The default is 'repeat'
       * @name fillPatternRepeat
       * @method
       * @memberof Kinetic.Shape.prototype
       * @param {String} repeat
       * @returns {String}
       * @example
       * // get fill pattern repeat<br>
       * var repeat = shape.fillPatternRepeat();<br><br>
       *
       * // repeat pattern in x direction only<br>
       * shape.fillPatternRepeat('repeat-x');<br><br>
       *
       * // do not repeat the pattern<br>
       * shape.fillPatternRepeat('no repeat');
       */

      Kinetic.Factory.addGetterSetter(Kinetic.Shape, 'fillEnabled', true);

      /**
       * get/set fill enabled flag
       * @name fillEnabled
       * @method
       * @memberof Kinetic.Shape.prototype
       * @param {Boolean} enabled
       * @returns {Boolean}
       * @example
       * // get fill enabled flag<br>
       * var fillEnabled = shape.fillEnabled();<br><br>
       *
       * // disable fill<br>
       * shape.fillEnabled(false);<br><br>
       *
       * // enable fill<br>
       * shape.fillEnabled(true);
       */

      Kinetic.Factory.addGetterSetter(Kinetic.Shape, 'strokeEnabled', true);

      /**
       * get/set stroke enabled flag
       * @name strokeEnabled
       * @method
       * @memberof Kinetic.Shape.prototype
       * @param {Boolean} enabled
       * @returns {Boolean}
       * @example
       * // get stroke enabled flag<br>
       * var strokeEnabled = shape.strokeEnabled();<br><br>
       *
       * // disable stroke<br>
       * shape.strokeEnabled(false);<br><br>
       *
       * // enable stroke<br>
       * shape.strokeEnabled(true);
       */

      Kinetic.Factory.addGetterSetter(Kinetic.Shape, 'shadowEnabled', true);

      /**
       * get/set shadow enabled flag
       * @name shadowEnabled
       * @method
       * @memberof Kinetic.Shape.prototype
       * @param {Boolean} enabled
       * @returns {Boolean}
       * @example
       * // get shadow enabled flag<br>
       * var shadowEnabled = shape.shadowEnabled();<br><br>
       *
       * // disable shadow<br>
       * shape.shadowEnabled(false);<br><br>
       *
       * // enable shadow<br>
       * shape.shadowEnabled(true);
       */

      Kinetic.Factory.addGetterSetter(Kinetic.Shape, 'dashEnabled', true);

      /**
       * get/set dash enabled flag
       * @name dashEnabled
       * @method
       * @memberof Kinetic.Shape.prototype
       * @param {Boolean} enabled
       * @returns {Boolean}
       * @example
       * // get dash enabled flag<br>
       * var dashEnabled = shape.dashEnabled();<br><br>
       *
       * // disable dash<br>
       * shape.dashEnabled(false);<br><br>
       *
       * // enable dash<br>
       * shape.dashEnabled(true);
       */

      Kinetic.Factory.addGetterSetter(Kinetic.Shape, 'strokeScaleEnabled', true);

      /**
       * get/set strokeScale enabled flag
       * @name strokeScaleEnabled
       * @method
       * @memberof Kinetic.Shape.prototype
       * @param {Boolean} enabled
       * @returns {Boolean}
       * @example
       * // get stroke scale enabled flag<br>
       * var strokeScaleEnabled = shape.strokeScaleEnabled();<br><br>
       *
       * // disable stroke scale<br>
       * shape.strokeScaleEnabled(false);<br><br>
       *
       * // enable stroke scale<br>
       * shape.strokeScaleEnabled(true);
       */

      Kinetic.Factory.addGetterSetter(Kinetic.Shape, 'fillPriority', 'color');

      /**
       * get/set fill priority.  can be color, pattern, linear-gradient, or radial-gradient.  The default is color.
       *   This is handy if you want to toggle between different fill types.
       * @name fillPriority
       * @method
       * @memberof Kinetic.Shape.prototype
       * @param {String} priority
       * @returns {String}
       * @example
       * // get fill priority<br>
       * var fillPriority = shape.fillPriority();<br><br>
       *
       * // set fill priority<br>
       * shape.fillPriority('linear-gradient');
       */

      Kinetic.Factory.addComponentsGetterSetter(Kinetic.Shape, 'fillPatternOffset', [
          'x',
          'y'
      ]);

      /**
       * get/set fill pattern offset
       * @name fillPatternOffset
       * @method
       * @memberof Kinetic.Shape.prototype
       * @param {Object} offset
       * @param {Number} offset.x
       * @param {Number} offset.y
       * @returns {Object}
       * @example
       * // get fill pattern offset<br>
       * var patternOffset = shape.fillPatternOffset();<br><br>
       *
       * // set fill pattern offset<br>
       * shape.fillPatternOffset({<br>
       *   x: 20<br>
       *   y: 10<br>
       * });
       */


      Kinetic.Factory.addGetterSetter(Kinetic.Shape, 'fillPatternOffsetX', 0);
      /**
       * get/set fill pattern offset x
       * @name fillPatternOffsetX
       * @method
       * @memberof Kinetic.Shape.prototype
       * @param {Number} x
       * @returns {Number}
       * @example
       * // get fill pattern offset x<br>
       * var patternOffsetX = shape.fillPatternOffsetX();<br><br>
       *
       * // set fill pattern offset x<br>
       * shape.fillPatternOffsetX(20);
       */

      Kinetic.Factory.addGetterSetter(Kinetic.Shape, 'fillPatternOffsetY', 0);
      /**
       * get/set fill pattern offset y
       * @name fillPatternOffsetY
       * @method
       * @memberof Kinetic.Shape.prototype
       * @param {Number} y
       * @returns {Number}
       * @example
       * // get fill pattern offset y<br>
       * var patternOffsetY = shape.fillPatternOffsetY();<br><br>
       *
       * // set fill pattern offset y<br>
       * shape.fillPatternOffsetY(10);
       */

      Kinetic.Factory.addComponentsGetterSetter(Kinetic.Shape, 'fillPatternScale', [
          'x',
          'y'
      ]);

      /**
       * get/set fill pattern scale
       * @name fillPatternScale
       * @method
       * @memberof Kinetic.Shape.prototype
       * @param {Object} scale
       * @param {Number} scale.x
       * @param {Number} scale.y
       * @returns {Object}
       * @example
       * // get fill pattern scale<br>
       * var patternScale = shape.fillPatternScale();<br><br>
       *
       * // set fill pattern scale<br>
       * shape.fillPatternScale({<br>
       *   x: 2<br>
       *   y: 2<br>
       * });
       */


      Kinetic.Factory.addGetterSetter(Kinetic.Shape, 'fillPatternScaleX', 1);
      /**
       * get/set fill pattern scale x
       * @name fillPatternScaleX
       * @method
       * @memberof Kinetic.Shape.prototype
       * @param {Number} x
       * @returns {Number}
       * @example
       * // get fill pattern scale x<br>
       * var patternScaleX = shape.fillPatternScaleX();<br><br>
       *
       * // set fill pattern scale x<br>
       * shape.fillPatternScaleX(2);
       */

      Kinetic.Factory.addGetterSetter(Kinetic.Shape, 'fillPatternScaleY', 1);
      /**
       * get/set fill pattern scale y
       * @name fillPatternScaleY
       * @method
       * @memberof Kinetic.Shape.prototype
       * @param {Number} y
       * @returns {Number}
       * @example
       * // get fill pattern scale y<br>
       * var patternScaleY = shape.fillPatternScaleY();<br><br>
       *
       * // set fill pattern scale y<br>
       * shape.fillPatternScaleY(2);
       */

      Kinetic.Factory.addComponentsGetterSetter(Kinetic.Shape, 'fillLinearGradientStartPoint', [
          'x',
          'y'
      ]);

      /**
       * get/set fill linear gradient start point
       * @name fillLinearGradientStartPoint
       * @method
       * @memberof Kinetic.Shape.prototype
       * @param {Object} startPoint
       * @param {Number} startPoint.x
       * @param {Number} startPoint.y
       * @returns {Object}
       * @example
       * // get fill linear gradient start point<br>
       * var startPoint = shape.fillLinearGradientStartPoint();<br><br>
       *
       * // set fill linear gradient start point<br>
       * shape.fillLinearGradientStartPoint({<br>
       *   x: 20<br>
       *   y: 10<br>
       * });
       */

      Kinetic.Factory.addGetterSetter(Kinetic.Shape, 'fillLinearGradientStartPointX', 0);
      /**
       * get/set fill linear gradient start point x
       * @name fillLinearGradientStartPointX
       * @method
       * @memberof Kinetic.Shape.prototype
       * @param {Number} x
       * @returns {Number}
       * @example
       * // get fill linear gradient start point x<br>
       * var startPointX = shape.fillLinearGradientStartPointX();<br><br>
       *
       * // set fill linear gradient start point x<br>
       * shape.fillLinearGradientStartPointX(20);
       */

      Kinetic.Factory.addGetterSetter(Kinetic.Shape, 'fillLinearGradientStartPointY', 0);
      /**
       * get/set fill linear gradient start point y
       * @name fillLinearGradientStartPointY
       * @method
       * @memberof Kinetic.Shape.prototype
       * @param {Number} y
       * @returns {Number}
       * @example
       * // get fill linear gradient start point y<br>
       * var startPointY = shape.fillLinearGradientStartPointY();<br><br>
       *
       * // set fill linear gradient start point y<br>
       * shape.fillLinearGradientStartPointY(20);
       */

      Kinetic.Factory.addComponentsGetterSetter(Kinetic.Shape, 'fillLinearGradientEndPoint', [
          'x',
          'y'
      ]);

      /**
       * get/set fill linear gradient end point
       * @name fillLinearGradientEndPoint
       * @method
       * @memberof Kinetic.Shape.prototype
       * @param {Object} endPoint
       * @param {Number} endPoint.x
       * @param {Number} endPoint.y
       * @returns {Object}
       * @example
       * // get fill linear gradient end point<br>
       * var endPoint = shape.fillLinearGradientEndPoint();<br><br>
       *
       * // set fill linear gradient end point<br>
       * shape.fillLinearGradientEndPoint({<br>
       *   x: 20<br>
       *   y: 10<br>
       * });
       */

      Kinetic.Factory.addGetterSetter(Kinetic.Shape, 'fillLinearGradientEndPointX', 0);
      /**
       * get/set fill linear gradient end point x
       * @name fillLinearGradientEndPointX
       * @method
       * @memberof Kinetic.Shape.prototype
       * @param {Number} x
       * @returns {Number}
       * @example
       * // get fill linear gradient end point x<br>
       * var endPointX = shape.fillLinearGradientEndPointX();<br><br>
       *
       * // set fill linear gradient end point x<br>
       * shape.fillLinearGradientEndPointX(20);
       */

      Kinetic.Factory.addGetterSetter(Kinetic.Shape, 'fillLinearGradientEndPointY', 0);
      /**
       * get/set fill linear gradient end point y
       * @name fillLinearGradientEndPointY
       * @method
       * @memberof Kinetic.Shape.prototype
       * @param {Number} y
       * @returns {Number}
       * @example
       * // get fill linear gradient end point y<br>
       * var endPointY = shape.fillLinearGradientEndPointY();<br><br>
       *
       * // set fill linear gradient end point y<br>
       * shape.fillLinearGradientEndPointY(20);
       */

      Kinetic.Factory.addComponentsGetterSetter(Kinetic.Shape, 'fillRadialGradientStartPoint', [
          'x',
          'y'
      ]);

      /**
       * get/set fill radial gradient start point
       * @name fillRadialGradientStartPoint
       * @method
       * @memberof Kinetic.Shape.prototype
       * @param {Object} startPoint
       * @param {Number} startPoint.x
       * @param {Number} startPoint.y
       * @returns {Object}
       * @example
       * // get fill radial gradient start point<br>
       * var startPoint = shape.fillRadialGradientStartPoint();<br><br>
       *
       * // set fill radial gradient start point<br>
       * shape.fillRadialGradientStartPoint({<br>
       *   x: 20<br>
       *   y: 10<br>
       * });
       */

      Kinetic.Factory.addGetterSetter(Kinetic.Shape, 'fillRadialGradientStartPointX', 0);
      /**
       * get/set fill radial gradient start point x
       * @name fillRadialGradientStartPointX
       * @method
       * @memberof Kinetic.Shape.prototype
       * @param {Number} x
       * @returns {Number}
       * @example
       * // get fill radial gradient start point x<br>
       * var startPointX = shape.fillRadialGradientStartPointX();<br><br>
       *
       * // set fill radial gradient start point x<br>
       * shape.fillRadialGradientStartPointX(20);
       */

      Kinetic.Factory.addGetterSetter(Kinetic.Shape, 'fillRadialGradientStartPointY', 0);
      /**
       * get/set fill radial gradient start point y
       * @name fillRadialGradientStartPointY
       * @method
       * @memberof Kinetic.Shape.prototype
       * @param {Number} y
       * @returns {Number}
       * @example
       * // get fill radial gradient start point y<br>
       * var startPointY = shape.fillRadialGradientStartPointY();<br><br>
       *
       * // set fill radial gradient start point y<br>
       * shape.fillRadialGradientStartPointY(20);
       */

      Kinetic.Factory.addComponentsGetterSetter(Kinetic.Shape, 'fillRadialGradientEndPoint', [
          'x',
          'y'
      ]);

      /**
       * get/set fill radial gradient end point
       * @name fillRadialGradientEndPoint
       * @method
       * @memberof Kinetic.Shape.prototype
       * @param {Object} endPoint
       * @param {Number} endPoint.x
       * @param {Number} endPoint.y
       * @returns {Object}
       * @example
       * // get fill radial gradient end point<br>
       * var endPoint = shape.fillRadialGradientEndPoint();<br><br>
       *
       * // set fill radial gradient end point<br>
       * shape.fillRadialGradientEndPoint({<br>
       *   x: 20<br>
       *   y: 10<br>
       * });
       */

      Kinetic.Factory.addGetterSetter(Kinetic.Shape, 'fillRadialGradientEndPointX', 0);
      /**
       * get/set fill radial gradient end point x
       * @name fillRadialGradientEndPointX
       * @method
       * @memberof Kinetic.Shape.prototype
       * @param {Number} x
       * @returns {Number}
       * @example
       * // get fill radial gradient end point x<br>
       * var endPointX = shape.fillRadialGradientEndPointX();<br><br>
       *
       * // set fill radial gradient end point x<br>
       * shape.fillRadialGradientEndPointX(20);
       */

      Kinetic.Factory.addGetterSetter(Kinetic.Shape, 'fillRadialGradientEndPointY', 0);
      /**
       * get/set fill radial gradient end point y
       * @name fillRadialGradientEndPointY
       * @method
       * @memberof Kinetic.Shape.prototype
       * @param {Number} y
       * @returns {Number}
       * @example
       * // get fill radial gradient end point y<br>
       * var endPointY = shape.fillRadialGradientEndPointY();<br><br>
       *
       * // set fill radial gradient end point y<br>
       * shape.fillRadialGradientEndPointY(20);
       */

      Kinetic.Factory.addGetterSetter(Kinetic.Shape, 'fillPatternRotation', 0);

      /**
       * get/set fill pattern rotation in degrees
       * @name fillPatternRotation
       * @method
       * @memberof Kinetic.Shape.prototype
       * @param {Number} rotation
       * @returns {Kinetic.Shape}
       * @example
       * // get fill pattern rotation<br>
       * var patternRotation = shape.fillPatternRotation();<br><br>
       *
       * // set fill pattern rotation<br>
       * shape.fillPatternRotation(20);
       */


      Kinetic.Factory.backCompat(Kinetic.Shape, {
          dashArray: 'dash',
          getDashArray: 'getDash',
          setDashArray: 'getDash',
          drawFunc: 'sceneFunc',
          getDrawFunc: 'getSceneFunc',
          setDrawFunc: 'setSceneFunc',
          drawHitFunc: 'hitFunc',
          getDrawHitFunc: 'getHitFunc',
          setDrawHitFunc: 'setHitFunc'
      });

      Kinetic.Collection.mapMethods(Kinetic.Shape);
  })();
  ;
  (function () {
      // CONSTANTS
      var STAGE = 'Stage',
        STRING = 'string',
        PX = 'px',
        MOUSEOUT = 'mouseout',
        MOUSELEAVE = 'mouseleave',
        MOUSEOVER = 'mouseover',
        MOUSEENTER = 'mouseenter',
        MOUSEMOVE = 'mousemove',
        MOUSEDOWN = 'mousedown',
        MOUSEUP = 'mouseup',
        CLICK = 'click',
        DBL_CLICK = 'dblclick',
        TOUCHSTART = 'touchstart',
        TOUCHEND = 'touchend',
        TAP = 'tap',
        DBL_TAP = 'dbltap',
        TOUCHMOVE = 'touchmove',
        CONTENT_MOUSEOUT = 'contentMouseout',
        CONTENT_MOUSELEAVE = 'contentMouseleave',
        CONTENT_MOUSEOVER = 'contentMouseover',
        CONTENT_MOUSEENTER = 'contentMouseenter',
        CONTENT_MOUSEMOVE = 'contentMousemove',
        CONTENT_MOUSEDOWN = 'contentMousedown',
        CONTENT_MOUSEUP = 'contentMouseup',
        CONTENT_CLICK = 'contentClick',
        CONTENT_DBL_CLICK = 'contentDblclick',
        CONTENT_TOUCHSTART = 'contentTouchstart',
        CONTENT_TOUCHEND = 'contentTouchend',
        CONTENT_TAP = 'contentTap',
        CONTENT_DBL_TAP = 'contentDbltap',
        CONTENT_TOUCHMOVE = 'contentTouchmove',
        DIV = 'div',
        RELATIVE = 'relative',
        INLINE_BLOCK = 'inline-block',
        KINETICJS_CONTENT = 'kineticjs-content',
        SPACE = ' ',
        UNDERSCORE = '_',
        CONTAINER = 'container',
        EMPTY_STRING = '',
        EVENTS = [
          MOUSEDOWN,
          MOUSEMOVE,
          MOUSEUP,
          MOUSEOUT,
          TOUCHSTART,
          TOUCHMOVE,
          TOUCHEND,
          MOUSEOVER
      ],
        // cached variables
        eventsLength = EVENTS.length;

      function addEvent (ctx, eventName) {
          ctx.content.addEventListener(eventName, function (evt) {
              ctx[UNDERSCORE + eventName](evt);
          }, false);
      }

      Kinetic.Util.addMethods(Kinetic.Stage, {
          ___init: function (config) {
              this.nodeType = STAGE;
              // call super constructor
              Kinetic.Container.call(this, config);
              this._id = Kinetic.idCounter++;
              this._buildDOM();
              this._bindContentEvents();
              this._enableNestedTransforms = false;
              Kinetic.stages.push(this);
          },
          _validateAdd: function (child) {
              if (child.getType() !== 'Layer') {
                  Kinetic.Util.error('You may only add layers to the stage.');
              }
          },
          /**
           * set container dom element which contains the stage wrapper div element
           * @method
           * @memberof Kinetic.Stage.prototype
           * @param {DomElement} container can pass in a dom element or id string
           */
          setContainer: function (container) {
              if (typeof container === STRING) {
                  container = document.getElementById(container);
              }
              this._setAttr(CONTAINER, container);
              return this;
          },
          shouldDrawHit: function () {
              return true;
          },
          draw: function () {
              Kinetic.Node.prototype.draw.call(this);
              return this;
          },
          /**
           * draw layer scene graphs
           * @name draw
           * @method
           * @memberof Kinetic.Stage.prototype
           */

          /**
           * draw layer hit graphs
           * @name drawHit
           * @method
           * @memberof Kinetic.Stage.prototype
           */

          /**
           * set height
           * @method
           * @memberof Kinetic.Stage.prototype
           * @param {Number} height
           */
          setHeight: function (height) {
              Kinetic.Node.prototype.setHeight.call(this, height);
              this._resizeDOM();
              return this;
          },
          /**
           * set width
           * @method
           * @memberof Kinetic.Stage.prototype
           * @param {Number} width
           */
          setWidth: function (width) {
              Kinetic.Node.prototype.setWidth.call(this, width);
              this._resizeDOM();
              return this;
          },
          /**
           * clear all layers
           * @method
           * @memberof Kinetic.Stage.prototype
           */
          clear: function () {
              var layers = this.children,
                len = layers.length,
                n;

              for (n = 0; n < len; n++) {
                  layers[n].clear();
              }
              return this;
          },
          /**
           * remove stage
           * @method
           * @memberof Kinetic.Stage.prototype
           */
          destroy: function () {
              var content = this.content;
              Kinetic.Container.prototype.destroy.call(this);

              if (content && Kinetic.Util._isInDocument(content)) {
                  this.getContainer().removeChild(content);
              }
          },
          /**
           * get pointer position which can be a touch position or mouse position
           * @method
           * @memberof Kinetic.Stage.prototype
           * @returns {Object}
           */
          getPointerPosition: function () {
              return this.pointerPos;
          },
          getStage: function () {
              return this;
          },
          /**
           * get stage content div element which has the
           *  the class name "kineticjs-content"
           * @method
           * @memberof Kinetic.Stage.prototype
           */
          getContent: function () {
              return this.content;
          },
          /**
           * Creates a composite data URL and requires a callback because the composite is generated asynchronously.
           * @method
           * @memberof Kinetic.Stage.prototype
           * @param {Object} config
           * @param {Function} config.callback function executed when the composite has completed
           * @param {String} [config.mimeType] can be "image/png" or "image/jpeg".
           *  "image/png" is the default
           * @param {Number} [config.x] x position of canvas section
           * @param {Number} [config.y] y position of canvas section
           * @param {Number} [config.width] width of canvas section
           * @param {Number} [config.height] height of canvas section
           * @param {Number} [config.quality] jpeg quality.  If using an "image/jpeg" mimeType,
           *  you can specify the quality from 0 to 1, where 0 is very poor quality and 1
           *  is very high quality
           */
          toDataURL: function (config) {
              config = config || {
              };

              var mimeType = config.mimeType || null,
                quality = config.quality || null,
                x = config.x || 0,
                y = config.y || 0,
                canvas = new Kinetic.SceneCanvas({
                  width: config.width || this.getWidth(),
                  height: config.height || this.getHeight(),
                  pixelRatio: 1
              }),
              _context = canvas.getContext()._context,
                layers = this.children;

              if (x || y) {
                  _context.translate(-1 * x, -1 * y);
              }

              function drawLayer (n) {
                  var layer = layers[n],
                    layerUrl = layer.toDataURL(),
                    imageObj = new Image();

                  imageObj.onload = function () {
                      _context.drawImage(imageObj, 0, 0);

                      if (n < layers.length - 1) {
                          drawLayer(n + 1);
                      }
                      else {
                          config.callback(canvas.toDataURL(mimeType, quality));
                      }
                  };
                  imageObj.src = layerUrl;
              }
              drawLayer(0);
          },
          /**
           * converts stage into an image.
           * @method
           * @memberof Kinetic.Stage.prototype
           * @param {Object} config
           * @param {Function} config.callback function executed when the composite has completed
           * @param {String} [config.mimeType] can be "image/png" or "image/jpeg".
           *  "image/png" is the default
           * @param {Number} [config.x] x position of canvas section
           * @param {Number} [config.y] y position of canvas section
           * @param {Number} [config.width] width of canvas section
           * @param {Number} [config.height] height of canvas section
           * @param {Number} [config.quality] jpeg quality.  If using an "image/jpeg" mimeType,
           *  you can specify the quality from 0 to 1, where 0 is very poor quality and 1
           *  is very high quality
           */
          toImage: function (config) {
              var cb = config.callback;

              config.callback = function (dataUrl) {
                  Kinetic.Util._getImage(dataUrl, function (img) {
                      cb(img);
                  });
              };
              this.toDataURL(config);
          },
          /**
           * get visible intersection shape. This is the preferred
           *  method for determining if a point intersects a shape or not
           * @method
           * @memberof Kinetic.Stage.prototype
           * @param {Object} pos
           * @param {Number} pos.x
           * @param {Number} pos.y
           * @returns {Kinetic.Shape}
           */
          getIntersection: function (pos) {
              var layers = this.getChildren(),
                len = layers.length,
                end = len - 1,
                n, shape;

              for (n = end; n >= 0; n--) {
                  shape = layers[n].getIntersection(pos);
                  if (shape) {
                      return shape;
                  }
              }

              return null;
          },
          _resizeDOM: function () {
              if (this.content) {
                  var width = this.getWidth(),
                    height = this.getHeight(),
                    layers = this.getChildren(),
                    len = layers.length,
                    n, layer;

                  // set content dimensions
                  this.content.style.width = width + PX;
                  this.content.style.height = height + PX;

                  this.bufferCanvas.setSize(width, height);
                  this.bufferHitCanvas.setSize(width, height);

                  // set layer dimensions
                  for (n = 0; n < len; n++) {
                      layer = layers[n];
                      layer.getCanvas().setSize(width, height);
                      layer.hitCanvas.setSize(width, height);
                      layer.draw();
                  }
              }
          },
          /**
           * add layer to stage
           * @method
           * @memberof Kinetic.Stage.prototype
           * @param {Kinetic.Layer} layer
           */
          add: function (layer) {
              Kinetic.Container.prototype.add.call(this, layer);
              layer.canvas.setSize(this.attrs.width, this.attrs.height);
              layer.hitCanvas.setSize(this.attrs.width, this.attrs.height);

              // draw layer and append canvas to container
              layer.draw();
              this.content.appendChild(layer.canvas._canvas);

              // chainable
              return this;
          },
          getParent: function () {
              return null;
          },
          getLayer: function () {
              return null;
          },
          /**
           * returns a {@link Kinetic.Collection} of layers
           * @method
           * @memberof Kinetic.Stage.prototype
           */
          getLayers: function () {
              return this.getChildren();
          },
          _bindContentEvents: function () {
              var that = this,
                n;

              for (n = 0; n < eventsLength; n++) {
                  addEvent(this, EVENTS[n]);
              }
          },
          _mouseover: function (evt) {
              this._fire(CONTENT_MOUSEOVER, evt);
          },
          _mouseout: function (evt) {
              this._setPointerPosition(evt);
              var targetShape = this.targetShape;

              if (targetShape && !Kinetic.isDragging()) {
                  targetShape._fireAndBubble(MOUSEOUT, evt);
                  targetShape._fireAndBubble(MOUSELEAVE, evt);
                  this.targetShape = null;
              }
              this.pointerPos = undefined;

              this._fire(CONTENT_MOUSEOUT, evt);
          },
          _mousemove: function (evt) {
              this._setPointerPosition(evt);
              var dd = Kinetic.DD,
                shape = this.getIntersection(this.getPointerPosition());

              if (shape && shape.isListening()) {
                  if (!Kinetic.isDragging() && (!this.targetShape || this.targetShape._id !== shape._id)) {
                      if (this.targetShape) {
                          this.targetShape._fireAndBubble(MOUSEOUT, evt, shape);
                          this.targetShape._fireAndBubble(MOUSELEAVE, evt, shape);
                      }
                      shape._fireAndBubble(MOUSEOVER, evt, this.targetShape);
                      shape._fireAndBubble(MOUSEENTER, evt, this.targetShape);
                      this.targetShape = shape;
                  }
                  else {
                      shape._fireAndBubble(MOUSEMOVE, evt);
                  }
              }
              /*
               * if no shape was detected, clear target shape and try
               * to run mouseout from previous target shape
               */
              else {
                  if (this.targetShape && !Kinetic.isDragging()) {
                      this.targetShape._fireAndBubble(MOUSEOUT, evt);
                      this.targetShape._fireAndBubble(MOUSELEAVE, evt);
                      this.targetShape = null;
                  }

              }

              // content event
              this._fire(CONTENT_MOUSEMOVE, evt);

              if (dd) {
                  dd._drag(evt);
              }

              // always call preventDefault for desktop events because some browsers
              // try to drag and drop the canvas element
              if (evt.preventDefault) {
                  evt.preventDefault();
              }
          },
          _mousedown: function (evt) {
              this._setPointerPosition(evt);
              var shape = this.getIntersection(this.getPointerPosition());

              Kinetic.listenClickTap = true;

              if (shape && shape.isListening()) {
                  this.clickStartShape = shape;
                  shape._fireAndBubble(MOUSEDOWN, evt);
              }

              // content event
              this._fire(CONTENT_MOUSEDOWN, evt);

              // always call preventDefault for desktop events because some browsers
              // try to drag and drop the canvas element
              if (evt.preventDefault) {
                  evt.preventDefault();
              }
          },
          _mouseup: function (evt) {
              this._setPointerPosition(evt);
              var that = this,
                shape = this.getIntersection(this.getPointerPosition()),
                clickStartShape = this.clickStartShape,
                fireDblClick = false;

              if (Kinetic.inDblClickWindow) {
                  fireDblClick = true;
                  Kinetic.inDblClickWindow = false;
              }
              else {
                  Kinetic.inDblClickWindow = true;
              }

              setTimeout(function () {
                  Kinetic.inDblClickWindow = false;
              }, Kinetic.dblClickWindow);

              if (shape && shape.isListening()) {
                  shape._fireAndBubble(MOUSEUP, evt);

                  // detect if click or double click occurred
                  if (Kinetic.listenClickTap && clickStartShape && clickStartShape._id === shape._id) {
                      shape._fireAndBubble(CLICK, evt);

                      if (fireDblClick) {
                          shape._fireAndBubble(DBL_CLICK, evt);
                      }
                  }
              }
              // content events
              this._fire(CONTENT_MOUSEUP, evt);
              if (Kinetic.listenClickTap) {
                  this._fire(CONTENT_CLICK, evt);
                  if (fireDblClick) {
                      this._fire(CONTENT_DBL_CLICK, evt);
                  }
              }

              Kinetic.listenClickTap = false;

              // always call preventDefault for desktop events because some browsers
              // try to drag and drop the canvas element
              if (evt.preventDefault) {
                  evt.preventDefault();
              }
          },
          _touchstart: function (evt) {
              this._setPointerPosition(evt);
              var shape = this.getIntersection(this.getPointerPosition());

              Kinetic.listenClickTap = true;

              if (shape && shape.isListening()) {
                  this.tapStartShape = shape;
                  shape._fireAndBubble(TOUCHSTART, evt);

                  // only call preventDefault if the shape is listening for events
                  if (shape.isListening() && evt.preventDefault) {
                      evt.preventDefault();
                  }
              }
              // content event
              this._fire(CONTENT_TOUCHSTART, evt);
          },
          _touchend: function (evt) {
              this._setPointerPosition(evt);
              var that = this,
                shape = this.getIntersection(this.getPointerPosition());
              fireDblClick = false;

              if (Kinetic.inDblClickWindow) {
                  fireDblClick = true;
                  Kinetic.inDblClickWindow = false;
              }
              else {
                  Kinetic.inDblClickWindow = true;
              }

              setTimeout(function () {
                  Kinetic.inDblClickWindow = false;
              }, Kinetic.dblClickWindow);

              if (shape && shape.isListening()) {
                  shape._fireAndBubble(TOUCHEND, evt);

                  // detect if tap or double tap occurred
                  if (Kinetic.listenClickTap && shape._id === this.tapStartShape._id) {
                      shape._fireAndBubble(TAP, evt);

                      if (fireDblClick) {
                          shape._fireAndBubble(DBL_TAP, evt);
                      }
                  }
                  // only call preventDefault if the shape is listening for events
                  if (shape.isListening() && evt.preventDefault) {
                      evt.preventDefault();
                  }
              }
              // content events
              if (Kinetic.listenClickTap) {
                  this._fire(CONTENT_TOUCHEND, evt);
                  if (fireDblClick) {
                      this._fire(CONTENT_DBL_TAP, evt);
                  }
              }

              Kinetic.listenClickTap = false;
          },
          _touchmove: function (evt) {
              this._setPointerPosition(evt);
              var dd = Kinetic.DD,
                shape = this.getIntersection(this.getPointerPosition());

              if (shape && shape.isListening()) {
                  shape._fireAndBubble(TOUCHMOVE, evt);

                  // only call preventDefault if the shape is listening for events
                  if (shape.isListening() && evt.preventDefault) {
                      evt.preventDefault();
                  }
              }
              this._fire(CONTENT_TOUCHMOVE, evt);

              // start drag and drop
              if (dd) {
                  dd._drag(evt);
              }
          },
          _setPointerPosition: function (evt) {
              var evt = evt ? evt : window.event,
                contentPosition = this._getContentPosition(),
                offsetX = evt.offsetX,
                clientX = evt.clientX,
                x = null,
                y = null,
                touch;

              // touch events
              if (evt.touches !== undefined) {
                  // currently, only handle one finger
                  if (evt.touches.length === 1) {

                      touch = evt.touches[0];

                      // get the information for finger #1
                      x = touch.clientX - contentPosition.left;
                      y = touch.clientY - contentPosition.top;
                  }
              }
              // mouse events
              else {
                  // if offsetX is defined, assume that offsetY is defined as well
                  if (offsetX !== undefined) {
                      x = offsetX;
                      y = evt.offsetY;
                  }
                  // we unforunately have to use UA detection here because accessing
                  // the layerX or layerY properties in newer veresions of Chrome
                  // throws a JS warning.  layerX and layerY are required for FF
                  // when the container is transformed via CSS.
                  else if (Kinetic.UA.browser === 'mozilla') {
                      x = evt.layerX;
                      y = evt.layerY;
                  }
                  // if clientX is defined, assume that clientY is defined as well
                  else if (clientX !== undefined && contentPosition) {
                      x = clientX - contentPosition.left;
                      y = evt.clientY - contentPosition.top;
                  }
              }

              if (x !== null && y !== null) {
                  this.pointerPos = {
                      x: x,
                      y: y
                  };
              }
          },
          _getContentPosition: function () {
              var rect = this.content.getBoundingClientRect ? this.content.getBoundingClientRect() : {
                  top: 0,
                  left: 0
              };
              return {
                  top: rect.top,
                  left: rect.left
              };
          },
          _buildDOM: function () {
              var container = this.getContainer();

              // clear content inside container
              container.innerHTML = EMPTY_STRING;

              // content
              this.content = document.createElement(DIV);
              this.content.style.position = RELATIVE;
              this.content.style.display = INLINE_BLOCK;
              this.content.className = KINETICJS_CONTENT;
              this.content.setAttribute('role', 'presentation');
              container.appendChild(this.content);

              // the buffer canvas pixel ratio must be 1 because it is used as an
              // intermediate canvas before copying the result onto a scene canvas.
              // not setting it to 1 will result in an over compensation
              this.bufferCanvas = new Kinetic.SceneCanvas({
                  pixelRatio: 1
              });
              this.bufferHitCanvas = new Kinetic.HitCanvas();

              this._resizeDOM();
          },
          _onContent: function (typesStr, handler) {
              var types = typesStr.split(SPACE),
                len = types.length,
                n, baseEvent;

              for (n = 0; n < len; n++) {
                  baseEvent = types[n];
                  this.content.addEventListener(baseEvent, handler, false);
              }
          }
      });
      Kinetic.Util.extend(Kinetic.Stage, Kinetic.Container);

      // add getters and setters
      Kinetic.Factory.addGetter(Kinetic.Stage, 'container');
      Kinetic.Factory.addOverloadedGetterSetter(Kinetic.Stage, 'container');

      /**
       * get container DOM element
       * @name container
       * @method
       * @memberof Kinetic.Stage.prototype
       * @returns {DomElement} container
       * @example
       * // get container<br>
       * var container = stage.container();<br><br>
       *
       * // set container<br>
       * var container = document.createElement('div');<br>
       * body.appendChild(container);<br>
       * stage.container(container);
       */

  })();
  ;
  (function () {
      // constants
      var HASH = '#',
        BEFORE_DRAW = 'beforeDraw',
        DRAW = 'draw',
        /*
         * 2 - 3 - 4
         * |       |
         * 1 - 0   5
         *         |
         * 8 - 7 - 6
         */
        INTERSECTION_OFFSETS = [
          {
              x: 0,
              y: 0
          }, // 0
          {
              x: -1,
              y: 0
          }, // 1
          {
              x: -1,
              y: -1
          }, // 2
          {
              x: 0,
              y: -1
          }, // 3
          {
              x: 1,
              y: -1
          }, // 4
          {
              x: 1,
              y: 0
          }, // 5
          {
              x: 1,
              y: 1
          }, // 6
          {
              x: 0,
              y: 1
          }, // 7
          {
              x: -1,
              y: 1
          }  // 8
      ],
        INTERSECTION_OFFSETS_LEN = INTERSECTION_OFFSETS.length;


      Kinetic.Util.addMethods(Kinetic.Layer, {
          ___init: function (config) {
              this.nodeType = 'Layer';
              this.canvas = new Kinetic.SceneCanvas();
              this.hitCanvas = new Kinetic.HitCanvas();
              // call super constructor
              Kinetic.Container.call(this, config);
          },
          _validateAdd: function (child) {
              var type = child.getType();
              if (type !== 'Group' && type !== 'Shape') {
                  Kinetic.Util.error('You may only add groups and shapes to a layer.');
              }
          },
          /**
           * get visible intersection shape. This is the preferred
           * method for determining if a point intersects a shape or not
           * @method
           * @memberof Kinetic.Layer.prototype
           * @param {Object} pos
           * @param {Number} pos.x
           * @param {Number} pos.y
           * @returns {Kinetic.Shape}
           */
          getIntersection: function (pos) {
              var obj, i, intersectionOffset, shape;

              if (this.isVisible()) {
                  for (i = 0; i < INTERSECTION_OFFSETS_LEN; i++) {
                      intersectionOffset = INTERSECTION_OFFSETS[i];
                      obj = this._getIntersection({
                          x: pos.x + intersectionOffset.x,
                          y: pos.y + intersectionOffset.y
                      });
                      shape = obj.shape;
                      if (shape) {
                          return shape;
                      }
                      else if (!obj.antialiased) {
                          return null;
                      }
                  }
              }
              else {
                  return null;
              }
          },
          _getIntersection: function (pos) {
              var p = this.hitCanvas.context._context.getImageData(pos.x, pos.y, 1, 1).data,
                p3 = p[3],
                colorKey, shape;

              // fully opaque pixel
              if (p3 === 255) {
                  colorKey = Kinetic.Util._rgbToHex(p[0], p[1], p[2]);
                  shape = Kinetic.shapes[HASH + colorKey];
                  return {
                      shape: shape
                  };
              }
              // antialiased pixel
              else if (p3 > 0) {
                  return {
                      antialiased: true
                  };
              }
              // empty pixel
              else {
                  return {
                  };
              }
          },
          drawScene: function (can) {
              var layer = this.getLayer(),
                canvas = can || (layer && layer.getCanvas());

              this._fire(BEFORE_DRAW, {
                  node: this
              });

              if (this.getClearBeforeDraw()) {
                  canvas.getContext().clear();
              }

              Kinetic.Container.prototype.drawScene.call(this, canvas);

              this._fire(DRAW, {
                  node: this
              });

              return this;
          },
          drawHit: function (can) {
              var layer = this.getLayer(),
                canvas = can || (layer && layer.hitCanvas);

              if (layer && layer.getClearBeforeDraw()) {
                  layer.getHitCanvas().getContext().clear();
              }

              Kinetic.Container.prototype.drawHit.call(this, canvas);
              return this;
          },
          /**
           * get layer canvas
           * @method
           * @memberof Kinetic.Layer.prototype
           */
          getCanvas: function () {
              return this.canvas;
          },
          /**
           * get layer hit canvas
           * @method
           * @memberof Kinetic.Layer.prototype
           */
          getHitCanvas: function () {
              return this.hitCanvas;
          },
          /**
           * get layer canvas context
           * @method
           * @memberof Kinetic.Layer.prototype
           */
          getContext: function () {
              return this.getCanvas().getContext();
          },
          /**
           * clear scene and hit canvas contexts tied to the layer
           * @method
           * @memberof Kinetic.Node.prototype
           * @param {Object} [bounds]
           * @param {Number} [bounds.x]
           * @param {Number} [bounds.y]
           * @param {Number} [bounds.width]
           * @param {Number} [bounds.height]
           * @example
           * layer.clear();<br>
           * layer.clear(0, 0, 100, 100);
           */
          clear: function (bounds) {
              var context = this.getContext(),
                hitContext = this.getHitCanvas().getContext();

              context.clear(bounds);
              hitContext.clear(bounds);
              return this;
          },
          // extend Node.prototype.setVisible
          setVisible: function (visible) {
              Kinetic.Node.prototype.setVisible.call(this, visible);
              if (visible) {
                  this.getCanvas()._canvas.style.display = 'block';
                  this.hitCanvas._canvas.style.display = 'block';
              }
              else {
                  this.getCanvas()._canvas.style.display = 'none';
                  this.hitCanvas._canvas.style.display = 'none';
              }
              return this;
          },
          // extend Node.prototype.setZIndex
          setZIndex: function (index) {
              Kinetic.Node.prototype.setZIndex.call(this, index);
              var stage = this.getStage();
              if (stage) {
                  stage.content.removeChild(this.getCanvas()._canvas);

                  if (index < stage.getChildren().length - 1) {
                      stage.content.insertBefore(this.getCanvas()._canvas, stage.getChildren()[index + 1].getCanvas()._canvas);
                  }
                  else {
                      stage.content.appendChild(this.getCanvas()._canvas);
                  }
              }
              return this;
          },
          // extend Node.prototype.moveToTop
          moveToTop: function () {
              Kinetic.Node.prototype.moveToTop.call(this);
              var stage = this.getStage();
              if (stage) {
                  stage.content.removeChild(this.getCanvas()._canvas);
                  stage.content.appendChild(this.getCanvas()._canvas);
              }
          },
          // extend Node.prototype.moveUp
          moveUp: function () {
              if (Kinetic.Node.prototype.moveUp.call(this)) {
                  var stage = this.getStage();
                  if (stage) {
                      stage.content.removeChild(this.getCanvas()._canvas);

                      if (this.index < stage.getChildren().length - 1) {
                          stage.content.insertBefore(this.getCanvas()._canvas, stage.getChildren()[this.index + 1].getCanvas()._canvas);
                      }
                      else {
                          stage.content.appendChild(this.getCanvas()._canvas);
                      }
                  }
              }
          },
          // extend Node.prototype.moveDown
          moveDown: function () {
              if (Kinetic.Node.prototype.moveDown.call(this)) {
                  var stage = this.getStage();
                  if (stage) {
                      var children = stage.getChildren();
                      stage.content.removeChild(this.getCanvas()._canvas);
                      stage.content.insertBefore(this.getCanvas()._canvas, children[this.index + 1].getCanvas()._canvas);
                  }
              }
          },
          // extend Node.prototype.moveToBottom
          moveToBottom: function () {
              if (Kinetic.Node.prototype.moveToBottom.call(this)) {
                  var stage = this.getStage();
                  if (stage) {
                      var children = stage.getChildren();
                      stage.content.removeChild(this.getCanvas()._canvas);
                      stage.content.insertBefore(this.getCanvas()._canvas, children[1].getCanvas()._canvas);
                  }
              }
          },
          getLayer: function () {
              return this;
          },
          remove: function () {
              var stage = this.getStage(),
                canvas = this.getCanvas(),
                _canvas = canvas._canvas;

              Kinetic.Node.prototype.remove.call(this);

              if (stage && _canvas && Kinetic.Util._isInDocument(_canvas)) {
                  stage.content.removeChild(_canvas);
              }
              return this;
          },
          getStage: function () {
              return this.parent;
          },
          /**
           * enable hit graph
           * @name enableHitGraph
           * @method
           * @memberof Kinetic.Layer.prototype
           * @returns {Node}
           */
          enableHitGraph: function () {
              this.setHitGraphEnabled(true);
              return this;
          },
          /**
           * disable hit graph
           * @name enableHitGraph
           * @method
           * @memberof Kinetic.Layer.prototype
           * @returns {Node}
           */
          disableHitGraph: function () {
              this.setHitGraphEnabled(false);
              return this;
          }
      });
      Kinetic.Util.extend(Kinetic.Layer, Kinetic.Container);

      // add getters and setters
      Kinetic.Factory.addGetterSetter(Kinetic.Layer, 'clearBeforeDraw', true);
      /**
       * get/set clearBeforeDraw flag which determines if the layer is cleared or not
       *  before drawing
       * @name clearBeforeDraw
       * @method
       * @memberof Kinetic.Layer.prototype
       * @param {Boolean} clearBeforeDraw
       * @returns {Boolean}
       * @example
       * // get clearBeforeDraw flag<br>
       * var clearBeforeDraw = layer.clearBeforeDraw();<br><br>
       *
       * // disable clear before draw<br>
       * layer.clearBeforeDraw(false);<br><br>
       *
       * // enable clear before draw<br>
       * layer.clearBeforeDraw(true);
       */

      Kinetic.Factory.addGetterSetter(Kinetic.Layer, 'hitGraphEnabled', true);
      /**
       * get/set hitGraphEnabled flag.  Disabling the hit graph will greatly increase
       *  draw performance because the hit graph will not be redrawn each time the layer is
       *  drawn.  This, however, also disables mouse/touch event detection
       * @name hitGraphEnabled
       * @method
       * @memberof Kinetic.Layer.prototype
       * @param {Boolean} enabled
       * @returns {Boolean}
       * @example
       * // get hitGraphEnabled flag<br>
       * var hitGraphEnabled = layer.hitGraphEnabled();<br><br>
       *
       * // disable hit graph<br>
       * layer.hitGraphEnabled(false);<br><br>
       *
       * // enable hit graph<br>
       * layer.hitGraphEnabled(true);
       */

      Kinetic.Collection.mapMethods(Kinetic.Layer);
  })();
  ;
  (function () {
      Kinetic.Util.addMethods(Kinetic.Group, {
          ___init: function (config) {
              this.nodeType = 'Group';
              // call super constructor
              Kinetic.Container.call(this, config);
          },
          _validateAdd: function (child) {
              var type = child.getType();
              if (type !== 'Group' && type !== 'Shape') {
                  Kinetic.Util.error('You may only add groups and shapes to groups.');
              }
          }
      });
      Kinetic.Util.extend(Kinetic.Group, Kinetic.Container);

      Kinetic.Collection.mapMethods(Kinetic.Group);
  })();
  ;
  (function () {
      /**
       * Rect constructor
       * @constructor
       * @memberof Kinetic
       * @augments Kinetic.Shape
       * @param {Object} config
       * @param {Number} [config.cornerRadius]
       * @param {String} [config.fill] fill color
       * @param {Integer} [config.fillRed] set fill red component
       * @param {Integer} [config.fillGreen] set fill green component
       * @param {Integer} [config.fillBlue] set fill blue component
       * @param {Integer} [config.fillAlpha] set fill alpha component
       * @param {Image} [config.fillPatternImage] fill pattern image
       * @param {Number} [config.fillPatternX]
       * @param {Number} [config.fillPatternY]
       * @param {Object} [config.fillPatternOffset] object with x and y component
       * @param {Number} [config.fillPatternOffsetX]
       * @param {Number} [config.fillPatternOffsetY]
       * @param {Object} [config.fillPatternScale] object with x and y component
       * @param {Number} [config.fillPatternScaleX]
       * @param {Number} [config.fillPatternScaleY]
       * @param {Number} [config.fillPatternRotation]
       * @param {String} [config.fillPatternRepeat] can be "repeat", "repeat-x", "repeat-y", or "no-repeat".  The default is "no-repeat"
       * @param {Object} [config.fillLinearGradientStartPoint] object with x and y component
       * @param {Number} [config.fillLinearGradientStartPointX]
       * @param {Number} [config.fillLinearGradientStartPointY]
       * @param {Object} [config.fillLinearGradientEndPoint] object with x and y component
       * @param {Number} [config.fillLinearGradientEndPointX]
       * @param {Number} [config.fillLinearGradientEndPointY]
       * @param {Array} [config.fillLinearGradientColorStops] array of color stops
       * @param {Object} [config.fillRadialGradientStartPoint] object with x and y component
       * @param {Number} [config.fillRadialGradientStartPointX]
       * @param {Number} [config.fillRadialGradientStartPointY]
       * @param {Object} [config.fillRadialGradientEndPoint] object with x and y component
       * @param {Number} [config.fillRadialGradientEndPointX]
       * @param {Number} [config.fillRadialGradientEndPointY]
       * @param {Number} [config.fillRadialGradientStartRadius]
       * @param {Number} [config.fillRadialGradientEndRadius]
       * @param {Array} [config.fillRadialGradientColorStops] array of color stops
       * @param {Boolean} [config.fillEnabled] flag which enables or disables the fill.  The default value is true
       * @param {String} [config.fillPriority] can be color, linear-gradient, radial-graident, or pattern.  The default value is color.  The fillPriority property makes it really easy to toggle between different fill types.  For example, if you want to toggle between a fill color style and a fill pattern style, simply set the fill property and the fillPattern properties, and then use setFillPriority('color') to render the shape with a color fill, or use setFillPriority('pattern') to render the shape with the pattern fill configuration
       * @param {String} [config.stroke] stroke color
       * @param {Integer} [config.strokeRed] set stroke red component
       * @param {Integer} [config.strokeGreen] set stroke green component
       * @param {Integer} [config.strokeBlue] set stroke blue component
       * @param {Integer} [config.strokeAlpha] set stroke alpha component
       * @param {Number} [config.strokeWidth] stroke width
       * @param {Boolean} [config.strokeScaleEnabled] flag which enables or disables stroke scale.  The default is true
       * @param {Boolean} [config.strokeEnabled] flag which enables or disables the stroke.  The default value is true
       * @param {String} [config.lineJoin] can be miter, round, or bevel.  The default
       *  is miter
       * @param {String} [config.lineCap] can be butt, round, or sqare.  The default
       *  is butt
       * @param {String} [config.shadowColor]
       * @param {Integer} [config.shadowColorRed] set shadow color red component
       * @param {Integer} [config.shadowColorGreen] set shadow color green component
       * @param {Integer} [config.shadowColorBlue] set shadow color blue component
       * @param {Integer} [config.shadowColorAlpha] set shadow color alpha component
       * @param {Number} [config.shadowBlur]
       * @param {Object} [config.shadowOffset] object with x and y component
       * @param {Number} [config.shadowOffsetX]
       * @param {Number} [config.shadowOffsetY]
       * @param {Number} [config.shadowOpacity] shadow opacity.  Can be any real number
       *  between 0 and 1
       * @param {Boolean} [config.shadowEnabled] flag which enables or disables the shadow.  The default value is true
       * @param {Array} [config.dash]
       * @param {Boolean} [config.dashEnabled] flag which enables or disables the dashArray.  The default value is true
       * @param {Number} [config.x]
       * @param {Number} [config.y]
       * @param {Number} [config.width]
       * @param {Number} [config.height]
       * @param {Boolean} [config.visible]
       * @param {Boolean} [config.listening] whether or not the node is listening for events
       * @param {String} [config.id] unique id
       * @param {String} [config.name] non-unique name
       * @param {Number} [config.opacity] determines node opacity.  Can be any number between 0 and 1
       * @param {Object} [config.scale] set scale
       * @param {Number} [config.scaleX] set scale x
       * @param {Number} [config.scaleY] set scale y
       * @param {Number} [config.rotation] rotation in degrees
       * @param {Object} [config.offset] offset from center point and rotation point
       * @param {Number} [config.offsetX] set offset x
       * @param {Number} [config.offsetY] set offset y
       * @param {Boolean} [config.draggable] makes the node draggable.  When stages are draggable, you can drag and drop
       *  the entire stage by dragging any portion of the stage
       * @param {Function} [config.dragBoundFunc]
       * @example
       * var rect = new Kinetic.Rect({<br>
       *   width: 100,<br>
       *   height: 50,<br>
       *   fill: 'red',<br>
       *   stroke: 'black'<br>
       *   strokeWidth: 5<br>
       * });
       */
      Kinetic.Rect = function (config) {
          this.___init(config);
      };

      Kinetic.Rect.prototype = {
          ___init: function (config) {
              Kinetic.Shape.call(this, config);
              this.className = 'Rect';
              this.sceneFunc(this._sceneFunc);
          },
          _sceneFunc: function (context) {
              var cornerRadius = this.getCornerRadius(),
                width = this.getWidth(),
                height = this.getHeight();


              context.beginPath();

              if (!cornerRadius) {
                  // simple rect - don't bother doing all that complicated maths stuff.
                  context.rect(0, 0, width, height);
              }
              else {
                  // arcTo would be nicer, but browser support is patchy (Opera)
                  context.moveTo(cornerRadius, 0);
                  context.lineTo(width - cornerRadius, 0);
                  context.arc(width - cornerRadius, cornerRadius, cornerRadius, Math.PI * 3 / 2, 0, false);
                  context.lineTo(width, height - cornerRadius);
                  context.arc(width - cornerRadius, height - cornerRadius, cornerRadius, 0, Math.PI / 2, false);
                  context.lineTo(cornerRadius, height);
                  context.arc(cornerRadius, height - cornerRadius, cornerRadius, Math.PI / 2, Math.PI, false);
                  context.lineTo(0, cornerRadius);
                  context.arc(cornerRadius, cornerRadius, cornerRadius, Math.PI, Math.PI * 3 / 2, false);
              }
              context.closePath();
              context.fillStrokeShape(this);
          }
      };

      Kinetic.Util.extend(Kinetic.Rect, Kinetic.Shape);

      Kinetic.Factory.addGetterSetter(Kinetic.Rect, 'cornerRadius', 0);
      /**
       * get/set corner radius
       * @name cornerRadius
       * @method
       * @memberof Kinetic.Rect.prototype
       * @param {Number} cornerRadius
       * @returns {Number}
       * @example
       * // get corner radius<br>
       * var cornerRadius = rect.cornerRadius();<br><br>
       *
       * // set corner radius<br>
       * rect.cornerRadius(10);
       */

      Kinetic.Collection.mapMethods(Kinetic.Rect);
  })();
  ;
  (function () {
      // the 0.0001 offset fixes a bug in Chrome 27
      var PIx2 = (Math.PI * 2) - 0.0001,
        CIRCLE = 'Circle';

      /**
       * Circle constructor
       * @constructor
       * @memberof Kinetic
       * @augments Kinetic.Shape
       * @param {Object} config
       * @param {Number} config.radius
       * @param {String} [config.fill] fill color
       * @param {Integer} [config.fillRed] set fill red component
       * @param {Integer} [config.fillGreen] set fill green component
       * @param {Integer} [config.fillBlue] set fill blue component
       * @param {Integer} [config.fillAlpha] set fill alpha component
       * @param {Image} [config.fillPatternImage] fill pattern image
       * @param {Number} [config.fillPatternX]
       * @param {Number} [config.fillPatternY]
       * @param {Object} [config.fillPatternOffset] object with x and y component
       * @param {Number} [config.fillPatternOffsetX]
       * @param {Number} [config.fillPatternOffsetY]
       * @param {Object} [config.fillPatternScale] object with x and y component
       * @param {Number} [config.fillPatternScaleX]
       * @param {Number} [config.fillPatternScaleY]
       * @param {Number} [config.fillPatternRotation]
       * @param {String} [config.fillPatternRepeat] can be "repeat", "repeat-x", "repeat-y", or "no-repeat".  The default is "no-repeat"
       * @param {Object} [config.fillLinearGradientStartPoint] object with x and y component
       * @param {Number} [config.fillLinearGradientStartPointX]
       * @param {Number} [config.fillLinearGradientStartPointY]
       * @param {Object} [config.fillLinearGradientEndPoint] object with x and y component
       * @param {Number} [config.fillLinearGradientEndPointX]
       * @param {Number} [config.fillLinearGradientEndPointY]
       * @param {Array} [config.fillLinearGradientColorStops] array of color stops
       * @param {Object} [config.fillRadialGradientStartPoint] object with x and y component
       * @param {Number} [config.fillRadialGradientStartPointX]
       * @param {Number} [config.fillRadialGradientStartPointY]
       * @param {Object} [config.fillRadialGradientEndPoint] object with x and y component
       * @param {Number} [config.fillRadialGradientEndPointX]
       * @param {Number} [config.fillRadialGradientEndPointY]
       * @param {Number} [config.fillRadialGradientStartRadius]
       * @param {Number} [config.fillRadialGradientEndRadius]
       * @param {Array} [config.fillRadialGradientColorStops] array of color stops
       * @param {Boolean} [config.fillEnabled] flag which enables or disables the fill.  The default value is true
       * @param {String} [config.fillPriority] can be color, linear-gradient, radial-graident, or pattern.  The default value is color.  The fillPriority property makes it really easy to toggle between different fill types.  For example, if you want to toggle between a fill color style and a fill pattern style, simply set the fill property and the fillPattern properties, and then use setFillPriority('color') to render the shape with a color fill, or use setFillPriority('pattern') to render the shape with the pattern fill configuration
       * @param {String} [config.stroke] stroke color
       * @param {Integer} [config.strokeRed] set stroke red component
       * @param {Integer} [config.strokeGreen] set stroke green component
       * @param {Integer} [config.strokeBlue] set stroke blue component
       * @param {Integer} [config.strokeAlpha] set stroke alpha component
       * @param {Number} [config.strokeWidth] stroke width
       * @param {Boolean} [config.strokeScaleEnabled] flag which enables or disables stroke scale.  The default is true
       * @param {Boolean} [config.strokeEnabled] flag which enables or disables the stroke.  The default value is true
       * @param {String} [config.lineJoin] can be miter, round, or bevel.  The default
       *  is miter
       * @param {String} [config.lineCap] can be butt, round, or sqare.  The default
       *  is butt
       * @param {String} [config.shadowColor]
       * @param {Integer} [config.shadowColorRed] set shadow color red component
       * @param {Integer} [config.shadowColorGreen] set shadow color green component
       * @param {Integer} [config.shadowColorBlue] set shadow color blue component
       * @param {Integer} [config.shadowColorAlpha] set shadow color alpha component
       * @param {Number} [config.shadowBlur]
       * @param {Object} [config.shadowOffset] object with x and y component
       * @param {Number} [config.shadowOffsetX]
       * @param {Number} [config.shadowOffsetY]
       * @param {Number} [config.shadowOpacity] shadow opacity.  Can be any real number
       *  between 0 and 1
       * @param {Boolean} [config.shadowEnabled] flag which enables or disables the shadow.  The default value is true
       * @param {Array} [config.dash]
       * @param {Boolean} [config.dashEnabled] flag which enables or disables the dashArray.  The default value is true
       * @param {Number} [config.x]
       * @param {Number} [config.y]
       * @param {Number} [config.width]
       * @param {Number} [config.height]
       * @param {Boolean} [config.visible]
       * @param {Boolean} [config.listening] whether or not the node is listening for events
       * @param {String} [config.id] unique id
       * @param {String} [config.name] non-unique name
       * @param {Number} [config.opacity] determines node opacity.  Can be any number between 0 and 1
       * @param {Object} [config.scale] set scale
       * @param {Number} [config.scaleX] set scale x
       * @param {Number} [config.scaleY] set scale y
       * @param {Number} [config.rotation] rotation in degrees
       * @param {Object} [config.offset] offset from center point and rotation point
       * @param {Number} [config.offsetX] set offset x
       * @param {Number} [config.offsetY] set offset y
       * @param {Boolean} [config.draggable] makes the node draggable.  When stages are draggable, you can drag and drop
       *  the entire stage by dragging any portion of the stage
       * @param {Function} [config.dragBoundFunc]
       * @example
       * // create circle
       * var circle = new Kinetic.Circle({<br>
       *   radius: 40,<br>
       *   fill: 'red',<br>
       *   stroke: 'black'<br>
       *   strokeWidth: 5<br>
       * });
       */
      Kinetic.Circle = function (config) {
          this.___init(config);
      };

      Kinetic.Circle.prototype = {
          ___init: function (config) {
              // call super constructor
              Kinetic.Shape.call(this, config);
              this.className = CIRCLE;
              this.sceneFunc(this._sceneFunc);
          },
          _sceneFunc: function (context) {
              context.beginPath();
              context.arc(0, 0, this.getRadius(), 0, PIx2, false);
              context.closePath();
              context.fillStrokeShape(this);
          },
          // implements Shape.prototype.getWidth()
          getWidth: function () {
              return this.getRadius() * 2;
          },
          // implements Shape.prototype.getHeight()
          getHeight: function () {
              return this.getRadius() * 2;
          },
          // implements Shape.prototype.setWidth()
          setWidth: function (width) {
              Kinetic.Node.prototype.setWidth.call(this, width);
              this.setRadius(width / 2);
          },
          // implements Shape.prototype.setHeight()
          setHeight: function (height) {
              Kinetic.Node.prototype.setHeight.call(this, height);
              this.setRadius(height / 2);
          }
      };
      Kinetic.Util.extend(Kinetic.Circle, Kinetic.Shape);

      // add getters setters
      Kinetic.Factory.addGetterSetter(Kinetic.Circle, 'radius', 0);

      /**
       * get/set radius
       * @name radius
       * @method
       * @memberof Kinetic.Circle.prototype
       * @param {Number} radius
       * @returns {Number}
       * @example
       * // get radius<br>
       * var radius = circle.radius();<br><br>
       *
       * // set radius<br>
       * circle.radius(10);<br>
       */

      Kinetic.Collection.mapMethods(Kinetic.Circle);
  })();
  ;
  (function () {
      // the 0.0001 offset fixes a bug in Chrome 27
      var PIx2 = (Math.PI * 2) - 0.0001,
        ELLIPSE = 'Ellipse';

      /**
       * Ellipse constructor
       * @constructor
       * @augments Kinetic.Shape
       * @param {Object} config
       * @param {Number|Array|Object} config.radius defines x and y radius
       * @@ShapeParams
       * @@NodeParams
       */
      Kinetic.Ellipse = function (config) {
          this.___init(config);
      };

      Kinetic.Ellipse.prototype = {
          ___init: function (config) {
              // call super constructor
              Kinetic.Shape.call(this, config);
              this.className = ELLIPSE;
              this.sceneFunc(this._sceneFunc);
          },
          _sceneFunc: function (context) {
              var r = this.getRadius(),
                rx = r.x,
                ry = r.y;

              context.beginPath();
              context.save();
              if (rx !== ry) {
                  context.scale(1, ry / rx);
              }
              context.arc(0, 0, rx, 0, PIx2, false);
              context.restore();
              context.closePath();
              context.fillStrokeShape(this);
          },
          // implements Shape.prototype.getWidth()
          getWidth: function () {
              return this.getRadius().x * 2;
          },
          // implements Shape.prototype.getHeight()
          getHeight: function () {
              return this.getRadius().y * 2;
          },
          // implements Shape.prototype.setWidth()
          setWidth: function (width) {
              Kinetic.Node.prototype.setWidth.call(this, width);
              this.setRadius({
                  x: width / 2
              });
          },
          // implements Shape.prototype.setHeight()
          setHeight: function (height) {
              Kinetic.Node.prototype.setHeight.call(this, height);
              this.setRadius({
                  y: height / 2
              });
          }
      };
      Kinetic.Util.extend(Kinetic.Ellipse, Kinetic.Shape);

      // add getters setters
      Kinetic.Factory.addComponentsGetterSetter(Kinetic.Ellipse, 'radius', [
          'x',
          'y'
      ]);

      /**
       * get/set radius
       * @name radius
       * @method
       * @memberof Kinetic.Ellipse.prototype
       * @param {Object} radius
       * @param {Number} radius.x
       * @param {Number} radius.y
       * @returns {Object}
       * @example
       * // get radius<br>
       * var radius = ellipse.radius();<br><br>
       *
       * // set radius<br>
       * ellipse.radius({<br>
       *   x: 200,<br>
       *   y: 100<br>
       * });
       */

      Kinetic.Factory.addGetterSetter(Kinetic.Ellipse, 'radiusX', 0);
      /**
       * get/set radius x
       * @name radiusX
       * @method
       * @memberof Kinetic.Ellipse.prototype
       * @param {Number} x
       * @returns {Number}
       * @example
       * // get radius x<br>
       * var radiusX = ellipse.radiusX();<br><br>
       *
       * // set radius x<br>
       * ellipse.radiusX(200);
       */

      Kinetic.Factory.addGetterSetter(Kinetic.Ellipse, 'radiusY', 0);
      /**
       * get/set radius y
       * @name radiusY
       * @method
       * @memberof Kinetic.Ellipse.prototype
       * @param {Number} y
       * @returns {Number}
       * @example
       * // get radius y<br>
       * var radiusY = ellipse.radiusY();<br><br>
       *
       * // set radius y<br>
       * ellipse.radiusY(200);
       */

      Kinetic.Collection.mapMethods(Kinetic.Ellipse);

  })();
  ;
  (function () {
      // the 0.0001 offset fixes a bug in Chrome 27
      var PIx2 = (Math.PI * 2) - 0.0001;

      /**
       * Ring constructor
       * @constructor
       * @augments Kinetic.Shape
       * @param {Object} config
       * @param {Number} config.innerRadius
       * @param {Number} config.outerRadius
       * @param {Boolean} [config.clockwise]
       * @param {String} [config.fill] fill color
       * @param {Integer} [config.fillRed] set fill red component
       * @param {Integer} [config.fillGreen] set fill green component
       * @param {Integer} [config.fillBlue] set fill blue component
       * @param {Integer} [config.fillAlpha] set fill alpha component
       * @param {Image} [config.fillPatternImage] fill pattern image
       * @param {Number} [config.fillPatternX]
       * @param {Number} [config.fillPatternY]
       * @param {Object} [config.fillPatternOffset] object with x and y component
       * @param {Number} [config.fillPatternOffsetX]
       * @param {Number} [config.fillPatternOffsetY]
       * @param {Object} [config.fillPatternScale] object with x and y component
       * @param {Number} [config.fillPatternScaleX]
       * @param {Number} [config.fillPatternScaleY]
       * @param {Number} [config.fillPatternRotation]
       * @param {String} [config.fillPatternRepeat] can be "repeat", "repeat-x", "repeat-y", or "no-repeat".  The default is "no-repeat"
       * @param {Object} [config.fillLinearGradientStartPoint] object with x and y component
       * @param {Number} [config.fillLinearGradientStartPointX]
       * @param {Number} [config.fillLinearGradientStartPointY]
       * @param {Object} [config.fillLinearGradientEndPoint] object with x and y component
       * @param {Number} [config.fillLinearGradientEndPointX]
       * @param {Number} [config.fillLinearGradientEndPointY]
       * @param {Array} [config.fillLinearGradientColorStops] array of color stops
       * @param {Object} [config.fillRadialGradientStartPoint] object with x and y component
       * @param {Number} [config.fillRadialGradientStartPointX]
       * @param {Number} [config.fillRadialGradientStartPointY]
       * @param {Object} [config.fillRadialGradientEndPoint] object with x and y component
       * @param {Number} [config.fillRadialGradientEndPointX]
       * @param {Number} [config.fillRadialGradientEndPointY]
       * @param {Number} [config.fillRadialGradientStartRadius]
       * @param {Number} [config.fillRadialGradientEndRadius]
       * @param {Array} [config.fillRadialGradientColorStops] array of color stops
       * @param {Boolean} [config.fillEnabled] flag which enables or disables the fill.  The default value is true
       * @param {String} [config.fillPriority] can be color, linear-gradient, radial-graident, or pattern.  The default value is color.  The fillPriority property makes it really easy to toggle between different fill types.  For example, if you want to toggle between a fill color style and a fill pattern style, simply set the fill property and the fillPattern properties, and then use setFillPriority('color') to render the shape with a color fill, or use setFillPriority('pattern') to render the shape with the pattern fill configuration
       * @param {String} [config.stroke] stroke color
       * @param {Integer} [config.strokeRed] set stroke red component
       * @param {Integer} [config.strokeGreen] set stroke green component
       * @param {Integer} [config.strokeBlue] set stroke blue component
       * @param {Integer} [config.strokeAlpha] set stroke alpha component
       * @param {Number} [config.strokeWidth] stroke width
       * @param {Boolean} [config.strokeScaleEnabled] flag which enables or disables stroke scale.  The default is true
       * @param {Boolean} [config.strokeEnabled] flag which enables or disables the stroke.  The default value is true
       * @param {String} [config.lineJoin] can be miter, round, or bevel.  The default
       *  is miter
       * @param {String} [config.lineCap] can be butt, round, or sqare.  The default
       *  is butt
       * @param {String} [config.shadowColor]
       * @param {Integer} [config.shadowColorRed] set shadow color red component
       * @param {Integer} [config.shadowColorGreen] set shadow color green component
       * @param {Integer} [config.shadowColorBlue] set shadow color blue component
       * @param {Integer} [config.shadowColorAlpha] set shadow color alpha component
       * @param {Number} [config.shadowBlur]
       * @param {Object} [config.shadowOffset] object with x and y component
       * @param {Number} [config.shadowOffsetX]
       * @param {Number} [config.shadowOffsetY]
       * @param {Number} [config.shadowOpacity] shadow opacity.  Can be any real number
       *  between 0 and 1
       * @param {Boolean} [config.shadowEnabled] flag which enables or disables the shadow.  The default value is true
       * @param {Array} [config.dash]
       * @param {Boolean} [config.dashEnabled] flag which enables or disables the dashArray.  The default value is true
       * @param {Number} [config.x]
       * @param {Number} [config.y]
       * @param {Number} [config.width]
       * @param {Number} [config.height]
       * @param {Boolean} [config.visible]
       * @param {Boolean} [config.listening] whether or not the node is listening for events
       * @param {String} [config.id] unique id
       * @param {String} [config.name] non-unique name
       * @param {Number} [config.opacity] determines node opacity.  Can be any number between 0 and 1
       * @param {Object} [config.scale] set scale
       * @param {Number} [config.scaleX] set scale x
       * @param {Number} [config.scaleY] set scale y
       * @param {Number} [config.rotation] rotation in degrees
       * @param {Object} [config.offset] offset from center point and rotation point
       * @param {Number} [config.offsetX] set offset x
       * @param {Number} [config.offsetY] set offset y
       * @param {Boolean} [config.draggable] makes the node draggable.  When stages are draggable, you can drag and drop
       *  the entire stage by dragging any portion of the stage
       * @param {Function} [config.dragBoundFunc]
       * @example
       * var ring = new Kinetic.Ring({<br>
       *   innerRadius: 40,<br>
       *   outerRadius: 80,<br>
       *   fill: 'red',<br>
       *   stroke: 'black',<br>
       *   strokeWidth: 5<br>
       * });
       */
      Kinetic.Ring = function (config) {
          this.___init(config);
      };

      Kinetic.Ring.prototype = {
          ___init: function (config) {
              // call super constructor
              Kinetic.Shape.call(this, config);
              this.className = 'Ring';
              this.sceneFunc(this._sceneFunc);
          },
          _sceneFunc: function (context) {
              context.beginPath();
              context.arc(0, 0, this.getInnerRadius(), 0, PIx2, false);
              context.moveTo(this.getOuterRadius(), 0);
              context.arc(0, 0, this.getOuterRadius(), PIx2, 0, true);
              context.closePath();
              context.fillStrokeShape(this);
          },
          // implements Shape.prototype.getWidth()
          getWidth: function () {
              return this.getOuterRadius() * 2;
          },
          // implements Shape.prototype.getHeight()
          getHeight: function () {
              return this.getOuterRadius() * 2;
          },
          // implements Shape.prototype.setWidth()
          setWidth: function (width) {
              Kinetic.Node.prototype.setWidth.call(this, width);
              this.setOuterRadius(width / 2);
          },
          // implements Shape.prototype.setHeight()
          setHeight: function (height) {
              Kinetic.Node.prototype.setHeight.call(this, height);
              this.setOuterRadius(height / 2);
          }
      };
      Kinetic.Util.extend(Kinetic.Ring, Kinetic.Shape);

      // add getters setters
      Kinetic.Factory.addGetterSetter(Kinetic.Ring, 'innerRadius', 0);

      /**
       * get/set innerRadius
       * @name innerRadius
       * @method
       * @memberof Kinetic.Ring.prototype
       * @param {Number} innerRadius
       * @returns {Number}
       * @example
       * // get inner radius<br>
       * var innerRadius = ring.innerRadius();<br><br>
       *
       * // set inner radius<br>
       * ring.innerRadius(20);
       */

      Kinetic.Factory.addGetterSetter(Kinetic.Ring, 'outerRadius', 0);

      /**
       * get/set outerRadius
       * @name outerRadius
       * @method
       * @memberof Kinetic.Ring.prototype
       * @param {Number} outerRadius
       * @returns {Number}
       * @example
       * // get outer radius<br>
       * var outerRadius = ring.outerRadius();<br><br>
       *
       * // set outer radius<br>
       * ring.outerRadius(20);
       */

      Kinetic.Collection.mapMethods(Kinetic.Ring);
  })();
  ;
  (function () {
      /**
       * Wedge constructor
       * @constructor
       * @augments Kinetic.Shape
       * @param {Object} config
       * @param {Number} config.angle in degrees
       * @param {Number} config.radius
       * @param {Boolean} [config.clockwise]
       * @param {String} [config.fill] fill color
       * @param {Integer} [config.fillRed] set fill red component
       * @param {Integer} [config.fillGreen] set fill green component
       * @param {Integer} [config.fillBlue] set fill blue component
       * @param {Integer} [config.fillAlpha] set fill alpha component
       * @param {Image} [config.fillPatternImage] fill pattern image
       * @param {Number} [config.fillPatternX]
       * @param {Number} [config.fillPatternY]
       * @param {Object} [config.fillPatternOffset] object with x and y component
       * @param {Number} [config.fillPatternOffsetX]
       * @param {Number} [config.fillPatternOffsetY]
       * @param {Object} [config.fillPatternScale] object with x and y component
       * @param {Number} [config.fillPatternScaleX]
       * @param {Number} [config.fillPatternScaleY]
       * @param {Number} [config.fillPatternRotation]
       * @param {String} [config.fillPatternRepeat] can be "repeat", "repeat-x", "repeat-y", or "no-repeat".  The default is "no-repeat"
       * @param {Object} [config.fillLinearGradientStartPoint] object with x and y component
       * @param {Number} [config.fillLinearGradientStartPointX]
       * @param {Number} [config.fillLinearGradientStartPointY]
       * @param {Object} [config.fillLinearGradientEndPoint] object with x and y component
       * @param {Number} [config.fillLinearGradientEndPointX]
       * @param {Number} [config.fillLinearGradientEndPointY]
       * @param {Array} [config.fillLinearGradientColorStops] array of color stops
       * @param {Object} [config.fillRadialGradientStartPoint] object with x and y component
       * @param {Number} [config.fillRadialGradientStartPointX]
       * @param {Number} [config.fillRadialGradientStartPointY]
       * @param {Object} [config.fillRadialGradientEndPoint] object with x and y component
       * @param {Number} [config.fillRadialGradientEndPointX]
       * @param {Number} [config.fillRadialGradientEndPointY]
       * @param {Number} [config.fillRadialGradientStartRadius]
       * @param {Number} [config.fillRadialGradientEndRadius]
       * @param {Array} [config.fillRadialGradientColorStops] array of color stops
       * @param {Boolean} [config.fillEnabled] flag which enables or disables the fill.  The default value is true
       * @param {String} [config.fillPriority] can be color, linear-gradient, radial-graident, or pattern.  The default value is color.  The fillPriority property makes it really easy to toggle between different fill types.  For example, if you want to toggle between a fill color style and a fill pattern style, simply set the fill property and the fillPattern properties, and then use setFillPriority('color') to render the shape with a color fill, or use setFillPriority('pattern') to render the shape with the pattern fill configuration
       * @param {String} [config.stroke] stroke color
       * @param {Integer} [config.strokeRed] set stroke red component
       * @param {Integer} [config.strokeGreen] set stroke green component
       * @param {Integer} [config.strokeBlue] set stroke blue component
       * @param {Integer} [config.strokeAlpha] set stroke alpha component
       * @param {Number} [config.strokeWidth] stroke width
       * @param {Boolean} [config.strokeScaleEnabled] flag which enables or disables stroke scale.  The default is true
       * @param {Boolean} [config.strokeEnabled] flag which enables or disables the stroke.  The default value is true
       * @param {String} [config.lineJoin] can be miter, round, or bevel.  The default
       *  is miter
       * @param {String} [config.lineCap] can be butt, round, or sqare.  The default
       *  is butt
       * @param {String} [config.shadowColor]
       * @param {Integer} [config.shadowColorRed] set shadow color red component
       * @param {Integer} [config.shadowColorGreen] set shadow color green component
       * @param {Integer} [config.shadowColorBlue] set shadow color blue component
       * @param {Integer} [config.shadowColorAlpha] set shadow color alpha component
       * @param {Number} [config.shadowBlur]
       * @param {Object} [config.shadowOffset] object with x and y component
       * @param {Number} [config.shadowOffsetX]
       * @param {Number} [config.shadowOffsetY]
       * @param {Number} [config.shadowOpacity] shadow opacity.  Can be any real number
       *  between 0 and 1
       * @param {Boolean} [config.shadowEnabled] flag which enables or disables the shadow.  The default value is true
       * @param {Array} [config.dash]
       * @param {Boolean} [config.dashEnabled] flag which enables or disables the dashArray.  The default value is true
       * @param {Number} [config.x]
       * @param {Number} [config.y]
       * @param {Number} [config.width]
       * @param {Number} [config.height]
       * @param {Boolean} [config.visible]
       * @param {Boolean} [config.listening] whether or not the node is listening for events
       * @param {String} [config.id] unique id
       * @param {String} [config.name] non-unique name
       * @param {Number} [config.opacity] determines node opacity.  Can be any number between 0 and 1
       * @param {Object} [config.scale] set scale
       * @param {Number} [config.scaleX] set scale x
       * @param {Number} [config.scaleY] set scale y
       * @param {Number} [config.rotation] rotation in degrees
       * @param {Object} [config.offset] offset from center point and rotation point
       * @param {Number} [config.offsetX] set offset x
       * @param {Number} [config.offsetY] set offset y
       * @param {Boolean} [config.draggable] makes the node draggable.  When stages are draggable, you can drag and drop
       *  the entire stage by dragging any portion of the stage
       * @param {Function} [config.dragBoundFunc]
       * @example
       * // draw a wedge that's pointing downwards<br>
       * var wedge = new Kinetic.Wedge({<br>
       *   radius: 40,<br>
       *   fill: 'red',<br>
       *   stroke: 'black'<br>
       *   strokeWidth: 5,<br>
       *   angleDeg: 60,<br>
       *   rotationDeg: -120<br>
       * });
       */
      Kinetic.Wedge = function (config) {
          this.___init(config);
      };

      Kinetic.Wedge.prototype = {
          ___init: function (config) {
              // call super constructor
              Kinetic.Shape.call(this, config);
              this.className = 'Wedge';
              this.sceneFunc(this._sceneFunc);
          },
          _sceneFunc: function (context) {
              context.beginPath();
              context.arc(0, 0, this.getRadius(), 0, this.getAngle() * Math.PI / 180, this.getClockwise());
              context.lineTo(0, 0);
              context.closePath();
              context.fillStrokeShape(this);
          }
      };
      Kinetic.Util.extend(Kinetic.Wedge, Kinetic.Shape);

      // add getters setters
      Kinetic.Factory.addGetterSetter(Kinetic.Wedge, 'radius', 0);

      /**
       * get/set radius
       * @name radius
       * @method
       * @memberof Kinetic.Wedge.prototype
       * @param {Number} radius
       * @returns {Number}
       * @example
       * // get radius<br>
       * var radius = wedge.radius();<br><br>
       *
       * // set radius<br>
       * wedge.radius(10);<br>
       */

      Kinetic.Factory.addGetterSetter(Kinetic.Wedge, 'angle', 0);

      /**
       * get/set angle in degrees
       * @name angle
       * @method
       * @memberof Kinetic.Wedge.prototype
       * @param {Number} angle
       * @returns {Number}
       * @example
       * // get angle<br>
       * var angle = wedge.angle();<br><br>
       *
       * // set angle<br>
       * wedge.angle(20);
       */

      Kinetic.Factory.addGetterSetter(Kinetic.Wedge, 'clockwise', false);

      /**
       * get/set clockwise flag
       * @name clockwise
       * @method
       * @memberof Kinetic.Wedge.prototype
       * @param {Number} clockwise
       * @returns {Number}
       * @example
       * // get clockwise flag<br>
       * var clockwise = wedge.clockwise();<br><br>
       *
       * // draw wedge counter-clockwise<br>
       * wedge.clockwise(false);<br><br>
       *
       * // draw wedge clockwise<br>
       * wedge.clockwise(true);
       */

      Kinetic.Factory.backCompat(Kinetic.Wedge, {
          angleDeg: 'angle',
          getAngleDeg: 'getAngle',
          setAngleDeg: 'setAngle'
      });

      Kinetic.Collection.mapMethods(Kinetic.Wedge);
  })();
  ;
  (function () {
      /**
       * Arc constructor
       * @constructor
       * @augments Kinetic.Shape
       * @param {Object} config
       * @param {Number} config.angle in degrees
       * @param {Number} config.innerRadius
       * @param {Number} config.outerRadius
       * @param {Boolean} [config.clockwise]
       * @param {String} [config.fill] fill color
       * @param {Integer} [config.fillRed] set fill red component
       * @param {Integer} [config.fillGreen] set fill green component
       * @param {Integer} [config.fillBlue] set fill blue component
       * @param {Integer} [config.fillAlpha] set fill alpha component
       * @param {Image} [config.fillPatternImage] fill pattern image
       * @param {Number} [config.fillPatternX]
       * @param {Number} [config.fillPatternY]
       * @param {Object} [config.fillPatternOffset] object with x and y component
       * @param {Number} [config.fillPatternOffsetX]
       * @param {Number} [config.fillPatternOffsetY]
       * @param {Object} [config.fillPatternScale] object with x and y component
       * @param {Number} [config.fillPatternScaleX]
       * @param {Number} [config.fillPatternScaleY]
       * @param {Number} [config.fillPatternRotation]
       * @param {String} [config.fillPatternRepeat] can be "repeat", "repeat-x", "repeat-y", or "no-repeat".  The default is "no-repeat"
       * @param {Object} [config.fillLinearGradientStartPoint] object with x and y component
       * @param {Number} [config.fillLinearGradientStartPointX]
       * @param {Number} [config.fillLinearGradientStartPointY]
       * @param {Object} [config.fillLinearGradientEndPoint] object with x and y component
       * @param {Number} [config.fillLinearGradientEndPointX]
       * @param {Number} [config.fillLinearGradientEndPointY]
       * @param {Array} [config.fillLinearGradientColorStops] array of color stops
       * @param {Object} [config.fillRadialGradientStartPoint] object with x and y component
       * @param {Number} [config.fillRadialGradientStartPointX]
       * @param {Number} [config.fillRadialGradientStartPointY]
       * @param {Object} [config.fillRadialGradientEndPoint] object with x and y component
       * @param {Number} [config.fillRadialGradientEndPointX]
       * @param {Number} [config.fillRadialGradientEndPointY]
       * @param {Number} [config.fillRadialGradientStartRadius]
       * @param {Number} [config.fillRadialGradientEndRadius]
       * @param {Array} [config.fillRadialGradientColorStops] array of color stops
       * @param {Boolean} [config.fillEnabled] flag which enables or disables the fill.  The default value is true
       * @param {String} [config.fillPriority] can be color, linear-gradient, radial-graident, or pattern.  The default value is color.  The fillPriority property makes it really easy to toggle between different fill types.  For example, if you want to toggle between a fill color style and a fill pattern style, simply set the fill property and the fillPattern properties, and then use setFillPriority('color') to render the shape with a color fill, or use setFillPriority('pattern') to render the shape with the pattern fill configuration
       * @param {String} [config.stroke] stroke color
       * @param {Integer} [config.strokeRed] set stroke red component
       * @param {Integer} [config.strokeGreen] set stroke green component
       * @param {Integer} [config.strokeBlue] set stroke blue component
       * @param {Integer} [config.strokeAlpha] set stroke alpha component
       * @param {Number} [config.strokeWidth] stroke width
       * @param {Boolean} [config.strokeScaleEnabled] flag which enables or disables stroke scale.  The default is true
       * @param {Boolean} [config.strokeEnabled] flag which enables or disables the stroke.  The default value is true
       * @param {String} [config.lineJoin] can be miter, round, or bevel.  The default
       *  is miter
       * @param {String} [config.lineCap] can be butt, round, or sqare.  The default
       *  is butt
       * @param {String} [config.shadowColor]
       * @param {Integer} [config.shadowColorRed] set shadow color red component
       * @param {Integer} [config.shadowColorGreen] set shadow color green component
       * @param {Integer} [config.shadowColorBlue] set shadow color blue component
       * @param {Integer} [config.shadowColorAlpha] set shadow color alpha component
       * @param {Number} [config.shadowBlur]
       * @param {Object} [config.shadowOffset] object with x and y component
       * @param {Number} [config.shadowOffsetX]
       * @param {Number} [config.shadowOffsetY]
       * @param {Number} [config.shadowOpacity] shadow opacity.  Can be any real number
       *  between 0 and 1
       * @param {Boolean} [config.shadowEnabled] flag which enables or disables the shadow.  The default value is true
       * @param {Array} [config.dash]
       * @param {Boolean} [config.dashEnabled] flag which enables or disables the dashArray.  The default value is true
       * @param {Number} [config.x]
       * @param {Number} [config.y]
       * @param {Number} [config.width]
       * @param {Number} [config.height]
       * @param {Boolean} [config.visible]
       * @param {Boolean} [config.listening] whether or not the node is listening for events
       * @param {String} [config.id] unique id
       * @param {String} [config.name] non-unique name
       * @param {Number} [config.opacity] determines node opacity.  Can be any number between 0 and 1
       * @param {Object} [config.scale] set scale
       * @param {Number} [config.scaleX] set scale x
       * @param {Number} [config.scaleY] set scale y
       * @param {Number} [config.rotation] rotation in degrees
       * @param {Object} [config.offset] offset from center point and rotation point
       * @param {Number} [config.offsetX] set offset x
       * @param {Number} [config.offsetY] set offset y
       * @param {Boolean} [config.draggable] makes the node draggable.  When stages are draggable, you can drag and drop
       *  the entire stage by dragging any portion of the stage
       * @param {Function} [config.dragBoundFunc]
       * @example
       * // draw a Arc that's pointing downwards<br>
       * var arc = new Kinetic.Arc({<br>
       *   innerRadius: 40,<br>
       *   outerRadius: 80,<br>
       *   fill: 'red',<br>
       *   stroke: 'black'<br>
       *   strokeWidth: 5,<br>
       *   angle: 60,<br>
       *   rotationDeg: -120<br>
       * });
       */
      Kinetic.Arc = function (config) {
          this.___init(config);
      };

      Kinetic.Arc.prototype = {
          ___init: function (config) {
              // call super constructor
              Kinetic.Shape.call(this, config);
              this.className = 'Arc';
              this.sceneFunc(this._sceneFunc);
          },
          _sceneFunc: function (context) {
              var angle = this.angle() * Math.PI / 180,
                clockwise = this.clockwise();

              context.beginPath();
              context.arc(0, 0, this.getOuterRadius(), 0, angle, clockwise);
              context.arc(0, 0, this.getInnerRadius(), angle, 0, !clockwise);
              context.closePath();
              context.fillStrokeShape(this);
          }
      };
      Kinetic.Util.extend(Kinetic.Arc, Kinetic.Shape);

      // add getters setters
      Kinetic.Factory.addGetterSetter(Kinetic.Arc, 'innerRadius', 0);

      /**
       * get/set innerRadius
       * @name innerRadius
       * @method
       * @memberof Kinetic.Arc.prototype
       * @param {Number} innerRadius
       * @returns {Number}
       * @example
       * // get inner radius
       * var innerRadius = arc.innerRadius();
       *
       * // set inner radius
       * arc.innerRadius(20);
       */

      Kinetic.Factory.addGetterSetter(Kinetic.Arc, 'outerRadius', 0);

      /**
       * get/set outerRadius
       * @name outerRadius
       * @method
       * @memberof Kinetic.Arc.prototype
       * @param {Number} outerRadius
       * @returns {Number}
       * @example
       * // get outer radius<br>
       * var outerRadius = arc.outerRadius();<br><br>
       *
       * // set outer radius<br>
       * arc.outerRadius(20);
       */

      Kinetic.Factory.addGetterSetter(Kinetic.Arc, 'angle', 0);

      /**
       * get/set angle in degrees
       * @name angle
       * @method
       * @memberof Kinetic.Arc.prototype
       * @param {Number} angle
       * @returns {Number}
       * @example
       * // get angle<br>
       * var angle = arc.angle();<br><br>
       *
       * // set angle<br>
       * arc.angle(20);
       */

      Kinetic.Factory.addGetterSetter(Kinetic.Arc, 'clockwise', false);

      /**
       * get/set clockwise flag
       * @name clockwise
       * @method
       * @memberof Kinetic.Arc.prototype
       * @param {Number} clockwise
       * @returns {Number}
       * @example
       * // get clockwise flag<br>
       * var clockwise = arc.clockwise();<br><br>
       *
       * // draw arc counter-clockwise<br>
       * arc.clockwise(false);<br><br>
       *
       * // draw arc clockwise<br>
       * arc.clockwise(true);
       */

      Kinetic.Collection.mapMethods(Kinetic.Arc);
  })();
  ;
  (function () {

      // CONSTANTS
      var IMAGE = 'Image',
        SET = 'set';

      /**
       * Image constructor
       * @constructor
       * @memberof Kinetic
       * @augments Kinetic.Shape
       * @param {Object} config
       * @param {ImageObject} config.image
       * @param {Object} [config.crop]
       * @param {String} [config.fill] fill color
       * @param {Integer} [config.fillRed] set fill red component
       * @param {Integer} [config.fillGreen] set fill green component
       * @param {Integer} [config.fillBlue] set fill blue component
       * @param {Integer} [config.fillAlpha] set fill alpha component
       * @param {Image} [config.fillPatternImage] fill pattern image
       * @param {Number} [config.fillPatternX]
       * @param {Number} [config.fillPatternY]
       * @param {Object} [config.fillPatternOffset] object with x and y component
       * @param {Number} [config.fillPatternOffsetX]
       * @param {Number} [config.fillPatternOffsetY]
       * @param {Object} [config.fillPatternScale] object with x and y component
       * @param {Number} [config.fillPatternScaleX]
       * @param {Number} [config.fillPatternScaleY]
       * @param {Number} [config.fillPatternRotation]
       * @param {String} [config.fillPatternRepeat] can be "repeat", "repeat-x", "repeat-y", or "no-repeat".  The default is "no-repeat"
       * @param {Object} [config.fillLinearGradientStartPoint] object with x and y component
       * @param {Number} [config.fillLinearGradientStartPointX]
       * @param {Number} [config.fillLinearGradientStartPointY]
       * @param {Object} [config.fillLinearGradientEndPoint] object with x and y component
       * @param {Number} [config.fillLinearGradientEndPointX]
       * @param {Number} [config.fillLinearGradientEndPointY]
       * @param {Array} [config.fillLinearGradientColorStops] array of color stops
       * @param {Object} [config.fillRadialGradientStartPoint] object with x and y component
       * @param {Number} [config.fillRadialGradientStartPointX]
       * @param {Number} [config.fillRadialGradientStartPointY]
       * @param {Object} [config.fillRadialGradientEndPoint] object with x and y component
       * @param {Number} [config.fillRadialGradientEndPointX]
       * @param {Number} [config.fillRadialGradientEndPointY]
       * @param {Number} [config.fillRadialGradientStartRadius]
       * @param {Number} [config.fillRadialGradientEndRadius]
       * @param {Array} [config.fillRadialGradientColorStops] array of color stops
       * @param {Boolean} [config.fillEnabled] flag which enables or disables the fill.  The default value is true
       * @param {String} [config.fillPriority] can be color, linear-gradient, radial-graident, or pattern.  The default value is color.  The fillPriority property makes it really easy to toggle between different fill types.  For example, if you want to toggle between a fill color style and a fill pattern style, simply set the fill property and the fillPattern properties, and then use setFillPriority('color') to render the shape with a color fill, or use setFillPriority('pattern') to render the shape with the pattern fill configuration
       * @param {String} [config.stroke] stroke color
       * @param {Integer} [config.strokeRed] set stroke red component
       * @param {Integer} [config.strokeGreen] set stroke green component
       * @param {Integer} [config.strokeBlue] set stroke blue component
       * @param {Integer} [config.strokeAlpha] set stroke alpha component
       * @param {Number} [config.strokeWidth] stroke width
       * @param {Boolean} [config.strokeScaleEnabled] flag which enables or disables stroke scale.  The default is true
       * @param {Boolean} [config.strokeEnabled] flag which enables or disables the stroke.  The default value is true
       * @param {String} [config.lineJoin] can be miter, round, or bevel.  The default
       *  is miter
       * @param {String} [config.lineCap] can be butt, round, or sqare.  The default
       *  is butt
       * @param {String} [config.shadowColor]
       * @param {Integer} [config.shadowColorRed] set shadow color red component
       * @param {Integer} [config.shadowColorGreen] set shadow color green component
       * @param {Integer} [config.shadowColorBlue] set shadow color blue component
       * @param {Integer} [config.shadowColorAlpha] set shadow color alpha component
       * @param {Number} [config.shadowBlur]
       * @param {Object} [config.shadowOffset] object with x and y component
       * @param {Number} [config.shadowOffsetX]
       * @param {Number} [config.shadowOffsetY]
       * @param {Number} [config.shadowOpacity] shadow opacity.  Can be any real number
       *  between 0 and 1
       * @param {Boolean} [config.shadowEnabled] flag which enables or disables the shadow.  The default value is true
       * @param {Array} [config.dash]
       * @param {Boolean} [config.dashEnabled] flag which enables or disables the dashArray.  The default value is true
       * @param {Number} [config.x]
       * @param {Number} [config.y]
       * @param {Number} [config.width]
       * @param {Number} [config.height]
       * @param {Boolean} [config.visible]
       * @param {Boolean} [config.listening] whether or not the node is listening for events
       * @param {String} [config.id] unique id
       * @param {String} [config.name] non-unique name
       * @param {Number} [config.opacity] determines node opacity.  Can be any number between 0 and 1
       * @param {Object} [config.scale] set scale
       * @param {Number} [config.scaleX] set scale x
       * @param {Number} [config.scaleY] set scale y
       * @param {Number} [config.rotation] rotation in degrees
       * @param {Object} [config.offset] offset from center point and rotation point
       * @param {Number} [config.offsetX] set offset x
       * @param {Number} [config.offsetY] set offset y
       * @param {Boolean} [config.draggable] makes the node draggable.  When stages are draggable, you can drag and drop
       *  the entire stage by dragging any portion of the stage
       * @param {Function} [config.dragBoundFunc]
       * @example
       * var imageObj = new Image();<br>
       * imageObj.onload = function() {<br>
       *   var image = new Kinetic.Image({<br>
       *     x: 200,<br>
       *     y: 50,<br>
       *     image: imageObj,<br>
       *     width: 100,<br>
       *     height: 100<br>
       *   });<br>
       * };<br>
       * imageObj.src = '/path/to/image.jpg'
       */
      Kinetic.Image = function (config) {
          this.___init(config);
      };

      Kinetic.Image.prototype = {
          ___init: function (config) {
              // call super constructor
              Kinetic.Shape.call(this, config);
              this.className = IMAGE;
              this.sceneFunc(this._sceneFunc);
              this.hitFunc(this._hitFunc);
          },
          _useBufferCanvas: function () {
              return (this.hasShadow() || this.getAbsoluteOpacity() !== 1) && this.hasStroke();
          },
          _sceneFunc: function (context) {
              var width = this.getWidth(),
                height = this.getHeight(),
                image = this.getImage(),
                crop, cropWidth, cropHeight, params;

              if (image) {
                  crop = this.getCrop(),
                    cropWidth = crop.width;
                  cropHeight = crop.height;
                  if (cropWidth && cropHeight) {
                      params = [
                          image,
                          crop.x,
                          crop.y,
                          cropWidth,
                          cropHeight,
                          0,
                          0,
                          width,
                          height
                      ];
                  }
                  else {
                      params = [
                          image,
                          0,
                          0,
                          width,
                          height
                      ];
                  }
              }

              context.beginPath();
              context.rect(0, 0, width, height);
              context.closePath();
              context.fillStrokeShape(this);

              if (image) {
                  context.drawImage.apply(context, params);
              }
          },
          _hitFunc: function (context) {
              var width = this.getWidth(),
                height = this.getHeight();

              context.beginPath();
              context.rect(0, 0, width, height);
              context.closePath();
              context.fillStrokeShape(this);
          },
          getWidth: function () {
              var image = this.getImage();
              return this.attrs.width || (image ? image.width : 0);
          },
          getHeight: function () {
              var image = this.getImage();
              return this.attrs.height || (image ? image.height : 0);
          }
      };
      Kinetic.Util.extend(Kinetic.Image, Kinetic.Shape);

      // add getters setters
      Kinetic.Factory.addGetterSetter(Kinetic.Image, 'image');

      /**
       * set image
       * @name setImage
       * @method
       * @memberof Kinetic.Image.prototype
       * @param {ImageObject} image
       */

      /**
       * get image
       * @name getImage
       * @method
       * @memberof Kinetic.Image.prototype
       * @returns {ImageObject}
       */

      Kinetic.Factory.addComponentsGetterSetter(Kinetic.Image, 'crop', [
          'x',
          'y',
          'width',
          'height'
      ]);
      /**
       * get/set crop
       * @method
       * @name crop
       * @memberof Kinetic.Image.prototype
       * @param {Object} crop
       * @param {Number} crop.x
       * @param {Number} crop.y
       * @param {Number} crop.width
       * @param {Number} crop.height
       * @returns {Object}
       * @example
       * // get crop<br>
       * var crop = image.crop();<br><br>
       *
       * // set crop<br>
       * image.crop({<br>
       *   x: 20,<br>
       *   y: 20,<br>
       *   width: 20,<br>
       *   height: 20<br>
       * });
       */

      Kinetic.Factory.addGetterSetter(Kinetic.Image, 'cropX', 0);
      /**
       * get/set crop x
       * @method
       * @name cropX
       * @memberof Kinetic.Image.prototype
       * @param {Number} x
       * @returns {Number}
       * @example
       * // get crop x<br>
       * var cropX = image.cropX();<br><br>
       *
       * // set crop x<br>
       * image.cropX(20);
       */

      Kinetic.Factory.addGetterSetter(Kinetic.Image, 'cropY', 0);
      /**
       * get/set crop y
       * @name cropY
       * @method
       * @memberof Kinetic.Image.prototype
       * @param {Number} y
       * @returns {Number}
       * @example
       * // get crop y<br>
       * var cropY = image.cropY();<br><br>
       *
       * // set crop y<br>
       * image.cropY(20);
       */

      Kinetic.Factory.addGetterSetter(Kinetic.Image, 'cropWidth', 0);
      /**
       * get/set crop width
       * @name cropWidth
       * @method
       * @memberof Kinetic.Image.prototype
       * @param {Number} width
       * @returns {Number}
       * @example
       * // get crop width<br>
       * var cropWidth = image.cropWidth();<br><br>
       *
       * // set crop width<br>
       * image.cropWidth(20);
       */

      Kinetic.Factory.addGetterSetter(Kinetic.Image, 'cropHeight', 0);
      /**
       * get/set crop height
       * @name cropHeight
       * @method
       * @memberof Kinetic.Image.prototype
       * @param {Number} height
       * @returns {Number}
       * @example
       * // get crop height<br>
       * var cropHeight = image.cropHeight();<br><br>
       *
       * // set crop height<br>
       * image.cropHeight(20);
       */

      Kinetic.Collection.mapMethods(Kinetic.Image);
  })();
  ;
  (function () {
      // constants
      var AUTO = 'auto',
        CANVAS = 'canvas',
        CENTER = 'center',
        CHANGE_KINETIC = 'Change.kinetic',
        CONTEXT_2D = '2d',
        DASH = '-',
        EMPTY_STRING = '',
        LEFT = 'left',
        TEXT = 'text',
        TEXT_UPPER = 'Text',
        MIDDLE = 'middle',
        NORMAL = 'normal',
        PX_SPACE = 'px ',
        SPACE = ' ',
        RIGHT = 'right',
        WORD = 'word',
        CHAR = 'char',
        NONE = 'none',
        ATTR_CHANGE_LIST = [
          'fontFamily',
          'fontSize',
          'fontStyle',
          'padding',
          'align',
          'lineHeight',
          'text',
          'width',
          'height',
          'wrap'
      ],
        // cached variables
        attrChangeListLen = ATTR_CHANGE_LIST.length,
        dummyContext = document.createElement(CANVAS).getContext(CONTEXT_2D);

      /**
       * Text constructor
       * @constructor
       * @memberof Kinetic
       * @augments Kinetic.Shape
       * @param {Object} config
       * @param {String} [config.fontFamily] default is Arial
       * @param {Number} [config.fontSize] in pixels.  Default is 12
       * @param {String} [config.fontStyle] can be normal, bold, or italic.  Default is normal
       * @param {String} config.text
       * @param {String} [config.align] can be left, center, or right
       * @param {Number} [config.padding]
       * @param {Number} [config.width] default is auto
       * @param {Number} [config.height] default is auto
       * @param {Number} [config.lineHeight] default is 1
       * @param {String} [config.wrap] can be word, char, or none. Default is word
       * @param {String} [config.fill] fill color
       * @param {Integer} [config.fillRed] set fill red component
       * @param {Integer} [config.fillGreen] set fill green component
       * @param {Integer} [config.fillBlue] set fill blue component
       * @param {Integer} [config.fillAlpha] set fill alpha component
       * @param {Image} [config.fillPatternImage] fill pattern image
       * @param {Number} [config.fillPatternX]
       * @param {Number} [config.fillPatternY]
       * @param {Object} [config.fillPatternOffset] object with x and y component
       * @param {Number} [config.fillPatternOffsetX]
       * @param {Number} [config.fillPatternOffsetY]
       * @param {Object} [config.fillPatternScale] object with x and y component
       * @param {Number} [config.fillPatternScaleX]
       * @param {Number} [config.fillPatternScaleY]
       * @param {Number} [config.fillPatternRotation]
       * @param {String} [config.fillPatternRepeat] can be "repeat", "repeat-x", "repeat-y", or "no-repeat".  The default is "no-repeat"
       * @param {Object} [config.fillLinearGradientStartPoint] object with x and y component
       * @param {Number} [config.fillLinearGradientStartPointX]
       * @param {Number} [config.fillLinearGradientStartPointY]
       * @param {Object} [config.fillLinearGradientEndPoint] object with x and y component
       * @param {Number} [config.fillLinearGradientEndPointX]
       * @param {Number} [config.fillLinearGradientEndPointY]
       * @param {Array} [config.fillLinearGradientColorStops] array of color stops
       * @param {Object} [config.fillRadialGradientStartPoint] object with x and y component
       * @param {Number} [config.fillRadialGradientStartPointX]
       * @param {Number} [config.fillRadialGradientStartPointY]
       * @param {Object} [config.fillRadialGradientEndPoint] object with x and y component
       * @param {Number} [config.fillRadialGradientEndPointX]
       * @param {Number} [config.fillRadialGradientEndPointY]
       * @param {Number} [config.fillRadialGradientStartRadius]
       * @param {Number} [config.fillRadialGradientEndRadius]
       * @param {Array} [config.fillRadialGradientColorStops] array of color stops
       * @param {Boolean} [config.fillEnabled] flag which enables or disables the fill.  The default value is true
       * @param {String} [config.fillPriority] can be color, linear-gradient, radial-graident, or pattern.  The default value is color.  The fillPriority property makes it really easy to toggle between different fill types.  For example, if you want to toggle between a fill color style and a fill pattern style, simply set the fill property and the fillPattern properties, and then use setFillPriority('color') to render the shape with a color fill, or use setFillPriority('pattern') to render the shape with the pattern fill configuration
       * @param {String} [config.stroke] stroke color
       * @param {Integer} [config.strokeRed] set stroke red component
       * @param {Integer} [config.strokeGreen] set stroke green component
       * @param {Integer} [config.strokeBlue] set stroke blue component
       * @param {Integer} [config.strokeAlpha] set stroke alpha component
       * @param {Number} [config.strokeWidth] stroke width
       * @param {Boolean} [config.strokeScaleEnabled] flag which enables or disables stroke scale.  The default is true
       * @param {Boolean} [config.strokeEnabled] flag which enables or disables the stroke.  The default value is true
       * @param {String} [config.lineJoin] can be miter, round, or bevel.  The default
       *  is miter
       * @param {String} [config.lineCap] can be butt, round, or sqare.  The default
       *  is butt
       * @param {String} [config.shadowColor]
       * @param {Integer} [config.shadowColorRed] set shadow color red component
       * @param {Integer} [config.shadowColorGreen] set shadow color green component
       * @param {Integer} [config.shadowColorBlue] set shadow color blue component
       * @param {Integer} [config.shadowColorAlpha] set shadow color alpha component
       * @param {Number} [config.shadowBlur]
       * @param {Object} [config.shadowOffset] object with x and y component
       * @param {Number} [config.shadowOffsetX]
       * @param {Number} [config.shadowOffsetY]
       * @param {Number} [config.shadowOpacity] shadow opacity.  Can be any real number
       *  between 0 and 1
       * @param {Boolean} [config.shadowEnabled] flag which enables or disables the shadow.  The default value is true
       * @param {Array} [config.dash]
       * @param {Boolean} [config.dashEnabled] flag which enables or disables the dashArray.  The default value is true
       * @param {Number} [config.x]
       * @param {Number} [config.y]
       * @param {Number} [config.width]
       * @param {Number} [config.height]
       * @param {Boolean} [config.visible]
       * @param {Boolean} [config.listening] whether or not the node is listening for events
       * @param {String} [config.id] unique id
       * @param {String} [config.name] non-unique name
       * @param {Number} [config.opacity] determines node opacity.  Can be any number between 0 and 1
       * @param {Object} [config.scale] set scale
       * @param {Number} [config.scaleX] set scale x
       * @param {Number} [config.scaleY] set scale y
       * @param {Number} [config.rotation] rotation in degrees
       * @param {Object} [config.offset] offset from center point and rotation point
       * @param {Number} [config.offsetX] set offset x
       * @param {Number} [config.offsetY] set offset y
       * @param {Boolean} [config.draggable] makes the node draggable.  When stages are draggable, you can drag and drop
       *  the entire stage by dragging any portion of the stage
       * @param {Function} [config.dragBoundFunc]
       * @example
       * var text = new Kinetic.Text({<br>
       *   x: 10,<br>
       *   y: 15,<br>
       *   text: 'Simple Text',<br>
       *   fontSize: 30,<br>
       *   fontFamily: 'Calibri',<br>
       *   fill: 'green'<br>
       * });
       */
      Kinetic.Text = function (config) {
          this.___init(config);
      };
      function _fillFunc (context) {
          context.fillText(this.partialText, 0, 0);
      }
      function _strokeFunc (context) {
          context.strokeText(this.partialText, 0, 0);
      }

      Kinetic.Text.prototype = {
          ___init: function (config) {
              var that = this;

              if (config.width === undefined) {
                  config.width = AUTO;
              }
              if (config.height === undefined) {
                  config.height = AUTO;
              }

              // call super constructor
              Kinetic.Shape.call(this, config);

              this._fillFunc = _fillFunc;
              this._strokeFunc = _strokeFunc;
              this.className = TEXT_UPPER;

              // update text data for certain attr changes
              for (var n = 0; n < attrChangeListLen; n++) {
                  this.on(ATTR_CHANGE_LIST[n] + CHANGE_KINETIC, that._setTextData);
              }

              this._setTextData();
              this.sceneFunc(this._sceneFunc);
              this.hitFunc(this._hitFunc);
          },
          _sceneFunc: function (context) {
              var p = this.getPadding(),
                textHeight = this.getTextHeight(),
                lineHeightPx = this.getLineHeight() * textHeight,
                textArr = this.textArr,
                textArrLen = textArr.length,
                totalWidth = this.getWidth(),
                n;

              context.setAttr('font', this._getContextFont());
              context.setAttr('textBaseline', MIDDLE);
              context.setAttr('textAlign', LEFT);
              context.save();
              context.translate(p, 0);
              context.translate(0, p + textHeight / 2);

              // draw text lines
              for (n = 0; n < textArrLen; n++) {
                  var obj = textArr[n],
                    text = obj.text,
                    width = obj.width;

                  // horizontal alignment
                  context.save();
                  if (this.getAlign() === RIGHT) {
                      context.translate(totalWidth - width - p * 2, 0);
                  }
                  else if (this.getAlign() === CENTER) {
                      context.translate((totalWidth - width - p * 2) / 2, 0);
                  }

                  this.partialText = text;
                  context.fillStrokeShape(this);
                  context.restore();
                  context.translate(0, lineHeightPx);
              }
              context.restore();
          },
          _hitFunc: function (context) {
              var width = this.getWidth(),
                height = this.getHeight();

              context.beginPath();
              context.rect(0, 0, width, height);
              context.closePath();
              context.fillStrokeShape(this);
          },
          setText: function (text) {
              var str = Kinetic.Util._isString(text) ? text : text.toString();
              this._setAttr(TEXT, str);
              return this;
          },
          /**
           * get width of text area, which includes padding
           * @method
           * @memberof Kinetic.Text.prototype
           * @returns {Number}
           */
          getWidth: function () {
              return this.attrs.width === AUTO ? this.getTextWidth() + this.getPadding() * 2 : this.attrs.width;
          },
          /**
           * get the height of the text area, which takes into account multi-line text, line heights, and padding
           * @method
           * @memberof Kinetic.Text.prototype
           * @returns {Number}
           */
          getHeight: function () {
              return this.attrs.height === AUTO ? (this.getTextHeight() * this.textArr.length * this.getLineHeight()) + this.getPadding() * 2 : this.attrs.height;
          },
          /**
           * get text width
           * @method
           * @memberof Kinetic.Text.prototype
           * @returns {Number}
           */
          getTextWidth: function () {
              return this.textWidth;
          },
          /**
           * get text height
           * @method
           * @memberof Kinetic.Text.prototype
           * @returns {Number}
           */
          getTextHeight: function () {
              return this.textHeight;
          },
          _getTextSize: function (text) {
              var _context = dummyContext,
                fontSize = this.getFontSize(),
                metrics;

              _context.save();
              _context.font = this._getContextFont();

              metrics = _context.measureText(text);
              _context.restore();
              return {
                  width: metrics.width,
                  height: parseInt(fontSize, 10)
              };
          },
          _getContextFont: function () {
              return this.getFontStyle() + SPACE + this.getFontSize() + PX_SPACE + this.getFontFamily();
          },
          _addTextLine: function (line, width) {
              return this.textArr.push({
                  text: line,
                  width: width
              });
          },
          _getTextWidth: function (text) {
              return dummyContext.measureText(text).width;
          },
          _setTextData: function () {
              var lines = this.getText().split('\n'),
                fontSize = +this.getFontSize(),
                textWidth = 0,
                lineHeightPx = this.getLineHeight() * fontSize,
                width = this.attrs.width,
                height = this.attrs.height,
                fixedWidth = width !== AUTO,
                fixedHeight = height !== AUTO,
                padding = this.getPadding(),
                maxWidth = width - padding * 2,
                maxHeightPx = height - padding * 2,
                currentHeightPx = 0,
                wrap = this.getWrap(),
                shouldWrap = wrap !== NONE,
                wrapAtWord = wrap !== CHAR && shouldWrap;

              this.textArr = [
              ];
              dummyContext.save();
              dummyContext.font = this.getFontStyle() + SPACE + fontSize + PX_SPACE + this.getFontFamily();
              for (var i = 0, max = lines.length; i < max; ++i) {
                  var line = lines[i],
                    lineWidth = this._getTextWidth(line);
                  if (fixedWidth && lineWidth > maxWidth) {
                      /*
                       * if width is fixed and line does not fit entirely
                       * break the line into multiple fitting lines
                       */
                      while (line.length > 0) {
                          /*
                           * use binary search to find the longest substring that
                           * that would fit in the specified width
                           */
                          var low = 0, high = line.length,
                            match = '', matchWidth = 0;
                          while (low < high) {
                              var mid = (low + high) >>> 1,
                                substr = line.slice(0, mid + 1),
                                substrWidth = this._getTextWidth(substr);
                              if (substrWidth <= maxWidth) {
                                  low = mid + 1;
                                  match = substr;
                                  matchWidth = substrWidth;
                              } else {
                                  high = mid;
                              }
                          }
                          /*
                           * 'low' is now the index of the substring end
                           * 'match' is the substring
                           * 'matchWidth' is the substring width in px
                           */
                          if (match) {
                              // a fitting substring was found
                              if (wrapAtWord) {
                                  // try to find a space or dash where wrapping could be done
                                  var wrapIndex = Math.max(match.lastIndexOf(SPACE),
                                    match.lastIndexOf(DASH)) + 1;
                                  if (wrapIndex > 0) {
                                      // re-cut the substring found at the space/dash position
                                      low = wrapIndex;
                                      match = match.slice(0, low);
                                      matchWidth = this._getTextWidth(match);
                                  }
                              }
                              this._addTextLine(match, matchWidth);
                              currentHeightPx += lineHeightPx;
                              if (!shouldWrap ||
                                (fixedHeight && currentHeightPx + lineHeightPx > maxHeightPx)) {
                                  /*
                                   * stop wrapping if wrapping is disabled or if adding
                                   * one more line would overflow the fixed height
                                   */
                                  break;
                              }
                              line = line.slice(low);
                              if (line.length > 0) {
                                  // Check if the remaining text would fit on one line
                                  lineWidth = this._getTextWidth(line);
                                  if (lineWidth <= maxWidth) {
                                      // if it does, add the line and break out of the loop
                                      this._addTextLine(line, lineWidth);
                                      currentHeightPx += lineHeightPx;
                                      break;
                                  }
                              }
                          } else {
                              // not even one character could fit in the element, abort
                              break;
                          }
                      }
                  } else {
                      // element width is automatically adjusted to max line width
                      this._addTextLine(line, lineWidth);
                      currentHeightPx += lineHeightPx;
                      textWidth = Math.max(textWidth, lineWidth);
                  }
                  // if element height is fixed, abort if adding one more line would overflow
                  if (fixedHeight && currentHeightPx + lineHeightPx > maxHeightPx) {
                      break;
                  }
              }
              dummyContext.restore();
              this.textHeight = fontSize;
              this.textWidth = textWidth;
          }
      };
      Kinetic.Util.extend(Kinetic.Text, Kinetic.Shape);

      // add getters setters
      Kinetic.Factory.addGetterSetter(Kinetic.Text, 'fontFamily', 'Arial');

      /**
       * get/set font family
       * @name fontFamily
       * @method
       * @memberof Kinetic.Text.prototype
       * @param {String} fontFamily
       * @returns {String}
       * @example
       * // get font family<br>
       * var fontFamily = text.fontFamily();<br><br><br>
       *
       * // set font family<br>
       * text.fontFamily('Arial');
       */

      Kinetic.Factory.addGetterSetter(Kinetic.Text, 'fontSize', 12);

      /**
       * get/set font size in pixels
       * @name fontSize
       * @method
       * @memberof Kinetic.Text.prototype
       * @param {Number} fontSize
       * @returns {Number}
       * @example
       * // get font size<br>
       * var fontSize = text.fontSize();<br><br>
       *
       * // set font size to 22px<br>
       * text.fontSize(22);
       */

      Kinetic.Factory.addGetterSetter(Kinetic.Text, 'fontStyle', NORMAL);

      /**
       * set font style.  Can be 'normal', 'italic', or 'bold'.  'normal' is the default.
       * @name fontStyle
       * @method
       * @memberof Kinetic.Text.prototype
       * @param {String} fontStyle
       * @returns {String}
       * @example
       * // get font style<br>
       * var fontStyle = text.fontStyle();<br><br>
       *
       * // set font style<br>
       * text.fontStyle('bold');
       */

      Kinetic.Factory.addGetterSetter(Kinetic.Text, 'padding', 0);

      /**
       * set padding
       * @name padding
       * @method
       * @memberof Kinetic.Text.prototype
       * @param {Number} padding
       * @returns {Number}
       * @example
       * // get padding<br>
       * var padding = text.padding();<br><br>
       *
       * // set padding to 10 pixels<br>
       * text.padding(10);
       */

      Kinetic.Factory.addGetterSetter(Kinetic.Text, 'align', LEFT);

      /**
       * get/set horizontal align of text.  Can be 'left', 'center', or 'right'
       * @name align
       * @method
       * @memberof Kinetic.Text.prototype
       * @param {String} align
       * @returns {String}
       * @example
       * // get text align<br>
       * var align = text.align();<br><br>
       *
       * // center text<br>
       * text.align('center');<br><br>
       *
       * // align text to right<br>
       * text.align('right');
       */

      Kinetic.Factory.addGetterSetter(Kinetic.Text, 'lineHeight', 1);

      /**
       * get/set line height.  The default is 1.
       * @name lineHeight
       * @method
       * @memberof Kinetic.Text.prototype
       * @param {Number} lineHeight
       * @returns {Number}
       * @example
       * // get line height<br>
       * var lineHeight = text.lineHeight();<br><br><br>
       *
       * // set the line height<br>
       * text.lineHeight(2);
       */

      Kinetic.Factory.addGetterSetter(Kinetic.Text, 'wrap', WORD);

      /**
       * get/set wrap.  Can be word, char, or none. Default is word.
       * @name wrap
       * @method
       * @memberof Kinetic.Text.prototype
       * @param {String} wrap
       * @returns {String}
       * @example
       * // get wrap<br>
       * var wrap = text.wrap();<br><br>
       *
       * // set wrap<br>
       * text.wrap('word');
       */

      Kinetic.Factory.addGetter(Kinetic.Text, 'text', EMPTY_STRING);
      Kinetic.Factory.addOverloadedGetterSetter(Kinetic.Text, 'text');

      /**
       * get/set text
       * @name getText
       * @method
       * @memberof Kinetic.Text.prototype
       * @param {String} text
       * @returns {String}
       * @example
       * // get text<br>
       * var text = text.text();<br><br>
       *
       * // set text<br>
       * text.text('Hello world!');
       */

      Kinetic.Collection.mapMethods(Kinetic.Text);
  })();
  ;
  (function () {
      /**
       * Line constructor.&nbsp; Lines are defined by an array of points and
       *  a tension
       * @constructor
       * @memberof Kinetic
       * @augments Kinetic.Shape
       * @param {Object} config
       * @param {Array} config.points
       * @param {Number} [config.tension] Higher values will result in a more curvy line.  A value of 0 will result in no interpolation.
       *   The default is 0
       * @param {Boolean} [config.closed] defines whether or not the line shape is closed, creating a polygon or blob
       * @param {String} [config.fill] fill color
       * @param {Integer} [config.fillRed] set fill red component
       * @param {Integer} [config.fillGreen] set fill green component
       * @param {Integer} [config.fillBlue] set fill blue component
       * @param {Integer} [config.fillAlpha] set fill alpha component
       * @param {Image} [config.fillPatternImage] fill pattern image
       * @param {Number} [config.fillPatternX]
       * @param {Number} [config.fillPatternY]
       * @param {Object} [config.fillPatternOffset] object with x and y component
       * @param {Number} [config.fillPatternOffsetX]
       * @param {Number} [config.fillPatternOffsetY]
       * @param {Object} [config.fillPatternScale] object with x and y component
       * @param {Number} [config.fillPatternScaleX]
       * @param {Number} [config.fillPatternScaleY]
       * @param {Number} [config.fillPatternRotation]
       * @param {String} [config.fillPatternRepeat] can be "repeat", "repeat-x", "repeat-y", or "no-repeat".  The default is "no-repeat"
       * @param {Object} [config.fillLinearGradientStartPoint] object with x and y component
       * @param {Number} [config.fillLinearGradientStartPointX]
       * @param {Number} [config.fillLinearGradientStartPointY]
       * @param {Object} [config.fillLinearGradientEndPoint] object with x and y component
       * @param {Number} [config.fillLinearGradientEndPointX]
       * @param {Number} [config.fillLinearGradientEndPointY]
       * @param {Array} [config.fillLinearGradientColorStops] array of color stops
       * @param {Object} [config.fillRadialGradientStartPoint] object with x and y component
       * @param {Number} [config.fillRadialGradientStartPointX]
       * @param {Number} [config.fillRadialGradientStartPointY]
       * @param {Object} [config.fillRadialGradientEndPoint] object with x and y component
       * @param {Number} [config.fillRadialGradientEndPointX]
       * @param {Number} [config.fillRadialGradientEndPointY]
       * @param {Number} [config.fillRadialGradientStartRadius]
       * @param {Number} [config.fillRadialGradientEndRadius]
       * @param {Array} [config.fillRadialGradientColorStops] array of color stops
       * @param {Boolean} [config.fillEnabled] flag which enables or disables the fill.  The default value is true
       * @param {String} [config.fillPriority] can be color, linear-gradient, radial-graident, or pattern.  The default value is color.  The fillPriority property makes it really easy to toggle between different fill types.  For example, if you want to toggle between a fill color style and a fill pattern style, simply set the fill property and the fillPattern properties, and then use setFillPriority('color') to render the shape with a color fill, or use setFillPriority('pattern') to render the shape with the pattern fill configuration
       * @param {String} [config.stroke] stroke color
       * @param {Integer} [config.strokeRed] set stroke red component
       * @param {Integer} [config.strokeGreen] set stroke green component
       * @param {Integer} [config.strokeBlue] set stroke blue component
       * @param {Integer} [config.strokeAlpha] set stroke alpha component
       * @param {Number} [config.strokeWidth] stroke width
       * @param {Boolean} [config.strokeScaleEnabled] flag which enables or disables stroke scale.  The default is true
       * @param {Boolean} [config.strokeEnabled] flag which enables or disables the stroke.  The default value is true
       * @param {String} [config.lineJoin] can be miter, round, or bevel.  The default
       *  is miter
       * @param {String} [config.lineCap] can be butt, round, or sqare.  The default
       *  is butt
       * @param {String} [config.shadowColor]
       * @param {Integer} [config.shadowColorRed] set shadow color red component
       * @param {Integer} [config.shadowColorGreen] set shadow color green component
       * @param {Integer} [config.shadowColorBlue] set shadow color blue component
       * @param {Integer} [config.shadowColorAlpha] set shadow color alpha component
       * @param {Number} [config.shadowBlur]
       * @param {Object} [config.shadowOffset] object with x and y component
       * @param {Number} [config.shadowOffsetX]
       * @param {Number} [config.shadowOffsetY]
       * @param {Number} [config.shadowOpacity] shadow opacity.  Can be any real number
       *  between 0 and 1
       * @param {Boolean} [config.shadowEnabled] flag which enables or disables the shadow.  The default value is true
       * @param {Array} [config.dash]
       * @param {Boolean} [config.dashEnabled] flag which enables or disables the dashArray.  The default value is true
       * @param {Number} [config.x]
       * @param {Number} [config.y]
       * @param {Number} [config.width]
       * @param {Number} [config.height]
       * @param {Boolean} [config.visible]
       * @param {Boolean} [config.listening] whether or not the node is listening for events
       * @param {String} [config.id] unique id
       * @param {String} [config.name] non-unique name
       * @param {Number} [config.opacity] determines node opacity.  Can be any number between 0 and 1
       * @param {Object} [config.scale] set scale
       * @param {Number} [config.scaleX] set scale x
       * @param {Number} [config.scaleY] set scale y
       * @param {Number} [config.rotation] rotation in degrees
       * @param {Object} [config.offset] offset from center point and rotation point
       * @param {Number} [config.offsetX] set offset x
       * @param {Number} [config.offsetY] set offset y
       * @param {Boolean} [config.draggable] makes the node draggable.  When stages are draggable, you can drag and drop
       *  the entire stage by dragging any portion of the stage
       * @param {Function} [config.dragBoundFunc]
       * @example
       * var line = new Kinetic.Line({<br>
       *   x: 100,<br>
       *   y: 50,<br>
       *   points: [73, 70, 340, 23, 450, 60, 500, 20],<br>
       *   stroke: 'red',<br>
       *   tension: 1<br>
       * });
       */
      Kinetic.Line = function (config) {
          this.___init(config);
      };

      Kinetic.Line.prototype = {
          ___init: function (config) {
              var that = this;
              // call super constructor
              Kinetic.Shape.call(this, config);
              this.className = 'Line';

              this.on('pointsChange.kinetic tensionChange.kinetic closedChange.kinetic', function () {
                  this._clearCache('tensionPoints');
              });

              this.sceneFunc(this._sceneFunc);
          },
          _sceneFunc: function (context) {
              var points = this.getPoints(),
                length = points.length,
                tension = this.getTension(),
                closed = this.getClosed(),
                tp, len, n, point;

              context.beginPath();
              context.moveTo(points[0], points[1]);

              // tension
              if (tension !== 0 && length > 4) {
                  tp = this.getTensionPoints();
                  len = tp.length;
                  n = closed ? 0 : 4;

                  if (!closed) {
                      context.quadraticCurveTo(tp[0], tp[1], tp[2], tp[3]);
                  }

                  while (n < len - 2) {
                      context.bezierCurveTo(tp[n++], tp[n++], tp[n++], tp[n++], tp[n++], tp[n++]);
                  }

                  if (!closed) {
                      context.quadraticCurveTo(tp[len - 2], tp[len - 1], points[length - 2], points[length - 1]);
                  }
              }
              // no tension
              else {
                  for (n = 2; n < length; n += 2) {
                      context.lineTo(points[n], points[n + 1]);
                  }
              }

              // closed e.g. polygons and blobs
              if (closed) {
                  context.closePath();
                  context.fillStrokeShape(this);
              }
              // open e.g. lines and splines
              else {
                  context.strokeShape(this);
              }
              ;
          },
          getTensionPoints: function () {
              return this._getCache('tensionPoints', this._getTensionPoints);
          },
          _getTensionPoints: function () {
              if (this.getClosed()) {
                  return this._getTensionPointsClosed();
              }
              else {
                  return Kinetic.Util._expandPoints(this.getPoints(), this.getTension());
              }
          },
          _getTensionPointsClosed: function () {
              var p = this.getPoints(),
                len = p.length,
                tension = this.getTension(),
                util = Kinetic.Util,
                firstControlPoints = util._getControlPoints(
                p[len - 2],
                p[len - 1],
                p[0],
                p[1],
                p[2],
                p[3],
                tension
                ),
                lastControlPoints = util._getControlPoints(
                p[len - 4],
                p[len - 3],
                p[len - 2],
                p[len - 1],
                p[0],
                p[1],
                tension
                ),
                middle = Kinetic.Util._expandPoints(p, tension),
                tp = [
                  firstControlPoints[2],
                  firstControlPoints[3]
              ]
                .concat(middle)
                .concat([
                  lastControlPoints[0],
                  lastControlPoints[1],
                  p[len - 2],
                  p[len - 1],
                  lastControlPoints[2],
                  lastControlPoints[3],
                  firstControlPoints[0],
                  firstControlPoints[1],
                  p[0],
                  p[1]
              ]);

              return tp;
          }
      };
      Kinetic.Util.extend(Kinetic.Line, Kinetic.Shape);

      // add getters setters
      Kinetic.Factory.addGetterSetter(Kinetic.Line, 'closed', false);

      /**
       * get/set closed flag.  The default is false
       * @name closed
       * @method
       * @memberof Kinetic.Line.prototype
       * @param {Boolean} closed
       * @returns {Boolean}
       * @example
       * // get closed flag<br>
       * var closed = line.closed();<br><br>
       *
       * // close the shape<br>
       * line.closed(true);<br><br>
       *
       * // open the shape<br>
       * line.closed(false);
       */

      Kinetic.Factory.addGetterSetter(Kinetic.Line, 'tension', 0);

      /**
       * get/set tension
       * @name tension
       * @method
       * @memberof Kinetic.Line.prototype
       * @param {Number} Higher values will result in a more curvy line.  A value of 0 will result in no interpolation.
       *   The default is 0
       * @returns {Number}
       * @example
       * // get tension<br>
       * var tension = line.tension();<br><br>
       *
       * // set tension<br>
       * line.tension(3);
       */

      Kinetic.Factory.addGetterSetter(Kinetic.Line, 'points');
      /**
       * get/set points array
       * @name points
       * @method
       * @memberof Kinetic.Line.prototype
       * @param {Array} points
       * @returns {Array}
       * @example
       * // get points<br>
       * var points = line.points();<br><br>
       *
       * // set points<br>
       * line.points([10, 20, 30, 40, 50, 60]);<br><br>
       *
       * // push a new point<br>
       * line.points(line.points().concat([70, 80]));
       */

      Kinetic.Collection.mapMethods(Kinetic.Line);
  })();
  ;
  (function () {
      /**
       * Sprite constructor
       * @constructor
       * @memberof Kinetic
       * @augments Kinetic.Shape
       * @param {Object} config
       * @param {String} config.animation animation key
       * @param {Object} config.animations animation map
       * @param {Integer} [config.frameIndex] animation frame index
       * @param {Image} config.image image object
       * @param {String} [config.fill] fill color
       * @param {Integer} [config.fillRed] set fill red component
       * @param {Integer} [config.fillGreen] set fill green component
       * @param {Integer} [config.fillBlue] set fill blue component
       * @param {Integer} [config.fillAlpha] set fill alpha component
       * @param {Image} [config.fillPatternImage] fill pattern image
       * @param {Number} [config.fillPatternX]
       * @param {Number} [config.fillPatternY]
       * @param {Object} [config.fillPatternOffset] object with x and y component
       * @param {Number} [config.fillPatternOffsetX]
       * @param {Number} [config.fillPatternOffsetY]
       * @param {Object} [config.fillPatternScale] object with x and y component
       * @param {Number} [config.fillPatternScaleX]
       * @param {Number} [config.fillPatternScaleY]
       * @param {Number} [config.fillPatternRotation]
       * @param {String} [config.fillPatternRepeat] can be "repeat", "repeat-x", "repeat-y", or "no-repeat".  The default is "no-repeat"
       * @param {Object} [config.fillLinearGradientStartPoint] object with x and y component
       * @param {Number} [config.fillLinearGradientStartPointX]
       * @param {Number} [config.fillLinearGradientStartPointY]
       * @param {Object} [config.fillLinearGradientEndPoint] object with x and y component
       * @param {Number} [config.fillLinearGradientEndPointX]
       * @param {Number} [config.fillLinearGradientEndPointY]
       * @param {Array} [config.fillLinearGradientColorStops] array of color stops
       * @param {Object} [config.fillRadialGradientStartPoint] object with x and y component
       * @param {Number} [config.fillRadialGradientStartPointX]
       * @param {Number} [config.fillRadialGradientStartPointY]
       * @param {Object} [config.fillRadialGradientEndPoint] object with x and y component
       * @param {Number} [config.fillRadialGradientEndPointX]
       * @param {Number} [config.fillRadialGradientEndPointY]
       * @param {Number} [config.fillRadialGradientStartRadius]
       * @param {Number} [config.fillRadialGradientEndRadius]
       * @param {Array} [config.fillRadialGradientColorStops] array of color stops
       * @param {Boolean} [config.fillEnabled] flag which enables or disables the fill.  The default value is true
       * @param {String} [config.fillPriority] can be color, linear-gradient, radial-graident, or pattern.  The default value is color.  The fillPriority property makes it really easy to toggle between different fill types.  For example, if you want to toggle between a fill color style and a fill pattern style, simply set the fill property and the fillPattern properties, and then use setFillPriority('color') to render the shape with a color fill, or use setFillPriority('pattern') to render the shape with the pattern fill configuration
       * @param {String} [config.stroke] stroke color
       * @param {Integer} [config.strokeRed] set stroke red component
       * @param {Integer} [config.strokeGreen] set stroke green component
       * @param {Integer} [config.strokeBlue] set stroke blue component
       * @param {Integer} [config.strokeAlpha] set stroke alpha component
       * @param {Number} [config.strokeWidth] stroke width
       * @param {Boolean} [config.strokeScaleEnabled] flag which enables or disables stroke scale.  The default is true
       * @param {Boolean} [config.strokeEnabled] flag which enables or disables the stroke.  The default value is true
       * @param {String} [config.lineJoin] can be miter, round, or bevel.  The default
       *  is miter
       * @param {String} [config.lineCap] can be butt, round, or sqare.  The default
       *  is butt
       * @param {String} [config.shadowColor]
       * @param {Integer} [config.shadowColorRed] set shadow color red component
       * @param {Integer} [config.shadowColorGreen] set shadow color green component
       * @param {Integer} [config.shadowColorBlue] set shadow color blue component
       * @param {Integer} [config.shadowColorAlpha] set shadow color alpha component
       * @param {Number} [config.shadowBlur]
       * @param {Object} [config.shadowOffset] object with x and y component
       * @param {Number} [config.shadowOffsetX]
       * @param {Number} [config.shadowOffsetY]
       * @param {Number} [config.shadowOpacity] shadow opacity.  Can be any real number
       *  between 0 and 1
       * @param {Boolean} [config.shadowEnabled] flag which enables or disables the shadow.  The default value is true
       * @param {Array} [config.dash]
       * @param {Boolean} [config.dashEnabled] flag which enables or disables the dashArray.  The default value is true
       * @param {Number} [config.x]
       * @param {Number} [config.y]
       * @param {Number} [config.width]
       * @param {Number} [config.height]
       * @param {Boolean} [config.visible]
       * @param {Boolean} [config.listening] whether or not the node is listening for events
       * @param {String} [config.id] unique id
       * @param {String} [config.name] non-unique name
       * @param {Number} [config.opacity] determines node opacity.  Can be any number between 0 and 1
       * @param {Object} [config.scale] set scale
       * @param {Number} [config.scaleX] set scale x
       * @param {Number} [config.scaleY] set scale y
       * @param {Number} [config.rotation] rotation in degrees
       * @param {Object} [config.offset] offset from center point and rotation point
       * @param {Number} [config.offsetX] set offset x
       * @param {Number} [config.offsetY] set offset y
       * @param {Boolean} [config.draggable] makes the node draggable.  When stages are draggable, you can drag and drop
       *  the entire stage by dragging any portion of the stage
       * @param {Function} [config.dragBoundFunc]
       * @example
       * var imageObj = new Image();<br>
       * imageObj.onload = function() {<br>
       *   var sprite = new Kinetic.Sprite({<br>
       *     x: 200,<br>
       *     y: 100,<br>
       *     image: imageObj,<br>
       *     animation: 'standing',<br>
       *     animations: {<br>
       *       standing: [<br>
       *         // x, y, width, height (6 frames)<br>
       *         0, 0, 49, 109,<br>
       *         52, 0, 49, 109,<br>
       *         105, 0, 49, 109,<br>
       *         158, 0, 49, 109,<br>
       *         210, 0, 49, 109,<br>
       *         262, 0, 49, 109<br>
       *       ],<br>
       *       kicking: [<br>
       *         // x, y, width, height (6 frames)<br>
       *         0, 109, 45, 98,<br>
       *         45, 109, 45, 98,<br>
       *         95, 109, 63, 98,<br>
       *         156, 109, 70, 98,<br>
       *         229, 109, 60, 98,<br>
       *         287, 109, 41, 98<br>
       *       ]<br>
       *     },<br>
       *     frameRate: 7,<br>
       *     frameIndex: 0<br>
       *   });<br>
       * };<br>
       * imageObj.src = '/path/to/image.jpg'
       */
      Kinetic.Sprite = function (config) {
          this.___init(config);
      };

      Kinetic.Sprite.prototype = {
          ___init: function (config) {
              // call super constructor
              Kinetic.Shape.call(this, config);
              this.className = 'Sprite';

              this.anim = new Kinetic.Animation();
              this.on('animationChange.kinetic', function () {
                  // reset index when animation changes
                  this.frameIndex(0);
              });

              this.sceneFunc(this._sceneFunc);
              this.hitFunc(this._hitFunc);
          },
          _sceneFunc: function (context) {
              var anim = this.getAnimation(),
                index = this.frameIndex(),
                ix4 = index * 4,
                set = this.getAnimations()[anim],
                x = set[ix4 + 0],
                y = set[ix4 + 1],
                width = set[ix4 + 2],
                height = set[ix4 + 3],
                image = this.getImage();

              if (image) {
                  context.drawImage(image, x, y, width, height, 0, 0, width, height);
              }
          },
          _hitFunc: function (context) {
              var anim = this.getAnimation(),
                index = this.frameIndex(),
                ix4 = index * 4,
                set = this.getAnimations()[anim],
                width = set[ix4 + 2],
                height = set[ix4 + 3];

              context.beginPath();
              context.rect(0, 0, width, height);
              context.closePath();
              context.fillShape(this);
          },
          _useBufferCanvas: function () {
              return (this.hasShadow() || this.getAbsoluteOpacity() !== 1) && this.hasStroke();
          },
          /**
           * start sprite animation
           * @method
           * @memberof Kinetic.Sprite.prototype
           */
          start: function () {
              var that = this;
              var layer = this.getLayer();

              /*
               * animation object has no executable function because
               *  the updates are done with a fixed FPS with the setInterval
               *  below.  The anim object only needs the layer reference for
               *  redraw
               */
              this.anim.setLayers(layer);

              this.interval = setInterval(function () {
                  that._updateIndex();
              }, 1000 / this.getFrameRate());

              this.anim.start();
          },
          /**
           * stop sprite animation
           * @method
           * @memberof Kinetic.Sprite.prototype
           */
          stop: function () {
              this.anim.stop();
              clearInterval(this.interval);
          },
          _updateIndex: function () {
              var index = this.frameIndex(),
                animation = this.getAnimation(),
                animations = this.getAnimations(),
                anim = animations[animation],
                len = anim.length / 4;

              if (index < len - 1) {
                  this.frameIndex(index + 1);
              }
              else {
                  this.frameIndex(0);
              }
          }
      };
      Kinetic.Util.extend(Kinetic.Sprite, Kinetic.Shape);

      // add getters setters
      Kinetic.Factory.addGetterSetter(Kinetic.Sprite, 'animation');

      /**
       * get/set animation key
       * @name animation
       * @method
       * @memberof Kinetic.Sprite.prototype
       * @param {String} anim animation key
       * @returns {String}
       * @example
       * // get animation key<br>
       * var animation = sprite.animation();<br><br>
       *
       * // set animation key<br>
       * sprite.animation('kicking');
       */

      Kinetic.Factory.addGetterSetter(Kinetic.Sprite, 'animations');

      /**
       * get/set animations map
       * @name animations
       * @method
       * @memberof Kinetic.Sprite.prototype
       * @param {Object} animations
       * @returns {Object}
       * @example
       * // get animations map<br>
       * var animations = sprite.animations();<br><br>
       *
       * // set animations map<br>
       * sprite.animations({<br>
       *   standing: [<br>
       *     // x, y, width, height (6 frames)<br>
       *     0, 0, 49, 109,<br>
       *     52, 0, 49, 109,<br>
       *     105, 0, 49, 109,<br>
       *     158, 0, 49, 109,<br>
       *     210, 0, 49, 109,<br>
       *     262, 0, 49, 109<br>
       *   ],<br>
       *   kicking: [<br>
       *     // x, y, width, height (6 frames)<br>
       *     0, 109, 45, 98,<br>
       *     45, 109, 45, 98,<br>
       *     95, 109, 63, 98,<br>
       *     156, 109, 70, 98,<br>
       *     229, 109, 60, 98,<br>
       *     287, 109, 41, 98<br>
       *   ]<br>
       * });
       */

      Kinetic.Factory.addGetterSetter(Kinetic.Sprite, 'image');

      /**
       * get/set image
       * @name image
       * @method
       * @memberof Kinetic.Sprite.prototype
       * @param {Image} image
       * @returns {Image}
       * @example
       * // get image
       * var image = sprite.image();<br><br>
       *
       * // set image<br>
       * sprite.image(imageObj);
       */

      Kinetic.Factory.addGetterSetter(Kinetic.Sprite, 'frameIndex', 0);

      /**
       * set/set animation frame index
       * @name frameIndex
       * @method
       * @memberof Kinetic.Sprite.prototype
       * @param {Integer} frameIndex
       * @returns {Integer}
       * @example
       * // get animation frame index<br>
       * var frameIndex = sprite.frameIndex();<br><br>
       *
       * // set animation frame index<br>
       * sprite.frameIndex(3);
       */

      Kinetic.Factory.addGetterSetter(Kinetic.Sprite, 'frameRate', 17);

      /**
       * get/set frame rate in frames per second.  Increase this number to make the sprite
       *  animation run faster, and decrease the number to make the sprite animation run slower
       *  The default is 17 frames per second
       * @name frameRate
       * @method
       * @memberof Kinetic.Sprite.prototype
       * @param {Integer} frameRate
       * @returns {Integer}
       * @example
       * // get frame rate<br>
       * var frameRate = sprite.frameRate();<br><br>
       *
       * // set frame rate to 2 frames per second<br>
       * sprite.frameRate(2);
       */

      Kinetic.Factory.backCompat(Kinetic.Sprite, {
          index: 'frameIndex',
          getIndex: 'getFrameIndex',
          setIndex: 'setFrameIndex'
      });

      Kinetic.Collection.mapMethods(Kinetic.Sprite);
  })();
  ;
  (function () {
      /**
       * Path constructor.
       * @author Jason Follas
       * @constructor
       * @memberof Kinetic
       * @augments Kinetic.Shape
       * @param {Object} config
       * @param {String} config.data SVG data string
       * @param {String} [config.fill] fill color
       * @param {Integer} [config.fillRed] set fill red component
       * @param {Integer} [config.fillGreen] set fill green component
       * @param {Integer} [config.fillBlue] set fill blue component
       * @param {Integer} [config.fillAlpha] set fill alpha component
       * @param {Image} [config.fillPatternImage] fill pattern image
       * @param {Number} [config.fillPatternX]
       * @param {Number} [config.fillPatternY]
       * @param {Object} [config.fillPatternOffset] object with x and y component
       * @param {Number} [config.fillPatternOffsetX]
       * @param {Number} [config.fillPatternOffsetY]
       * @param {Object} [config.fillPatternScale] object with x and y component
       * @param {Number} [config.fillPatternScaleX]
       * @param {Number} [config.fillPatternScaleY]
       * @param {Number} [config.fillPatternRotation]
       * @param {String} [config.fillPatternRepeat] can be "repeat", "repeat-x", "repeat-y", or "no-repeat".  The default is "no-repeat"
       * @param {Object} [config.fillLinearGradientStartPoint] object with x and y component
       * @param {Number} [config.fillLinearGradientStartPointX]
       * @param {Number} [config.fillLinearGradientStartPointY]
       * @param {Object} [config.fillLinearGradientEndPoint] object with x and y component
       * @param {Number} [config.fillLinearGradientEndPointX]
       * @param {Number} [config.fillLinearGradientEndPointY]
       * @param {Array} [config.fillLinearGradientColorStops] array of color stops
       * @param {Object} [config.fillRadialGradientStartPoint] object with x and y component
       * @param {Number} [config.fillRadialGradientStartPointX]
       * @param {Number} [config.fillRadialGradientStartPointY]
       * @param {Object} [config.fillRadialGradientEndPoint] object with x and y component
       * @param {Number} [config.fillRadialGradientEndPointX]
       * @param {Number} [config.fillRadialGradientEndPointY]
       * @param {Number} [config.fillRadialGradientStartRadius]
       * @param {Number} [config.fillRadialGradientEndRadius]
       * @param {Array} [config.fillRadialGradientColorStops] array of color stops
       * @param {Boolean} [config.fillEnabled] flag which enables or disables the fill.  The default value is true
       * @param {String} [config.fillPriority] can be color, linear-gradient, radial-graident, or pattern.  The default value is color.  The fillPriority property makes it really easy to toggle between different fill types.  For example, if you want to toggle between a fill color style and a fill pattern style, simply set the fill property and the fillPattern properties, and then use setFillPriority('color') to render the shape with a color fill, or use setFillPriority('pattern') to render the shape with the pattern fill configuration
       * @param {String} [config.stroke] stroke color
       * @param {Integer} [config.strokeRed] set stroke red component
       * @param {Integer} [config.strokeGreen] set stroke green component
       * @param {Integer} [config.strokeBlue] set stroke blue component
       * @param {Integer} [config.strokeAlpha] set stroke alpha component
       * @param {Number} [config.strokeWidth] stroke width
       * @param {Boolean} [config.strokeScaleEnabled] flag which enables or disables stroke scale.  The default is true
       * @param {Boolean} [config.strokeEnabled] flag which enables or disables the stroke.  The default value is true
       * @param {String} [config.lineJoin] can be miter, round, or bevel.  The default
       *  is miter
       * @param {String} [config.lineCap] can be butt, round, or sqare.  The default
       *  is butt
       * @param {String} [config.shadowColor]
       * @param {Integer} [config.shadowColorRed] set shadow color red component
       * @param {Integer} [config.shadowColorGreen] set shadow color green component
       * @param {Integer} [config.shadowColorBlue] set shadow color blue component
       * @param {Integer} [config.shadowColorAlpha] set shadow color alpha component
       * @param {Number} [config.shadowBlur]
       * @param {Object} [config.shadowOffset] object with x and y component
       * @param {Number} [config.shadowOffsetX]
       * @param {Number} [config.shadowOffsetY]
       * @param {Number} [config.shadowOpacity] shadow opacity.  Can be any real number
       *  between 0 and 1
       * @param {Boolean} [config.shadowEnabled] flag which enables or disables the shadow.  The default value is true
       * @param {Array} [config.dash]
       * @param {Boolean} [config.dashEnabled] flag which enables or disables the dashArray.  The default value is true
       * @param {Number} [config.x]
       * @param {Number} [config.y]
       * @param {Number} [config.width]
       * @param {Number} [config.height]
       * @param {Boolean} [config.visible]
       * @param {Boolean} [config.listening] whether or not the node is listening for events
       * @param {String} [config.id] unique id
       * @param {String} [config.name] non-unique name
       * @param {Number} [config.opacity] determines node opacity.  Can be any number between 0 and 1
       * @param {Object} [config.scale] set scale
       * @param {Number} [config.scaleX] set scale x
       * @param {Number} [config.scaleY] set scale y
       * @param {Number} [config.rotation] rotation in degrees
       * @param {Object} [config.offset] offset from center point and rotation point
       * @param {Number} [config.offsetX] set offset x
       * @param {Number} [config.offsetY] set offset y
       * @param {Boolean} [config.draggable] makes the node draggable.  When stages are draggable, you can drag and drop
       *  the entire stage by dragging any portion of the stage
       * @param {Function} [config.dragBoundFunc]
       * @example
       * var path = new Kinetic.Path({<br>
       *   x: 240,<br>
       *   y: 40,<br>
       *   data: 'M12.582,9.551C3.251,16.237,0.921,29.021,7.08,38.564l-2.36,1.689l4.893,2.262l4.893,2.262l-0.568-5.36l-0.567-5.359l-2.365,1.694c-4.657-7.375-2.83-17.185,4.352-22.33c7.451-5.338,17.817-3.625,23.156,3.824c5.337,7.449,3.625,17.813-3.821,23.152l2.857,3.988c9.617-6.893,11.827-20.277,4.935-29.896C35.591,4.87,22.204,2.658,12.582,9.551z',<br>
       *   fill: 'green',<br>
       *   scale: 2<br>
       * });
       */
      Kinetic.Path = function (config) {
          this.___init(config);
      };

      Kinetic.Path.prototype = {
          ___init: function (config) {
              this.dataArray = [
              ];
              var that = this;

              // call super constructor
              Kinetic.Shape.call(this, config);
              this.className = 'Path';

              this.dataArray = Kinetic.Path.parsePathData(this.getData());
              this.on('dataChange.kinetic', function () {
                  that.dataArray = Kinetic.Path.parsePathData(this.getData());
              });

              this.sceneFunc(this._sceneFunc);
          },
          _sceneFunc: function (context) {
              var ca = this.dataArray,
                closedPath = false;

              // context position
              context.beginPath();
              for (var n = 0; n < ca.length; n++) {
                  var c = ca[n].command;
                  var p = ca[n].points;
                  switch (c) {
                      case 'L':
                          context.lineTo(p[0], p[1]);
                          break;
                      case 'M':
                          context.moveTo(p[0], p[1]);
                          break;
                      case 'C':
                          context.bezierCurveTo(p[0], p[1], p[2], p[3], p[4], p[5]);
                          break;
                      case 'Q':
                          context.quadraticCurveTo(p[0], p[1], p[2], p[3]);
                          break;
                      case 'A':
                          var cx = p[0], cy = p[1], rx = p[2], ry = p[3], theta = p[4], dTheta = p[5], psi = p[6], fs = p[7];

                          var r = (rx > ry) ? rx : ry;
                          var scaleX = (rx > ry) ? 1 : rx / ry;
                          var scaleY = (rx > ry) ? ry / rx : 1;

                          context.translate(cx, cy);
                          context.rotate(psi);
                          context.scale(scaleX, scaleY);
                          context.arc(0, 0, r, theta, theta + dTheta, 1 - fs);
                          context.scale(1 / scaleX, 1 / scaleY);
                          context.rotate(-psi);
                          context.translate(-cx, -cy);

                          break;
                      case 'z':
                          context.closePath();
                          closedPath = true;
                          break;
                  }
              }

              if (closedPath) {
                  context.fillStrokeShape(this);
              }
              else {
                  context.strokeShape(this);
              }
          }
      };
      Kinetic.Util.extend(Kinetic.Path, Kinetic.Shape);

      Kinetic.Path.getLineLength = function (x1, y1, x2, y2) {
          return Math.sqrt((x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1));
      };
      Kinetic.Path.getPointOnLine = function (dist, P1x, P1y, P2x, P2y, fromX, fromY) {
          if (fromX === undefined) {
              fromX = P1x;
          }
          if (fromY === undefined) {
              fromY = P1y;
          }

          var m = (P2y - P1y) / ((P2x - P1x) + 0.00000001);
          var run = Math.sqrt(dist * dist / (1 + m * m));
          if (P2x < P1x)
              run *= -1;
          var rise = m * run;
          var pt;

          if (P2x === P1x) { // vertical line
              pt = {
                  x: fromX,
                  y: fromY + rise
              };
          } else if ((fromY - P1y) / ((fromX - P1x) + 0.00000001) === m) {
              pt = {
                  x: fromX + run,
                  y: fromY + rise
              };
          }
          else {
              var ix, iy;

              var len = this.getLineLength(P1x, P1y, P2x, P2y);
              if (len < 0.00000001) {
                  return undefined;
              }
              var u = (((fromX - P1x) * (P2x - P1x)) + ((fromY - P1y) * (P2y - P1y)));
              u = u / (len * len);
              ix = P1x + u * (P2x - P1x);
              iy = P1y + u * (P2y - P1y);

              var pRise = this.getLineLength(fromX, fromY, ix, iy);
              var pRun = Math.sqrt(dist * dist - pRise * pRise);
              run = Math.sqrt(pRun * pRun / (1 + m * m));
              if (P2x < P1x)
                  run *= -1;
              rise = m * run;
              pt = {
                  x: ix + run,
                  y: iy + rise
              };
          }

          return pt;
      };

      Kinetic.Path.getPointOnCubicBezier = function (pct, P1x, P1y, P2x, P2y, P3x, P3y, P4x, P4y) {
          function CB1 (t) {
              return t * t * t;
          }
          function CB2 (t) {
              return 3 * t * t * (1 - t);
          }
          function CB3 (t) {
              return 3 * t * (1 - t) * (1 - t);
          }
          function CB4 (t) {
              return (1 - t) * (1 - t) * (1 - t);
          }
          var x = P4x * CB1(pct) + P3x * CB2(pct) + P2x * CB3(pct) + P1x * CB4(pct);
          var y = P4y * CB1(pct) + P3y * CB2(pct) + P2y * CB3(pct) + P1y * CB4(pct);

          return {
              x: x,
              y: y
          };
      };
      Kinetic.Path.getPointOnQuadraticBezier = function (pct, P1x, P1y, P2x, P2y, P3x, P3y) {
          function QB1 (t) {
              return t * t;
          }
          function QB2 (t) {
              return 2 * t * (1 - t);
          }
          function QB3 (t) {
              return (1 - t) * (1 - t);
          }
          var x = P3x * QB1(pct) + P2x * QB2(pct) + P1x * QB3(pct);
          var y = P3y * QB1(pct) + P2y * QB2(pct) + P1y * QB3(pct);

          return {
              x: x,
              y: y
          };
      };
      Kinetic.Path.getPointOnEllipticalArc = function (cx, cy, rx, ry, theta, psi) {
          var cosPsi = Math.cos(psi), sinPsi = Math.sin(psi);
          var pt = {
              x: rx * Math.cos(theta),
              y: ry * Math.sin(theta)
          };
          return {
              x: cx + (pt.x * cosPsi - pt.y * sinPsi),
              y: cy + (pt.x * sinPsi + pt.y * cosPsi)
          };
      };
      /*
       * get parsed data array from the data
       *  string.  V, v, H, h, and l data are converted to
       *  L data for the purpose of high performance Path
       *  rendering
       */
      Kinetic.Path.parsePathData = function (data) {
          // Path Data Segment must begin with a moveTo
          //m (x y)+  Relative moveTo (subsequent points are treated as lineTo)
          //M (x y)+  Absolute moveTo (subsequent points are treated as lineTo)
          //l (x y)+  Relative lineTo
          //L (x y)+  Absolute LineTo
          //h (x)+    Relative horizontal lineTo
          //H (x)+    Absolute horizontal lineTo
          //v (y)+    Relative vertical lineTo
          //V (y)+    Absolute vertical lineTo
          //z (closepath)
          //Z (closepath)
          //c (x1 y1 x2 y2 x y)+ Relative Bezier curve
          //C (x1 y1 x2 y2 x y)+ Absolute Bezier curve
          //q (x1 y1 x y)+       Relative Quadratic Bezier
          //Q (x1 y1 x y)+       Absolute Quadratic Bezier
          //t (x y)+    Shorthand/Smooth Relative Quadratic Bezier
          //T (x y)+    Shorthand/Smooth Absolute Quadratic Bezier
          //s (x2 y2 x y)+       Shorthand/Smooth Relative Bezier curve
          //S (x2 y2 x y)+       Shorthand/Smooth Absolute Bezier curve
          //a (rx ry x-axis-rotation large-arc-flag sweep-flag x y)+     Relative Elliptical Arc
          //A (rx ry x-axis-rotation large-arc-flag sweep-flag x y)+  Absolute Elliptical Arc

          // return early if data is not defined
          if (!data) {
              return [
              ];
          }

          // command string
          var cs = data;

          // command chars
          var cc = [
              'm',
              'M',
              'l',
              'L',
              'v',
              'V',
              'h',
              'H',
              'z',
              'Z',
              'c',
              'C',
              'q',
              'Q',
              't',
              'T',
              's',
              'S',
              'a',
              'A'
          ];
          // convert white spaces to commas
          cs = cs.replace(new RegExp(' ', 'g'), ',');
          // create pipes so that we can split the data
          for (var n = 0; n < cc.length; n++) {
              cs = cs.replace(new RegExp(cc[n], 'g'), '|' + cc[n]);
          }
          // create array
          var arr = cs.split('|');
          var ca = [
          ];
          // init context point
          var cpx = 0;
          var cpy = 0;
          for (n = 1; n < arr.length; n++) {
              var str = arr[n];
              var c = str.charAt(0);
              str = str.slice(1);
              // remove ,- for consistency
              str = str.replace(new RegExp(',-', 'g'), '-');
              // add commas so that it's easy to split
              str = str.replace(new RegExp('-', 'g'), ',-');
              str = str.replace(new RegExp('e,-', 'g'), 'e-');
              var p = str.split(',');
              if (p.length > 0 && p[0] === '') {
                  p.shift();
              }
              // convert strings to floats
              for (var i = 0; i < p.length; i++) {
                  p[i] = parseFloat(p[i]);
              }
              while (p.length > 0) {
                  if (isNaN(p[0]))// case for a trailing comma before next command
                      break;

                  var cmd = null;
                  var points = [
                  ];
                  var startX = cpx, startY = cpy;
                  // Move var from within the switch to up here (jshint)
                  var prevCmd, ctlPtx, ctlPty;     // Ss, Tt
                  var rx, ry, psi, fa, fs, x1, y1; // Aa


                  // convert l, H, h, V, and v to L
                  switch (c) {

                      // Note: Keep the lineTo's above the moveTo's in this switch
                      case 'l':
                          cpx += p.shift();
                          cpy += p.shift();
                          cmd = 'L';
                          points.push(cpx, cpy);
                          break;
                      case 'L':
                          cpx = p.shift();
                          cpy = p.shift();
                          points.push(cpx, cpy);
                          break;

                          // Note: lineTo handlers need to be above this point
                      case 'm':
                          var dx = p.shift();
                          var dy = p.shift();
                          cpx += dx;
                          cpy += dy;
                          cmd = 'M';
                          // After closing the path move the current position
                          // to the the first point of the path (if any).
                          if (ca.length > 2 && ca[ca.length - 1].command === 'z') {
                              for (var idx = ca.length - 2; idx >= 0; idx--) {
                                  if (ca[idx].command === 'M') {
                                      cpx = ca[idx].points[0] + dx;
                                      cpy = ca[idx].points[1] + dy;
                                      break;
                                  }
                              }
                          }
                          points.push(cpx, cpy);
                          c = 'l';
                          // subsequent points are treated as relative lineTo
                          break;
                      case 'M':
                          cpx = p.shift();
                          cpy = p.shift();
                          cmd = 'M';
                          points.push(cpx, cpy);
                          c = 'L';
                          // subsequent points are treated as absolute lineTo
                          break;

                      case 'h':
                          cpx += p.shift();
                          cmd = 'L';
                          points.push(cpx, cpy);
                          break;
                      case 'H':
                          cpx = p.shift();
                          cmd = 'L';
                          points.push(cpx, cpy);
                          break;
                      case 'v':
                          cpy += p.shift();
                          cmd = 'L';
                          points.push(cpx, cpy);
                          break;
                      case 'V':
                          cpy = p.shift();
                          cmd = 'L';
                          points.push(cpx, cpy);
                          break;
                      case 'C':
                          points.push(p.shift(), p.shift(), p.shift(), p.shift());
                          cpx = p.shift();
                          cpy = p.shift();
                          points.push(cpx, cpy);
                          break;
                      case 'c':
                          points.push(cpx + p.shift(), cpy + p.shift(), cpx + p.shift(), cpy + p.shift());
                          cpx += p.shift();
                          cpy += p.shift();
                          cmd = 'C';
                          points.push(cpx, cpy);
                          break;
                      case 'S':
                          ctlPtx = cpx, ctlPty = cpy;
                          prevCmd = ca[ca.length - 1];
                          if (prevCmd.command === 'C') {
                              ctlPtx = cpx + (cpx - prevCmd.points[2]);
                              ctlPty = cpy + (cpy - prevCmd.points[3]);
                          }
                          points.push(ctlPtx, ctlPty, p.shift(), p.shift());
                          cpx = p.shift();
                          cpy = p.shift();
                          cmd = 'C';
                          points.push(cpx, cpy);
                          break;
                      case 's':
                          ctlPtx = cpx, ctlPty = cpy;
                          prevCmd = ca[ca.length - 1];
                          if (prevCmd.command === 'C') {
                              ctlPtx = cpx + (cpx - prevCmd.points[2]);
                              ctlPty = cpy + (cpy - prevCmd.points[3]);
                          }
                          points.push(ctlPtx, ctlPty, cpx + p.shift(), cpy + p.shift());
                          cpx += p.shift();
                          cpy += p.shift();
                          cmd = 'C';
                          points.push(cpx, cpy);
                          break;
                      case 'Q':
                          points.push(p.shift(), p.shift());
                          cpx = p.shift();
                          cpy = p.shift();
                          points.push(cpx, cpy);
                          break;
                      case 'q':
                          points.push(cpx + p.shift(), cpy + p.shift());
                          cpx += p.shift();
                          cpy += p.shift();
                          cmd = 'Q';
                          points.push(cpx, cpy);
                          break;
                      case 'T':
                          ctlPtx = cpx, ctlPty = cpy;
                          prevCmd = ca[ca.length - 1];
                          if (prevCmd.command === 'Q') {
                              ctlPtx = cpx + (cpx - prevCmd.points[0]);
                              ctlPty = cpy + (cpy - prevCmd.points[1]);
                          }
                          cpx = p.shift();
                          cpy = p.shift();
                          cmd = 'Q';
                          points.push(ctlPtx, ctlPty, cpx, cpy);
                          break;
                      case 't':
                          ctlPtx = cpx, ctlPty = cpy;
                          prevCmd = ca[ca.length - 1];
                          if (prevCmd.command === 'Q') {
                              ctlPtx = cpx + (cpx - prevCmd.points[0]);
                              ctlPty = cpy + (cpy - prevCmd.points[1]);
                          }
                          cpx += p.shift();
                          cpy += p.shift();
                          cmd = 'Q';
                          points.push(ctlPtx, ctlPty, cpx, cpy);
                          break;
                      case 'A':
                          rx = p.shift(), ry = p.shift(), psi = p.shift(), fa = p.shift(), fs = p.shift();
                          x1 = cpx, y1 = cpy;
                          cpx = p.shift(), cpy = p.shift();
                          cmd = 'A';
                          points = this.convertEndpointToCenterParameterization(x1, y1, cpx, cpy, fa, fs, rx, ry, psi);
                          break;
                      case 'a':
                          rx = p.shift(), ry = p.shift(), psi = p.shift(), fa = p.shift(), fs = p.shift();
                          x1 = cpx, y1 = cpy;
                          cpx += p.shift(), cpy += p.shift();
                          cmd = 'A';
                          points = this.convertEndpointToCenterParameterization(x1, y1, cpx, cpy, fa, fs, rx, ry, psi);
                          break;
                  }

                  ca.push({
                      command: cmd || c,
                      points: points,
                      start: {
                          x: startX,
                          y: startY
                      },
                      pathLength: this.calcLength(startX, startY, cmd || c, points)
                  });
              }

              if (c === 'z' || c === 'Z') {
                  ca.push({
                      command: 'z',
                      points: [
                      ],
                      start: undefined,
                      pathLength: 0
                  });
              }
          }

          return ca;
      };
      Kinetic.Path.calcLength = function (x, y, cmd, points) {
          var len, p1, p2;
          var path = Kinetic.Path;

          switch (cmd) {
              case 'L':
                  return path.getLineLength(x, y, points[0], points[1]);
              case 'C':
                  // Approximates by breaking curve into 100 line segments
                  len = 0.0;
                  p1 = path.getPointOnCubicBezier(0, x, y, points[0], points[1], points[2], points[3], points[4], points[5]);
                  for (t = 0.01; t <= 1; t += 0.01) {
                      p2 = path.getPointOnCubicBezier(t, x, y, points[0], points[1], points[2], points[3], points[4], points[5]);
                      len += path.getLineLength(p1.x, p1.y, p2.x, p2.y);
                      p1 = p2;
                  }
                  return len;
              case 'Q':
                  // Approximates by breaking curve into 100 line segments
                  len = 0.0;
                  p1 = path.getPointOnQuadraticBezier(0, x, y, points[0], points[1], points[2], points[3]);
                  for (t = 0.01; t <= 1; t += 0.01) {
                      p2 = path.getPointOnQuadraticBezier(t, x, y, points[0], points[1], points[2], points[3]);
                      len += path.getLineLength(p1.x, p1.y, p2.x, p2.y);
                      p1 = p2;
                  }
                  return len;
              case 'A':
                  // Approximates by breaking curve into line segments
                  len = 0.0;
                  var start = points[4];
                  // 4 = theta
                  var dTheta = points[5];
                  // 5 = dTheta
                  var end = points[4] + dTheta;
                  var inc = Math.PI / 180.0;
                  // 1 degree resolution
                  if (Math.abs(start - end) < inc) {
                      inc = Math.abs(start - end);
                  }
                  // Note: for purpose of calculating arc length, not going to worry about rotating X-axis by angle psi
                  p1 = path.getPointOnEllipticalArc(points[0], points[1], points[2], points[3], start, 0);
                  if (dTheta < 0) {// clockwise
                      for (t = start - inc; t > end; t -= inc) {
                          p2 = path.getPointOnEllipticalArc(points[0], points[1], points[2], points[3], t, 0);
                          len += path.getLineLength(p1.x, p1.y, p2.x, p2.y);
                          p1 = p2;
                      }
                  }
                  else {// counter-clockwise
                      for (t = start + inc; t < end; t += inc) {
                          p2 = path.getPointOnEllipticalArc(points[0], points[1], points[2], points[3], t, 0);
                          len += path.getLineLength(p1.x, p1.y, p2.x, p2.y);
                          p1 = p2;
                      }
                  }
                  p2 = path.getPointOnEllipticalArc(points[0], points[1], points[2], points[3], end, 0);
                  len += path.getLineLength(p1.x, p1.y, p2.x, p2.y);

                  return len;
          }

          return 0;
      };
      Kinetic.Path.convertEndpointToCenterParameterization = function (x1, y1, x2, y2, fa, fs, rx, ry, psiDeg) {
          // Derived from: http://www.w3.org/TR/SVG/implnote.html#ArcImplementationNotes
          var psi = psiDeg * (Math.PI / 180.0);
          var xp = Math.cos(psi) * (x1 - x2) / 2.0 + Math.sin(psi) * (y1 - y2) / 2.0;
          var yp = -1 * Math.sin(psi) * (x1 - x2) / 2.0 + Math.cos(psi) * (y1 - y2) / 2.0;

          var lambda = (xp * xp) / (rx * rx) + (yp * yp) / (ry * ry);

          if (lambda > 1) {
              rx *= Math.sqrt(lambda);
              ry *= Math.sqrt(lambda);
          }

          var f = Math.sqrt((((rx * rx) * (ry * ry)) - ((rx * rx) * (yp * yp)) - ((ry * ry) * (xp * xp))) / ((rx * rx) * (yp * yp) + (ry * ry) * (xp * xp)));

          if (fa == fs) {
              f *= -1;
          }
          if (isNaN(f)) {
              f = 0;
          }

          var cxp = f * rx * yp / ry;
          var cyp = f * -ry * xp / rx;

          var cx = (x1 + x2) / 2.0 + Math.cos(psi) * cxp - Math.sin(psi) * cyp;
          var cy = (y1 + y2) / 2.0 + Math.sin(psi) * cxp + Math.cos(psi) * cyp;

          var vMag = function (v) {
              return Math.sqrt(v[0] * v[0] + v[1] * v[1]);
          };
          var vRatio = function (u, v) {
              return (u[0] * v[0] + u[1] * v[1]) / (vMag(u) * vMag(v));
          };
          var vAngle = function (u, v) {
              return (u[0] * v[1] < u[1] * v[0] ? -1 : 1) * Math.acos(vRatio(u, v));
          };
          var theta = vAngle([
              1,
              0
          ], [
              (xp - cxp) / rx,
              (yp - cyp) / ry
          ]);
          var u = [
              (xp - cxp) / rx,
              (yp - cyp) / ry
          ];
          var v = [
              (-1 * xp - cxp) / rx,
              (-1 * yp - cyp) / ry
          ];
          var dTheta = vAngle(u, v);

          if (vRatio(u, v) <= -1) {
              dTheta = Math.PI;
          }
          if (vRatio(u, v) >= 1) {
              dTheta = 0;
          }
          if (fs === 0 && dTheta > 0) {
              dTheta = dTheta - 2 * Math.PI;
          }
          if (fs == 1 && dTheta < 0) {
              dTheta = dTheta + 2 * Math.PI;
          }
          return [
              cx,
              cy,
              rx,
              ry,
              theta,
              dTheta,
              psi,
              fs
          ];
      };
      // add getters setters
      Kinetic.Factory.addGetterSetter(Kinetic.Path, 'data');

      /**
       * set SVG path data string.  This method
       *  also automatically parses the data string
       *  into a data array.  Currently supported SVG data:
       *  M, m, L, l, H, h, V, v, Q, q, T, t, C, c, S, s, A, a, Z, z
       * @name setData
       * @method
       * @memberof Kinetic.Path.prototype
       * @param {String} SVG path command string
       */

      /**
       * get SVG path data string
       * @name getData
       * @method
       * @memberof Kinetic.Path.prototype
       */

      Kinetic.Collection.mapMethods(Kinetic.Path);
  })();
  ;
  (function () {
      var EMPTY_STRING = '',
        CALIBRI = 'Calibri',
        NORMAL = 'normal';

      /**
       * Path constructor.
       * @author Jason Follas
       * @constructor
       * @memberof Kinetic
       * @augments Kinetic.Shape
       * @param {Object} config
       * @param {String} [config.fontFamily] default is Calibri
       * @param {Number} [config.fontSize] default is 12
       * @param {String} [config.fontStyle] can be normal, bold, or italic.  Default is normal
       * @param {String} config.text
       * @param {String} config.data SVG data string
       * @param {String} [config.fill] fill color
       * @param {Integer} [config.fillRed] set fill red component
       * @param {Integer} [config.fillGreen] set fill green component
       * @param {Integer} [config.fillBlue] set fill blue component
       * @param {Integer} [config.fillAlpha] set fill alpha component
       * @param {Image} [config.fillPatternImage] fill pattern image
       * @param {Number} [config.fillPatternX]
       * @param {Number} [config.fillPatternY]
       * @param {Object} [config.fillPatternOffset] object with x and y component
       * @param {Number} [config.fillPatternOffsetX]
       * @param {Number} [config.fillPatternOffsetY]
       * @param {Object} [config.fillPatternScale] object with x and y component
       * @param {Number} [config.fillPatternScaleX]
       * @param {Number} [config.fillPatternScaleY]
       * @param {Number} [config.fillPatternRotation]
       * @param {String} [config.fillPatternRepeat] can be "repeat", "repeat-x", "repeat-y", or "no-repeat".  The default is "no-repeat"
       * @param {Object} [config.fillLinearGradientStartPoint] object with x and y component
       * @param {Number} [config.fillLinearGradientStartPointX]
       * @param {Number} [config.fillLinearGradientStartPointY]
       * @param {Object} [config.fillLinearGradientEndPoint] object with x and y component
       * @param {Number} [config.fillLinearGradientEndPointX]
       * @param {Number} [config.fillLinearGradientEndPointY]
       * @param {Array} [config.fillLinearGradientColorStops] array of color stops
       * @param {Object} [config.fillRadialGradientStartPoint] object with x and y component
       * @param {Number} [config.fillRadialGradientStartPointX]
       * @param {Number} [config.fillRadialGradientStartPointY]
       * @param {Object} [config.fillRadialGradientEndPoint] object with x and y component
       * @param {Number} [config.fillRadialGradientEndPointX]
       * @param {Number} [config.fillRadialGradientEndPointY]
       * @param {Number} [config.fillRadialGradientStartRadius]
       * @param {Number} [config.fillRadialGradientEndRadius]
       * @param {Array} [config.fillRadialGradientColorStops] array of color stops
       * @param {Boolean} [config.fillEnabled] flag which enables or disables the fill.  The default value is true
       * @param {String} [config.fillPriority] can be color, linear-gradient, radial-graident, or pattern.  The default value is color.  The fillPriority property makes it really easy to toggle between different fill types.  For example, if you want to toggle between a fill color style and a fill pattern style, simply set the fill property and the fillPattern properties, and then use setFillPriority('color') to render the shape with a color fill, or use setFillPriority('pattern') to render the shape with the pattern fill configuration
       * @param {String} [config.stroke] stroke color
       * @param {Integer} [config.strokeRed] set stroke red component
       * @param {Integer} [config.strokeGreen] set stroke green component
       * @param {Integer} [config.strokeBlue] set stroke blue component
       * @param {Integer} [config.strokeAlpha] set stroke alpha component
       * @param {Number} [config.strokeWidth] stroke width
       * @param {Boolean} [config.strokeScaleEnabled] flag which enables or disables stroke scale.  The default is true
       * @param {Boolean} [config.strokeEnabled] flag which enables or disables the stroke.  The default value is true
       * @param {String} [config.lineJoin] can be miter, round, or bevel.  The default
       *  is miter
       * @param {String} [config.lineCap] can be butt, round, or sqare.  The default
       *  is butt
       * @param {String} [config.shadowColor]
       * @param {Integer} [config.shadowColorRed] set shadow color red component
       * @param {Integer} [config.shadowColorGreen] set shadow color green component
       * @param {Integer} [config.shadowColorBlue] set shadow color blue component
       * @param {Integer} [config.shadowColorAlpha] set shadow color alpha component
       * @param {Number} [config.shadowBlur]
       * @param {Object} [config.shadowOffset] object with x and y component
       * @param {Number} [config.shadowOffsetX]
       * @param {Number} [config.shadowOffsetY]
       * @param {Number} [config.shadowOpacity] shadow opacity.  Can be any real number
       *  between 0 and 1
       * @param {Boolean} [config.shadowEnabled] flag which enables or disables the shadow.  The default value is true
       * @param {Array} [config.dash]
       * @param {Boolean} [config.dashEnabled] flag which enables or disables the dashArray.  The default value is true
       * @param {Number} [config.x]
       * @param {Number} [config.y]
       * @param {Number} [config.width]
       * @param {Number} [config.height]
       * @param {Boolean} [config.visible]
       * @param {Boolean} [config.listening] whether or not the node is listening for events
       * @param {String} [config.id] unique id
       * @param {String} [config.name] non-unique name
       * @param {Number} [config.opacity] determines node opacity.  Can be any number between 0 and 1
       * @param {Object} [config.scale] set scale
       * @param {Number} [config.scaleX] set scale x
       * @param {Number} [config.scaleY] set scale y
       * @param {Number} [config.rotation] rotation in degrees
       * @param {Object} [config.offset] offset from center point and rotation point
       * @param {Number} [config.offsetX] set offset x
       * @param {Number} [config.offsetY] set offset y
       * @param {Boolean} [config.draggable] makes the node draggable.  When stages are draggable, you can drag and drop
       *  the entire stage by dragging any portion of the stage
       * @param {Function} [config.dragBoundFunc]
       * @example
       * var textpath = new Kinetic.TextPath({<br>
       *   x: 100,<br>
       *   y: 50,<br>
       *   fill: '#333',<br>
       *   fontSize: '24',<br>
       *   fontFamily: 'Arial',<br>
       *   text: 'All the world\'s a stage, and all the men and women merely players.',<br>
       *   data: 'M10,10 C0,0 10,150 100,100 S300,150 400,50'<br>
       * });
       */
      Kinetic.TextPath = function (config) {
          this.___init(config);
      };

      function _fillFunc (context) {
          context.fillText(this.partialText, 0, 0);
      }
      function _strokeFunc (context) {
          context.strokeText(this.partialText, 0, 0);
      }

      Kinetic.TextPath.prototype = {
          ___init: function (config) {
              var that = this;
              this.dummyCanvas = document.createElement('canvas');
              this.dataArray = [
              ];

              // call super constructor
              Kinetic.Shape.call(this, config);

              // overrides
              // TODO: shouldn't this be on the prototype?
              this._fillFunc = _fillFunc;
              this._strokeFunc = _strokeFunc;
              this._fillFuncHit = _fillFunc;
              this._strokeFuncHit = _strokeFunc;

              this.className = 'TextPath';

              this.dataArray = Kinetic.Path.parsePathData(this.attrs.data);
              this.on('dataChange.kinetic', function () {
                  that.dataArray = Kinetic.Path.parsePathData(this.attrs.data);
              });

              // update text data for certain attr changes
              this.on('textChange.kinetic textStroke.kinetic textStrokeWidth.kinetic', that._setTextData);
              that._setTextData();
              this.sceneFunc(this._sceneFunc);
          },
          _sceneFunc: function (context) {
              context.setAttr('font', this._getContextFont());
              context.setAttr('textBaseline', 'middle');
              context.setAttr('textAlign', 'left');
              context.save();

              var glyphInfo = this.glyphInfo;
              for (var i = 0; i < glyphInfo.length; i++) {
                  context.save();

                  var p0 = glyphInfo[i].p0;

                  context.translate(p0.x, p0.y);
                  context.rotate(glyphInfo[i].rotation);
                  this.partialText = glyphInfo[i].text;

                  context.fillStrokeShape(this);
                  context.restore();

                  //// To assist with debugging visually, uncomment following
                  // context.beginPath();
                  // if (i % 2)
                  // context.strokeStyle = 'cyan';
                  // else
                  // context.strokeStyle = 'green';
                  // var p1 = glyphInfo[i].p1;
                  // context.moveTo(p0.x, p0.y);
                  // context.lineTo(p1.x, p1.y);
                  // context.stroke();
              }
              context.restore();
          },
          /**
           * get text width in pixels
           * @method
           * @memberof Kinetic.TextPath.prototype
           */
          getTextWidth: function () {
              return this.textWidth;
          },
          /**
           * get text height in pixels
           * @method
           * @memberof Kinetic.TextPath.prototype
           */
          getTextHeight: function () {
              return this.textHeight;
          },
          /**
           * set text
           * @method
           * @memberof Kinetic.TextPath.prototype
           * @param {String} text
           */
          setText: function (text) {
              Kinetic.Text.prototype.setText.call(this, text);
          },
          _getTextSize: function (text) {
              var dummyCanvas = this.dummyCanvas;
              var _context = dummyCanvas.getContext('2d');

              _context.save();

              _context.font = this._getContextFont();
              var metrics = _context.measureText(text);

              _context.restore();

              return {
                  width: metrics.width,
                  height: parseInt(this.attrs.fontSize, 10)
              };
          },
          _setTextData: function () {

              var that = this;
              var size = this._getTextSize(this.attrs.text);
              this.textWidth = size.width;
              this.textHeight = size.height;

              this.glyphInfo = [
              ];

              var charArr = this.attrs.text.split('');

              var p0, p1, pathCmd;

              var pIndex = -1;
              var currentT = 0;

              var getNextPathSegment = function () {
                  currentT = 0;
                  var pathData = that.dataArray;

                  for (var i = pIndex + 1; i < pathData.length; i++) {
                      if (pathData[i].pathLength > 0) {
                          pIndex = i;

                          return pathData[i];
                      }
                      else if (pathData[i].command == 'M') {
                          p0 = {
                              x: pathData[i].points[0],
                              y: pathData[i].points[1]
                          };
                      }
                  }

                  return {
                  };
              };
              var findSegmentToFitCharacter = function (c, before) {

                  var glyphWidth = that._getTextSize(c).width;

                  var currLen = 0;
                  var attempts = 0;

                  p1 = undefined;
                  while (Math.abs(glyphWidth - currLen) / glyphWidth > 0.01 && attempts < 25) {
                      attempts++;
                      var cumulativePathLength = currLen;
                      while (pathCmd === undefined) {
                          pathCmd = getNextPathSegment();

                          if (pathCmd && cumulativePathLength + pathCmd.pathLength < glyphWidth) {
                              cumulativePathLength += pathCmd.pathLength;
                              pathCmd = undefined;
                          }
                      }

                      if (pathCmd === {
                      } || p0 === undefined)
                          return undefined;

                      var needNewSegment = false;

                      switch (pathCmd.command) {
                          case 'L':
                              if (Kinetic.Path.getLineLength(p0.x, p0.y, pathCmd.points[0], pathCmd.points[1]) > glyphWidth) {
                                  p1 = Kinetic.Path.getPointOnLine(glyphWidth, p0.x, p0.y, pathCmd.points[0], pathCmd.points[1], p0.x, p0.y);
                              }
                              else
                                  pathCmd = undefined;
                              break;
                          case 'A':

                              var start = pathCmd.points[4];
                              // 4 = theta
                              var dTheta = pathCmd.points[5];
                              // 5 = dTheta
                              var end = pathCmd.points[4] + dTheta;

                              if (currentT === 0)
                                  currentT = start + 0.00000001;
                              // Just in case start is 0
                              else if (glyphWidth > currLen)
                                  currentT += (Math.PI / 180.0) * dTheta / Math.abs(dTheta);
                              else
                                  currentT -= Math.PI / 360.0 * dTheta / Math.abs(dTheta);

                              // Credit for bug fix: @therth https://github.com/ericdrowell/KineticJS/issues/249
                              // Old code failed to render text along arc of this path: "M 50 50 a 150 50 0 0 1 250 50 l 50 0"
                              if (dTheta < 0 && currentT < end || dTheta >= 0 && currentT > end) {
                                  currentT = end;
                                  needNewSegment = true;
                              }
                              p1 = Kinetic.Path.getPointOnEllipticalArc(pathCmd.points[0], pathCmd.points[1], pathCmd.points[2], pathCmd.points[3], currentT, pathCmd.points[6]);
                              break;
                          case 'C':
                              if (currentT === 0) {
                                  if (glyphWidth > pathCmd.pathLength)
                                      currentT = 0.00000001;
                                  else
                                      currentT = glyphWidth / pathCmd.pathLength;
                              }
                              else if (glyphWidth > currLen)
                                  currentT += (glyphWidth - currLen) / pathCmd.pathLength;
                              else
                                  currentT -= (currLen - glyphWidth) / pathCmd.pathLength;

                              if (currentT > 1.0) {
                                  currentT = 1.0;
                                  needNewSegment = true;
                              }
                              p1 = Kinetic.Path.getPointOnCubicBezier(currentT, pathCmd.start.x, pathCmd.start.y, pathCmd.points[0], pathCmd.points[1], pathCmd.points[2], pathCmd.points[3], pathCmd.points[4], pathCmd.points[5]);
                              break;
                          case 'Q':
                              if (currentT === 0)
                                  currentT = glyphWidth / pathCmd.pathLength;
                              else if (glyphWidth > currLen)
                                  currentT += (glyphWidth - currLen) / pathCmd.pathLength;
                              else
                                  currentT -= (currLen - glyphWidth) / pathCmd.pathLength;

                              if (currentT > 1.0) {
                                  currentT = 1.0;
                                  needNewSegment = true;
                              }
                              p1 = Kinetic.Path.getPointOnQuadraticBezier(currentT, pathCmd.start.x, pathCmd.start.y, pathCmd.points[0], pathCmd.points[1], pathCmd.points[2], pathCmd.points[3]);
                              break;

                      }

                      if (p1 !== undefined) {
                          currLen = Kinetic.Path.getLineLength(p0.x, p0.y, p1.x, p1.y);
                      }

                      if (needNewSegment) {
                          needNewSegment = false;
                          pathCmd = undefined;
                      }
                  }
              };
              for (var i = 0; i < charArr.length; i++) {

                  // Find p1 such that line segment between p0 and p1 is approx. width of glyph
                  findSegmentToFitCharacter(charArr[i]);

                  if (p0 === undefined || p1 === undefined)
                      break;

                  var width = Kinetic.Path.getLineLength(p0.x, p0.y, p1.x, p1.y);

                  // Note: Since glyphs are rendered one at a time, any kerning pair data built into the font will not be used.
                  // Can foresee having a rough pair table built in that the developer can override as needed.

                  var kern = 0;
                  // placeholder for future implementation

                  var midpoint = Kinetic.Path.getPointOnLine(kern + width / 2.0, p0.x, p0.y, p1.x, p1.y);

                  var rotation = Math.atan2((p1.y - p0.y), (p1.x - p0.x));
                  this.glyphInfo.push({
                      transposeX: midpoint.x,
                      transposeY: midpoint.y,
                      text: charArr[i],
                      rotation: rotation,
                      p0: p0,
                      p1: p1
                  });
                  p0 = p1;
              }
          }
      };

      // map TextPath methods to Text
      Kinetic.TextPath.prototype._getContextFont = Kinetic.Text.prototype._getContextFont;

      Kinetic.Util.extend(Kinetic.TextPath, Kinetic.Shape);

      // add setters and getters
      Kinetic.Factory.addGetterSetter(Kinetic.TextPath, 'fontFamily', 'Arial');

      /**
       * set font family
       * @name setFontFamily
       * @method
       * @memberof Kinetic.TextPath.prototype
       * @param {String} fontFamily
       */

      /**
       * get font family
       * @name getFontFamily
       * @method
       * @memberof Kinetic.TextPath.prototype
       */

      Kinetic.Factory.addGetterSetter(Kinetic.TextPath, 'fontSize', 12);

      /**
       * set font size
       * @name setFontSize
       * @method
       * @memberof Kinetic.TextPath.prototype
       * @param {int} fontSize
       */

      /**
       * get font size
       * @name getFontSize
       * @method
       * @memberof Kinetic.TextPath.prototype
       */

      Kinetic.Factory.addGetterSetter(Kinetic.TextPath, 'fontStyle', NORMAL);

      /**
       * set font style.  Can be 'normal', 'italic', or 'bold'.  'normal' is the default.
       * @name setFontStyle
       * @method
       * @memberof Kinetic.TextPath.prototype
       * @param {String} fontStyle
       */

      /**
       * get font style
       * @name getFontStyle
       * @method
       * @memberof Kinetic.TextPath.prototype
       */

      Kinetic.Factory.addGetter(Kinetic.TextPath, 'text', EMPTY_STRING);

      /**
       * get text
       * @name getText
       * @method
       * @memberof Kinetic.TextPath.prototype
       */

      Kinetic.Collection.mapMethods(Kinetic.TextPath);
  })();
  ;
  (function () {
      /**
       * RegularPolygon constructor.&nbsp; Examples include triangles, squares, pentagons, hexagons, etc.
       * @constructor
       * @memberof Kinetic
       * @augments Kinetic.Shape
       * @param {Object} config
       * @param {Number} config.sides
       * @param {Number} config.radius
       * @param {String} [config.fill] fill color
       * @param {Integer} [config.fillRed] set fill red component
       * @param {Integer} [config.fillGreen] set fill green component
       * @param {Integer} [config.fillBlue] set fill blue component
       * @param {Integer} [config.fillAlpha] set fill alpha component
       * @param {Image} [config.fillPatternImage] fill pattern image
       * @param {Number} [config.fillPatternX]
       * @param {Number} [config.fillPatternY]
       * @param {Object} [config.fillPatternOffset] object with x and y component
       * @param {Number} [config.fillPatternOffsetX]
       * @param {Number} [config.fillPatternOffsetY]
       * @param {Object} [config.fillPatternScale] object with x and y component
       * @param {Number} [config.fillPatternScaleX]
       * @param {Number} [config.fillPatternScaleY]
       * @param {Number} [config.fillPatternRotation]
       * @param {String} [config.fillPatternRepeat] can be "repeat", "repeat-x", "repeat-y", or "no-repeat".  The default is "no-repeat"
       * @param {Object} [config.fillLinearGradientStartPoint] object with x and y component
       * @param {Number} [config.fillLinearGradientStartPointX]
       * @param {Number} [config.fillLinearGradientStartPointY]
       * @param {Object} [config.fillLinearGradientEndPoint] object with x and y component
       * @param {Number} [config.fillLinearGradientEndPointX]
       * @param {Number} [config.fillLinearGradientEndPointY]
       * @param {Array} [config.fillLinearGradientColorStops] array of color stops
       * @param {Object} [config.fillRadialGradientStartPoint] object with x and y component
       * @param {Number} [config.fillRadialGradientStartPointX]
       * @param {Number} [config.fillRadialGradientStartPointY]
       * @param {Object} [config.fillRadialGradientEndPoint] object with x and y component
       * @param {Number} [config.fillRadialGradientEndPointX]
       * @param {Number} [config.fillRadialGradientEndPointY]
       * @param {Number} [config.fillRadialGradientStartRadius]
       * @param {Number} [config.fillRadialGradientEndRadius]
       * @param {Array} [config.fillRadialGradientColorStops] array of color stops
       * @param {Boolean} [config.fillEnabled] flag which enables or disables the fill.  The default value is true
       * @param {String} [config.fillPriority] can be color, linear-gradient, radial-graident, or pattern.  The default value is color.  The fillPriority property makes it really easy to toggle between different fill types.  For example, if you want to toggle between a fill color style and a fill pattern style, simply set the fill property and the fillPattern properties, and then use setFillPriority('color') to render the shape with a color fill, or use setFillPriority('pattern') to render the shape with the pattern fill configuration
       * @param {String} [config.stroke] stroke color
       * @param {Integer} [config.strokeRed] set stroke red component
       * @param {Integer} [config.strokeGreen] set stroke green component
       * @param {Integer} [config.strokeBlue] set stroke blue component
       * @param {Integer} [config.strokeAlpha] set stroke alpha component
       * @param {Number} [config.strokeWidth] stroke width
       * @param {Boolean} [config.strokeScaleEnabled] flag which enables or disables stroke scale.  The default is true
       * @param {Boolean} [config.strokeEnabled] flag which enables or disables the stroke.  The default value is true
       * @param {String} [config.lineJoin] can be miter, round, or bevel.  The default
       *  is miter
       * @param {String} [config.lineCap] can be butt, round, or sqare.  The default
       *  is butt
       * @param {String} [config.shadowColor]
       * @param {Integer} [config.shadowColorRed] set shadow color red component
       * @param {Integer} [config.shadowColorGreen] set shadow color green component
       * @param {Integer} [config.shadowColorBlue] set shadow color blue component
       * @param {Integer} [config.shadowColorAlpha] set shadow color alpha component
       * @param {Number} [config.shadowBlur]
       * @param {Object} [config.shadowOffset] object with x and y component
       * @param {Number} [config.shadowOffsetX]
       * @param {Number} [config.shadowOffsetY]
       * @param {Number} [config.shadowOpacity] shadow opacity.  Can be any real number
       *  between 0 and 1
       * @param {Boolean} [config.shadowEnabled] flag which enables or disables the shadow.  The default value is true
       * @param {Array} [config.dash]
       * @param {Boolean} [config.dashEnabled] flag which enables or disables the dashArray.  The default value is true
       * @param {Number} [config.x]
       * @param {Number} [config.y]
       * @param {Number} [config.width]
       * @param {Number} [config.height]
       * @param {Boolean} [config.visible]
       * @param {Boolean} [config.listening] whether or not the node is listening for events
       * @param {String} [config.id] unique id
       * @param {String} [config.name] non-unique name
       * @param {Number} [config.opacity] determines node opacity.  Can be any number between 0 and 1
       * @param {Object} [config.scale] set scale
       * @param {Number} [config.scaleX] set scale x
       * @param {Number} [config.scaleY] set scale y
       * @param {Number} [config.rotation] rotation in degrees
       * @param {Object} [config.offset] offset from center point and rotation point
       * @param {Number} [config.offsetX] set offset x
       * @param {Number} [config.offsetY] set offset y
       * @param {Boolean} [config.draggable] makes the node draggable.  When stages are draggable, you can drag and drop
       *  the entire stage by dragging any portion of the stage
       * @param {Function} [config.dragBoundFunc]
       * @example
       * var hexagon = new Kinetic.RegularPolygon({<br>
       *   x: 100,<br>
       *   y: 200,<br>
       *   sides: 6,<br>
       *   radius: 70,<br>
       *   fill: 'red',<br>
       *   stroke: 'black',<br>
       *   strokeWidth: 4<br>
       * });
       */
      Kinetic.RegularPolygon = function (config) {
          this.___init(config);
      };

      Kinetic.RegularPolygon.prototype = {
          ___init: function (config) {
              // call super constructor
              Kinetic.Shape.call(this, config);
              this.className = 'RegularPolygon';
              this.sceneFunc(this._sceneFunc);
          },
          _sceneFunc: function (context) {
              var sides = this.attrs.sides,
                radius = this.attrs.radius,
                n, x, y;

              context.beginPath();
              context.moveTo(0, 0 - radius);

              for (n = 1; n < sides; n++) {
                  x = radius * Math.sin(n * 2 * Math.PI / sides);
                  y = -1 * radius * Math.cos(n * 2 * Math.PI / sides);
                  context.lineTo(x, y);
              }
              context.closePath();
              context.fillStrokeShape(this);
          }
      };
      Kinetic.Util.extend(Kinetic.RegularPolygon, Kinetic.Shape);

      // add getters setters
      Kinetic.Factory.addGetterSetter(Kinetic.RegularPolygon, 'radius', 0);

      /**
       * set radius
       * @name setRadius
       * @method
       * @memberof Kinetic.RegularPolygon.prototype
       * @param {Number} radius
       */

      /**
       * get radius
       * @name getRadius
       * @method
       * @memberof Kinetic.RegularPolygon.prototype
       */

      Kinetic.Factory.addGetterSetter(Kinetic.RegularPolygon, 'sides', 0);

      /**
       * set number of sides
       * @name setSides
       * @method
       * @memberof Kinetic.RegularPolygon.prototype
       * @param {int} sides
       */

      /**
       * get number of sides
       * @name getSides
       * @method
       * @memberof Kinetic.RegularPolygon.prototype
       */

      Kinetic.Collection.mapMethods(Kinetic.RegularPolygon);
  })();
  ;
  (function () {
      /**
       * Star constructor
       * @constructor
       * @memberof Kinetic
       * @augments Kinetic.Shape
       * @param {Object} config
       * @param {Integer} config.numPoints
       * @param {Number} config.innerRadius
       * @param {Number} config.outerRadius
       * @param {String} [config.fill] fill color
       * @param {Integer} [config.fillRed] set fill red component
       * @param {Integer} [config.fillGreen] set fill green component
       * @param {Integer} [config.fillBlue] set fill blue component
       * @param {Integer} [config.fillAlpha] set fill alpha component
       * @param {Image} [config.fillPatternImage] fill pattern image
       * @param {Number} [config.fillPatternX]
       * @param {Number} [config.fillPatternY]
       * @param {Object} [config.fillPatternOffset] object with x and y component
       * @param {Number} [config.fillPatternOffsetX]
       * @param {Number} [config.fillPatternOffsetY]
       * @param {Object} [config.fillPatternScale] object with x and y component
       * @param {Number} [config.fillPatternScaleX]
       * @param {Number} [config.fillPatternScaleY]
       * @param {Number} [config.fillPatternRotation]
       * @param {String} [config.fillPatternRepeat] can be "repeat", "repeat-x", "repeat-y", or "no-repeat".  The default is "no-repeat"
       * @param {Object} [config.fillLinearGradientStartPoint] object with x and y component
       * @param {Number} [config.fillLinearGradientStartPointX]
       * @param {Number} [config.fillLinearGradientStartPointY]
       * @param {Object} [config.fillLinearGradientEndPoint] object with x and y component
       * @param {Number} [config.fillLinearGradientEndPointX]
       * @param {Number} [config.fillLinearGradientEndPointY]
       * @param {Array} [config.fillLinearGradientColorStops] array of color stops
       * @param {Object} [config.fillRadialGradientStartPoint] object with x and y component
       * @param {Number} [config.fillRadialGradientStartPointX]
       * @param {Number} [config.fillRadialGradientStartPointY]
       * @param {Object} [config.fillRadialGradientEndPoint] object with x and y component
       * @param {Number} [config.fillRadialGradientEndPointX]
       * @param {Number} [config.fillRadialGradientEndPointY]
       * @param {Number} [config.fillRadialGradientStartRadius]
       * @param {Number} [config.fillRadialGradientEndRadius]
       * @param {Array} [config.fillRadialGradientColorStops] array of color stops
       * @param {Boolean} [config.fillEnabled] flag which enables or disables the fill.  The default value is true
       * @param {String} [config.fillPriority] can be color, linear-gradient, radial-graident, or pattern.  The default value is color.  The fillPriority property makes it really easy to toggle between different fill types.  For example, if you want to toggle between a fill color style and a fill pattern style, simply set the fill property and the fillPattern properties, and then use setFillPriority('color') to render the shape with a color fill, or use setFillPriority('pattern') to render the shape with the pattern fill configuration
       * @param {String} [config.stroke] stroke color
       * @param {Integer} [config.strokeRed] set stroke red component
       * @param {Integer} [config.strokeGreen] set stroke green component
       * @param {Integer} [config.strokeBlue] set stroke blue component
       * @param {Integer} [config.strokeAlpha] set stroke alpha component
       * @param {Number} [config.strokeWidth] stroke width
       * @param {Boolean} [config.strokeScaleEnabled] flag which enables or disables stroke scale.  The default is true
       * @param {Boolean} [config.strokeEnabled] flag which enables or disables the stroke.  The default value is true
       * @param {String} [config.lineJoin] can be miter, round, or bevel.  The default
       *  is miter
       * @param {String} [config.lineCap] can be butt, round, or sqare.  The default
       *  is butt
       * @param {String} [config.shadowColor]
       * @param {Integer} [config.shadowColorRed] set shadow color red component
       * @param {Integer} [config.shadowColorGreen] set shadow color green component
       * @param {Integer} [config.shadowColorBlue] set shadow color blue component
       * @param {Integer} [config.shadowColorAlpha] set shadow color alpha component
       * @param {Number} [config.shadowBlur]
       * @param {Object} [config.shadowOffset] object with x and y component
       * @param {Number} [config.shadowOffsetX]
       * @param {Number} [config.shadowOffsetY]
       * @param {Number} [config.shadowOpacity] shadow opacity.  Can be any real number
       *  between 0 and 1
       * @param {Boolean} [config.shadowEnabled] flag which enables or disables the shadow.  The default value is true
       * @param {Array} [config.dash]
       * @param {Boolean} [config.dashEnabled] flag which enables or disables the dashArray.  The default value is true
       * @param {Number} [config.x]
       * @param {Number} [config.y]
       * @param {Number} [config.width]
       * @param {Number} [config.height]
       * @param {Boolean} [config.visible]
       * @param {Boolean} [config.listening] whether or not the node is listening for events
       * @param {String} [config.id] unique id
       * @param {String} [config.name] non-unique name
       * @param {Number} [config.opacity] determines node opacity.  Can be any number between 0 and 1
       * @param {Object} [config.scale] set scale
       * @param {Number} [config.scaleX] set scale x
       * @param {Number} [config.scaleY] set scale y
       * @param {Number} [config.rotation] rotation in degrees
       * @param {Object} [config.offset] offset from center point and rotation point
       * @param {Number} [config.offsetX] set offset x
       * @param {Number} [config.offsetY] set offset y
       * @param {Boolean} [config.draggable] makes the node draggable.  When stages are draggable, you can drag and drop
       *  the entire stage by dragging any portion of the stage
       * @param {Function} [config.dragBoundFunc]
       * @example
       * var star = new Kinetic.Star({<br>
       *   x: 100,<br>
       *   y: 200,<br>
       *   numPoints: 5,<br>
       *   innerRadius: 70,<br>
       *   outerRadius: 70,<br>
       *   fill: 'red',<br>
       *   stroke: 'black',<br>
       *   strokeWidth: 4<br>
       * });
       */
      Kinetic.Star = function (config) {
          this.___init(config);
      };

      Kinetic.Star.prototype = {
          ___init: function (config) {
              // call super constructor
              Kinetic.Shape.call(this, config);
              this.className = 'Star';
              this.sceneFunc(this._sceneFunc);
          },
          _sceneFunc: function (context) {
              var innerRadius = this.innerRadius(),
                outerRadius = this.outerRadius(),
                numPoints = this.numPoints();

              context.beginPath();
              context.moveTo(0, 0 - outerRadius);

              for (var n = 1; n < numPoints * 2; n++) {
                  var radius = n % 2 === 0 ? outerRadius : innerRadius;
                  var x = radius * Math.sin(n * Math.PI / numPoints);
                  var y = -1 * radius * Math.cos(n * Math.PI / numPoints);
                  context.lineTo(x, y);
              }
              context.closePath();

              context.fillStrokeShape(this);
          }
      };
      Kinetic.Util.extend(Kinetic.Star, Kinetic.Shape);

      // add getters setters
      Kinetic.Factory.addGetterSetter(Kinetic.Star, 'numPoints', 5);

      /**
       * set number of points
       * @name setNumPoints
       * @method
       * @memberof Kinetic.Star.prototype
       * @param {Integer} points
       */

      /**
       * get number of points
       * @name getNumPoints
       * @method
       * @memberof Kinetic.Star.prototype
       */

      Kinetic.Factory.addGetterSetter(Kinetic.Star, 'innerRadius', 0);

      /**
       * set inner radius
       * @name setInnerRadius
       * @method
       * @memberof Kinetic.Star.prototype
       * @param {Number} radius
       */

      /**
       * get inner radius
       * @name getInnerRadius
       * @method
       * @memberof Kinetic.Star.prototype
       */

      Kinetic.Factory.addGetterSetter(Kinetic.Star, 'outerRadius', 0);

      /**
       * set outer radius
       * @name setOuterRadius
       * @method
       * @memberof Kinetic.Star.prototype
       * @param {Number} radius
       */

      /**
       * get outer radius
       * @name getOuterRadius
       * @method
       * @memberof Kinetic.Star.prototype
       */

      Kinetic.Collection.mapMethods(Kinetic.Star);
  })();
  ;
  (function () {
      // constants
      var ATTR_CHANGE_LIST = [
          'fontFamily',
          'fontSize',
          'fontStyle',
          'padding',
          'lineHeight',
          'text'
      ],
        CHANGE_KINETIC = 'Change.kinetic',
        NONE = 'none',
        UP = 'up',
        RIGHT = 'right',
        DOWN = 'down',
        LEFT = 'left',
        LABEL = 'Label',
        // cached variables
        attrChangeListLen = ATTR_CHANGE_LIST.length;

      /**
       * Label constructor.&nbsp; Labels are groups that contain a Text and Tag shape
       * @constructor
       * @memberof Kinetic
       * @param {Object} config
       * @param {Number} [config.x]
       * @param {Number} [config.y]
       * @param {Number} [config.width]
       * @param {Number} [config.height]
       * @param {Boolean} [config.visible]
       * @param {Boolean} [config.listening] whether or not the node is listening for events
       * @param {String} [config.id] unique id
       * @param {String} [config.name] non-unique name
       * @param {Number} [config.opacity] determines node opacity.  Can be any number between 0 and 1
       * @param {Object} [config.scale] set scale
       * @param {Number} [config.scaleX] set scale x
       * @param {Number} [config.scaleY] set scale y
       * @param {Number} [config.rotation] rotation in degrees
       * @param {Object} [config.offset] offset from center point and rotation point
       * @param {Number} [config.offsetX] set offset x
       * @param {Number} [config.offsetY] set offset y
       * @param {Boolean} [config.draggable] makes the node draggable.  When stages are draggable, you can drag and drop
       *  the entire stage by dragging any portion of the stage
       * @param {Function} [config.dragBoundFunc]
       * @example
       * // create label
       * var label = new Kinetic.Label({<br>
       *   x: 100,<br>
       *   y: 100, <br>
       *   draggable: true<br>
       * });<br><br>
       *
       * // add a tag to the label<br>
       * label.add(new Kinetic.Tag({<br>
       *   fill: '#bbb',<br>
       *   stroke: '#333',<br>
       *   shadowColor: 'black',<br>
       *   shadowBlur: 10,<br>
       *   shadowOffset: [10, 10],<br>
       *   shadowOpacity: 0.2,<br>
       *   lineJoin: 'round',<br>
       *   pointerDirection: 'up',<br>
       *   pointerWidth: 20,<br>
       *   pointerHeight: 20,<br>
       *   cornerRadius: 5<br>
       * }));<br><br>
       *
       * // add text to the label<br>
       * label.add(new Kinetic.Text({<br>
       *   text: 'Hello World!',<br>
       *   fontSize: 50,<br>
       *   lineHeight: 1.2,<br>
       *   padding: 10,<br>
       *   fill: 'green'<br>
       *  }));
       */
      Kinetic.Label = function (config) {
          this.____init(config);
      };

      Kinetic.Label.prototype = {
          ____init: function (config) {
              var that = this;

              this.className = LABEL;
              Kinetic.Group.call(this, config);

              this.on('add.kinetic', function (evt) {
                  that._addListeners(evt.child);
                  that._sync();
              });
          },
          /**
           * get Text shape for the label.  You need to access the Text shape in order to update
           * the text properties
           * @name getText
           * @method
           * @memberof Kinetic.Label.prototype
           */
          getText: function () {
              return this.find('Text')[0];
          },
          /**
           * get Tag shape for the label.  You need to access the Tag shape in order to update
           * the pointer properties and the corner radius
           * @name getTag
           * @method
           * @memberof Kinetic.Label.prototype
           */
          getTag: function () {
              return this.find('Tag')[0];
          },
          _addListeners: function (text) {
              var that = this,
                n;
              var func = function () {
                  that._sync();
              };

              // update text data for certain attr changes
              for (n = 0; n < attrChangeListLen; n++) {
                  text.on(ATTR_CHANGE_LIST[n] + CHANGE_KINETIC, func);
              }
          },
          getWidth: function () {
              return this.getText().getWidth();
          },
          getHeight: function () {
              return this.getText().getHeight();
          },
          _sync: function () {
              var text = this.getText(),
                tag = this.getTag(),
                width, height, pointerDirection, pointerWidth, x, y;

              if (text && tag) {
                  width = text.getWidth(),
                    height = text.getHeight(),
                    pointerDirection = tag.getPointerDirection(),
                    pointerWidth = tag.getPointerWidth(),
                    pointerHeight = tag.getPointerHeight(),
                    x = 0,
                    y = 0;

                  switch (pointerDirection) {
                      case UP:
                          x = width / 2;
                          y = -1 * pointerHeight;
                          break;
                      case RIGHT:
                          x = width + pointerWidth;
                          y = height / 2;
                          break;
                      case DOWN:
                          x = width / 2;
                          y = height + pointerHeight;
                          break;
                      case LEFT:
                          x = -1 * pointerWidth;
                          y = height / 2;
                          break;
                  }

                  tag.setAttrs({
                      x: -1 * x,
                      y: -1 * y,
                      width: width,
                      height: height
                  });

                  text.setAttrs({
                      x: -1 * x,
                      y: -1 * y
                  });
              }
          }
      };

      Kinetic.Util.extend(Kinetic.Label, Kinetic.Group);

      Kinetic.Collection.mapMethods(Kinetic.Label);

      /**
       * Tag constructor.&nbsp; A Tag can be configured
       *  to have a pointer element that points up, right, down, or left
       * @constructor
       * @memberof Kinetic
       * @param {Object} config
       * @param {String} [config.pointerDirection] can be up, right, down, left, or none; the default
       *  is none.  When a pointer is present, the positioning of the label is relative to the tip of the pointer.
       * @param {Number} [config.pointerWidth]
       * @param {Number} [config.pointerHeight]
       * @param {Number} [config.cornerRadius]
       */
      Kinetic.Tag = function (config) {
          this.___init(config);
      };

      Kinetic.Tag.prototype = {
          ___init: function (config) {
              Kinetic.Shape.call(this, config);
              this.className = 'Tag';
              this.sceneFunc(this._sceneFunc);
          },
          _sceneFunc: function (context) {
              var width = this.getWidth(),
                height = this.getHeight(),
                pointerDirection = this.getPointerDirection(),
                pointerWidth = this.getPointerWidth(),
                pointerHeight = this.getPointerHeight(),
                cornerRadius = this.getCornerRadius();

              context.beginPath();
              context.moveTo(0, 0);

              if (pointerDirection === UP) {
                  context.lineTo((width - pointerWidth) / 2, 0);
                  context.lineTo(width / 2, -1 * pointerHeight);
                  context.lineTo((width + pointerWidth) / 2, 0);
              }

              context.lineTo(width, 0);

              if (pointerDirection === RIGHT) {
                  context.lineTo(width, (height - pointerHeight) / 2);
                  context.lineTo(width + pointerWidth, height / 2);
                  context.lineTo(width, (height + pointerHeight) / 2);
              }

              context.lineTo(width, height);

              if (pointerDirection === DOWN) {
                  context.lineTo((width + pointerWidth) / 2, height);
                  context.lineTo(width / 2, height + pointerHeight);
                  context.lineTo((width - pointerWidth) / 2, height);
              }

              context.lineTo(0, height);

              if (pointerDirection === LEFT) {
                  context.lineTo(0, (height + pointerHeight) / 2);
                  context.lineTo(-1 * pointerWidth, height / 2);
                  context.lineTo(0, (height - pointerHeight) / 2);
              }

              context.closePath();
              context.fillStrokeShape(this);
          }
      };

      Kinetic.Util.extend(Kinetic.Tag, Kinetic.Shape);
      Kinetic.Factory.addGetterSetter(Kinetic.Tag, 'pointerDirection', NONE);

      /**
       * set pointer Direction
       * @name setPointerDirection
       * @method
       * @memberof Kinetic.Tag.prototype
       * @param {String} pointerDirection can be up, right, down, left, or none.  The
       *  default is none
       */

      /**
       * get pointer Direction
       * @name getPointerDirection
       * @method
       * @memberof Kinetic.Tag.prototype
       */

      Kinetic.Factory.addGetterSetter(Kinetic.Tag, 'pointerWidth', 0);

      /**
       * set pointer width
       * @name setPointerWidth
       * @method
       * @memberof Kinetic.Tag.prototype
       * @param {Number} pointerWidth
       */

      /**
       * get pointer width
       * @name getPointerWidth
       * @method
       * @memberof Kinetic.Tag.prototype
       */

      Kinetic.Factory.addGetterSetter(Kinetic.Tag, 'pointerHeight', 0);

      /**
       * set pointer height
       * @name setPointerHeight
       * @method
       * @memberof Kinetic.Tag.prototype
       * @param {Number} pointerHeight
       */

      /**
       * get pointer height
       * @name getPointerHeight
       * @method
       * @memberof Kinetic.Tag.prototype
       */

      Kinetic.Factory.addGetterSetter(Kinetic.Tag, 'cornerRadius', 0);

      /**
       * set corner radius
       * @name setCornerRadius
       * @method
       * @memberof Kinetic.Tag.prototype
       * @param {Number} corner radius
       */

      /**
       * get corner radius
       * @name getCornerRadius
       * @method
       * @memberof Kinetic.Tag.prototype
       */

      Kinetic.Collection.mapMethods(Kinetic.Tag);
  })();

  /**
   * KineticJS JavaScript Framework v5.0.1
   * http://www.kineticjs.com/
   *
   * @name 1-Vector-1.1.7.js
   * @version 1.1.7
   *
   * @author Sino Boeckmann <sino.boeckmann@aufwind.cc>
   * @copyright 2013-2015 Werbeagentur aufwind. GmbH
   */

  (function () {
      /**
       * @constructor
       * @augments Kinetic.Shape
       * @param {Object} objectConfig
       */
      Kinetic.Vector = function (objectConfig) {
          this.___init(objectConfig);
      };

      /**
       * @prototype
       */
      Kinetic.Vector.prototype = {
          /**
           * @param {type} objectConfig
           * @returns {void}
           */
          ___init: function (objectConfig) {
              // call super constructor
              Kinetic.Shape.call(this, objectConfig);

              //Wir setzen den Namen unserer Klasse
              this.className = 'Vector';

              //Und bestimmen die Zeichenfunktion
              this.sceneFunc(this._drawFunc);
          },
          /**
           *
           * @param {Kinetic.SceneContext} objectSceneContext
           * @returns {Kinetic.SceneContext}
           */
          _drawFunc: function (objectSceneContext) {
              var arrayPoints = this.getPoints();

              //Die Standardwerte
              var floatX = this.getInitX();
              var floatY = this.getInitY();
              //Vorberechenbaren Zahlen
              var floatToRad = (Math.PI / 180);
              var floatHalfPi = (Math.PI / 2);

              //Wir starten an zu zeichnen
              objectSceneContext.beginPath();

              //Start Drawing at this Point
              objectSceneContext.moveTo(floatX, floatY);

              for (var intIndex = 0; intIndex < arrayPoints.length; intIndex++) {
                  var KineticPoint = arrayPoints[intIndex];

                  //Ist alles korrekt
                  if (KineticPoint instanceof Kinetic.Point === false) {
                      continue;
                  }

                  var floatAngle = KineticPoint.getAngle();
                  var floatLength = KineticPoint.getLength();

                  // Convert the angle to radians with 0deg starting at north
                  var floatRadian = (floatAngle * floatToRad) - floatHalfPi;

                  //Der erste Punkte den wir neu berechnen ist der vorherige bevor wir diesen Punkte setzen
                  if (KineticPoint.getRecalc() === true) {
                      KineticPoint.setX1(floatX);
                      KineticPoint.setY1(floatY);

                      //Wir mssen noch den X3/Y3 Wert des vorherigen Punktes korrigieren wenn wir den X1/Y1 Wert an dieser Stelle anpassen
                      var objectPointBefore = arrayPoints[intIndex - 1];

                      //Ist alles korrekt
                      if (objectPointBefore instanceof Kinetic.Point === true) {
                          objectPointBefore.setX3(floatX);
                          objectPointBefore.setY3(floatY);

                          //Dann aktualisieren wir auch diesen Punkt noch einmal!
                          this.updatePoint(intIndex - 1, objectPointBefore);
                      }

                  }

                  // Compute (x, y) coordinates from angle and length
                  floatX += (floatLength * Math.cos(floatRadian));
                  floatY += (floatLength * Math.sin(floatRadian));

                  //Malt einen Halbkreis
                  if (KineticPoint.getUseSemiCircle() === true) {
                      KineticPoint.updateSemiCircle();

                      //Wenn noch nicht hinzugefgt, hinzufgen
                      if (KineticPoint.getSemiCircleAdded() !== true) {
                          this.getLayer().add(KineticPoint.getSemiCircle());
                          KineticPoint.setSemiCircleAdded(true);
                      }

                      //Wir verschieben das Element um die entsprechende Stelle und setzen den Wert von X neu
                      objectSceneContext.moveTo(KineticPoint.getSemiCircle().getMoveX(), KineticPoint.getSemiCircle().getMoveY());

                      //Anpassung der Punkte
                      floatX = KineticPoint.getSemiCircle().getMoveX() + floatLength * Math.cos(floatRadian);
                      floatY = KineticPoint.getSemiCircle().getMoveY() + floatLength * Math.sin(floatRadian);

                      //Damit der Anfangspunkt noch stimmt mssen wir die Werte aktualisieren
                      KineticPoint.setY2(floatY);
                      KineticPoint.setX2(floatX);

                      //Dann setzen wir noch die Farbe
                      KineticPoint.getSemiCircle().setStrokeColor(this.getStroke());
                  } //end Use Semi Sircle

                  //Diese Punkte setzen wir dann im Objekt fest
                  KineticPoint.setX(floatX);
                  KineticPoint.setY(floatY);

                  //Danach setzen wir noch den zweite Koordinaten und beenden damit die neuberechnung des Punkts
                  if (KineticPoint.getRecalc() === true) {
                      KineticPoint.setX2(floatX);
                      KineticPoint.setY2(floatY);
                  }

                  //Und aktualisieren den Punkt bei un sim Array
                  this.updatePoint(intIndex, KineticPoint);

                  //Wenn wir ein Label benutzen, dann aktualiseren wir es
                  if (KineticPoint.getUseLabel()) {
                      //Mit den neugewonnen Daten aktualisieren wir unser Label
                      KineticPoint.updateLabel();

                      //Aber nur wenn es noch nicht hinzugefgt wurde
                      if (KineticPoint.getLabelAdded() !== true && this.getLayer() !== null) {
                          this.getLayer().add(KineticPoint.getLabel());
                          KineticPoint.setLabelAdded(true);
                      }

                      //Dann prfen wir noch ob wir das Verbinungsstck darstellen mssen
                      if (KineticPoint.getUseLabelJoint()) {
                          //Mit den neugewonnen Daten aktualisieren wir unser Joint-Label
                          if (typeof KineticPoint.getLabel().updateJointLabel === 'function') {
                              KineticPoint.getLabel().updateJointLabel();
                          }

                          //Wir holen uns das Label
                          var objectLabelJoint = KineticPoint.getLabelJoint();

                          //Aber nur wenn wir eines haben
                          if (objectLabelJoint !== null) {
                              //Und aktualisieren noch die anderne Daten darin
                              objectLabelJoint.updateCircleBeginnig();
                              objectLabelJoint.updateCircleEnd();

                              //Aber nur wenn es noch nicht hinzugefgt wurde
                              if (KineticPoint.getLabelJointAdded() !== true) {
                                  //Wir fgen das Objekt dem Layer hinzu
                                  this.getLayer().add(objectLabelJoint);
                                  //Lasses es das Objekt wissen, dass es hinzugefgt wurde
                                  KineticPoint.setLabelJointAdded(true);

                                  //Und fgen noch die Punkte/ Kreise ein (Anfang und Ende der Linie)
                                  if (objectLabelJoint.isCircleBeginnigAdded() === false) {
                                      this.getLayer().add(objectLabelJoint.getCircleBeginnig());
                                      objectLabelJoint.setCircleBeginnigAdded(true);
                                  }
                                  if (objectLabelJoint.isCircleEndAdded() === false) {
                                      this.getLayer().add(objectLabelJoint.getCircleEnd());
                                      objectLabelJoint.setCircleEndAdded(true);
                                  }
                              }
                          }
                      }
                  } //end Use Label

                  //Wenn wir ein Winkel benutzen, dann aktualiseren wir es
                  if (KineticPoint.getUseAngleIndicator() && floatLength > 2) {
                      //Mit den neugewonnen Daten aktualisieren wir unseren Winkel
                      KineticPoint.updateAngleIndicator();

                      //Aber nur wenn es noch nicht hinzugefgt wurde
                      if (KineticPoint.getAngleIndicatorAdded() !== true) {
                          this.getLayer().add(KineticPoint.getAngleIndicator());
                          this.getLayer().add(KineticPoint.getAngleIndicator().getLabel().getLine());
                          this.getLayer().add(KineticPoint.getAngleIndicator().getLabel());
                          KineticPoint.setAngleIndicatorAdded(true);
                      }
                  } //end Use Angle Indicator

                  //Die Sichtseite muss/ kann auch eingezeichnet werden
                  if (KineticPoint.getUseVisibleSideArrow()) {
                      //Neue Daten, also aktualiesieren wir den Pfeil
                      KineticPoint.updateVisibleSideArrow();

                      if (KineticPoint.getVisibleSideArrowAdded() !== true && this.getLayer() !== null) {
                          this.getLayer().add(KineticPoint.getVisibleSideArrow());
                          KineticPoint.setVisibleSideArrowAdded(true);
                      }
                  } //end Use Visible Side Arrow

                  //Damit setzen wir dann die Neuberechnung wieder auf false
                  if (KineticPoint.getRecalc() === true)
                      KineticPoint.setRecalc(false);

                  //und zeichnen die Linie
                  objectSceneContext.lineTo(floatX, floatY);
              }

              //Weitere Daten fr den Canvas
              objectSceneContext.lineWidth = this.getLineWidth();
              objectSceneContext.strokeShape(this);

              //und beendet
              objectSceneContext.closePath();
          },
          /**
           * Damit berechnen wir die Punkte im Vektor alle neu (aber ohne sie zu zeichnen)
           * @returns Kinetic.Vector
           */
          fullReCalculation: function () {
              var arrayPoints = this.getPoints();
              //Die Werte auf denen es aufbaut
              var floatX = this.getInitX();
              var floatY = this.getInitY();
              var floatTranslatedX = this.getInitX();
              var floatTranslatedY = this.getInitY();
              //Vorberechenbaren Zahlen
              var floatToRad = (Math.PI / 180);
              var floatHalfPi = (Math.PI / 2);

              //Danach gehen wir alle Punkte durch und versuchen die Werte zu ermitteln
              for (var n = 0; n < arrayPoints.length; n++) {
                  var KineticPoint = arrayPoints[n];

                  //Ist alles korrekt
                  if (KineticPoint instanceof Kinetic.Point === false)
                      continue;

                  var floatAngle = KineticPoint.getAngle();
                  var floatLength = KineticPoint.getLength();
                  var floatTranslatedLength = KineticPoint.getTranslatedLength();

                  // Convert the angle to radians with 0deg starting at north
                  var floatRadian = (floatAngle * floatToRad) - floatHalfPi;

                  //Der erste Punkte den wir neu berechnen ist der vorherige bevor wir diesen Punkte setzen
                  KineticPoint.setX1(floatX);
                  KineticPoint.setY1(floatY);
                  //Wir speichern die bersetzten Punkte
                  KineticPoint.setTranslatedX1(floatTranslatedX);
                  KineticPoint.setTranslatedY1(floatTranslatedY);

                  //Wir mssen noch den X3/Y3 Wert des vorherigen Punktes korrigieren wenn wir den X1/Y1 Wert an dieser Stelle anpassen
                  var objectPointBefore = arrayPoints[n - 1];

                  //Ist alles korrekt
                  if (objectPointBefore instanceof Kinetic.Point === true) {
                      objectPointBefore.setX3(floatX);
                      objectPointBefore.setY3(floatY);
                      //Wir speichern die bersetzten Punkte
                      KineticPoint.setTranslatedX3(floatTranslatedX);
                      KineticPoint.setTranslatedY3(floatTranslatedY);

                      //Dann aktualisieren wir auch diesen Punkt noch einmal!
                      this.updatePoint(n - 1, objectPointBefore);
                  }

                  // Compute (x, y) coordinates from angle and length
                  floatX += (floatLength * Math.cos(floatRadian));
                  floatY += (floatLength * Math.sin(floatRadian));

                  // Compute (x, y) coordinates from angle and length (TRANSLATED)
                  floatTranslatedX += (floatTranslatedLength * Math.cos(floatRadian));
                  floatTranslatedY += (floatTranslatedLength * Math.sin(floatRadian));

                  //Malt einen Halbkreis (wenn wir ihn brauchen)
                  if (KineticPoint.getUseSemiCircle() && KineticPoint.getSemiCircleAdded() === true) {
                      //Anpassung der Punkte
                      floatX = KineticPoint.getSemiCircle().getMoveX() + floatLength * Math.cos(floatRadian);
                      floatY = KineticPoint.getSemiCircle().getMoveY() + floatLength * Math.sin(floatRadian);

                      //Anpassung der Punkte (bersetzt)
                      floatTranslatedX = KineticPoint.getSemiCircle().getMoveX() + floatTranslatedLength * Math.cos(floatRadian);
                      floatTranslatedY = KineticPoint.getSemiCircle().getMoveY() + floatTranslatedLength * Math.sin(floatRadian);

                      //Damit der Anfangspunkt noch stimmt mssen wir die Werte aktualisieren
                      KineticPoint.setY2(floatY);
                      KineticPoint.setX2(floatX);
                      //Wir speichern die bersetzten Punkte
                      KineticPoint.setTranslatedX2(floatTranslatedX);
                      KineticPoint.setTranslatedY2(floatTranslatedY);
                  } //end Use Semi Sircle

                  //Diese Punkte setzen wir dann im Objekt fest
                  KineticPoint.setX(floatX);
                  KineticPoint.setY(floatY);

                  //Wir speichern die bersetzten Punkte
                  KineticPoint.setTranslatedX(floatTranslatedX);
                  KineticPoint.setTranslatedY(floatTranslatedY);

                  //Wir erzwingen eine neu Berechnung, weswegen dieser Wert auch neu berechnet wird
                  KineticPoint.setX2(floatX);
                  KineticPoint.setY2(floatY);
                  //Wir speichern die bersetzten Punkte
                  KineticPoint.setTranslatedX2(floatTranslatedX);
                  KineticPoint.setTranslatedY2(floatTranslatedY);

                  //Und aktualisieren den Punkt bei un sim Array
                  this.updatePoint(n, KineticPoint);
              }

              //Wir geben den Vektor an sich zurck
              return this;
          },
          /**
           *
           * @returns {Array}
           */
          performPointsCheck: function () {
              //Wir holen uns unsere Punkte
              var arrayPoints = this['attrs']['points'];
              var arrayCorrectedPoints = new Array();

              //Dann durchlaufen wir die Schleife
              for (var intN = 0; intN < arrayPoints.length; intN++) {
                  var Point = arrayPoints[intN];
                  //dann prfen wir ob es ein Punkt ist
                  if (Point instanceof Kinetic.Point === true) {
                      arrayCorrectedPoints.push(Point);
                      //weiter gehts
                      continue;
                  }

                  //Wenn wir falsche Daten haben loopen wir weiter
                  if (Point === null || Point === undefined)
                      continue;

                  //Wir fuegen die fehlende Klasse hinzu
                  Point['className'] = 'Point';

                  //Wenn dem nicht so ist, muessen wir den Punkt korrigieren
                  arrayCorrectedPoints.push(new Kinetic.Point(Point));
              }

              //Dann sollte unser Punkt Objekt stimmen
              return this['attrs']['points'] = arrayCorrectedPoints;
          },
          /**
           * @param {Int} intIndex
           * @returns {Kinetic.Point}
           */
          getPointAt: function (intIndex) {
              //unser Punkt
              var KineticPoint = this.getPoints()[parseInt(intIndex)];
              //wir prfen ob der Punkt existiert
              if (typeof KineticPoint === 'undefined')
                  return null;

              return KineticPoint;
          },
          /**
           * @param {Int} intIndex
           * @param {Kinetic.Point} KineticPoint
           *
           * @returns {Kinetic.Point}
           */
          updatePoint: function (intIndex, KineticPoint) {
              //Wir prfen ob ein Punkt an dieser Stelle existieren kann
              if (typeof this.getPoints()[parseInt(intIndex)] === 'undefined')
                  return false;

              //Wenn nicht dann knnen wir ihn ja aktualsieren
              this.getPoints()[parseInt(intIndex)] = KineticPoint;

              //Den selben Punkt geben wir zurck
              return KineticPoint;
          },
          /**
           *
           * @param {Int} intIndex
           * @param {Kinetic.Point} KineticPoint
           * @returns {Kinetic.Point}
           */
          addPointAt: function (intIndex, KineticPoint) {
              if (KineticPoint instanceof Kinetic.Point === false) {
                  return false;
              }

              //Ansonsten fuegen wir den neuen Punkt hinzu
              this.getPoints()[parseInt(intIndex)] = KineticPoint;

              //Wir geben den aktuellen Punkt zurck
              return KineticPoint;
          },
          /**
           * Entfernt einen Punkt aus dem Vektor an der Stelle intIndex
           *
           * @param {Int} intIndex
           * @returns {Boolean}
           */
          removePointAt: function (intIndex) {
              //Unser Punkt
              var KineticPoint = this.getAttr('points')[parseInt(intIndex)];

              //Wir prfen ob ein Punkt an dieser Stelle existieren kann
              if (KineticPoint instanceof Kinetic.Point === false) {
                  return false;
              }

              //Damit das Label verschwindet
              if (KineticPoint.getUseLabel()) {
                  KineticPoint.getLabel().hide();

                  //Wenn das Label verschoben wurde mssen wir es auch entfernen
                  if (KineticPoint.getUseLabelJoint()) {
                      KineticPoint.getLabelJoint().hide();
                      KineticPoint.getLabelJoint().getCircleBeginnig().hide();
                      KineticPoint.getLabelJoint().getCircleEnd().hide();
                  }
              }
              //Damit der Winkel verschwindet
              if (KineticPoint.getUseAngleIndicator()) {
                  KineticPoint.getAngleIndicator().hide();
                  KineticPoint.getAngleIndicator().getLabel().hide();
                  KineticPoint.getAngleIndicator().getLabel().getLine().hide();
              }
              //Damit das auch verschwindet
              if (KineticPoint.getUseSemiCircle())
                  KineticPoint.getSemiCircle().hide();

              //Damit das auch verschwindet
              if (KineticPoint.getUseSemiCircle())
                  KineticPoint.getSemiCircle().hide();

              //Ansonsten probieren wir es mit Delete
              delete this.getPoints()[parseInt(intIndex)];

              //Und geben ein Positives Ergebnis zurck
              return true;
          },
          /**
           * Entfernt alle Punkte aus diesem Vektor
           *
           * @returns Boolean
           */
          removeAllPoints: function () {
              //Wir durchlaufen alle Punkte und entfernen die dazugehrigen Elemente
              var arrayKineticPoints = this.getPoints();

              //Array durchlaufen und alle Punkte ausblenden
              for (var n = 0, pL = arrayKineticPoints.length; n < pL; n++) {
                  var KineticPoint = arrayKineticPoints[n];

                  //Wir prfen ob ein Punkt an dieser Stelle existieren kann
                  if (KineticPoint instanceof Kinetic.Point !== true)
                      continue;

                  //Damit das Label verschwindet
                  if (KineticPoint.getUseLabel())
                      KineticPoint.getLabel().hide();
                  //Damit der Winkel verschwindet
                  if (KineticPoint.getUseAngleIndicator()) {
                      KineticPoint.getAngleIndicator().hide();
                      KineticPoint.getAngleIndicator().getLabel().hide();
                      KineticPoint.getAngleIndicator().getLabel().getLine().hide();
                  }
                  //Damit das auch verschwindet
                  if (KineticPoint.getUseSemiCircle())
                      KineticPoint.getSemiCircle().hide();
              }

              //Danach die Punkte komplett zurcksetzen
              this['attrs']['points'] = new Array();

              //Gibt true zurck weil hier eigentlich nichts schief gehen kann
              return true;
          },
          /**
           * Wirft eventuelle unpassende Werte aus dem Array bevor es zurckgegebn wird
           * @returns Kinetic.Point[]
           */
          getPoints: function () {
              var arrayPoints = this['attrs']['points'];

              if (!Kinetic.Util._isArray(arrayPoints)) {
                  return this['attrs']['points'] = new Array();
              }

              //erst wandeln
              arrayPoints.reverse();

              //Dann schauen wir ob das Element null ist und werfen es raus
              if (arrayPoints[0] === null)
                  arrayPoints.shift();

              //erst wandeln
              arrayPoints.reverse();

              //Dann zurck
              return this['attrs']['points'] = arrayPoints;
          }
      };

      //Wir erben unsere Eigenschaften von Kinetic.Shape
      Kinetic.Util.extend(Kinetic.Vector, Kinetic.Shape);

      //Ausgangspunkte
      Kinetic.Factory.addGetterSetter(Kinetic.Vector, 'initX', 0);
      Kinetic.Factory.addGetterSetter(Kinetic.Vector, 'initY', 0);

      //Die Referenz auf unseren Layer
      Kinetic.Factory.addGetterSetter(Kinetic.Vector, 'layer', null);

      //Die Sichtseite
      Kinetic.Factory.addGetterSetter(Kinetic.Vector, 'visibleSide', '');

      //Die Strke der Linie
      Kinetic.Factory.addGetterSetter(Kinetic.Vector, 'lineWidth', 1);

      //bersetzt (Ja/Nein)
      Kinetic.Factory.addGetterSetter(Kinetic.Vector, 'translated', false);

      //Darin speichern wir unsere Punkte
      Kinetic.Factory.addGetterSetter(Kinetic.Vector, 'points', new Array);
  })();

  /**
   * KineticJS JavaScript Framework v5.0.1
   * http://www.kineticjs.com/
   *
   * @name 2-Point-1.1.6.js
   * @version 1.1.7
   *
   * @author Sino Boeckmann <sino.boeckmann@aufwind.cc>
   * @copyright 2013-2014 Werbeagentur aufwind. GmbH
   */

  (function() {
      /**
       * @constructor
       * @augments Kinetic.Shape
       * @param {Object} objectConfig
       */
      Kinetic.Point = function(objectConfig) {
          this.___init(objectConfig);
      };

      /**
       * @prototype
       */
      Kinetic.Point.prototype = {
          /**
           * Konstruktor
           *
           * @param {Object} objectConfig
           */
          ___init: function(objectConfig) {
              objectConfig = objectConfig || new Object;

              // call super constructor
              Kinetic.Node.call(this, objectConfig);

              this.eventListeners = new Object();
              this.className = 'Point';
              this.setInitConfig(objectConfig);

              //Falls schon Daten existieren mssen wir diese zurcksetzen
              this.setAngleIndicatorAdded(false);
              this.setVisibleSideArrowAdded(false);
              this.setLabelAdded(false);

              //Benutzen wir es?
              this.setUseLabel(objectConfig['useLabel'] || false);
              this.setUseAngleIndicator(objectConfig['useAngleIndicator'] || false);

              //Wenn die Config sagt dass wir ein Label erstellen sollen
              if (objectConfig['useLabel'] === true)
                  this.createLabel(objectConfig['labelConfig'] || new Object());

              //Wenn die Config sagt dass wir ein Label erstellen sollen
              if (objectConfig['useAngleIndicator'] === true)
                  this.createAngleIndicator(objectConfig['angleIndicatorConfig'] || new Object());

              //Damit koennen wir die Sichtseite einzeichnen (ein Pfeil)
              if (objectConfig['useVisibleSideArrow'] === true)
                  this.createVisibleSideArrow(objectConfig['visibleSideArrowConfig'] || new Object());

              //Damit koennen wir die Sichtseite einzeichnen (ein Pfeil)
              if (objectConfig['useSemiCircle'] === true)
                  this.createSemiCircle(objectConfig['semiCircleConfig'] || new Object());
          },
          /**
           * Erstellt das Label zu diesem Punkt
           *
           * @param {Object} objectLabelConfig
           * @returns {Kinetic.Text}
           */
          createLabel: function(objectLabelConfig) {
              //Unsere Standard-Config
              objectLabelConfig = $.extend(true, {
                  /**
                   * @type {Object}
                   */
                  tagConfig: {
                      fill: 'rgba(255,255,255,0.9)'
                  },
                  /**
                   * @type {Object}
                   */
                  textConfig: {
                      fontSize: 12,
                      fill: '#000'
                  },
                  /**
                   * @type {Float}
                   */
                  jointLabelOffset: 5.,
                  /**
                   * @type {Boolean}
                   */
                  listening: true,
                  /**
                   * @type {Boolean}
                   */
                  refPoint: this,
                  /**
                   * @type {Boolean}
                   */
                  draggable: false,
                  /**
                   * @type {Boolean}
                   */
                  dragged: false,
                  /**
                   * @param {Object} objectPoisition
                   * @returns {Object}
                   */
                  dragBoundFunc: function(objectPoisition) {
                      //Wir speichern uns kurz die Koordinaten zwischen
                      var floatNewLabelX = objectPoisition['x'];
                      var floatNewLabelY = objectPoisition['y'];

                      //Wenn wir uns noch nicht bewegt haben, nehmen wir die Daten des Labels
                      //diese sind genauer, auch wenn im maximized-Modus sind
                      if (this.getDragged() !== true) {
                          floatNewLabelX = this.getX();
                          floatNewLabelY = this.getY();
                      }

                      //Wir haben dieses Label verschoben, damit updaten wir es nicht mehr durch unsere Methoden
                      this.setDragged(true);

                      //Das Label darf nur im selben Winkel weggeschoben werden
                      var objectPoint = this.getRefPoint();

                      if (objectPoint.getLabelJointAdded() === false) {
                          //Wir holen uns die Offest-Konfiguration aus dem Label
                          var floatJointLabelOffset = objectLabelConfig['jointLabelOffset'];

                          //Unsere Konfiguration
                          var objectJointLineConfig = $.extend(true, {
                              points: [
                                  floatNewLabelX + floatJointLabelOffset,
                                  floatNewLabelY + floatJointLabelOffset,
                                  floatNewLabelX + floatJointLabelOffset,
                                  floatNewLabelY + floatJointLabelOffset
                              ],
                              stroke: '#504E52',
                              strokeWidth: objectPoint.getLineWidth() / 2,
                              refPoint: this,
                              circleBeginningAdded: false,
                              circleBeginning: null,
                              circleEndAdded: false,
                              circleEnd: null
                          },
                          (objectLabelConfig['jointLabel'] || new Object));

                          //Wir erstellen das Label
                          var objectLabelJoint = new Kinetic.Line(objectJointLineConfig);

                          //Der Punkt am Anfang der Linie
                          (function() {
                              //Wir erweitern unsere Konfiguration
                              var objectJointLabelCircleConfig = $.extend(true, {
                                  radius: 2.5,
                                  fill: '#504E52',
                                  refPoint: objectLabelJoint,
                                  x: floatNewLabelX + floatJointLabelOffset,
                                  y: floatNewLabelY + floatJointLabelOffset
                              },
                              (objectJointLineConfig['circleBeginning'] || new Object));

                              //Wir erstellen unseren Punkt
                              objectLabelJoint['attrs']['circleBeginning'] = new Kinetic.Circle(objectJointLabelCircleConfig);
                              /**
                               * @returns {Boolean}
                               */
                              objectLabelJoint.isCircleBeginnigAdded = function() {
                                  return this['attrs']['circleBeginningAdded'];
                              };
                              /**
                               * @param {Boolean} booleanAdded
                               * @returns {Boolean}
                               */
                              objectLabelJoint.setCircleBeginnigAdded = function(booleanAdded) {
                                  return this['attrs']['circleBeginningAdded'] = booleanAdded || false;
                              };
                              /**
                               * @returns {Kinetic.Circle}
                               */
                              objectLabelJoint.getCircleBeginnig = function() {
                                  return this['attrs']['circleBeginning'];
                              };
                              /**
                               * @returns {Kinetic.Circle}
                               */
                              objectLabelJoint.updateCircleBeginnig = function() {
                                  var objectCircle = this.getCircleBeginnig();

                                  //Aber nur wenn es existiert
                                  if (objectCircle instanceof Kinetic.Circle !== true)
                                      return false;

                                  //Damit wir es abfangen koennen und weiter bearbeiten koennen
                                  objectCircle.fire('update', this);

                                  //Lief ja gut. :)
                                  return true;
                              };
                              /**
                               * Dann fuegen wir diesem Label einen Getter hinzu um den Punkt zu bekommen
                               * @returns {Kinetic.Circle}
                               */
                              objectLabelJoint['attrs']['circleBeginning']['getRefPoint'] = function() {
                                  return this['attrs']['refPoint'] || null;
                              };

                              //Wir fgen die Listener hinzu
                              var objectListener = objectJointLabelCircleConfig['listener'] ||new Object;

                              //Wir gehen die Listener im Objekt durch
                              for (var mixedIndex in objectListener) {
                                  if (typeof objectListener[mixedIndex] === 'function')
                                      objectLabelJoint['attrs']['circleBeginning'].on(mixedIndex, objectListener[mixedIndex]);
                              }
                          })();

                          //Der Punkt am Anfang der Linie
                          (function() {
                              //Wir erweitern unsere Konfiguration
                              var objectJointLabelCircleConfig = $.extend(true, {
                                  radius: 2,
                                  fill: '#504E52',
                                  refPoint: objectLabelJoint,
                                  x: floatNewLabelX + (floatJointLabelOffset * 2),
                                  y: floatNewLabelY + (floatJointLabelOffset * 2)
                              },
                              (objectJointLineConfig['circleEnd'] || new Object));

                              //Wir erstellen unseren Punkt
                              objectLabelJoint['attrs']['circleEnd'] = new Kinetic.Circle(objectJointLabelCircleConfig);
                              /**
                               * @returns {Boolean}
                               */
                              objectLabelJoint.isCircleEndAdded = function() {
                                  return this['attrs']['circleEndAdded'];
                              };
                              /**
                               * @param {Boolean} booleanAdded
                               * @returns {Boolean}
                               */
                              objectLabelJoint.setCircleEndAdded = function(booleanAdded) {
                                  return this['attrs']['circleEndAdded'] = booleanAdded || false;
                              };
                              /**
                               * @returns {Kinetic.Circle}
                               */
                              objectLabelJoint.getCircleEnd = function() {
                                  return this['attrs']['circleEnd'];
                              };
                              /**
                               * @returns {Boolean}
                               */
                              objectLabelJoint.updateCircleEnd = function() {
                                  var objectCircle = this.getCircleEnd();

                                  //Aber nur wenn es existiert
                                  if (objectCircle instanceof Kinetic.Circle !== true)
                                      return false;

                                  //Damit wir es abfangen koennen und weiter bearbeiten koennen
                                  objectCircle.fire('update', this);

                                  //Lief ja gut. :)
                                  return true;
                              };
                              /**
                               * Dann fuegen wir diesem Label einen Getter hinzu um den Punkt zu bekommen
                               * @returns {Kinetic.Circle}
                               */
                              objectLabelJoint['attrs']['circleEnd'].getRefPoint = function() {
                                  return this['attrs']['refPoint'] || null;
                              };

                              //Wir fgen die Listener hinzu
                              var objectListener = objectJointLabelCircleConfig['listener'] ||new Object;

                              //Wir gehen die Listener im Objekt durch
                              for (var mixedIndex in objectListener) {
                                  if (typeof objectListener[mixedIndex] === 'function')
                                      objectLabelJoint['attrs']['circleEnd'].on(mixedIndex, objectListener[mixedIndex]);
                              }
                          })();

                          //Wir fgen die Listener hinzu
                          var objectListener = objectJointLineConfig['listener'] ||new Object;

                          //Wir gehen die Listener im Objekt durch
                          for (var mixedIndex in objectListener) {
                              if (typeof objectListener[mixedIndex] === 'function')
                                  objectLabelJoint.on(mixedIndex, objectListener[mixedIndex]);
                          }

                          /**
                           * Dann fuegen wir diesem Label einen Getter hinzu um den Punkt zu bekommen
                           * @returns {Kinetic.Line}
                           */
                          objectLabelJoint.getRefPoint = function() {
                              return this['attrs']['refPoint'] || null;
                          };

                          //Damit wei der Vector beim Zeichnen bescheid, dass wir diese Linie zeichnen mssen
                          objectPoint.setUseLabelJoint(true);

                          //Das Label setzen wir als Objekt direkt in das Wedge Objekt
                          objectPoint.setLabelJoint(objectLabelJoint);

                          /**
                           * @returns {Boolean}
                           */
                          this.updateJointLabel = function() {
                              var objectJointLabel = objectPoint.getLabelJoint();

                              //Aber nur wenn es existiert
                              if (objectJointLabel instanceof Kinetic.Line !== true)
                                  return false;

                              //Damit wir es abfangen koennen und weiter bearbeiten koennen
                              objectJointLabel.fire('update', this);

                              //Lief ja gut. :)
                              return true;
                          };
                      }
                      else {
                          var objectLabelJoint = objectPoint.getLabelJoint();
                          if (objectLabelJoint !== null)
                              objectLabelJoint.fire('update', objectPoint);
                      }

                      //Und geben das Punkt-Objekt zurck
                      return objectPoisition;
                  }
              },
              (objectLabelConfig || new Object));

              //Wir erstellen das Label
              var objectLabel = new Kinetic.Label(objectLabelConfig);

              /**
               * 4.5.2 May 21 2013
               * API changes
               * Label config API was rewritten. You now need to instantiate individual Text and Tag shapes, and then add them to the Label group. Please check the tutorials for examples.
               */
              objectLabel.add(new Kinetic.Tag(objectLabelConfig['tagConfig']));
              objectLabel.add(new Kinetic.Text(objectLabelConfig['textConfig']));

              //Wir fgen die Listener hinzu
              var objectListener = objectLabelConfig['listener'] ||new Object;

              //Wir gehen die Listener im Objekt durch
              for (var mixedIdx in objectListener) {
                  if (typeof objectListener[mixedIdx] === 'function')
                      objectLabel.on(mixedIdx, objectListener[mixedIdx]);
              }

              /**
               * Dann fuegen wir diesem Label einen Getter hinzu um den Punkt zu bekommen
               * @returns {Kinetic.Label}
               */
              objectLabel.getRefPoint = function() {
                  return this['attrs']['refPoint'] || null;
              };

              /**
               * Die interne getId-Methode scheint nicht korrekt zu funktionieren, daher berschreiben wir dieser hier
               * @returns {Int}
               */
              objectLabel.getId = function() {
                  return this['_id'] || -1;
              };

              /**
               * @param {Boolean} boolDragged
               * @returns {Boolean}
               */
              objectLabel.setDragged = function(boolDragged) {
                  return this['attrs']['dragged'] = boolDragged;
              };

              /**
               * @returns {Boolean}
               */
              objectLabel.getDragged = function() {
                  return this['attrs']['dragged'];
              };

              //Dann setzen wir das Label fest
              return this['attrs']['label'] = objectLabel;
          },
          /**
           * Aktualisiert das Label eigenstndig
           *
           * @returns {Boolean}
           */
          updateLabel: function() {
              var objectLabel = this.getLabel();

              //Aber nur wenn es existiert
              if (objectLabel instanceof Kinetic.Label !== true)
                  return false;

              //Damit wir es abfangen koennen und weiter bearbeiten koennen
              objectLabel.fire('update', this);

              //Lief ja gut. :)
              return true;
          },
          /**
           * Erstellt einen Prozentkreis fr die Winkeldarstellung
           *
           * @param {Object} objectConfig
           * @returns {Kinetic.Wedge}
           */
          createAngleIndicator: function(objectConfig) {
              //Unsere Standard-Config
              objectConfig = $.extend(true, {
                  x: 0,
                  y: 0,
                  radius: 30,
                  angleDeg: 0,
                  rorationDeg: 0,
                  strokeWidth: this.getLineWidth(),
                  visible: false,
                  refPoint: this,
                  /**
                   * Um die Gradzahl zu notieren brauchen wir noch ein Label
                   */
                  label: null
              },
              (objectConfig || new Object));

              //Wir erstellen das Label
              var objectAngleIndicator = new Kinetic.Wedge(objectConfig);
              var objectListener = objectConfig['listener'] ||new Object;

              //Dann fuegen wir diesem Label einen Getter hinzu um den Punkt zu bekommen
              objectAngleIndicator.getRefPoint = function() {
                  return this['attrs']['refPoint'] || null;
              };

              //Das fuegen wir dann hinzu
              //Unsere Standard-Config
              var objectLabelConfig = $.extend(true, {
                  offset: -10,
                  text: {
                      fontSize: 12,
                      padding: 5,
                      fill: '#000',
                      align: 'center'
                  },
                  rect: {
                      fill: 'transparent'
                  },
                  circle: {
                      radius: 15,
                      fill: 'transparent',
                      visible: false,
                      shadowColor: '#000',
                      shadowBlur: 5,
                      shadowOpacity: .25
                  },
                  refPoint: objectAngleIndicator
              },
              (objectConfig['labelConfig'] || new Object));

              //Wir erstellen das Label
              var objectWedgeLabel = new Kinetic.Label(objectLabelConfig);

              //---- Circle
              var objectLineConfig = $.extend(true, {
                  refPoint: objectAngleIndicator.getRefPoint()
              },
              (objectLabelConfig['circle'] || new Object));

              //Wir erstellen das Label
              var objectWedgeCircleTag = new Kinetic.Circle(objectLineConfig);

              //Das Label setzen wir als Objekt direkt in das Wedge Objekt
              objectWedgeLabel['attrs']['circleTag'] = objectWedgeCircleTag;

              //Dann fuegen wir noch einen Getter hinzu um das Objekt zu bekommen
              objectWedgeLabel.getCircleTag = function() {
                  return this['attrs']['circleTag'] || null;
              };

              objectWedgeLabel.add(objectWedgeCircleTag);

              /**
               * 4.5.2 May 21 2013
               * API changes
               * Label config API was rewritten. You now need to instantiate individual Text and Tag shapes, and then add them to the Label group. Please check the tutorials for examples.
               */
              //Das fuegen wir dann hier hinzu
              objectWedgeLabel.add((function() {
                  var objectText = new Kinetic.Text($.extend(true, {
                      refPoint: objectAngleIndicator.getRefPoint()
                  },
                  objectLabelConfig['text']));

                  //Dann fuegen wir diesem Label einen Getter hinzu um den Punkt zu bekommen
                  objectText.getRefPoint = function() {
                      return this['attrs']['refPoint'] || null;
                  };

                  //Das Label setzen wir als Objekt direkt in das Wedge Objekt
                  objectText['attrs']['label'] = objectWedgeLabel;

                  //Dann fuegen wir noch einen Getter hinzu um das Objekt zu bekommen
                  objectText.getLabel = function() {
                      return this['attrs']['label'] || null;
                  };

                  for (var mixedIdx in objectListener) {
                      if (typeof objectListener[mixedIdx] === 'function')
                          objectText.on(mixedIdx, objectListener[mixedIdx]);
                  }

                  return objectText;
              })());

              //Das Label setzen wir als Objekt direkt in das Wedge Objekt
              objectAngleIndicator['attrs']['label'] = objectWedgeLabel;

              //Dann fuegen wir noch einen Getter hinzu um das Objekt zu bekommen
              objectAngleIndicator.getLabel = function() {
                  return this['attrs']['label'] || null;
              };

              //---- Line
              var objectLineConfig = $.extend(true, {
                  points: [
                      0,
                      0
                  ],
                  stroke: '#000',
                  strokeWidth: this.getLineWidth(),
                  refPoint: objectWedgeLabel
              },
              (objectConfig['lineConfig'] || new Object));

              //Wir erstellen das Label
              var objectWedgeLine = new Kinetic.Line(objectLineConfig);

              //Das Label setzen wir als Objekt direkt in das Wedge Objekt
              objectWedgeLabel['attrs']['line'] = objectWedgeLine;

              //Dann fuegen wir noch einen Getter hinzu um das Objekt zu bekommen
              objectWedgeLabel.getLine = function() {
                  return this['attrs']['line'] || null;
              };

              //---- Normal weiter

              //Dann fuegen wir diesem Label einen Getter hinzu um den Punkt zu bekommen
              objectAngleIndicator.getRefPoint = function() {
                  return this['attrs']['refPoint'] || null;
              };

              /**
               * Wir gehen die Listener im Objekt durch
               */
              for (var mixedIdx in objectListener) {
                  if (typeof objectListener[mixedIdx] === 'function')
                      objectAngleIndicator.on(mixedIdx, objectListener[mixedIdx]);
              }

              //Dann setzen wir das Label fest
              return this['attrs']['angleIndicator'] = objectAngleIndicator;
          },
          /**
           * Aktualisiert die Winkelanzeige eigenstndig
           *
           * @returns Boolean
           */
          updateAngleIndicator: function() {
              var objectAngleIndicator = this.getAngleIndicator();

              //Aber nur wenn es existiert
              if (objectAngleIndicator instanceof Kinetic.Wedge !== true)
                  return false;

              //Damit wir es abfangen koennen und weiter bearbeiten koennen
              objectAngleIndicator.fire('update', this);

              //Lief ja gut. :)
              return true;
          },
          /**
           * @param {Object} objectConfig
           * @returns {Kinetic.Image}
           */
          createVisibleSideArrow: function(objectConfig) {
              var self = this;

              //Unsere Standard-Config
              objectConfig = $.extend(true, {
                  x: 0,
                  y: 0,
                  image: (function() {
                      var objectImg = new Image();
                      objectImg.onerror = function() {
                          return console.warn(self.getVisibleSideArrowSource() + ' File not found. The Plugin will not work regularly!');
                      };
                      objectImg.src = self.getVisibleSideArrowSource() || '';
                      return objectImg;
                  })(),
                  width: 26,
                  height: 31,
                  listening: true,
                  refPoint: this
              },
              (objectConfig || new Object));

              //Wir erstellen das Label
              var objectVisibleSideArrow = new Kinetic.Image(objectConfig);
              var objectListener = objectConfig['listener'] ||new Object;

              //Dann fuegen wir diesem Label einen Getter hinzu um den Punkt zu bekommen
              objectVisibleSideArrow.getRefPoint = function() {
                  return this['attrs']['refPoint'] || null;
              };

              //Wir gehen die Listener im Objekt durch
              for (var mixedIdx in objectListener) {
                  if (typeof objectListener[mixedIdx] === 'function')
                      objectVisibleSideArrow.on(mixedIdx, objectListener[mixedIdx]);
              }

              //Dann setzen wir das Label fest
              return this['attrs']['visibleSideArrow'] = objectVisibleSideArrow;
          },
          /**
           * Aktualisiert den Pfeil auf die Sichtseite
           *
           * @returns Boolean
           */
          updateVisibleSideArrow: function() {
              var objectVisibleSideArrow = this.getVisibleSideArrow();

              //Aber nur wenn es existiert
              if (objectVisibleSideArrow instanceof Kinetic.Image !== true)
                  return false;

              //Damit wir es abfangen koennen und weiter bearbeiten koennen
              objectVisibleSideArrow.fire('update', this);

              //Lief ja gut. :)
              return true;
          },
          /**
           * Erstellt einen Halbkreis
           *
           * @param {Object} objectConfig
           * @returns {Kinetic.SemiCircle}
           */
          createSemiCircle: function(objectConfig) {
              //Unsere Standard-Config
              objectConfig = $.extend(true, {
                  listening: true,
                  refPoint: this
              },
              (objectConfig || new Object));

              //Dann erstellen wir unser Objekt
              var objectSemiCircle = new Kinetic.SemiCircle(objectConfig);

              //Aus der Config ziehen wir uns noch die Listener
              var objectListener = objectConfig['listener'] ||new Object;

              //Wir gehen die Listener im Objekt durch
              for (var mixedIdx in objectListener) {
                  if (typeof objectListener[mixedIdx] === 'function')
                      objectSemiCircle.on(mixedIdx, objectListener[mixedIdx]);
              }

              //Dann fuegen wir diesem Label einen Getter hinzu um den Punkt zu bekommen
              objectSemiCircle.getRefPoint = function() {
                  return this['attrs']['refPoint'] || null;
              };

              //Damit das auch alles klappt, blenden wir ihn vorsichtshalber wieder ein
              objectSemiCircle.show();

              //
              return this['attrs']['semiCircle'] = objectSemiCircle;
          },
          /**
           * Aktualisiert den Halbkreis wenn er aktiviert wurde/ ist
           * @returns {Boolean}
           */
          updateSemiCircle: function() {
              var objectSemiCircle = this.getSemiCircle();

              //Aber nur wenn es existiert
              if (objectSemiCircle instanceof Kinetic.SemiCircle !== true)
                  return false;

              //Damit wir es abfangen koennen und weiter bearbeiten koennen
              objectSemiCircle.fire('update', this);

              //Lief ja gut. :)
              return true;
          },
          /**
           * Entfernt den Halbkreis wieder aus diesem Punkt
           * @returns {Boolean}
           */
          removeSemiCircle: function() {
              this.getSemiCircle().hide();
              this.setSemiCircle(null);
              this.setUseSemiCircle(false);
              this.setSemiCircleAdded(false);
          },
          /**
           * Damit berschreiben wir die JSON Funktion in UTIL um diese fr dieses Objekt besser darzustellen
           * @returns {Object}
           */
          toJSON: function() {
              //Wir mssen die aktuelel Config in diese hinein mergen und Elemente daraus entfernen, sonst klappt das nicht
              var objectConfig = Kinetic.Util._merge(this.toObject()['attrs'], this.getInitConfig());

              //In diesem Hack mssen wir das nachtrgliche Hinzufgen des "SemiCircle" nachvollziehen
              if (this.getUseSemiCircle() === true && this.getSemiCircleAdded()) {
                  var objectSemiCircleConfig = this.getSemiCircle().toObject()['attrs'];
                  //Damit das Objekt bei der ReINITalisierung auch wieder korrekt erstellt wird
                  objectConfig['semiCircleConfig'] = objectSemiCircleConfig;
                  objectConfig['semiCircleAdded'] = false;
                  objectConfig['useSemiCircle'] = true;
              }

              //Die Initialconfig ist hier wichtiger, damit die Elemente auch korrekt erstellt werden knnen
              return objectConfig;
          }
      };

      //Register
      Kinetic.Util.extend(Kinetic.Point, Kinetic.Node);

      //Winkel
      Kinetic.Factory.addGetterSetter(Kinetic.Point, 'angle', 0);
      //Winkel Differenz zum Vorgnger
      Kinetic.Factory.addGetterSetter(Kinetic.Point, 'relativeAngle', 0);
      //Winkel Differenz zum Vorgnger korrigiert
      Kinetic.Factory.addGetterSetter(Kinetic.Point, 'relativeAngleCorrected', 0);
      Kinetic.Factory.addGetterSetter(Kinetic.Point, 'relativeAngleCorrectionValue', 0);
      Kinetic.Factory.addGetterSetter(Kinetic.Point, 'wasRelativeAngleCorrected', false);

      //Lnge
      Kinetic.Factory.addGetterSetter(Kinetic.Point, 'length', 0);
      //Lnge (Nicht Mastabsgetreu)
      Kinetic.Factory.addGetterSetter(Kinetic.Point, 'translatedLength', 0);
      Kinetic.Factory.addGetterSetter(Kinetic.Point, 'beforeTranslationLength', 0);

      //Berechneter Punkt (Start)
      Kinetic.Factory.addGetterSetter(Kinetic.Point, 'x', 0);
      Kinetic.Factory.addGetterSetter(Kinetic.Point, 'y', 0);

      //Berechneter Punkt (Start)
      Kinetic.Factory.addGetterSetter(Kinetic.Point, 'x1', 0);
      Kinetic.Factory.addGetterSetter(Kinetic.Point, 'y1', 0);

      //Berechneter Punkt (Ende) (Temporr)
      Kinetic.Factory.addGetterSetter(Kinetic.Point, 'x2', 0);
      Kinetic.Factory.addGetterSetter(Kinetic.Point, 'y2', 0);

      //Berechneter Punkt letzter Punkt
      Kinetic.Factory.addGetterSetter(Kinetic.Point, 'x3', 0);
      Kinetic.Factory.addGetterSetter(Kinetic.Point, 'y3', 0);

      //Die Koordinaten speichern wir alle noch einmal auch fr die bersetzte Lnge
      //// [-- START
      Kinetic.Factory.addGetterSetter(Kinetic.Point, 'translatedX', 0);
      Kinetic.Factory.addGetterSetter(Kinetic.Point, 'translatedY', 0);
      Kinetic.Factory.addGetterSetter(Kinetic.Point, 'translatedX1', 0);
      Kinetic.Factory.addGetterSetter(Kinetic.Point, 'translatedY1', 0);
      Kinetic.Factory.addGetterSetter(Kinetic.Point, 'translatedX2', 0);
      Kinetic.Factory.addGetterSetter(Kinetic.Point, 'translatedY2', 0);
      Kinetic.Factory.addGetterSetter(Kinetic.Point, 'translatedX3', 0);
      Kinetic.Factory.addGetterSetter(Kinetic.Point, 'translatedY3', 0);
      //// END --]

      //Zugehriger Step
      Kinetic.Factory.addGetterSetter(Kinetic.Point, 'step', 0);

      //Label
      Kinetic.Factory.addGetter(Kinetic.Point, 'label', null);
      Kinetic.Factory.addGetterSetter(Kinetic.Point, 'useLabel', false);
      Kinetic.Factory.addGetterSetter(Kinetic.Point, 'labelAdded', false);
      //Drag'n'Drop Verbindungsstrck zwischen Label "Neue" und "Alte" Position
      Kinetic.Factory.addGetterSetter(Kinetic.Point, 'labelJoint', null);
      Kinetic.Factory.addGetterSetter(Kinetic.Point, 'labelJointAdded', false);
      Kinetic.Factory.addGetterSetter(Kinetic.Point, 'useLabelJoint', false);

      //AngleIndicator
      Kinetic.Factory.addGetter(Kinetic.Point, 'angleIndicator', null);
      Kinetic.Factory.addGetterSetter(Kinetic.Point, 'useAngleIndicator', false);
      Kinetic.Factory.addGetterSetter(Kinetic.Point, 'angleIndicatorAdded', false);

      //VisibleSideArrow
      Kinetic.Factory.addGetter(Kinetic.Point, 'visibleSideArrow', null);
      Kinetic.Factory.addGetterSetter(Kinetic.Point, 'useVisibleSideArrow', false);
      Kinetic.Factory.addGetterSetter(Kinetic.Point, 'visibleSideArrowAdded', false);

      //Damit wir abgleichen knnen welche Grafik-Source genutzt werden soll
      Kinetic.Factory.addGetterSetter(Kinetic.Point, 'visibleSideArrowSource', null);

      //Sollen wir den Punkt neuzeichnen?
      Kinetic.Factory.addGetterSetter(Kinetic.Point, 'recalc', false);

      //Linienstrke
      Kinetic.Factory.addGetterSetter(Kinetic.Point, 'lineWidth', 1);

      //Ist dieser Punkt mit einem anderen durch einen Halbkreis verbunden?
      Kinetic.Factory.addGetterSetter(Kinetic.Point, 'semiCircle', null);
      Kinetic.Factory.addGetterSetter(Kinetic.Point, 'semiCircleAdded', false);
      Kinetic.Factory.addGetterSetter(Kinetic.Point, 'useSemiCircle', false);

      //Wir brauchen die Original-Config um den Punkt wiederherstellen zu knnen
      Kinetic.Factory.addGetterSetter(Kinetic.Point, 'initConfig', new Object());
  })();

  /**
   * KineticJS JavaScript Framework v5.0.1
   * http://www.kineticjs.com/
   *
   * @name 3-SemiCircle-1.1.4.js
   * @version 1.1.4
   *
   * @author Sino Boeckmann <sino.boeckmann@aufwind.cc>
   * @copyright 2013-2014 Werbeagentur aufwind. GmbH
   */

  (function () {
      /**
       * @constructor
       * @augments Kinetic.Shape
       * @param {Object} objectConfig
       */
      Kinetic.SemiCircle = function (objectConfig) {
          this.___init(objectConfig);
      };

      /**
       * @prototype
       */
      Kinetic.SemiCircle.prototype = {
          /**
           * @param {Object} objectConfig
           * @returns {void}
           */
          ___init: function (objectConfig) {
              // call super constructor
              Kinetic.Shape.call(this, objectConfig);

              //Wir setzen den Namen unserer Klasse
              this.className = 'SemiCircle';

              //Und bestimmen die Zeichenfunktion
              this.sceneFunc(this.drawFunc);
          },
          /**
           *
           * @param {Kinetic.SceneContext} objectSceneContext
           * @returns {Kinetic.SceneContext}
           */
          drawFunc: function (objectSceneContext) {
              objectSceneContext = objectSceneContext['_context'];

              //Der Pfad wird gestartet
              objectSceneContext.beginPath();

              //Parameter bergeben
              objectSceneContext.arc(this.getX(), this.getY(), this.getRadius(), this.getStartAngle(), this.getEndAngle(), this.getAntiClockwise());

              //Weitere Daten fr den Canvas
              objectSceneContext.lineWidth = this.getLineWeight() - 1;
              objectSceneContext.strokeStyle = this.getStrokeColor();
              objectSceneContext.stroke();

              //und beendet
              objectSceneContext.closePath();
          }
      };

      //Wir erweitern das Objekt aus der "Schablone"
      Kinetic.Util.extend(Kinetic.SemiCircle, Kinetic.Shape);

      //Fuegen entsprechende Getter & Setter hinzu
      Kinetic.Factory.addGetterSetter(Kinetic.SemiCircle, 'radius', 10);
      Kinetic.Factory.addGetterSetter(Kinetic.SemiCircle, 'startAngle', Math.PI);
      Kinetic.Factory.addGetterSetter(Kinetic.SemiCircle, 'endAngle', 0);
      Kinetic.Factory.addGetterSetter(Kinetic.SemiCircle, 'antiClockwise', false);
      Kinetic.Factory.addGetterSetter(Kinetic.SemiCircle, 'lineWeight', 1);
      Kinetic.Factory.addGetterSetter(Kinetic.SemiCircle, 'strokeColor', '#000000');

      //Darin speichern wir auch die Punkte fr die neue Berechnung
      Kinetic.Factory.addGetterSetter(Kinetic.SemiCircle, 'moveX', 0);
      Kinetic.Factory.addGetterSetter(Kinetic.SemiCircle, 'moveY', 0);
  })();

  /**
   * KineticJS JavaScript Framework v5.0.1
   * http://www.kineticjs.com/
   *
   * @name 4-ExtendedLine-1.0.0.js
   * @version 1.0.0
   *
   * @author Sino Boeckmann <sino.boeckmann@aufwind.cc>
   * @copyright 2013-2014 Werbeagentur aufwind. GmbH
   */

  (function() {
      /**
       * @constructor
       * @augments Kinetic.Line
       * @param {Object} objectConfig
       */
      Kinetic.ExtendedLine = function(objectConfig) {
          this.___init(objectConfig);
      };

      /**
       * @prototype
       */
      Kinetic.ExtendedLine.prototype = new Object;

      //Register
      Kinetic.Util.extend(Kinetic.ExtendedLine, Kinetic.Line);

      //Getter&Setter
      Kinetic.Factory.addGetterSetter(Kinetic.ExtendedLine, 'added', false);
  })();

/**
 * @author mrdoob / http://mrdoob.com/
 * @author Larry Battle / http://bateru.com/news
 * @author bhouston / http://exocortex.com
 */

var THREE = { REVISION: '65' };

self.console = self.console || {

	info: function () {},
	log: function () {},
	debug: function () {},
	warn: function () {},
	error: function () {}

};

String.prototype.trim = String.prototype.trim || function () {

	return this.replace( /^\s+|\s+$/g, '' );

};

// based on https://github.com/documentcloud/underscore/blob/bf657be243a075b5e72acc8a83e6f12a564d8f55/underscore.js#L767
THREE.extend = function ( obj, source ) {

	// ECMAScript5 compatibility based on: http://www.nczonline.net/blog/2012/12/11/are-your-mixins-ecmascript-5-compatible/
	if ( Object.keys ) {

		var keys = Object.keys( source );

		for (var i = 0, il = keys.length; i < il; i++) {

			var prop = keys[i];
			Object.defineProperty( obj, prop, Object.getOwnPropertyDescriptor( source, prop ) );

		}

	} else {

		var safeHasOwnProperty = {}.hasOwnProperty;

		for ( var prop in source ) {

			if ( safeHasOwnProperty.call( source, prop ) ) {

				obj[prop] = source[prop];

			}

		}

	}

	return obj;

};

// http://paulirish.com/2011/requestanimationframe-for-smart-animating/
// http://my.opera.com/emoller/blog/2011/12/20/requestanimationframe-for-smart-er-animating

// requestAnimationFrame polyfill by Erik Mller
// fixes from Paul Irish and Tino Zijdel
// using 'self' instead of 'window' for compatibility with both NodeJS and IE10.
( function () {

	var lastTime = 0;
	var vendors = [ 'ms', 'moz', 'webkit', 'o' ];

	for ( var x = 0; x < vendors.length && !self.requestAnimationFrame; ++ x ) {

		self.requestAnimationFrame = self[ vendors[ x ] + 'RequestAnimationFrame' ];
		self.cancelAnimationFrame = self[ vendors[ x ] + 'CancelAnimationFrame' ] || self[ vendors[ x ] + 'CancelRequestAnimationFrame' ];

	}

	if ( self.requestAnimationFrame === undefined && self['setTimeout'] !== undefined ) {

		self.requestAnimationFrame = function ( callback ) {

			var currTime = Date.now(), timeToCall = Math.max( 0, 16 - ( currTime - lastTime ) );
			var id = self.setTimeout( function() { callback( currTime + timeToCall ); }, timeToCall );
			lastTime = currTime + timeToCall;
			return id;

		};

	}

	if( self.cancelAnimationFrame === undefined && self['clearTimeout'] !== undefined ) {

		self.cancelAnimationFrame = function ( id ) { self.clearTimeout( id ) };

	}

}() );

// GL STATE CONSTANTS

THREE.CullFaceNone = 0;
THREE.CullFaceBack = 1;
THREE.CullFaceFront = 2;
THREE.CullFaceFrontBack = 3;

THREE.FrontFaceDirectionCW = 0;
THREE.FrontFaceDirectionCCW = 1;

// SHADOWING TYPES

THREE.BasicShadowMap = 0;
THREE.PCFShadowMap = 1;
THREE.PCFSoftShadowMap = 2;

// MATERIAL CONSTANTS

// side

THREE.FrontSide = 0;
THREE.BackSide = 1;
THREE.DoubleSide = 2;

// shading

THREE.NoShading = 0;
THREE.FlatShading = 1;
THREE.SmoothShading = 2;

// colors

THREE.NoColors = 0;
THREE.FaceColors = 1;
THREE.VertexColors = 2;

// blending modes

THREE.NoBlending = 0;
THREE.NormalBlending = 1;
THREE.AdditiveBlending = 2;
THREE.SubtractiveBlending = 3;
THREE.MultiplyBlending = 4;
THREE.CustomBlending = 5;

// custom blending equations
// (numbers start from 100 not to clash with other
//  mappings to OpenGL constants defined in Texture.js)

THREE.AddEquation = 100;
THREE.SubtractEquation = 101;
THREE.ReverseSubtractEquation = 102;

// custom blending destination factors

THREE.ZeroFactor = 200;
THREE.OneFactor = 201;
THREE.SrcColorFactor = 202;
THREE.OneMinusSrcColorFactor = 203;
THREE.SrcAlphaFactor = 204;
THREE.OneMinusSrcAlphaFactor = 205;
THREE.DstAlphaFactor = 206;
THREE.OneMinusDstAlphaFactor = 207;

// custom blending source factors

//THREE.ZeroFactor = 200;
//THREE.OneFactor = 201;
//THREE.SrcAlphaFactor = 204;
//THREE.OneMinusSrcAlphaFactor = 205;
//THREE.DstAlphaFactor = 206;
//THREE.OneMinusDstAlphaFactor = 207;
THREE.DstColorFactor = 208;
THREE.OneMinusDstColorFactor = 209;
THREE.SrcAlphaSaturateFactor = 210;


// TEXTURE CONSTANTS

THREE.MultiplyOperation = 0;
THREE.MixOperation = 1;
THREE.AddOperation = 2;

// Mapping modes

THREE.UVMapping = function () {};

THREE.CubeReflectionMapping = function () {};
THREE.CubeRefractionMapping = function () {};

THREE.SphericalReflectionMapping = function () {};
THREE.SphericalRefractionMapping = function () {};

// Wrapping modes

THREE.RepeatWrapping = 1000;
THREE.ClampToEdgeWrapping = 1001;
THREE.MirroredRepeatWrapping = 1002;

// Filters

THREE.NearestFilter = 1003;
THREE.NearestMipMapNearestFilter = 1004;
THREE.NearestMipMapLinearFilter = 1005;
THREE.LinearFilter = 1006;
THREE.LinearMipMapNearestFilter = 1007;
THREE.LinearMipMapLinearFilter = 1008;

// Data types

THREE.UnsignedByteType = 1009;
THREE.ByteType = 1010;
THREE.ShortType = 1011;
THREE.UnsignedShortType = 1012;
THREE.IntType = 1013;
THREE.UnsignedIntType = 1014;
THREE.FloatType = 1015;

// Pixel types

//THREE.UnsignedByteType = 1009;
THREE.UnsignedShort4444Type = 1016;
THREE.UnsignedShort5551Type = 1017;
THREE.UnsignedShort565Type = 1018;

// Pixel formats

THREE.AlphaFormat = 1019;
THREE.RGBFormat = 1020;
THREE.RGBAFormat = 1021;
THREE.LuminanceFormat = 1022;
THREE.LuminanceAlphaFormat = 1023;

// Compressed texture formats

THREE.RGB_S3TC_DXT1_Format = 2001;
THREE.RGBA_S3TC_DXT1_Format = 2002;
THREE.RGBA_S3TC_DXT3_Format = 2003;
THREE.RGBA_S3TC_DXT5_Format = 2004;

/*
// Potential future PVRTC compressed texture formats
THREE.RGB_PVRTC_4BPPV1_Format = 2100;
THREE.RGB_PVRTC_2BPPV1_Format = 2101;
THREE.RGBA_PVRTC_4BPPV1_Format = 2102;
THREE.RGBA_PVRTC_2BPPV1_Format = 2103;
*/

/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.Color = function ( value ) {

	if ( value !== undefined ) this.set( value );

	return this;

};

THREE.Color.prototype = {

	constructor: THREE.Color,

	r: 1, g: 1, b: 1,

	set: function ( value ) {

		if ( value instanceof THREE.Color ) {

			this.copy( value );

		} else if ( typeof value === 'number' ) {

			this.setHex( value );

		} else if ( typeof value === 'string' ) {

			this.setStyle( value );

		}

		return this;

	},

	setHex: function ( hex ) {

		hex = Math.floor( hex );

		this.r = ( hex >> 16 & 255 ) / 255;
		this.g = ( hex >> 8 & 255 ) / 255;
		this.b = ( hex & 255 ) / 255;

		return this;

	},

	setRGB: function ( r, g, b ) {

		this.r = r;
		this.g = g;
		this.b = b;

		return this;

	},

	setHSL: function ( h, s, l ) {

		// h,s,l ranges are in 0.0 - 1.0

		if ( s === 0 ) {

			this.r = this.g = this.b = l;

		} else {

			var hue2rgb = function ( p, q, t ) {

				if ( t < 0 ) t += 1;
				if ( t > 1 ) t -= 1;
				if ( t < 1 / 6 ) return p + ( q - p ) * 6 * t;
				if ( t < 1 / 2 ) return q;
				if ( t < 2 / 3 ) return p + ( q - p ) * 6 * ( 2 / 3 - t );
				return p;

			};

			var p = l <= 0.5 ? l * ( 1 + s ) : l + s - ( l * s );
			var q = ( 2 * l ) - p;

			this.r = hue2rgb( q, p, h + 1 / 3 );
			this.g = hue2rgb( q, p, h );
			this.b = hue2rgb( q, p, h - 1 / 3 );

		}

		return this;

	},

	setStyle: function ( style ) {

		// rgb(255,0,0)

		if ( /^rgb\((\d+), ?(\d+), ?(\d+)\)$/i.test( style ) ) {

			var color = /^rgb\((\d+), ?(\d+), ?(\d+)\)$/i.exec( style );

			this.r = Math.min( 255, parseInt( color[ 1 ], 10 ) ) / 255;
			this.g = Math.min( 255, parseInt( color[ 2 ], 10 ) ) / 255;
			this.b = Math.min( 255, parseInt( color[ 3 ], 10 ) ) / 255;

			return this;

		}

		// rgb(100%,0%,0%)

		if ( /^rgb\((\d+)\%, ?(\d+)\%, ?(\d+)\%\)$/i.test( style ) ) {

			var color = /^rgb\((\d+)\%, ?(\d+)\%, ?(\d+)\%\)$/i.exec( style );

			this.r = Math.min( 100, parseInt( color[ 1 ], 10 ) ) / 100;
			this.g = Math.min( 100, parseInt( color[ 2 ], 10 ) ) / 100;
			this.b = Math.min( 100, parseInt( color[ 3 ], 10 ) ) / 100;

			return this;

		}

		// #ff0000

		if ( /^\#([0-9a-f]{6})$/i.test( style ) ) {

			var color = /^\#([0-9a-f]{6})$/i.exec( style );

			this.setHex( parseInt( color[ 1 ], 16 ) );

			return this;

		}

		// #f00

		if ( /^\#([0-9a-f])([0-9a-f])([0-9a-f])$/i.test( style ) ) {

			var color = /^\#([0-9a-f])([0-9a-f])([0-9a-f])$/i.exec( style );

			this.setHex( parseInt( color[ 1 ] + color[ 1 ] + color[ 2 ] + color[ 2 ] + color[ 3 ] + color[ 3 ], 16 ) );

			return this;

		}

		// red

		if ( /^(\w+)$/i.test( style ) ) {

			this.setHex( THREE.ColorKeywords[ style ] );

			return this;

		}


	},

	copy: function ( color ) {

		this.r = color.r;
		this.g = color.g;
		this.b = color.b;

		return this;

	},

	copyGammaToLinear: function ( color ) {

		this.r = color.r * color.r;
		this.g = color.g * color.g;
		this.b = color.b * color.b;

		return this;

	},

	copyLinearToGamma: function ( color ) {

		this.r = Math.sqrt( color.r );
		this.g = Math.sqrt( color.g );
		this.b = Math.sqrt( color.b );

		return this;

	},

	convertGammaToLinear: function () {

		var r = this.r, g = this.g, b = this.b;

		this.r = r * r;
		this.g = g * g;
		this.b = b * b;

		return this;

	},

	convertLinearToGamma: function () {

		this.r = Math.sqrt( this.r );
		this.g = Math.sqrt( this.g );
		this.b = Math.sqrt( this.b );

		return this;

	},

	getHex: function () {

		return ( this.r * 255 ) << 16 ^ ( this.g * 255 ) << 8 ^ ( this.b * 255 ) << 0;

	},

	getHexString: function () {

		return ( '000000' + this.getHex().toString( 16 ) ).slice( - 6 );

	},

	getHSL: function ( optionalTarget ) {

		// h,s,l ranges are in 0.0 - 1.0

		var hsl = optionalTarget || { h: 0, s: 0, l: 0 };

		var r = this.r, g = this.g, b = this.b;

		var max = Math.max( r, g, b );
		var min = Math.min( r, g, b );

		var hue, saturation;
		var lightness = ( min + max ) / 2.0;

		if ( min === max ) {

			hue = 0;
			saturation = 0;

		} else {

			var delta = max - min;

			saturation = lightness <= 0.5 ? delta / ( max + min ) : delta / ( 2 - max - min );

			switch ( max ) {

				case r: hue = ( g - b ) / delta + ( g < b ? 6 : 0 ); break;
				case g: hue = ( b - r ) / delta + 2; break;
				case b: hue = ( r - g ) / delta + 4; break;

			}

			hue /= 6;

		}

		hsl.h = hue;
		hsl.s = saturation;
		hsl.l = lightness;

		return hsl;

	},

	getStyle: function () {

		return 'rgb(' + ( ( this.r * 255 ) | 0 ) + ',' + ( ( this.g * 255 ) | 0 ) + ',' + ( ( this.b * 255 ) | 0 ) + ')';

	},

	offsetHSL: function ( h, s, l ) {

		var hsl = this.getHSL();

		hsl.h += h; hsl.s += s; hsl.l += l;

		this.setHSL( hsl.h, hsl.s, hsl.l );

		return this;

	},

	add: function ( color ) {

		this.r += color.r;
		this.g += color.g;
		this.b += color.b;

		return this;

	},

	addColors: function ( color1, color2 ) {

		this.r = color1.r + color2.r;
		this.g = color1.g + color2.g;
		this.b = color1.b + color2.b;

		return this;

	},

	addScalar: function ( s ) {

		this.r += s;
		this.g += s;
		this.b += s;

		return this;

	},

	multiply: function ( color ) {

		this.r *= color.r;
		this.g *= color.g;
		this.b *= color.b;

		return this;

	},

	multiplyScalar: function ( s ) {

		this.r *= s;
		this.g *= s;
		this.b *= s;

		return this;

	},

	lerp: function ( color, alpha ) {

		this.r += ( color.r - this.r ) * alpha;
		this.g += ( color.g - this.g ) * alpha;
		this.b += ( color.b - this.b ) * alpha;

		return this;

	},

	equals: function ( c ) {

		return ( c.r === this.r ) && ( c.g === this.g ) && ( c.b === this.b );

	},

	fromArray: function ( array ) {

		this.r = array[ 0 ];
		this.g = array[ 1 ];
		this.b = array[ 2 ];

		return this;

	},

	toArray: function () {

		return [ this.r, this.g, this.b ];

	},

	clone: function () {

		return new THREE.Color().setRGB( this.r, this.g, this.b );

	}

};

THREE.ColorKeywords = { "aliceblue": 0xF0F8FF, "antiquewhite": 0xFAEBD7, "aqua": 0x00FFFF, "aquamarine": 0x7FFFD4, "azure": 0xF0FFFF,
"beige": 0xF5F5DC, "bisque": 0xFFE4C4, "black": 0x000000, "blanchedalmond": 0xFFEBCD, "blue": 0x0000FF, "blueviolet": 0x8A2BE2,
"brown": 0xA52A2A, "burlywood": 0xDEB887, "cadetblue": 0x5F9EA0, "chartreuse": 0x7FFF00, "chocolate": 0xD2691E, "coral": 0xFF7F50,
"cornflowerblue": 0x6495ED, "cornsilk": 0xFFF8DC, "crimson": 0xDC143C, "cyan": 0x00FFFF, "darkblue": 0x00008B, "darkcyan": 0x008B8B,
"darkgoldenrod": 0xB8860B, "darkgray": 0xA9A9A9, "darkgreen": 0x006400, "darkgrey": 0xA9A9A9, "darkkhaki": 0xBDB76B, "darkmagenta": 0x8B008B,
"darkolivegreen": 0x556B2F, "darkorange": 0xFF8C00, "darkorchid": 0x9932CC, "darkred": 0x8B0000, "darksalmon": 0xE9967A, "darkseagreen": 0x8FBC8F,
"darkslateblue": 0x483D8B, "darkslategray": 0x2F4F4F, "darkslategrey": 0x2F4F4F, "darkturquoise": 0x00CED1, "darkviolet": 0x9400D3,
"deeppink": 0xFF1493, "deepskyblue": 0x00BFFF, "dimgray": 0x696969, "dimgrey": 0x696969, "dodgerblue": 0x1E90FF, "firebrick": 0xB22222,
"floralwhite": 0xFFFAF0, "forestgreen": 0x228B22, "fuchsia": 0xFF00FF, "gainsboro": 0xDCDCDC, "ghostwhite": 0xF8F8FF, "gold": 0xFFD700,
"goldenrod": 0xDAA520, "gray": 0x808080, "green": 0x008000, "greenyellow": 0xADFF2F, "grey": 0x808080, "honeydew": 0xF0FFF0, "hotpink": 0xFF69B4,
"indianred": 0xCD5C5C, "indigo": 0x4B0082, "ivory": 0xFFFFF0, "khaki": 0xF0E68C, "lavender": 0xE6E6FA, "lavenderblush": 0xFFF0F5, "lawngreen": 0x7CFC00,
"lemonchiffon": 0xFFFACD, "lightblue": 0xADD8E6, "lightcoral": 0xF08080, "lightcyan": 0xE0FFFF, "lightgoldenrodyellow": 0xFAFAD2, "lightgray": 0xD3D3D3,
"lightgreen": 0x90EE90, "lightgrey": 0xD3D3D3, "lightpink": 0xFFB6C1, "lightsalmon": 0xFFA07A, "lightseagreen": 0x20B2AA, "lightskyblue": 0x87CEFA,
"lightslategray": 0x778899, "lightslategrey": 0x778899, "lightsteelblue": 0xB0C4DE, "lightyellow": 0xFFFFE0, "lime": 0x00FF00, "limegreen": 0x32CD32,
"linen": 0xFAF0E6, "magenta": 0xFF00FF, "maroon": 0x800000, "mediumaquamarine": 0x66CDAA, "mediumblue": 0x0000CD, "mediumorchid": 0xBA55D3,
"mediumpurple": 0x9370DB, "mediumseagreen": 0x3CB371, "mediumslateblue": 0x7B68EE, "mediumspringgreen": 0x00FA9A, "mediumturquoise": 0x48D1CC,
"mediumvioletred": 0xC71585, "midnightblue": 0x191970, "mintcream": 0xF5FFFA, "mistyrose": 0xFFE4E1, "moccasin": 0xFFE4B5, "navajowhite": 0xFFDEAD,
"navy": 0x000080, "oldlace": 0xFDF5E6, "olive": 0x808000, "olivedrab": 0x6B8E23, "orange": 0xFFA500, "orangered": 0xFF4500, "orchid": 0xDA70D6,
"palegoldenrod": 0xEEE8AA, "palegreen": 0x98FB98, "paleturquoise": 0xAFEEEE, "palevioletred": 0xDB7093, "papayawhip": 0xFFEFD5, "peachpuff": 0xFFDAB9,
"peru": 0xCD853F, "pink": 0xFFC0CB, "plum": 0xDDA0DD, "powderblue": 0xB0E0E6, "purple": 0x800080, "red": 0xFF0000, "rosybrown": 0xBC8F8F,
"royalblue": 0x4169E1, "saddlebrown": 0x8B4513, "salmon": 0xFA8072, "sandybrown": 0xF4A460, "seagreen": 0x2E8B57, "seashell": 0xFFF5EE,
"sienna": 0xA0522D, "silver": 0xC0C0C0, "skyblue": 0x87CEEB, "slateblue": 0x6A5ACD, "slategray": 0x708090, "slategrey": 0x708090, "snow": 0xFFFAFA,
"springgreen": 0x00FF7F, "steelblue": 0x4682B4, "tan": 0xD2B48C, "teal": 0x008080, "thistle": 0xD8BFD8, "tomato": 0xFF6347, "turquoise": 0x40E0D0,
"violet": 0xEE82EE, "wheat": 0xF5DEB3, "white": 0xFFFFFF, "whitesmoke": 0xF5F5F5, "yellow": 0xFFFF00, "yellowgreen": 0x9ACD32 };

/**
 * @author mikael emtinger / http://gomo.se/
 * @author alteredq / http://alteredqualia.com/
 * @author WestLangley / http://github.com/WestLangley
 * @author bhouston / http://exocortex.com
 */

THREE.Quaternion = function ( x, y, z, w ) {

	this._x = x || 0;
	this._y = y || 0;
	this._z = z || 0;
	this._w = ( w !== undefined ) ? w : 1;

};

THREE.Quaternion.prototype = {

	constructor: THREE.Quaternion,

	_x: 0,_y: 0, _z: 0, _w: 0,

	_euler: undefined,

	_updateEuler: function ( callback ) {

		if ( this._euler !== undefined ) {

			this._euler.setFromQuaternion( this, undefined, false );

		}

	},

	get x () {

		return this._x;

	},

	set x ( value ) {

		this._x = value;
		this._updateEuler();

	},

	get y () {

		return this._y;

	},

	set y ( value ) {

		this._y = value;
		this._updateEuler();

	},

	get z () {

		return this._z;

	},

	set z ( value ) {

		this._z = value;
		this._updateEuler();

	},

	get w () {

		return this._w;

	},

	set w ( value ) {

		this._w = value;
		this._updateEuler();

	},

	set: function ( x, y, z, w ) {

		this._x = x;
		this._y = y;
		this._z = z;
		this._w = w;

		this._updateEuler();

		return this;

	},

	copy: function ( quaternion ) {

		this._x = quaternion._x;
		this._y = quaternion._y;
		this._z = quaternion._z;
		this._w = quaternion._w;

		this._updateEuler();

		return this;

	},

	setFromEuler: function ( euler, update ) {

		if ( euler instanceof THREE.Euler === false ) {

			throw new Error( 'ERROR: Quaternion\'s .setFromEuler() now expects a Euler rotation rather than a Vector3 and order.  Please update your code.' );
		}

		// http://www.mathworks.com/matlabcentral/fileexchange/
		// 	20696-function-to-convert-between-dcm-euler-angles-quaternions-and-euler-vectors/
		//	content/SpinCalc.m

		var c1 = Math.cos( euler._x / 2 );
		var c2 = Math.cos( euler._y / 2 );
		var c3 = Math.cos( euler._z / 2 );
		var s1 = Math.sin( euler._x / 2 );
		var s2 = Math.sin( euler._y / 2 );
		var s3 = Math.sin( euler._z / 2 );

		if ( euler.order === 'XYZ' ) {

			this._x = s1 * c2 * c3 + c1 * s2 * s3;
			this._y = c1 * s2 * c3 - s1 * c2 * s3;
			this._z = c1 * c2 * s3 + s1 * s2 * c3;
			this._w = c1 * c2 * c3 - s1 * s2 * s3;

		} else if ( euler.order === 'YXZ' ) {

			this._x = s1 * c2 * c3 + c1 * s2 * s3;
			this._y = c1 * s2 * c3 - s1 * c2 * s3;
			this._z = c1 * c2 * s3 - s1 * s2 * c3;
			this._w = c1 * c2 * c3 + s1 * s2 * s3;

		} else if ( euler.order === 'ZXY' ) {

			this._x = s1 * c2 * c3 - c1 * s2 * s3;
			this._y = c1 * s2 * c3 + s1 * c2 * s3;
			this._z = c1 * c2 * s3 + s1 * s2 * c3;
			this._w = c1 * c2 * c3 - s1 * s2 * s3;

		} else if ( euler.order === 'ZYX' ) {

			this._x = s1 * c2 * c3 - c1 * s2 * s3;
			this._y = c1 * s2 * c3 + s1 * c2 * s3;
			this._z = c1 * c2 * s3 - s1 * s2 * c3;
			this._w = c1 * c2 * c3 + s1 * s2 * s3;

		} else if ( euler.order === 'YZX' ) {

			this._x = s1 * c2 * c3 + c1 * s2 * s3;
			this._y = c1 * s2 * c3 + s1 * c2 * s3;
			this._z = c1 * c2 * s3 - s1 * s2 * c3;
			this._w = c1 * c2 * c3 - s1 * s2 * s3;

		} else if ( euler.order === 'XZY' ) {

			this._x = s1 * c2 * c3 - c1 * s2 * s3;
			this._y = c1 * s2 * c3 - s1 * c2 * s3;
			this._z = c1 * c2 * s3 + s1 * s2 * c3;
			this._w = c1 * c2 * c3 + s1 * s2 * s3;

		}

		if ( update !== false ) this._updateEuler();

		return this;

	},

	setFromAxisAngle: function ( axis, angle ) {

		// from http://www.euclideanspace.com/maths/geometry/rotations/conversions/angleToQuaternion/index.htm
		// axis have to be normalized

		var halfAngle = angle / 2, s = Math.sin( halfAngle );

		this._x = axis.x * s;
		this._y = axis.y * s;
		this._z = axis.z * s;
		this._w = Math.cos( halfAngle );

		this._updateEuler();

		return this;

	},

	setFromRotationMatrix: function ( m ) {

		// http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToQuaternion/index.htm

		// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)

		var te = m.elements,

			m11 = te[0], m12 = te[4], m13 = te[8],
			m21 = te[1], m22 = te[5], m23 = te[9],
			m31 = te[2], m32 = te[6], m33 = te[10],

			trace = m11 + m22 + m33,
			s;

		if ( trace > 0 ) {

			s = 0.5 / Math.sqrt( trace + 1.0 );

			this._w = 0.25 / s;
			this._x = ( m32 - m23 ) * s;
			this._y = ( m13 - m31 ) * s;
			this._z = ( m21 - m12 ) * s;

		} else if ( m11 > m22 && m11 > m33 ) {

			s = 2.0 * Math.sqrt( 1.0 + m11 - m22 - m33 );

			this._w = (m32 - m23 ) / s;
			this._x = 0.25 * s;
			this._y = (m12 + m21 ) / s;
			this._z = (m13 + m31 ) / s;

		} else if ( m22 > m33 ) {

			s = 2.0 * Math.sqrt( 1.0 + m22 - m11 - m33 );

			this._w = (m13 - m31 ) / s;
			this._x = (m12 + m21 ) / s;
			this._y = 0.25 * s;
			this._z = (m23 + m32 ) / s;

		} else {

			s = 2.0 * Math.sqrt( 1.0 + m33 - m11 - m22 );

			this._w = ( m21 - m12 ) / s;
			this._x = ( m13 + m31 ) / s;
			this._y = ( m23 + m32 ) / s;
			this._z = 0.25 * s;

		}

		this._updateEuler();

		return this;

	},

	inverse: function () {

		this.conjugate().normalize();

		return this;

	},

	conjugate: function () {

		this._x *= -1;
		this._y *= -1;
		this._z *= -1;

		this._updateEuler();

		return this;

	},

	lengthSq: function () {

		return this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w;

	},

	length: function () {

		return Math.sqrt( this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w );

	},

	normalize: function () {

		var l = this.length();

		if ( l === 0 ) {

			this._x = 0;
			this._y = 0;
			this._z = 0;
			this._w = 1;

		} else {

			l = 1 / l;

			this._x = this._x * l;
			this._y = this._y * l;
			this._z = this._z * l;
			this._w = this._w * l;

		}

		return this;

	},

	multiply: function ( q, p ) {

		if ( p !== undefined ) {

			console.warn( 'DEPRECATED: Quaternion\'s .multiply() now only accepts one argument. Use .multiplyQuaternions( a, b ) instead.' );
			return this.multiplyQuaternions( q, p );

		}

		return this.multiplyQuaternions( this, q );

	},

	multiplyQuaternions: function ( a, b ) {

		// from http://www.euclideanspace.com/maths/algebra/realNormedAlgebra/quaternions/code/index.htm

		var qax = a._x, qay = a._y, qaz = a._z, qaw = a._w;
		var qbx = b._x, qby = b._y, qbz = b._z, qbw = b._w;

		this._x = qax * qbw + qaw * qbx + qay * qbz - qaz * qby;
		this._y = qay * qbw + qaw * qby + qaz * qbx - qax * qbz;
		this._z = qaz * qbw + qaw * qbz + qax * qby - qay * qbx;
		this._w = qaw * qbw - qax * qbx - qay * qby - qaz * qbz;

		this._updateEuler();

		return this;

	},

	multiplyVector3: function ( vector ) {

		console.warn( 'DEPRECATED: Quaternion\'s .multiplyVector3() has been removed. Use is now vector.applyQuaternion( quaternion ) instead.' );
		return vector.applyQuaternion( this );

	},

	slerp: function ( qb, t ) {

		var x = this._x, y = this._y, z = this._z, w = this._w;

		// http://www.euclideanspace.com/maths/algebra/realNormedAlgebra/quaternions/slerp/

		var cosHalfTheta = w * qb._w + x * qb._x + y * qb._y + z * qb._z;

		if ( cosHalfTheta < 0 ) {

			this._w = -qb._w;
			this._x = -qb._x;
			this._y = -qb._y;
			this._z = -qb._z;

			cosHalfTheta = -cosHalfTheta;

		} else {

			this.copy( qb );

		}

		if ( cosHalfTheta >= 1.0 ) {

			this._w = w;
			this._x = x;
			this._y = y;
			this._z = z;

			return this;

		}

		var halfTheta = Math.acos( cosHalfTheta );
		var sinHalfTheta = Math.sqrt( 1.0 - cosHalfTheta * cosHalfTheta );

		if ( Math.abs( sinHalfTheta ) < 0.001 ) {

			this._w = 0.5 * ( w + this._w );
			this._x = 0.5 * ( x + this._x );
			this._y = 0.5 * ( y + this._y );
			this._z = 0.5 * ( z + this._z );

			return this;

		}

		var ratioA = Math.sin( ( 1 - t ) * halfTheta ) / sinHalfTheta,
		ratioB = Math.sin( t * halfTheta ) / sinHalfTheta;

		this._w = ( w * ratioA + this._w * ratioB );
		this._x = ( x * ratioA + this._x * ratioB );
		this._y = ( y * ratioA + this._y * ratioB );
		this._z = ( z * ratioA + this._z * ratioB );

		this._updateEuler();

		return this;

	},

	equals: function ( quaternion ) {

		return ( quaternion._x === this._x ) && ( quaternion._y === this._y ) && ( quaternion._z === this._z ) && ( quaternion._w === this._w );

	},

	fromArray: function ( array ) {

		this._x = array[ 0 ];
		this._y = array[ 1 ];
		this._z = array[ 2 ];
		this._w = array[ 3 ];

		this._updateEuler();

		return this;

	},

	toArray: function () {

		return [ this._x, this._y, this._z, this._w ];

	},

	clone: function () {

		return new THREE.Quaternion( this._x, this._y, this._z, this._w );

	}

};

THREE.Quaternion.slerp = function ( qa, qb, qm, t ) {

	return qm.copy( qa ).slerp( qb, t );

}

/**
 * @author mrdoob / http://mrdoob.com/
 * @author philogb / http://blog.thejit.org/
 * @author egraether / http://egraether.com/
 * @author zz85 / http://www.lab4games.net/zz85/blog
 */

THREE.Vector2 = function ( x, y ) {

	this.x = x || 0;
	this.y = y || 0;

};

THREE.Vector2.prototype = {

	constructor: THREE.Vector2,

	set: function ( x, y ) {

		this.x = x;
		this.y = y;

		return this;

	},

	setX: function ( x ) {

		this.x = x;

		return this;

	},

	setY: function ( y ) {

		this.y = y;

		return this;

	},


	setComponent: function ( index, value ) {

		switch ( index ) {

			case 0: this.x = value; break;
			case 1: this.y = value; break;
			default: throw new Error( "index is out of range: " + index );

		}

	},

	getComponent: function ( index ) {

		switch ( index ) {

			case 0: return this.x;
			case 1: return this.y;
			default: throw new Error( "index is out of range: " + index );

		}

	},

	copy: function ( v ) {

		this.x = v.x;
		this.y = v.y;

		return this;

	},

	add: function ( v, w ) {

		if ( w !== undefined ) {

			console.warn( 'DEPRECATED: Vector2\'s .add() now only accepts one argument. Use .addVectors( a, b ) instead.' );
			return this.addVectors( v, w );

		}

		this.x += v.x;
		this.y += v.y;

		return this;

	},

	addVectors: function ( a, b ) {

		this.x = a.x + b.x;
		this.y = a.y + b.y;

		return this;

	},

	addScalar: function ( s ) {

		this.x += s;
		this.y += s;

		return this;

	},

	sub: function ( v, w ) {

		if ( w !== undefined ) {

			console.warn( 'DEPRECATED: Vector2\'s .sub() now only accepts one argument. Use .subVectors( a, b ) instead.' );
			return this.subVectors( v, w );

		}

		this.x -= v.x;
		this.y -= v.y;

		return this;

	},

	subVectors: function ( a, b ) {

		this.x = a.x - b.x;
		this.y = a.y - b.y;

		return this;

	},

	multiplyScalar: function ( s ) {

		this.x *= s;
		this.y *= s;

		return this;

	},

	divideScalar: function ( scalar ) {

		if ( scalar !== 0 ) {

			var invScalar = 1 / scalar;

			this.x *= invScalar;
			this.y *= invScalar;

		} else {

			this.x = 0;
			this.y = 0;

		}

		return this;

	},

	min: function ( v ) {

		if ( this.x > v.x ) {

			this.x = v.x;

		}

		if ( this.y > v.y ) {

			this.y = v.y;

		}

		return this;

	},

	max: function ( v ) {

		if ( this.x < v.x ) {

			this.x = v.x;

		}

		if ( this.y < v.y ) {

			this.y = v.y;

		}

		return this;

	},

	clamp: function ( min, max ) {

		// This function assumes min < max, if this assumption isn't true it will not operate correctly

		if ( this.x < min.x ) {

			this.x = min.x;

		} else if ( this.x > max.x ) {

			this.x = max.x;

		}

		if ( this.y < min.y ) {

			this.y = min.y;

		} else if ( this.y > max.y ) {

			this.y = max.y;

		}

		return this;

	},

	negate: function() {

		return this.multiplyScalar( - 1 );

	},

	dot: function ( v ) {

		return this.x * v.x + this.y * v.y;

	},

	lengthSq: function () {

		return this.x * this.x + this.y * this.y;

	},

	length: function () {

		return Math.sqrt( this.x * this.x + this.y * this.y );

	},

	normalize: function () {

		return this.divideScalar( this.length() );

	},

	distanceTo: function ( v ) {

		return Math.sqrt( this.distanceToSquared( v ) );

	},

	distanceToSquared: function ( v ) {

		var dx = this.x - v.x, dy = this.y - v.y;
		return dx * dx + dy * dy;

	},

	setLength: function ( l ) {

		var oldLength = this.length();

		if ( oldLength !== 0 && l !== oldLength ) {

			this.multiplyScalar( l / oldLength );
		}

		return this;

	},

	lerp: function ( v, alpha ) {

		this.x += ( v.x - this.x ) * alpha;
		this.y += ( v.y - this.y ) * alpha;

		return this;

	},

	equals: function( v ) {

		return ( ( v.x === this.x ) && ( v.y === this.y ) );

	},

	fromArray: function ( array ) {

		this.x = array[ 0 ];
		this.y = array[ 1 ];

		return this;

	},

	toArray: function () {

		return [ this.x, this.y ];

	},

	clone: function () {

		return new THREE.Vector2( this.x, this.y );

	}

};

/**
 * @author mrdoob / http://mrdoob.com/
 * @author *kile / http://kile.stravaganza.org/
 * @author philogb / http://blog.thejit.org/
 * @author mikael emtinger / http://gomo.se/
 * @author egraether / http://egraether.com/
 * @author WestLangley / http://github.com/WestLangley
 */

THREE.Vector3 = function ( x, y, z ) {

	this.x = x || 0;
	this.y = y || 0;
	this.z = z || 0;

};

THREE.Vector3.prototype = {

	constructor: THREE.Vector3,

	set: function ( x, y, z ) {

		this.x = x;
		this.y = y;
		this.z = z;

		return this;

	},

	setX: function ( x ) {

		this.x = x;

		return this;

	},

	setY: function ( y ) {

		this.y = y;

		return this;

	},

	setZ: function ( z ) {

		this.z = z;

		return this;

	},

	setComponent: function ( index, value ) {

		switch ( index ) {

			case 0: this.x = value; break;
			case 1: this.y = value; break;
			case 2: this.z = value; break;
			default: throw new Error( "index is out of range: " + index );

		}

	},

	getComponent: function ( index ) {

		switch ( index ) {

			case 0: return this.x;
			case 1: return this.y;
			case 2: return this.z;
			default: throw new Error( "index is out of range: " + index );

		}

	},

	copy: function ( v ) {

		this.x = v.x;
		this.y = v.y;
		this.z = v.z;

		return this;

	},

	add: function ( v, w ) {

		if ( w !== undefined ) {

			console.warn( 'DEPRECATED: Vector3\'s .add() now only accepts one argument. Use .addVectors( a, b ) instead.' );
			return this.addVectors( v, w );

		}

		this.x += v.x;
		this.y += v.y;
		this.z += v.z;

		return this;

	},

	addScalar: function ( s ) {

		this.x += s;
		this.y += s;
		this.z += s;

		return this;

	},

	addVectors: function ( a, b ) {

		this.x = a.x + b.x;
		this.y = a.y + b.y;
		this.z = a.z + b.z;

		return this;

	},

	sub: function ( v, w ) {

		if ( w !== undefined ) {

			console.warn( 'DEPRECATED: Vector3\'s .sub() now only accepts one argument. Use .subVectors( a, b ) instead.' );
			return this.subVectors( v, w );

		}

		this.x -= v.x;
		this.y -= v.y;
		this.z -= v.z;

		return this;

	},

	subVectors: function ( a, b ) {

		this.x = a.x - b.x;
		this.y = a.y - b.y;
		this.z = a.z - b.z;

		return this;

	},

	multiply: function ( v, w ) {

		if ( w !== undefined ) {

			console.warn( 'DEPRECATED: Vector3\'s .multiply() now only accepts one argument. Use .multiplyVectors( a, b ) instead.' );
			return this.multiplyVectors( v, w );

		}

		this.x *= v.x;
		this.y *= v.y;
		this.z *= v.z;

		return this;

	},

	multiplyScalar: function ( scalar ) {

		this.x *= scalar;
		this.y *= scalar;
		this.z *= scalar;

		return this;

	},

	multiplyVectors: function ( a, b ) {

		this.x = a.x * b.x;
		this.y = a.y * b.y;
		this.z = a.z * b.z;

		return this;

	},

	applyMatrix3: function ( m ) {

		var x = this.x;
		var y = this.y;
		var z = this.z;

		var e = m.elements;

		this.x = e[0] * x + e[3] * y + e[6] * z;
		this.y = e[1] * x + e[4] * y + e[7] * z;
		this.z = e[2] * x + e[5] * y + e[8] * z;

		return this;

	},

	applyMatrix4: function ( m ) {

		// input: THREE.Matrix4 affine matrix

		var x = this.x, y = this.y, z = this.z;

		var e = m.elements;

		this.x = e[0] * x + e[4] * y + e[8]  * z + e[12];
		this.y = e[1] * x + e[5] * y + e[9]  * z + e[13];
		this.z = e[2] * x + e[6] * y + e[10] * z + e[14];

		return this;

	},

	applyProjection: function ( m ) {

		// input: THREE.Matrix4 projection matrix

		var x = this.x, y = this.y, z = this.z;

		var e = m.elements;
		var d = 1 / ( e[3] * x + e[7] * y + e[11] * z + e[15] ); // perspective divide

		this.x = ( e[0] * x + e[4] * y + e[8]  * z + e[12] ) * d;
		this.y = ( e[1] * x + e[5] * y + e[9]  * z + e[13] ) * d;
		this.z = ( e[2] * x + e[6] * y + e[10] * z + e[14] ) * d;

		return this;

	},

	applyQuaternion: function ( q ) {

		var x = this.x;
		var y = this.y;
		var z = this.z;

		var qx = q.x;
		var qy = q.y;
		var qz = q.z;
		var qw = q.w;

		// calculate quat * vector

		var ix =  qw * x + qy * z - qz * y;
		var iy =  qw * y + qz * x - qx * z;
		var iz =  qw * z + qx * y - qy * x;
		var iw = -qx * x - qy * y - qz * z;

		// calculate result * inverse quat

		this.x = ix * qw + iw * -qx + iy * -qz - iz * -qy;
		this.y = iy * qw + iw * -qy + iz * -qx - ix * -qz;
		this.z = iz * qw + iw * -qz + ix * -qy - iy * -qx;

		return this;

	},

	transformDirection: function ( m ) {

		// input: THREE.Matrix4 affine matrix
		// vector interpreted as a direction

		var x = this.x, y = this.y, z = this.z;

		var e = m.elements;

		this.x = e[0] * x + e[4] * y + e[8]  * z;
		this.y = e[1] * x + e[5] * y + e[9]  * z;
		this.z = e[2] * x + e[6] * y + e[10] * z;

		this.normalize();

		return this;

	},

	divide: function ( v ) {

		this.x /= v.x;
		this.y /= v.y;
		this.z /= v.z;

		return this;

	},

	divideScalar: function ( scalar ) {

		if ( scalar !== 0 ) {

			var invScalar = 1 / scalar;

			this.x *= invScalar;
			this.y *= invScalar;
			this.z *= invScalar;

		} else {

			this.x = 0;
			this.y = 0;
			this.z = 0;

		}

		return this;

	},

	min: function ( v ) {

		if ( this.x > v.x ) {

			this.x = v.x;

		}

		if ( this.y > v.y ) {

			this.y = v.y;

		}

		if ( this.z > v.z ) {

			this.z = v.z;

		}

		return this;

	},

	max: function ( v ) {

		if ( this.x < v.x ) {

			this.x = v.x;

		}

		if ( this.y < v.y ) {

			this.y = v.y;

		}

		if ( this.z < v.z ) {

			this.z = v.z;

		}

		return this;

	},

	clamp: function ( min, max ) {

		// This function assumes min < max, if this assumption isn't true it will not operate correctly

		if ( this.x < min.x ) {

			this.x = min.x;

		} else if ( this.x > max.x ) {

			this.x = max.x;

		}

		if ( this.y < min.y ) {

			this.y = min.y;

		} else if ( this.y > max.y ) {

			this.y = max.y;

		}

		if ( this.z < min.z ) {

			this.z = min.z;

		} else if ( this.z > max.z ) {

			this.z = max.z;

		}

		return this;

	},

	negate: function () {

		return this.multiplyScalar( - 1 );

	},

	dot: function ( v ) {

		return this.x * v.x + this.y * v.y + this.z * v.z;

	},

	lengthSq: function () {

		return this.x * this.x + this.y * this.y + this.z * this.z;

	},

	length: function () {

		return Math.sqrt( this.x * this.x + this.y * this.y + this.z * this.z );

	},

	lengthManhattan: function () {

		return Math.abs( this.x ) + Math.abs( this.y ) + Math.abs( this.z );

	},

	normalize: function () {

		return this.divideScalar( this.length() );

	},

	setLength: function ( l ) {

		var oldLength = this.length();

		if ( oldLength !== 0 && l !== oldLength  ) {

			this.multiplyScalar( l / oldLength );
		}

		return this;

	},

	lerp: function ( v, alpha ) {

		this.x += ( v.x - this.x ) * alpha;
		this.y += ( v.y - this.y ) * alpha;
		this.z += ( v.z - this.z ) * alpha;

		return this;

	},

	cross: function ( v, w ) {

		if ( w !== undefined ) {

			console.warn( 'DEPRECATED: Vector3\'s .cross() now only accepts one argument. Use .crossVectors( a, b ) instead.' );
			return this.crossVectors( v, w );

		}

		var x = this.x, y = this.y, z = this.z;

		this.x = y * v.z - z * v.y;
		this.y = z * v.x - x * v.z;
		this.z = x * v.y - y * v.x;

		return this;

	},

	crossVectors: function ( a, b ) {

		var ax = a.x, ay = a.y, az = a.z;
		var bx = b.x, by = b.y, bz = b.z;

		this.x = ay * bz - az * by;
		this.y = az * bx - ax * bz;
		this.z = ax * by - ay * bx;

		return this;

	},

	angleTo: function ( v ) {

		var theta = this.dot( v ) / ( this.length() * v.length() );

		// clamp, to handle numerical problems

		return Math.acos( THREE.Math.clamp( theta, -1, 1 ) );

	},

	distanceTo: function ( v ) {

		return Math.sqrt( this.distanceToSquared( v ) );

	},

	distanceToSquared: function ( v ) {

		var dx = this.x - v.x;
		var dy = this.y - v.y;
		var dz = this.z - v.z;

		return dx * dx + dy * dy + dz * dz;

	},

	setEulerFromRotationMatrix: function ( m, order ) {

		console.error( "REMOVED: Vector3\'s setEulerFromRotationMatrix has been removed in favor of Euler.setFromRotationMatrix(), please update your code.");

	},

	setEulerFromQuaternion: function ( q, order ) {

		console.error( "REMOVED: Vector3\'s setEulerFromQuaternion: has been removed in favor of Euler.setFromQuaternion(), please update your code.");

	},

	getPositionFromMatrix: function ( m ) {

		console.warn( "DEPRECATED: Vector3\'s .getPositionFromMatrix() has been renamed to .setFromMatrixPosition(). Please update your code." );

		return this.setFromMatrixPosition( m );

	},

	getScaleFromMatrix: function ( m ) {

		console.warn( "DEPRECATED: Vector3\'s .getScaleFromMatrix() has been renamed to .setFromMatrixScale(). Please update your code." );

		return this.setFromMatrixScale( m );
	},

	getColumnFromMatrix: function ( index, matrix ) {

		console.warn( "DEPRECATED: Vector3\'s .getColumnFromMatrix() has been renamed to .setFromMatrixColumn(). Please update your code." );

		return this.setFromMatrixColumn( index, matrix );

	},

	setFromMatrixPosition: function ( m ) {

		this.x = m.elements[ 12 ];
		this.y = m.elements[ 13 ];
		this.z = m.elements[ 14 ];

		return this;

	},

	setFromMatrixScale: function ( m ) {

		var sx = this.set( m.elements[ 0 ], m.elements[ 1 ], m.elements[  2 ] ).length();
		var sy = this.set( m.elements[ 4 ], m.elements[ 5 ], m.elements[  6 ] ).length();
		var sz = this.set( m.elements[ 8 ], m.elements[ 9 ], m.elements[ 10 ] ).length();

		this.x = sx;
		this.y = sy;
		this.z = sz;

		return this;
	},

	setFromMatrixColumn: function ( index, matrix ) {

		var offset = index * 4;

		var me = matrix.elements;

		this.x = me[ offset ];
		this.y = me[ offset + 1 ];
		this.z = me[ offset + 2 ];

		return this;

	},

	equals: function ( v ) {

		return ( ( v.x === this.x ) && ( v.y === this.y ) && ( v.z === this.z ) );

	},

	fromArray: function ( array ) {

		this.x = array[ 0 ];
		this.y = array[ 1 ];
		this.z = array[ 2 ];

		return this;

	},

	toArray: function () {

		return [ this.x, this.y, this.z ];

	},

	clone: function () {

		return new THREE.Vector3( this.x, this.y, this.z );

	}

};

THREE.extend( THREE.Vector3.prototype, {

	applyEuler: function () {

		var quaternion = new THREE.Quaternion();

		return function ( euler ) {

			if ( euler instanceof THREE.Euler === false ) {

				console.error( 'ERROR: Vector3\'s .applyEuler() now expects a Euler rotation rather than a Vector3 and order.  Please update your code.' );

			}

			this.applyQuaternion( quaternion.setFromEuler( euler ) );

			return this;

		};

	}(),

	applyAxisAngle: function () {

		var quaternion = new THREE.Quaternion();

		return function ( axis, angle ) {

			this.applyQuaternion( quaternion.setFromAxisAngle( axis, angle ) );

			return this;

		};

	}(),

	projectOnVector: function () {

		var v1 = new THREE.Vector3();

		return function ( vector ) {

			v1.copy( vector ).normalize();
			var d = this.dot( v1 );
			return this.copy( v1 ).multiplyScalar( d );

		};

	}(),

	projectOnPlane: function () {

		var v1 = new THREE.Vector3();

		return function ( planeNormal ) {

			v1.copy( this ).projectOnVector( planeNormal );

			return this.sub( v1 );

		}

	}(),

	reflect: function () {

		var v1 = new THREE.Vector3();

		return function ( vector ) {

		    v1.copy( this ).projectOnVector( vector ).multiplyScalar( 2 );

		    return this.subVectors( v1, this );

		}

	}()

} );

/**
 * @author supereggbert / http://www.paulbrunt.co.uk/
 * @author philogb / http://blog.thejit.org/
 * @author mikael emtinger / http://gomo.se/
 * @author egraether / http://egraether.com/
 * @author WestLangley / http://github.com/WestLangley
 */

THREE.Vector4 = function ( x, y, z, w ) {

	this.x = x || 0;
	this.y = y || 0;
	this.z = z || 0;
	this.w = ( w !== undefined ) ? w : 1;

};

THREE.Vector4.prototype = {

	constructor: THREE.Vector4,

	set: function ( x, y, z, w ) {

		this.x = x;
		this.y = y;
		this.z = z;
		this.w = w;

		return this;

	},

	setX: function ( x ) {

		this.x = x;

		return this;

	},

	setY: function ( y ) {

		this.y = y;

		return this;

	},

	setZ: function ( z ) {

		this.z = z;

		return this;

	},

	setW: function ( w ) {

		this.w = w;

		return this;

	},

	setComponent: function ( index, value ) {

		switch ( index ) {

			case 0: this.x = value; break;
			case 1: this.y = value; break;
			case 2: this.z = value; break;
			case 3: this.w = value; break;
			default: throw new Error( "index is out of range: " + index );

		}

	},

	getComponent: function ( index ) {

		switch ( index ) {

			case 0: return this.x;
			case 1: return this.y;
			case 2: return this.z;
			case 3: return this.w;
			default: throw new Error( "index is out of range: " + index );

		}

	},

	copy: function ( v ) {

		this.x = v.x;
		this.y = v.y;
		this.z = v.z;
		this.w = ( v.w !== undefined ) ? v.w : 1;

		return this;

	},

	add: function ( v, w ) {

		if ( w !== undefined ) {

			console.warn( 'DEPRECATED: Vector4\'s .add() now only accepts one argument. Use .addVectors( a, b ) instead.' );
			return this.addVectors( v, w );

		}

		this.x += v.x;
		this.y += v.y;
		this.z += v.z;
		this.w += v.w;

		return this;

	},

	addScalar: function ( s ) {

		this.x += s;
		this.y += s;
		this.z += s;
		this.w += s;

		return this;

	},

	addVectors: function ( a, b ) {

		this.x = a.x + b.x;
		this.y = a.y + b.y;
		this.z = a.z + b.z;
		this.w = a.w + b.w;

		return this;

	},

	sub: function ( v, w ) {

		if ( w !== undefined ) {

			console.warn( 'DEPRECATED: Vector4\'s .sub() now only accepts one argument. Use .subVectors( a, b ) instead.' );
			return this.subVectors( v, w );

		}

		this.x -= v.x;
		this.y -= v.y;
		this.z -= v.z;
		this.w -= v.w;

		return this;

	},

	subVectors: function ( a, b ) {

		this.x = a.x - b.x;
		this.y = a.y - b.y;
		this.z = a.z - b.z;
		this.w = a.w - b.w;

		return this;

	},

	multiplyScalar: function ( scalar ) {

		this.x *= scalar;
		this.y *= scalar;
		this.z *= scalar;
		this.w *= scalar;

		return this;

	},

	applyMatrix4: function ( m ) {

		var x = this.x;
		var y = this.y;
		var z = this.z;
		var w = this.w;

		var e = m.elements;

		this.x = e[0] * x + e[4] * y + e[8] * z + e[12] * w;
		this.y = e[1] * x + e[5] * y + e[9] * z + e[13] * w;
		this.z = e[2] * x + e[6] * y + e[10] * z + e[14] * w;
		this.w = e[3] * x + e[7] * y + e[11] * z + e[15] * w;

		return this;

	},

	divideScalar: function ( scalar ) {

		if ( scalar !== 0 ) {

			var invScalar = 1 / scalar;

			this.x *= invScalar;
			this.y *= invScalar;
			this.z *= invScalar;
			this.w *= invScalar;

		} else {

			this.x = 0;
			this.y = 0;
			this.z = 0;
			this.w = 1;

		}

		return this;

	},

	setAxisAngleFromQuaternion: function ( q ) {

		// http://www.euclideanspace.com/maths/geometry/rotations/conversions/quaternionToAngle/index.htm

		// q is assumed to be normalized

		this.w = 2 * Math.acos( q.w );

		var s = Math.sqrt( 1 - q.w * q.w );

		if ( s < 0.0001 ) {

			 this.x = 1;
			 this.y = 0;
			 this.z = 0;

		} else {

			 this.x = q.x / s;
			 this.y = q.y / s;
			 this.z = q.z / s;

		}

		return this;

	},

	setAxisAngleFromRotationMatrix: function ( m ) {

		// http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToAngle/index.htm

		// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)

		var angle, x, y, z,		// variables for result
			epsilon = 0.01,		// margin to allow for rounding errors
			epsilon2 = 0.1,		// margin to distinguish between 0 and 180 degrees

			te = m.elements,

			m11 = te[0], m12 = te[4], m13 = te[8],
			m21 = te[1], m22 = te[5], m23 = te[9],
			m31 = te[2], m32 = te[6], m33 = te[10];

		if ( ( Math.abs( m12 - m21 ) < epsilon )
		  && ( Math.abs( m13 - m31 ) < epsilon )
		  && ( Math.abs( m23 - m32 ) < epsilon ) ) {

			// singularity found
			// first check for identity matrix which must have +1 for all terms
			// in leading diagonal and zero in other terms

			if ( ( Math.abs( m12 + m21 ) < epsilon2 )
			  && ( Math.abs( m13 + m31 ) < epsilon2 )
			  && ( Math.abs( m23 + m32 ) < epsilon2 )
			  && ( Math.abs( m11 + m22 + m33 - 3 ) < epsilon2 ) ) {

				// this singularity is identity matrix so angle = 0

				this.set( 1, 0, 0, 0 );

				return this; // zero angle, arbitrary axis

			}

			// otherwise this singularity is angle = 180

			angle = Math.PI;

			var xx = ( m11 + 1 ) / 2;
			var yy = ( m22 + 1 ) / 2;
			var zz = ( m33 + 1 ) / 2;
			var xy = ( m12 + m21 ) / 4;
			var xz = ( m13 + m31 ) / 4;
			var yz = ( m23 + m32 ) / 4;

			if ( ( xx > yy ) && ( xx > zz ) ) { // m11 is the largest diagonal term

				if ( xx < epsilon ) {

					x = 0;
					y = 0.707106781;
					z = 0.707106781;

				} else {

					x = Math.sqrt( xx );
					y = xy / x;
					z = xz / x;

				}

			} else if ( yy > zz ) { // m22 is the largest diagonal term

				if ( yy < epsilon ) {

					x = 0.707106781;
					y = 0;
					z = 0.707106781;

				} else {

					y = Math.sqrt( yy );
					x = xy / y;
					z = yz / y;

				}

			} else { // m33 is the largest diagonal term so base result on this

				if ( zz < epsilon ) {

					x = 0.707106781;
					y = 0.707106781;
					z = 0;

				} else {

					z = Math.sqrt( zz );
					x = xz / z;
					y = yz / z;

				}

			}

			this.set( x, y, z, angle );

			return this; // return 180 deg rotation

		}

		// as we have reached here there are no singularities so we can handle normally

		var s = Math.sqrt( ( m32 - m23 ) * ( m32 - m23 )
						 + ( m13 - m31 ) * ( m13 - m31 )
						 + ( m21 - m12 ) * ( m21 - m12 ) ); // used to normalize

		if ( Math.abs( s ) < 0.001 ) s = 1;

		// prevent divide by zero, should not happen if matrix is orthogonal and should be
		// caught by singularity test above, but I've left it in just in case

		this.x = ( m32 - m23 ) / s;
		this.y = ( m13 - m31 ) / s;
		this.z = ( m21 - m12 ) / s;
		this.w = Math.acos( ( m11 + m22 + m33 - 1 ) / 2 );

		return this;

	},

	min: function ( v ) {

		if ( this.x > v.x ) {

			this.x = v.x;

		}

		if ( this.y > v.y ) {

			this.y = v.y;

		}

		if ( this.z > v.z ) {

			this.z = v.z;

		}

		if ( this.w > v.w ) {

			this.w = v.w;

		}

		return this;

	},

	max: function ( v ) {

		if ( this.x < v.x ) {

			this.x = v.x;

		}

		if ( this.y < v.y ) {

			this.y = v.y;

		}

		if ( this.z < v.z ) {

			this.z = v.z;

		}

		if ( this.w < v.w ) {

			this.w = v.w;

		}

		return this;

	},

	clamp: function ( min, max ) {

		// This function assumes min < max, if this assumption isn't true it will not operate correctly

		if ( this.x < min.x ) {

			this.x = min.x;

		} else if ( this.x > max.x ) {

			this.x = max.x;

		}

		if ( this.y < min.y ) {

			this.y = min.y;

		} else if ( this.y > max.y ) {

			this.y = max.y;

		}

		if ( this.z < min.z ) {

			this.z = min.z;

		} else if ( this.z > max.z ) {

			this.z = max.z;

		}

		if ( this.w < min.w ) {

			this.w = min.w;

		} else if ( this.w > max.w ) {

			this.w = max.w;

		}

		return this;

	},

	negate: function() {

		return this.multiplyScalar( -1 );

	},

	dot: function ( v ) {

		return this.x * v.x + this.y * v.y + this.z * v.z + this.w * v.w;

	},

	lengthSq: function () {

		return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w;

	},

	length: function () {

		return Math.sqrt( this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w );

	},

	lengthManhattan: function () {

		return Math.abs( this.x ) + Math.abs( this.y ) + Math.abs( this.z ) + Math.abs( this.w );

	},

	normalize: function () {

		return this.divideScalar( this.length() );

	},

	setLength: function ( l ) {

		var oldLength = this.length();

		if ( oldLength !== 0 && l !== oldLength ) {

			this.multiplyScalar( l / oldLength );

		}

		return this;

	},

	lerp: function ( v, alpha ) {

		this.x += ( v.x - this.x ) * alpha;
		this.y += ( v.y - this.y ) * alpha;
		this.z += ( v.z - this.z ) * alpha;
		this.w += ( v.w - this.w ) * alpha;

		return this;

	},

	equals: function ( v ) {

		return ( ( v.x === this.x ) && ( v.y === this.y ) && ( v.z === this.z ) && ( v.w === this.w ) );

	},

	fromArray: function ( array ) {

		this.x = array[ 0 ];
		this.y = array[ 1 ];
		this.z = array[ 2 ];
		this.w = array[ 3 ];

		return this;

	},

	toArray: function () {

		return [ this.x, this.y, this.z, this.w ];

	},

	clone: function () {

		return new THREE.Vector4( this.x, this.y, this.z, this.w );

	}

};

/**
 * @author mrdoob / http://mrdoob.com/
 * @author WestLangley / http://github.com/WestLangley
 * @author bhouston / http://exocortex.com
 */

THREE.Euler = function ( x, y, z, order ) {

	this._x = x || 0;
	this._y = y || 0;
	this._z = z || 0;
	this._order = order || THREE.Euler.DefaultOrder;

};

THREE.Euler.RotationOrders = [ 'XYZ', 'YZX', 'ZXY', 'XZY', 'YXZ', 'ZYX' ];

THREE.Euler.DefaultOrder = 'XYZ';

THREE.Euler.prototype = {

	constructor: THREE.Euler,

	_x: 0, _y: 0, _z: 0, _order: THREE.Euler.DefaultOrder,

	_quaternion: undefined,

	_updateQuaternion: function () {

		if ( this._quaternion !== undefined ) {

			this._quaternion.setFromEuler( this, false );

		}

	},

	get x () {

		return this._x;

	},

	set x ( value ) {

		this._x = value;
		this._updateQuaternion();

	},

	get y () {

		return this._y;

	},

	set y ( value ) {

		this._y = value;
		this._updateQuaternion();

	},

	get z () {

		return this._z;

	},

	set z ( value ) {

		this._z = value;
		this._updateQuaternion();

	},

	get order () {

		return this._order;

	},

	set order ( value ) {

		this._order = value;
		this._updateQuaternion();

	},

	set: function ( x, y, z, order ) {

		this._x = x;
		this._y = y;
		this._z = z;
		this._order = order || this._order;

		this._updateQuaternion();

		return this;

	},

	copy: function ( euler ) {

		this._x = euler._x;
		this._y = euler._y;
		this._z = euler._z;
		this._order = euler._order;

		this._updateQuaternion();

		return this;

	},

	setFromRotationMatrix: function ( m, order ) {

		// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)

		// clamp, to handle numerical problems

		function clamp( x ) {

			return Math.min( Math.max( x, -1 ), 1 );

		}

		var te = m.elements;
		var m11 = te[0], m12 = te[4], m13 = te[8];
		var m21 = te[1], m22 = te[5], m23 = te[9];
		var m31 = te[2], m32 = te[6], m33 = te[10];

		order = order || this._order;

		if ( order === 'XYZ' ) {

			this._y = Math.asin( clamp( m13 ) );

			if ( Math.abs( m13 ) < 0.99999 ) {

				this._x = Math.atan2( - m23, m33 );
				this._z = Math.atan2( - m12, m11 );

			} else {

				this._x = Math.atan2( m32, m22 );
				this._z = 0;

			}

		} else if ( order === 'YXZ' ) {

			this._x = Math.asin( - clamp( m23 ) );

			if ( Math.abs( m23 ) < 0.99999 ) {

				this._y = Math.atan2( m13, m33 );
				this._z = Math.atan2( m21, m22 );

			} else {

				this._y = Math.atan2( - m31, m11 );
				this._z = 0;

			}

		} else if ( order === 'ZXY' ) {

			this._x = Math.asin( clamp( m32 ) );

			if ( Math.abs( m32 ) < 0.99999 ) {

				this._y = Math.atan2( - m31, m33 );
				this._z = Math.atan2( - m12, m22 );

			} else {

				this._y = 0;
				this._z = Math.atan2( m21, m11 );

			}

		} else if ( order === 'ZYX' ) {

			this._y = Math.asin( - clamp( m31 ) );

			if ( Math.abs( m31 ) < 0.99999 ) {

				this._x = Math.atan2( m32, m33 );
				this._z = Math.atan2( m21, m11 );

			} else {

				this._x = 0;
				this._z = Math.atan2( - m12, m22 );

			}

		} else if ( order === 'YZX' ) {

			this._z = Math.asin( clamp( m21 ) );

			if ( Math.abs( m21 ) < 0.99999 ) {

				this._x = Math.atan2( - m23, m22 );
				this._y = Math.atan2( - m31, m11 );

			} else {

				this._x = 0;
				this._y = Math.atan2( m13, m33 );

			}

		} else if ( order === 'XZY' ) {

			this._z = Math.asin( - clamp( m12 ) );

			if ( Math.abs( m12 ) < 0.99999 ) {

				this._x = Math.atan2( m32, m22 );
				this._y = Math.atan2( m13, m11 );

			} else {

				this._x = Math.atan2( - m23, m33 );
				this._y = 0;

			}

		} else {

			console.warn( 'WARNING: Euler.setFromRotationMatrix() given unsupported order: ' + order )

		}

		this._order = order;

		this._updateQuaternion();

		return this;

	},

	setFromQuaternion: function ( q, order, update ) {

		// q is assumed to be normalized

		// clamp, to handle numerical problems

		function clamp( x ) {

			return Math.min( Math.max( x, -1 ), 1 );

		}

		// http://www.mathworks.com/matlabcentral/fileexchange/20696-function-to-convert-between-dcm-euler-angles-quaternions-and-euler-vectors/content/SpinCalc.m

		var sqx = q.x * q.x;
		var sqy = q.y * q.y;
		var sqz = q.z * q.z;
		var sqw = q.w * q.w;

		order = order || this._order;

		if ( order === 'XYZ' ) {

			this._x = Math.atan2( 2 * ( q.x * q.w - q.y * q.z ), ( sqw - sqx - sqy + sqz ) );
			this._y = Math.asin(  clamp( 2 * ( q.x * q.z + q.y * q.w ) ) );
			this._z = Math.atan2( 2 * ( q.z * q.w - q.x * q.y ), ( sqw + sqx - sqy - sqz ) );

		} else if ( order ===  'YXZ' ) {

			this._x = Math.asin(  clamp( 2 * ( q.x * q.w - q.y * q.z ) ) );
			this._y = Math.atan2( 2 * ( q.x * q.z + q.y * q.w ), ( sqw - sqx - sqy + sqz ) );
			this._z = Math.atan2( 2 * ( q.x * q.y + q.z * q.w ), ( sqw - sqx + sqy - sqz ) );

		} else if ( order === 'ZXY' ) {

			this._x = Math.asin(  clamp( 2 * ( q.x * q.w + q.y * q.z ) ) );
			this._y = Math.atan2( 2 * ( q.y * q.w - q.z * q.x ), ( sqw - sqx - sqy + sqz ) );
			this._z = Math.atan2( 2 * ( q.z * q.w - q.x * q.y ), ( sqw - sqx + sqy - sqz ) );

		} else if ( order === 'ZYX' ) {

			this._x = Math.atan2( 2 * ( q.x * q.w + q.z * q.y ), ( sqw - sqx - sqy + sqz ) );
			this._y = Math.asin(  clamp( 2 * ( q.y * q.w - q.x * q.z ) ) );
			this._z = Math.atan2( 2 * ( q.x * q.y + q.z * q.w ), ( sqw + sqx - sqy - sqz ) );

		} else if ( order === 'YZX' ) {

			this._x = Math.atan2( 2 * ( q.x * q.w - q.z * q.y ), ( sqw - sqx + sqy - sqz ) );
			this._y = Math.atan2( 2 * ( q.y * q.w - q.x * q.z ), ( sqw + sqx - sqy - sqz ) );
			this._z = Math.asin(  clamp( 2 * ( q.x * q.y + q.z * q.w ) ) );

		} else if ( order === 'XZY' ) {

			this._x = Math.atan2( 2 * ( q.x * q.w + q.y * q.z ), ( sqw - sqx + sqy - sqz ) );
			this._y = Math.atan2( 2 * ( q.x * q.z + q.y * q.w ), ( sqw + sqx - sqy - sqz ) );
			this._z = Math.asin(  clamp( 2 * ( q.z * q.w - q.x * q.y ) ) );

		} else {

			console.warn( 'WARNING: Euler.setFromQuaternion() given unsupported order: ' + order )

		}

		this._order = order;

		if ( update !== false ) this._updateQuaternion();

		return this;

	},

	reorder: function () {

		// WARNING: this discards revolution information -bhouston

		var q = new THREE.Quaternion();

		return function ( newOrder ) {

			q.setFromEuler( this );
			this.setFromQuaternion( q, newOrder );

		};


	}(),

	fromArray: function ( array ) {

		this._x = array[ 0 ];
		this._y = array[ 1 ];
		this._z = array[ 2 ];
		if ( array[ 3 ] !== undefined ) this._order = array[ 3 ];

		this._updateQuaternion();

		return this;

	},

	toArray: function () {

		return [ this._x, this._y, this._z, this._order ];

	},

	equals: function ( euler ) {

		return ( euler._x === this._x ) && ( euler._y === this._y ) && ( euler._z === this._z ) && ( euler._order === this._order );

	},

	clone: function () {

		return new THREE.Euler( this._x, this._y, this._z, this._order );

	}

};

/**
 * @author bhouston / http://exocortex.com
 */

THREE.Line3 = function ( start, end ) {

	this.start = ( start !== undefined ) ? start : new THREE.Vector3();
	this.end = ( end !== undefined ) ? end : new THREE.Vector3();

};

THREE.Line3.prototype = {

	constructor: THREE.Line3,

	set: function ( start, end ) {

		this.start.copy( start );
		this.end.copy( end );

		return this;

	},

	copy: function ( line ) {

		this.start.copy( line.start );
		this.end.copy( line.end );

		return this;

	},

	center: function ( optionalTarget ) {

		var result = optionalTarget || new THREE.Vector3();
		return result.addVectors( this.start, this.end ).multiplyScalar( 0.5 );

	},

	delta: function ( optionalTarget ) {

		var result = optionalTarget || new THREE.Vector3();
		return result.subVectors( this.end, this.start );

	},

	distanceSq: function () {

		return this.start.distanceToSquared( this.end );

	},

	distance: function () {

		return this.start.distanceTo( this.end );

	},

	at: function ( t, optionalTarget ) {

		var result = optionalTarget || new THREE.Vector3();

		return this.delta( result ).multiplyScalar( t ).add( this.start );

	},

	closestPointToPointParameter: function() {

		var startP = new THREE.Vector3();
		var startEnd = new THREE.Vector3();

		return function ( point, clampToLine ) {

			startP.subVectors( point, this.start );
			startEnd.subVectors( this.end, this.start );

			var startEnd2 = startEnd.dot( startEnd );
			var startEnd_startP = startEnd.dot( startP );

			var t = startEnd_startP / startEnd2;

			if ( clampToLine ) {

				t = THREE.Math.clamp( t, 0, 1 );

			}

			return t;

		};

	}(),

	closestPointToPoint: function ( point, clampToLine, optionalTarget ) {

		var t = this.closestPointToPointParameter( point, clampToLine );

		var result = optionalTarget || new THREE.Vector3();

		return this.delta( result ).multiplyScalar( t ).add( this.start );

	},

	applyMatrix4: function ( matrix ) {

		this.start.applyMatrix4( matrix );
		this.end.applyMatrix4( matrix );

		return this;

	},

	equals: function ( line ) {

		return line.start.equals( this.start ) && line.end.equals( this.end );

	},

	clone: function () {

		return new THREE.Line3().copy( this );

	}

};

/**
 * @author bhouston / http://exocortex.com
 */

THREE.Box2 = function ( min, max ) {

	this.min = ( min !== undefined ) ? min : new THREE.Vector2( Infinity, Infinity );
	this.max = ( max !== undefined ) ? max : new THREE.Vector2( -Infinity, -Infinity );

};

THREE.Box2.prototype = {

	constructor: THREE.Box2,

	set: function ( min, max ) {

		this.min.copy( min );
		this.max.copy( max );

		return this;

	},

	setFromPoints: function ( points ) {

		if ( points.length > 0 ) {

			var point = points[ 0 ];

			this.min.copy( point );
			this.max.copy( point );

			for ( var i = 1, il = points.length; i < il; i ++ ) {

				point = points[ i ];

				if ( point.x < this.min.x ) {

					this.min.x = point.x;

				} else if ( point.x > this.max.x ) {

					this.max.x = point.x;

				}

				if ( point.y < this.min.y ) {

					this.min.y = point.y;

				} else if ( point.y > this.max.y ) {

					this.max.y = point.y;

				}

			}

		} else {

			this.makeEmpty();

		}

		return this;

	},

	setFromCenterAndSize: function () {

		var v1 = new THREE.Vector2();

		return function ( center, size ) {

			var halfSize = v1.copy( size ).multiplyScalar( 0.5 );
			this.min.copy( center ).sub( halfSize );
			this.max.copy( center ).add( halfSize );

			return this;

		};

	}(),

	copy: function ( box ) {

		this.min.copy( box.min );
		this.max.copy( box.max );

		return this;

	},

	makeEmpty: function () {

		this.min.x = this.min.y = Infinity;
		this.max.x = this.max.y = -Infinity;

		return this;

	},

	empty: function () {

		// this is a more robust check for empty than ( volume <= 0 ) because volume can get positive with two negative axes

		return ( this.max.x < this.min.x ) || ( this.max.y < this.min.y );

	},

	center: function ( optionalTarget ) {

		var result = optionalTarget || new THREE.Vector2();
		return result.addVectors( this.min, this.max ).multiplyScalar( 0.5 );

	},

	size: function ( optionalTarget ) {

		var result = optionalTarget || new THREE.Vector2();
		return result.subVectors( this.max, this.min );

	},

	expandByPoint: function ( point ) {

		this.min.min( point );
		this.max.max( point );

		return this;
	},

	expandByVector: function ( vector ) {

		this.min.sub( vector );
		this.max.add( vector );

		return this;
	},

	expandByScalar: function ( scalar ) {

		this.min.addScalar( -scalar );
		this.max.addScalar( scalar );

		return this;
	},

	containsPoint: function ( point ) {

		if ( point.x < this.min.x || point.x > this.max.x ||
		     point.y < this.min.y || point.y > this.max.y ) {

			return false;

		}

		return true;

	},

	containsBox: function ( box ) {

		if ( ( this.min.x <= box.min.x ) && ( box.max.x <= this.max.x ) &&
		     ( this.min.y <= box.min.y ) && ( box.max.y <= this.max.y ) ) {

			return true;

		}

		return false;

	},

	getParameter: function ( point, optionalTarget ) {

		// This can potentially have a divide by zero if the box
		// has a size dimension of 0.

		var result = optionalTarget || new THREE.Vector2();

		return result.set(
			( point.x - this.min.x ) / ( this.max.x - this.min.x ),
			( point.y - this.min.y ) / ( this.max.y - this.min.y )
		);

	},

	isIntersectionBox: function ( box ) {

		// using 6 splitting planes to rule out intersections.

		if ( box.max.x < this.min.x || box.min.x > this.max.x ||
		     box.max.y < this.min.y || box.min.y > this.max.y ) {

			return false;

		}

		return true;

	},

	clampPoint: function ( point, optionalTarget ) {

		var result = optionalTarget || new THREE.Vector2();
		return result.copy( point ).clamp( this.min, this.max );

	},

	distanceToPoint: function () {

		var v1 = new THREE.Vector2();

		return function ( point ) {

			var clampedPoint = v1.copy( point ).clamp( this.min, this.max );
			return clampedPoint.sub( point ).length();

		};

	}(),

	intersect: function ( box ) {

		this.min.max( box.min );
		this.max.min( box.max );

		return this;

	},

	union: function ( box ) {

		this.min.min( box.min );
		this.max.max( box.max );

		return this;

	},

	translate: function ( offset ) {

		this.min.add( offset );
		this.max.add( offset );

		return this;

	},

	equals: function ( box ) {

		return box.min.equals( this.min ) && box.max.equals( this.max );

	},

	clone: function () {

		return new THREE.Box2().copy( this );

	}

};

/**
 * @author bhouston / http://exocortex.com
 * @author WestLangley / http://github.com/WestLangley
 */

THREE.Box3 = function ( min, max ) {

	this.min = ( min !== undefined ) ? min : new THREE.Vector3( Infinity, Infinity, Infinity );
	this.max = ( max !== undefined ) ? max : new THREE.Vector3( -Infinity, -Infinity, -Infinity );

};

THREE.Box3.prototype = {

	constructor: THREE.Box3,

	set: function ( min, max ) {

		this.min.copy( min );
		this.max.copy( max );

		return this;

	},

	addPoint: function ( point ) {

		if ( point.x < this.min.x ) {

			this.min.x = point.x;

		} else if ( point.x > this.max.x ) {

			this.max.x = point.x;

		}

		if ( point.y < this.min.y ) {

			this.min.y = point.y;

		} else if ( point.y > this.max.y ) {

			this.max.y = point.y;

		}

		if ( point.z < this.min.z ) {

			this.min.z = point.z;

		} else if ( point.z > this.max.z ) {

			this.max.z = point.z;

		}

	},

	setFromPoints: function ( points ) {

		if ( points.length > 0 ) {

			var point = points[ 0 ];

			this.min.copy( point );
			this.max.copy( point );

			for ( var i = 1, il = points.length; i < il; i ++ ) {

				this.addPoint( points[ i ] )

			}

		} else {

			this.makeEmpty();

		}

		return this;

	},

	setFromCenterAndSize: function() {

		var v1 = new THREE.Vector3();

		return function ( center, size ) {

			var halfSize = v1.copy( size ).multiplyScalar( 0.5 );

			this.min.copy( center ).sub( halfSize );
			this.max.copy( center ).add( halfSize );

			return this;

		};

	}(),

	setFromObject: function() {

		// Computes the world-axis-aligned bounding box of an object (including its children),
		// accounting for both the object's, and childrens', world transforms

		var v1 = new THREE.Vector3();

		return function( object ) {

			var scope = this;

			object.updateMatrixWorld( true );

			this.makeEmpty();

			object.traverse( function ( node ) {

				if ( node.geometry !== undefined && node.geometry.vertices !== undefined ) {

					var vertices = node.geometry.vertices;

					for ( var i = 0, il = vertices.length; i < il; i++ ) {

						v1.copy( vertices[ i ] );

						v1.applyMatrix4( node.matrixWorld );

						scope.expandByPoint( v1 );

					}

				}

			} );

			return this;

		};

	}(),

	copy: function ( box ) {

		this.min.copy( box.min );
		this.max.copy( box.max );

		return this;

	},

	makeEmpty: function () {

		this.min.x = this.min.y = this.min.z = Infinity;
		this.max.x = this.max.y = this.max.z = -Infinity;

		return this;

	},

	empty: function () {

		// this is a more robust check for empty than ( volume <= 0 ) because volume can get positive with two negative axes

		return ( this.max.x < this.min.x ) || ( this.max.y < this.min.y ) || ( this.max.z < this.min.z );

	},

	center: function ( optionalTarget ) {

		var result = optionalTarget || new THREE.Vector3();
		return result.addVectors( this.min, this.max ).multiplyScalar( 0.5 );

	},

	size: function ( optionalTarget ) {

		var result = optionalTarget || new THREE.Vector3();
		return result.subVectors( this.max, this.min );

	},

	expandByPoint: function ( point ) {

		this.min.min( point );
		this.max.max( point );

		return this;

	},

	expandByVector: function ( vector ) {

		this.min.sub( vector );
		this.max.add( vector );

		return this;

	},

	expandByScalar: function ( scalar ) {

		this.min.addScalar( -scalar );
		this.max.addScalar( scalar );

		return this;

	},

	containsPoint: function ( point ) {

		if ( point.x < this.min.x || point.x > this.max.x ||
		     point.y < this.min.y || point.y > this.max.y ||
		     point.z < this.min.z || point.z > this.max.z ) {

			return false;

		}

		return true;

	},

	containsBox: function ( box ) {

		if ( ( this.min.x <= box.min.x ) && ( box.max.x <= this.max.x ) &&
			 ( this.min.y <= box.min.y ) && ( box.max.y <= this.max.y ) &&
			 ( this.min.z <= box.min.z ) && ( box.max.z <= this.max.z ) ) {

			return true;

		}

		return false;

	},

	getParameter: function ( point, optionalTarget ) {

		// This can potentially have a divide by zero if the box
		// has a size dimension of 0.

		var result = optionalTarget || new THREE.Vector3();

		return result.set(
			( point.x - this.min.x ) / ( this.max.x - this.min.x ),
			( point.y - this.min.y ) / ( this.max.y - this.min.y ),
			( point.z - this.min.z ) / ( this.max.z - this.min.z )
		);

	},

	isIntersectionBox: function ( box ) {

		// using 6 splitting planes to rule out intersections.

		if ( box.max.x < this.min.x || box.min.x > this.max.x ||
		     box.max.y < this.min.y || box.min.y > this.max.y ||
		     box.max.z < this.min.z || box.min.z > this.max.z ) {

			return false;

		}

		return true;

	},

	clampPoint: function ( point, optionalTarget ) {

		var result = optionalTarget || new THREE.Vector3();
		return result.copy( point ).clamp( this.min, this.max );

	},

	distanceToPoint: function() {

		var v1 = new THREE.Vector3();

		return function ( point ) {

			var clampedPoint = v1.copy( point ).clamp( this.min, this.max );
			return clampedPoint.sub( point ).length();

		};

	}(),

	getBoundingSphere: function() {

		var v1 = new THREE.Vector3();

		return function ( optionalTarget ) {

			var result = optionalTarget || new THREE.Sphere();

			result.center = this.center();
			result.radius = this.size( v1 ).length() * 0.5;

			return result;

		};

	}(),

	intersect: function ( box ) {

		this.min.max( box.min );
		this.max.min( box.max );

		return this;

	},

	union: function ( box ) {

		this.min.min( box.min );
		this.max.max( box.max );

		return this;

	},

	applyMatrix4: function() {

		var points = [
			new THREE.Vector3(),
			new THREE.Vector3(),
			new THREE.Vector3(),
			new THREE.Vector3(),
			new THREE.Vector3(),
			new THREE.Vector3(),
			new THREE.Vector3(),
			new THREE.Vector3()
		];

		return function ( matrix ) {

			// NOTE: I am using a binary pattern to specify all 2^3 combinations below
			points[0].set( this.min.x, this.min.y, this.min.z ).applyMatrix4( matrix ); // 000
			points[1].set( this.min.x, this.min.y, this.max.z ).applyMatrix4( matrix ); // 001
			points[2].set( this.min.x, this.max.y, this.min.z ).applyMatrix4( matrix ); // 010
			points[3].set( this.min.x, this.max.y, this.max.z ).applyMatrix4( matrix ); // 011
			points[4].set( this.max.x, this.min.y, this.min.z ).applyMatrix4( matrix ); // 100
			points[5].set( this.max.x, this.min.y, this.max.z ).applyMatrix4( matrix ); // 101
			points[6].set( this.max.x, this.max.y, this.min.z ).applyMatrix4( matrix ); // 110
			points[7].set( this.max.x, this.max.y, this.max.z ).applyMatrix4( matrix );  // 111

			this.makeEmpty();
			this.setFromPoints( points );

			return this;

		};

	}(),

	translate: function ( offset ) {

		this.min.add( offset );
		this.max.add( offset );

		return this;

	},

	equals: function ( box ) {

		return box.min.equals( this.min ) && box.max.equals( this.max );

	},

	clone: function () {

		return new THREE.Box3().copy( this );

	}

};

/**
 * @author alteredq / http://alteredqualia.com/
 * @author WestLangley / http://github.com/WestLangley
 * @author bhouston / http://exocortex.com
 */

THREE.Matrix3 = function ( n11, n12, n13, n21, n22, n23, n31, n32, n33 ) {

	this.elements = new Float32Array(9);

	this.set(

		( n11 !== undefined ) ? n11 : 1, n12 || 0, n13 || 0,
		n21 || 0, ( n22 !== undefined ) ? n22 : 1, n23 || 0,
		n31 || 0, n32 || 0, ( n33 !== undefined ) ? n33 : 1

	);
};

THREE.Matrix3.prototype = {

	constructor: THREE.Matrix3,

	set: function ( n11, n12, n13, n21, n22, n23, n31, n32, n33 ) {

		var te = this.elements;

		te[0] = n11; te[3] = n12; te[6] = n13;
		te[1] = n21; te[4] = n22; te[7] = n23;
		te[2] = n31; te[5] = n32; te[8] = n33;

		return this;

	},

	identity: function () {

		this.set(

			1, 0, 0,
			0, 1, 0,
			0, 0, 1

		);

		return this;

	},

	copy: function ( m ) {

		var me = m.elements;

		this.set(

			me[0], me[3], me[6],
			me[1], me[4], me[7],
			me[2], me[5], me[8]

		);

		return this;

	},

	multiplyVector3: function ( vector ) {

		console.warn( 'DEPRECATED: Matrix3\'s .multiplyVector3() has been removed. Use vector.applyMatrix3( matrix ) instead.' );
		return vector.applyMatrix3( this );

	},

	multiplyVector3Array: function() {

		var v1 = new THREE.Vector3();

		return function ( a ) {

			for ( var i = 0, il = a.length; i < il; i += 3 ) {

				v1.x = a[ i ];
				v1.y = a[ i + 1 ];
				v1.z = a[ i + 2 ];

				v1.applyMatrix3(this);

				a[ i ]     = v1.x;
				a[ i + 1 ] = v1.y;
				a[ i + 2 ] = v1.z;

			}

			return a;

		};

	}(),

	multiplyScalar: function ( s ) {

		var te = this.elements;

		te[0] *= s; te[3] *= s; te[6] *= s;
		te[1] *= s; te[4] *= s; te[7] *= s;
		te[2] *= s; te[5] *= s; te[8] *= s;

		return this;

	},

	determinant: function () {

		var te = this.elements;

		var a = te[0], b = te[1], c = te[2],
			d = te[3], e = te[4], f = te[5],
			g = te[6], h = te[7], i = te[8];

		return a*e*i - a*f*h - b*d*i + b*f*g + c*d*h - c*e*g;

	},

	getInverse: function ( matrix, throwOnInvertible ) {

		// input: THREE.Matrix4
		// ( based on http://code.google.com/p/webgl-mjs/ )

		var me = matrix.elements;
		var te = this.elements;

		te[ 0 ] =   me[10] * me[5] - me[6] * me[9];
		te[ 1 ] = - me[10] * me[1] + me[2] * me[9];
		te[ 2 ] =   me[6] * me[1] - me[2] * me[5];
		te[ 3 ] = - me[10] * me[4] + me[6] * me[8];
		te[ 4 ] =   me[10] * me[0] - me[2] * me[8];
		te[ 5 ] = - me[6] * me[0] + me[2] * me[4];
		te[ 6 ] =   me[9] * me[4] - me[5] * me[8];
		te[ 7 ] = - me[9] * me[0] + me[1] * me[8];
		te[ 8 ] =   me[5] * me[0] - me[1] * me[4];

		var det = me[ 0 ] * te[ 0 ] + me[ 1 ] * te[ 3 ] + me[ 2 ] * te[ 6 ];

		// no inverse

		if ( det === 0 ) {

			var msg = "Matrix3.getInverse(): can't invert matrix, determinant is 0";

			if ( throwOnInvertible || false ) {

				throw new Error( msg );

			} else {

				console.warn( msg );

			}

			this.identity();

			return this;

		}

		this.multiplyScalar( 1.0 / det );

		return this;

	},

	transpose: function () {

		var tmp, m = this.elements;

		tmp = m[1]; m[1] = m[3]; m[3] = tmp;
		tmp = m[2]; m[2] = m[6]; m[6] = tmp;
		tmp = m[5]; m[5] = m[7]; m[7] = tmp;

		return this;

	},

	getNormalMatrix: function ( m ) {

		// input: THREE.Matrix4

		this.getInverse( m ).transpose();

		return this;

	},

	transposeIntoArray: function ( r ) {

		var m = this.elements;

		r[ 0 ] = m[ 0 ];
		r[ 1 ] = m[ 3 ];
		r[ 2 ] = m[ 6 ];
		r[ 3 ] = m[ 1 ];
		r[ 4 ] = m[ 4 ];
		r[ 5 ] = m[ 7 ];
		r[ 6 ] = m[ 2 ];
		r[ 7 ] = m[ 5 ];
		r[ 8 ] = m[ 8 ];

		return this;

	},

	fromArray: function ( array ) {

		this.elements.set( array );

		return this;

	},

	toArray: function () {

		var te = this.elements;

		return [
			te[ 0 ], te[ 1 ], te[ 2 ],
			te[ 3 ], te[ 4 ], te[ 5 ],
			te[ 6 ], te[ 7 ], te[ 8 ]
		];

	},

	clone: function () {

		var te = this.elements;

		return new THREE.Matrix3(

			te[0], te[3], te[6],
			te[1], te[4], te[7],
			te[2], te[5], te[8]

		);

	}

};

/**
 * @author mrdoob / http://mrdoob.com/
 * @author supereggbert / http://www.paulbrunt.co.uk/
 * @author philogb / http://blog.thejit.org/
 * @author jordi_ros / http://plattsoft.com
 * @author D1plo1d / http://github.com/D1plo1d
 * @author alteredq / http://alteredqualia.com/
 * @author mikael emtinger / http://gomo.se/
 * @author timknip / http://www.floorplanner.com/
 * @author bhouston / http://exocortex.com
 * @author WestLangley / http://github.com/WestLangley
 */


THREE.Matrix4 = function ( n11, n12, n13, n14, n21, n22, n23, n24, n31, n32, n33, n34, n41, n42, n43, n44 ) {

	this.elements = new Float32Array( 16 );

	// TODO: if n11 is undefined, then just set to identity, otherwise copy all other values into matrix
	//   we should not support semi specification of Matrix4, it is just weird.

	var te = this.elements;

	te[0] = ( n11 !== undefined ) ? n11 : 1; te[4] = n12 || 0; te[8] = n13 || 0; te[12] = n14 || 0;
	te[1] = n21 || 0; te[5] = ( n22 !== undefined ) ? n22 : 1; te[9] = n23 || 0; te[13] = n24 || 0;
	te[2] = n31 || 0; te[6] = n32 || 0; te[10] = ( n33 !== undefined ) ? n33 : 1; te[14] = n34 || 0;
	te[3] = n41 || 0; te[7] = n42 || 0; te[11] = n43 || 0; te[15] = ( n44 !== undefined ) ? n44 : 1;

};

THREE.Matrix4.prototype = {

	constructor: THREE.Matrix4,

	set: function ( n11, n12, n13, n14, n21, n22, n23, n24, n31, n32, n33, n34, n41, n42, n43, n44 ) {

		var te = this.elements;

		te[0] = n11; te[4] = n12; te[8] = n13; te[12] = n14;
		te[1] = n21; te[5] = n22; te[9] = n23; te[13] = n24;
		te[2] = n31; te[6] = n32; te[10] = n33; te[14] = n34;
		te[3] = n41; te[7] = n42; te[11] = n43; te[15] = n44;

		return this;

	},

	identity: function () {

		this.set(

			1, 0, 0, 0,
			0, 1, 0, 0,
			0, 0, 1, 0,
			0, 0, 0, 1

		);

		return this;

	},

	copy: function ( m ) {

		this.elements.set( m.elements );

		return this;

	},

	extractPosition: function ( m ) {

		console.warn( 'DEPRECATED: Matrix4\'s .extractPosition() has been renamed to .copyPosition().' );
		return this.copyPosition( m );

	},

	copyPosition: function ( m ) {

		var te = this.elements;
		var me = m.elements;

		te[12] = me[12];
		te[13] = me[13];
		te[14] = me[14];

		return this;

	},

	extractRotation: function () {

		var v1 = new THREE.Vector3();

		return function ( m ) {

			var te = this.elements;
			var me = m.elements;

			var scaleX = 1 / v1.set( me[0], me[1], me[2] ).length();
			var scaleY = 1 / v1.set( me[4], me[5], me[6] ).length();
			var scaleZ = 1 / v1.set( me[8], me[9], me[10] ).length();

			te[0] = me[0] * scaleX;
			te[1] = me[1] * scaleX;
			te[2] = me[2] * scaleX;

			te[4] = me[4] * scaleY;
			te[5] = me[5] * scaleY;
			te[6] = me[6] * scaleY;

			te[8] = me[8] * scaleZ;
			te[9] = me[9] * scaleZ;
			te[10] = me[10] * scaleZ;

			return this;

		};

	}(),

	makeRotationFromEuler: function ( euler ) {

		if ( euler instanceof THREE.Euler === false ) {

			console.error( 'ERROR: Matrix\'s .makeRotationFromEuler() now expects a Euler rotation rather than a Vector3 and order.  Please update your code.' );

		}

		var te = this.elements;

		var x = euler.x, y = euler.y, z = euler.z;
		var a = Math.cos( x ), b = Math.sin( x );
		var c = Math.cos( y ), d = Math.sin( y );
		var e = Math.cos( z ), f = Math.sin( z );

		if ( euler.order === 'XYZ' ) {

			var ae = a * e, af = a * f, be = b * e, bf = b * f;

			te[0] = c * e;
			te[4] = - c * f;
			te[8] = d;

			te[1] = af + be * d;
			te[5] = ae - bf * d;
			te[9] = - b * c;

			te[2] = bf - ae * d;
			te[6] = be + af * d;
			te[10] = a * c;

		} else if ( euler.order === 'YXZ' ) {

			var ce = c * e, cf = c * f, de = d * e, df = d * f;

			te[0] = ce + df * b;
			te[4] = de * b - cf;
			te[8] = a * d;

			te[1] = a * f;
			te[5] = a * e;
			te[9] = - b;

			te[2] = cf * b - de;
			te[6] = df + ce * b;
			te[10] = a * c;

		} else if ( euler.order === 'ZXY' ) {

			var ce = c * e, cf = c * f, de = d * e, df = d * f;

			te[0] = ce - df * b;
			te[4] = - a * f;
			te[8] = de + cf * b;

			te[1] = cf + de * b;
			te[5] = a * e;
			te[9] = df - ce * b;

			te[2] = - a * d;
			te[6] = b;
			te[10] = a * c;

		} else if ( euler.order === 'ZYX' ) {

			var ae = a * e, af = a * f, be = b * e, bf = b * f;

			te[0] = c * e;
			te[4] = be * d - af;
			te[8] = ae * d + bf;

			te[1] = c * f;
			te[5] = bf * d + ae;
			te[9] = af * d - be;

			te[2] = - d;
			te[6] = b * c;
			te[10] = a * c;

		} else if ( euler.order === 'YZX' ) {

			var ac = a * c, ad = a * d, bc = b * c, bd = b * d;

			te[0] = c * e;
			te[4] = bd - ac * f;
			te[8] = bc * f + ad;

			te[1] = f;
			te[5] = a * e;
			te[9] = - b * e;

			te[2] = - d * e;
			te[6] = ad * f + bc;
			te[10] = ac - bd * f;

		} else if ( euler.order === 'XZY' ) {

			var ac = a * c, ad = a * d, bc = b * c, bd = b * d;

			te[0] = c * e;
			te[4] = - f;
			te[8] = d * e;

			te[1] = ac * f + bd;
			te[5] = a * e;
			te[9] = ad * f - bc;

			te[2] = bc * f - ad;
			te[6] = b * e;
			te[10] = bd * f + ac;

		}

		// last column
		te[3] = 0;
		te[7] = 0;
		te[11] = 0;

		// bottom row
		te[12] = 0;
		te[13] = 0;
		te[14] = 0;
		te[15] = 1;

		return this;

	},

	setRotationFromQuaternion: function ( q ) {

		console.warn( 'DEPRECATED: Matrix4\'s .setRotationFromQuaternion() has been deprecated in favor of makeRotationFromQuaternion.  Please update your code.' );

		return this.makeRotationFromQuaternion( q );

	},

	makeRotationFromQuaternion: function ( q ) {

		var te = this.elements;

		var x = q.x, y = q.y, z = q.z, w = q.w;
		var x2 = x + x, y2 = y + y, z2 = z + z;
		var xx = x * x2, xy = x * y2, xz = x * z2;
		var yy = y * y2, yz = y * z2, zz = z * z2;
		var wx = w * x2, wy = w * y2, wz = w * z2;

		te[0] = 1 - ( yy + zz );
		te[4] = xy - wz;
		te[8] = xz + wy;

		te[1] = xy + wz;
		te[5] = 1 - ( xx + zz );
		te[9] = yz - wx;

		te[2] = xz - wy;
		te[6] = yz + wx;
		te[10] = 1 - ( xx + yy );

		// last column
		te[3] = 0;
		te[7] = 0;
		te[11] = 0;

		// bottom row
		te[12] = 0;
		te[13] = 0;
		te[14] = 0;
		te[15] = 1;

		return this;

	},

	lookAt: function() {

		var x = new THREE.Vector3();
		var y = new THREE.Vector3();
		var z = new THREE.Vector3();

		return function ( eye, target, up ) {

			var te = this.elements;

			z.subVectors( eye, target ).normalize();

			if ( z.length() === 0 ) {

				z.z = 1;

			}

			x.crossVectors( up, z ).normalize();

			if ( x.length() === 0 ) {

				z.x += 0.0001;
				x.crossVectors( up, z ).normalize();

			}

			y.crossVectors( z, x );


			te[0] = x.x; te[4] = y.x; te[8] = z.x;
			te[1] = x.y; te[5] = y.y; te[9] = z.y;
			te[2] = x.z; te[6] = y.z; te[10] = z.z;

			return this;

		};

	}(),

	multiply: function ( m, n ) {

		if ( n !== undefined ) {

			console.warn( 'DEPRECATED: Matrix4\'s .multiply() now only accepts one argument. Use .multiplyMatrices( a, b ) instead.' );
			return this.multiplyMatrices( m, n );

		}

		return this.multiplyMatrices( this, m );

	},

	multiplyMatrices: function ( a, b ) {

		var ae = a.elements;
		var be = b.elements;
		var te = this.elements;

		var a11 = ae[0], a12 = ae[4], a13 = ae[8], a14 = ae[12];
		var a21 = ae[1], a22 = ae[5], a23 = ae[9], a24 = ae[13];
		var a31 = ae[2], a32 = ae[6], a33 = ae[10], a34 = ae[14];
		var a41 = ae[3], a42 = ae[7], a43 = ae[11], a44 = ae[15];

		var b11 = be[0], b12 = be[4], b13 = be[8], b14 = be[12];
		var b21 = be[1], b22 = be[5], b23 = be[9], b24 = be[13];
		var b31 = be[2], b32 = be[6], b33 = be[10], b34 = be[14];
		var b41 = be[3], b42 = be[7], b43 = be[11], b44 = be[15];

		te[0] = a11 * b11 + a12 * b21 + a13 * b31 + a14 * b41;
		te[4] = a11 * b12 + a12 * b22 + a13 * b32 + a14 * b42;
		te[8] = a11 * b13 + a12 * b23 + a13 * b33 + a14 * b43;
		te[12] = a11 * b14 + a12 * b24 + a13 * b34 + a14 * b44;

		te[1] = a21 * b11 + a22 * b21 + a23 * b31 + a24 * b41;
		te[5] = a21 * b12 + a22 * b22 + a23 * b32 + a24 * b42;
		te[9] = a21 * b13 + a22 * b23 + a23 * b33 + a24 * b43;
		te[13] = a21 * b14 + a22 * b24 + a23 * b34 + a24 * b44;

		te[2] = a31 * b11 + a32 * b21 + a33 * b31 + a34 * b41;
		te[6] = a31 * b12 + a32 * b22 + a33 * b32 + a34 * b42;
		te[10] = a31 * b13 + a32 * b23 + a33 * b33 + a34 * b43;
		te[14] = a31 * b14 + a32 * b24 + a33 * b34 + a34 * b44;

		te[3] = a41 * b11 + a42 * b21 + a43 * b31 + a44 * b41;
		te[7] = a41 * b12 + a42 * b22 + a43 * b32 + a44 * b42;
		te[11] = a41 * b13 + a42 * b23 + a43 * b33 + a44 * b43;
		te[15] = a41 * b14 + a42 * b24 + a43 * b34 + a44 * b44;

		return this;

	},

	multiplyToArray: function ( a, b, r ) {

		var te = this.elements;

		this.multiplyMatrices( a, b );

		r[ 0 ] = te[0]; r[ 1 ] = te[1]; r[ 2 ] = te[2]; r[ 3 ] = te[3];
		r[ 4 ] = te[4]; r[ 5 ] = te[5]; r[ 6 ] = te[6]; r[ 7 ] = te[7];
		r[ 8 ]  = te[8]; r[ 9 ]  = te[9]; r[ 10 ] = te[10]; r[ 11 ] = te[11];
		r[ 12 ] = te[12]; r[ 13 ] = te[13]; r[ 14 ] = te[14]; r[ 15 ] = te[15];

		return this;

	},

	multiplyScalar: function ( s ) {

		var te = this.elements;

		te[0] *= s; te[4] *= s; te[8] *= s; te[12] *= s;
		te[1] *= s; te[5] *= s; te[9] *= s; te[13] *= s;
		te[2] *= s; te[6] *= s; te[10] *= s; te[14] *= s;
		te[3] *= s; te[7] *= s; te[11] *= s; te[15] *= s;

		return this;

	},

	multiplyVector3: function ( vector ) {

		console.warn( 'DEPRECATED: Matrix4\'s .multiplyVector3() has been removed. Use vector.applyMatrix4( matrix ) or vector.applyProjection( matrix ) instead.' );
		return vector.applyProjection( this );

	},

	multiplyVector4: function ( vector ) {

		console.warn( 'DEPRECATED: Matrix4\'s .multiplyVector4() has been removed. Use vector.applyMatrix4( matrix ) instead.' );
		return vector.applyMatrix4( this );

	},

	multiplyVector3Array: function() {

		var v1 = new THREE.Vector3();

		return function ( a ) {

			for ( var i = 0, il = a.length; i < il; i += 3 ) {

				v1.x = a[ i ];
				v1.y = a[ i + 1 ];
				v1.z = a[ i + 2 ];

				v1.applyProjection( this );

				a[ i ]     = v1.x;
				a[ i + 1 ] = v1.y;
				a[ i + 2 ] = v1.z;

			}

			return a;

		};

	}(),

	rotateAxis: function ( v ) {

		console.warn( 'DEPRECATED: Matrix4\'s .rotateAxis() has been removed. Use Vector3.transformDirection( matrix ) instead.' );

		v.transformDirection( this );

	},

	crossVector: function ( vector ) {

		console.warn( 'DEPRECATED: Matrix4\'s .crossVector() has been removed. Use vector.applyMatrix4( matrix ) instead.' );
		return vector.applyMatrix4( this );

	},

	determinant: function () {

		var te = this.elements;

		var n11 = te[0], n12 = te[4], n13 = te[8], n14 = te[12];
		var n21 = te[1], n22 = te[5], n23 = te[9], n24 = te[13];
		var n31 = te[2], n32 = te[6], n33 = te[10], n34 = te[14];
		var n41 = te[3], n42 = te[7], n43 = te[11], n44 = te[15];

		//TODO: make this more efficient
		//( based on http://www.euclideanspace.com/maths/algebra/matrix/functions/inverse/fourD/index.htm )

		return (
			n41 * (
				+n14 * n23 * n32
				-n13 * n24 * n32
				-n14 * n22 * n33
				+n12 * n24 * n33
				+n13 * n22 * n34
				-n12 * n23 * n34
			) +
			n42 * (
				+n11 * n23 * n34
				-n11 * n24 * n33
				+n14 * n21 * n33
				-n13 * n21 * n34
				+n13 * n24 * n31
				-n14 * n23 * n31
			) +
			n43 * (
				+n11 * n24 * n32
				-n11 * n22 * n34
				-n14 * n21 * n32
				+n12 * n21 * n34
				+n14 * n22 * n31
				-n12 * n24 * n31
			) +
			n44 * (
				-n13 * n22 * n31
				-n11 * n23 * n32
				+n11 * n22 * n33
				+n13 * n21 * n32
				-n12 * n21 * n33
				+n12 * n23 * n31
			)

		);

	},

	transpose: function () {

		var te = this.elements;
		var tmp;

		tmp = te[1]; te[1] = te[4]; te[4] = tmp;
		tmp = te[2]; te[2] = te[8]; te[8] = tmp;
		tmp = te[6]; te[6] = te[9]; te[9] = tmp;

		tmp = te[3]; te[3] = te[12]; te[12] = tmp;
		tmp = te[7]; te[7] = te[13]; te[13] = tmp;
		tmp = te[11]; te[11] = te[14]; te[14] = tmp;

		return this;

	},

	flattenToArray: function ( flat ) {

		var te = this.elements;
		flat[ 0 ] = te[0]; flat[ 1 ] = te[1]; flat[ 2 ] = te[2]; flat[ 3 ] = te[3];
		flat[ 4 ] = te[4]; flat[ 5 ] = te[5]; flat[ 6 ] = te[6]; flat[ 7 ] = te[7];
		flat[ 8 ] = te[8]; flat[ 9 ] = te[9]; flat[ 10 ] = te[10]; flat[ 11 ] = te[11];
		flat[ 12 ] = te[12]; flat[ 13 ] = te[13]; flat[ 14 ] = te[14]; flat[ 15 ] = te[15];

		return flat;

	},

	flattenToArrayOffset: function( flat, offset ) {

		var te = this.elements;
		flat[ offset ] = te[0];
		flat[ offset + 1 ] = te[1];
		flat[ offset + 2 ] = te[2];
		flat[ offset + 3 ] = te[3];

		flat[ offset + 4 ] = te[4];
		flat[ offset + 5 ] = te[5];
		flat[ offset + 6 ] = te[6];
		flat[ offset + 7 ] = te[7];

		flat[ offset + 8 ]  = te[8];
		flat[ offset + 9 ]  = te[9];
		flat[ offset + 10 ] = te[10];
		flat[ offset + 11 ] = te[11];

		flat[ offset + 12 ] = te[12];
		flat[ offset + 13 ] = te[13];
		flat[ offset + 14 ] = te[14];
		flat[ offset + 15 ] = te[15];

		return flat;

	},

	getPosition: function() {

		var v1 = new THREE.Vector3();

		return function () {

			console.warn( 'DEPRECATED: Matrix4\'s .getPosition() has been removed. Use Vector3.setFromMatrixPosition( matrix ) instead.' );

			var te = this.elements;
			return v1.set( te[12], te[13], te[14] );

		};

	}(),

	setPosition: function ( v ) {

		var te = this.elements;

		te[12] = v.x;
		te[13] = v.y;
		te[14] = v.z;

		return this;

	},

	getInverse: function ( m, throwOnInvertible ) {

		// based on http://www.euclideanspace.com/maths/algebra/matrix/functions/inverse/fourD/index.htm
		var te = this.elements;
		var me = m.elements;

		var n11 = me[0], n12 = me[4], n13 = me[8], n14 = me[12];
		var n21 = me[1], n22 = me[5], n23 = me[9], n24 = me[13];
		var n31 = me[2], n32 = me[6], n33 = me[10], n34 = me[14];
		var n41 = me[3], n42 = me[7], n43 = me[11], n44 = me[15];

		te[0] = n23*n34*n42 - n24*n33*n42 + n24*n32*n43 - n22*n34*n43 - n23*n32*n44 + n22*n33*n44;
		te[4] = n14*n33*n42 - n13*n34*n42 - n14*n32*n43 + n12*n34*n43 + n13*n32*n44 - n12*n33*n44;
		te[8] = n13*n24*n42 - n14*n23*n42 + n14*n22*n43 - n12*n24*n43 - n13*n22*n44 + n12*n23*n44;
		te[12] = n14*n23*n32 - n13*n24*n32 - n14*n22*n33 + n12*n24*n33 + n13*n22*n34 - n12*n23*n34;
		te[1] = n24*n33*n41 - n23*n34*n41 - n24*n31*n43 + n21*n34*n43 + n23*n31*n44 - n21*n33*n44;
		te[5] = n13*n34*n41 - n14*n33*n41 + n14*n31*n43 - n11*n34*n43 - n13*n31*n44 + n11*n33*n44;
		te[9] = n14*n23*n41 - n13*n24*n41 - n14*n21*n43 + n11*n24*n43 + n13*n21*n44 - n11*n23*n44;
		te[13] = n13*n24*n31 - n14*n23*n31 + n14*n21*n33 - n11*n24*n33 - n13*n21*n34 + n11*n23*n34;
		te[2] = n22*n34*n41 - n24*n32*n41 + n24*n31*n42 - n21*n34*n42 - n22*n31*n44 + n21*n32*n44;
		te[6] = n14*n32*n41 - n12*n34*n41 - n14*n31*n42 + n11*n34*n42 + n12*n31*n44 - n11*n32*n44;
		te[10] = n12*n24*n41 - n14*n22*n41 + n14*n21*n42 - n11*n24*n42 - n12*n21*n44 + n11*n22*n44;
		te[14] = n14*n22*n31 - n12*n24*n31 - n14*n21*n32 + n11*n24*n32 + n12*n21*n34 - n11*n22*n34;
		te[3] = n23*n32*n41 - n22*n33*n41 - n23*n31*n42 + n21*n33*n42 + n22*n31*n43 - n21*n32*n43;
		te[7] = n12*n33*n41 - n13*n32*n41 + n13*n31*n42 - n11*n33*n42 - n12*n31*n43 + n11*n32*n43;
		te[11] = n13*n22*n41 - n12*n23*n41 - n13*n21*n42 + n11*n23*n42 + n12*n21*n43 - n11*n22*n43;
		te[15] = n12*n23*n31 - n13*n22*n31 + n13*n21*n32 - n11*n23*n32 - n12*n21*n33 + n11*n22*n33;

		var det = n11 * te[ 0 ] + n21 * te[ 4 ] + n31 * te[ 8 ] + n41 * te[ 12 ];

		if ( det == 0 ) {

			var msg = "Matrix4.getInverse(): can't invert matrix, determinant is 0";

			if ( throwOnInvertible || false ) {

				throw new Error( msg );

			} else {

				console.warn( msg );

			}

			this.identity();

			return this;
		}

		this.multiplyScalar( 1 / det );

		return this;

	},

	translate: function ( v ) {

		console.warn( 'DEPRECATED: Matrix4\'s .translate() has been removed.');

	},

	rotateX: function ( angle ) {

		console.warn( 'DEPRECATED: Matrix4\'s .rotateX() has been removed.');

	},

	rotateY: function ( angle ) {

		console.warn( 'DEPRECATED: Matrix4\'s .rotateY() has been removed.');

	},

	rotateZ: function ( angle ) {

		console.warn( 'DEPRECATED: Matrix4\'s .rotateZ() has been removed.');

	},

	rotateByAxis: function ( axis, angle ) {

		console.warn( 'DEPRECATED: Matrix4\'s .rotateByAxis() has been removed.');

	},

	scale: function ( v ) {

		var te = this.elements;
		var x = v.x, y = v.y, z = v.z;

		te[0] *= x; te[4] *= y; te[8] *= z;
		te[1] *= x; te[5] *= y; te[9] *= z;
		te[2] *= x; te[6] *= y; te[10] *= z;
		te[3] *= x; te[7] *= y; te[11] *= z;

		return this;

	},

	getMaxScaleOnAxis: function () {

		var te = this.elements;

		var scaleXSq = te[0] * te[0] + te[1] * te[1] + te[2] * te[2];
		var scaleYSq = te[4] * te[4] + te[5] * te[5] + te[6] * te[6];
		var scaleZSq = te[8] * te[8] + te[9] * te[9] + te[10] * te[10];

		return Math.sqrt( Math.max( scaleXSq, Math.max( scaleYSq, scaleZSq ) ) );

	},

	makeTranslation: function ( x, y, z ) {

		this.set(

			1, 0, 0, x,
			0, 1, 0, y,
			0, 0, 1, z,
			0, 0, 0, 1

		);

		return this;

	},

	makeRotationX: function ( theta ) {

		var c = Math.cos( theta ), s = Math.sin( theta );

		this.set(

			1, 0,  0, 0,
			0, c, -s, 0,
			0, s,  c, 0,
			0, 0,  0, 1

		);

		return this;

	},

	makeRotationY: function ( theta ) {

		var c = Math.cos( theta ), s = Math.sin( theta );

		this.set(

			 c, 0, s, 0,
			 0, 1, 0, 0,
			-s, 0, c, 0,
			 0, 0, 0, 1

		);

		return this;

	},

	makeRotationZ: function ( theta ) {

		var c = Math.cos( theta ), s = Math.sin( theta );

		this.set(

			c, -s, 0, 0,
			s,  c, 0, 0,
			0,  0, 1, 0,
			0,  0, 0, 1

		);

		return this;

	},

	makeRotationAxis: function ( axis, angle ) {

		// Based on http://www.gamedev.net/reference/articles/article1199.asp

		var c = Math.cos( angle );
		var s = Math.sin( angle );
		var t = 1 - c;
		var x = axis.x, y = axis.y, z = axis.z;
		var tx = t * x, ty = t * y;

		this.set(

			tx * x + c, tx * y - s * z, tx * z + s * y, 0,
			tx * y + s * z, ty * y + c, ty * z - s * x, 0,
			tx * z - s * y, ty * z + s * x, t * z * z + c, 0,
			0, 0, 0, 1

		);

		 return this;

	},

	makeScale: function ( x, y, z ) {

		this.set(

			x, 0, 0, 0,
			0, y, 0, 0,
			0, 0, z, 0,
			0, 0, 0, 1

		);

		return this;

	},

	compose: function ( position, quaternion, scale ) {

		this.makeRotationFromQuaternion( quaternion );
		this.scale( scale );
		this.setPosition( position );

		return this;

	},

	decompose: function () {

		var vector = new THREE.Vector3();
		var matrix = new THREE.Matrix4();

		return function ( position, quaternion, scale ) {

			var te = this.elements;

			var sx = vector.set( te[0], te[1], te[2] ).length();
			var sy = vector.set( te[4], te[5], te[6] ).length();
			var sz = vector.set( te[8], te[9], te[10] ).length();

			// if determine is negative, we need to invert one scale
			var det = this.determinant();
			if( det < 0 ) {
				sx = -sx;
			}

			position.x = te[12];
			position.y = te[13];
			position.z = te[14];

			// scale the rotation part

			matrix.elements.set( this.elements ); // at this point matrix is incomplete so we can't use .copy()

			var invSX = 1 / sx;
			var invSY = 1 / sy;
			var invSZ = 1 / sz;

			matrix.elements[0] *= invSX;
			matrix.elements[1] *= invSX;
			matrix.elements[2] *= invSX;

			matrix.elements[4] *= invSY;
			matrix.elements[5] *= invSY;
			matrix.elements[6] *= invSY;

			matrix.elements[8] *= invSZ;
			matrix.elements[9] *= invSZ;
			matrix.elements[10] *= invSZ;

			quaternion.setFromRotationMatrix( matrix );

			scale.x = sx;
			scale.y = sy;
			scale.z = sz;

			return this;

		};

	}(),

	makeFrustum: function ( left, right, bottom, top, near, far ) {

		var te = this.elements;
		var x = 2 * near / ( right - left );
		var y = 2 * near / ( top - bottom );

		var a = ( right + left ) / ( right - left );
		var b = ( top + bottom ) / ( top - bottom );
		var c = - ( far + near ) / ( far - near );
		var d = - 2 * far * near / ( far - near );

		te[0] = x;	te[4] = 0;	te[8] = a;	te[12] = 0;
		te[1] = 0;	te[5] = y;	te[9] = b;	te[13] = 0;
		te[2] = 0;	te[6] = 0;	te[10] = c;	te[14] = d;
		te[3] = 0;	te[7] = 0;	te[11] = - 1;	te[15] = 0;

		return this;

	},

	makePerspective: function ( fov, aspect, near, far ) {

		var ymax = near * Math.tan( THREE.Math.degToRad( fov * 0.5 ) );
		var ymin = - ymax;
		var xmin = ymin * aspect;
		var xmax = ymax * aspect;

		return this.makeFrustum( xmin, xmax, ymin, ymax, near, far );

	},

	makeOrthographic: function ( left, right, top, bottom, near, far ) {

		var te = this.elements;
		var w = right - left;
		var h = top - bottom;
		var p = far - near;

		var x = ( right + left ) / w;
		var y = ( top + bottom ) / h;
		var z = ( far + near ) / p;

		te[0] = 2 / w;	te[4] = 0;	te[8] = 0;	te[12] = -x;
		te[1] = 0;	te[5] = 2 / h;	te[9] = 0;	te[13] = -y;
		te[2] = 0;	te[6] = 0;	te[10] = -2/p;	te[14] = -z;
		te[3] = 0;	te[7] = 0;	te[11] = 0;	te[15] = 1;

		return this;

	},

	fromArray: function ( array ) {

		this.elements.set( array );

		return this;

	},

	toArray: function () {

		var te = this.elements;

		return [
			te[ 0 ], te[ 1 ], te[ 2 ], te[ 3 ],
			te[ 4 ], te[ 5 ], te[ 6 ], te[ 7 ],
			te[ 8 ], te[ 9 ], te[ 10 ], te[ 11 ],
			te[ 12 ], te[ 13 ], te[ 14 ], te[ 15 ]
		];

	},

	clone: function () {

		var te = this.elements;

		return new THREE.Matrix4(

			te[0], te[4], te[8], te[12],
			te[1], te[5], te[9], te[13],
			te[2], te[6], te[10], te[14],
			te[3], te[7], te[11], te[15]

		);

	}

};

/**
 * @author bhouston / http://exocortex.com
 */

THREE.Ray = function ( origin, direction ) {

	this.origin = ( origin !== undefined ) ? origin : new THREE.Vector3();
	this.direction = ( direction !== undefined ) ? direction : new THREE.Vector3();

};

THREE.Ray.prototype = {

	constructor: THREE.Ray,

	set: function ( origin, direction ) {

		this.origin.copy( origin );
		this.direction.copy( direction );

		return this;

	},

	copy: function ( ray ) {

		this.origin.copy( ray.origin );
		this.direction.copy( ray.direction );

		return this;

	},

	at: function ( t, optionalTarget ) {

		var result = optionalTarget || new THREE.Vector3();

		return result.copy( this.direction ).multiplyScalar( t ).add( this.origin );

	},

	recast: function () {

		var v1 = new THREE.Vector3();

		return function ( t ) {

			this.origin.copy( this.at( t, v1 ) );

			return this;

		};

	}(),

	closestPointToPoint: function ( point, optionalTarget ) {

		var result = optionalTarget || new THREE.Vector3();
		result.subVectors( point, this.origin );
		var directionDistance = result.dot( this.direction );

		if ( directionDistance < 0 ) {

			return result.copy( this.origin );

		}

		return result.copy( this.direction ).multiplyScalar( directionDistance ).add( this.origin );

	},

	distanceToPoint: function () {

		var v1 = new THREE.Vector3();

		return function ( point ) {

			var directionDistance = v1.subVectors( point, this.origin ).dot( this.direction );

			// point behind the ray

			if ( directionDistance < 0 ) {

				return this.origin.distanceTo( point );

			}

			v1.copy( this.direction ).multiplyScalar( directionDistance ).add( this.origin );

			return v1.distanceTo( point );

		};

	}(),

	distanceSqToSegment: function( v0, v1, optionalPointOnRay, optionalPointOnSegment ) {

		// from http://www.geometrictools.com/LibMathematics/Distance/Wm5DistRay3Segment3.cpp
		// It returns the min distance between the ray and the segment
		// defined by v0 and v1
		// It can also set two optional targets :
		// - The closest point on the ray
		// - The closest point on the segment

		var segCenter = v0.clone().add( v1 ).multiplyScalar( 0.5 );
		var segDir = v1.clone().sub( v0 ).normalize();
		var segExtent = v0.distanceTo( v1 ) * 0.5;
		var diff = this.origin.clone().sub( segCenter );
		var a01 = - this.direction.dot( segDir );
		var b0 = diff.dot( this.direction );
		var b1 = - diff.dot( segDir );
		var c = diff.lengthSq();
		var det = Math.abs( 1 - a01 * a01 );
		var s0, s1, sqrDist, extDet;

		if ( det >= 0 ) {

			// The ray and segment are not parallel.

			s0 = a01 * b1 - b0;
			s1 = a01 * b0 - b1;
			extDet = segExtent * det;

			if ( s0 >= 0 ) {

				if ( s1 >= - extDet ) {

					if ( s1 <= extDet ) {

						// region 0
						// Minimum at interior points of ray and segment.

						var invDet = 1 / det;
						s0 *= invDet;
						s1 *= invDet;
						sqrDist = s0 * ( s0 + a01 * s1 + 2 * b0 ) + s1 * ( a01 * s0 + s1 + 2 * b1 ) + c;

					} else {

						// region 1

						s1 = segExtent;
						s0 = Math.max( 0, - ( a01 * s1 + b0) );
						sqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;

					}

				} else {

					// region 5

					s1 = - segExtent;
					s0 = Math.max( 0, - ( a01 * s1 + b0) );
					sqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;

				}

			} else {

				if ( s1 <= - extDet) {

					// region 4

					s0 = Math.max( 0, - ( - a01 * segExtent + b0 ) );
					s1 = ( s0 > 0 ) ? - segExtent : Math.min( Math.max( - segExtent, - b1 ), segExtent );
					sqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;

				} else if ( s1 <= extDet ) {

					// region 3

					s0 = 0;
					s1 = Math.min( Math.max( - segExtent, - b1 ), segExtent );
					sqrDist = s1 * ( s1 + 2 * b1 ) + c;

				} else {

					// region 2

					s0 = Math.max( 0, - ( a01 * segExtent + b0 ) );
					s1 = ( s0 > 0 ) ? segExtent : Math.min( Math.max( - segExtent, - b1 ), segExtent );
					sqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;

				}

			}

		} else {

			// Ray and segment are parallel.

			s1 = ( a01 > 0 ) ? - segExtent : segExtent;
			s0 = Math.max( 0, - ( a01 * s1 + b0 ) );
			sqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;

		}

		if ( optionalPointOnRay ) {

			optionalPointOnRay.copy( this.direction.clone().multiplyScalar( s0 ).add( this.origin ) );

		}

		if ( optionalPointOnSegment ) {

			optionalPointOnSegment.copy( segDir.clone().multiplyScalar( s1 ).add( segCenter ) );

		}

		return sqrDist;

	},

	isIntersectionSphere: function ( sphere ) {

		return this.distanceToPoint( sphere.center ) <= sphere.radius;

	},

	isIntersectionPlane: function ( plane ) {

		// check if the ray lies on the plane first

		var distToPoint = plane.distanceToPoint( this.origin );

		if ( distToPoint === 0 ) {

			return true;

		}

		var denominator = plane.normal.dot( this.direction );

		if ( denominator * distToPoint < 0 ) {

			return true

		}

		// ray origin is behind the plane (and is pointing behind it)

		return false;

	},

	distanceToPlane: function ( plane ) {

		var denominator = plane.normal.dot( this.direction );
		if ( denominator == 0 ) {

			// line is coplanar, return origin
			if( plane.distanceToPoint( this.origin ) == 0 ) {

				return 0;

			}

			// Null is preferable to undefined since undefined means.... it is undefined

			return null;

		}

		var t = - ( this.origin.dot( plane.normal ) + plane.constant ) / denominator;

		// Return if the ray never intersects the plane

		return t >= 0 ? t :  null;

	},

	intersectPlane: function ( plane, optionalTarget ) {

		var t = this.distanceToPlane( plane );

		if ( t === null ) {

			return null;
		}

		return this.at( t, optionalTarget );

	},

	isIntersectionBox: function () {

		var v = new THREE.Vector3();

		return function ( box ) {

			return this.intersectBox( box, v ) !== null;

		}

	}(),

	intersectBox: function ( box , optionalTarget ) {

		// http://www.scratchapixel.com/lessons/3d-basic-lessons/lesson-7-intersecting-simple-shapes/ray-box-intersection/

		var tmin,tmax,tymin,tymax,tzmin,tzmax;

		var invdirx = 1/this.direction.x,
			invdiry = 1/this.direction.y,
			invdirz = 1/this.direction.z;

		var origin = this.origin;

		if (invdirx >= 0) {

			tmin = (box.min.x - origin.x) * invdirx;
			tmax = (box.max.x - origin.x) * invdirx;

		} else {

			tmin = (box.max.x - origin.x) * invdirx;
			tmax = (box.min.x - origin.x) * invdirx;
		}

		if (invdiry >= 0) {

			tymin = (box.min.y - origin.y) * invdiry;
			tymax = (box.max.y - origin.y) * invdiry;

		} else {

			tymin = (box.max.y - origin.y) * invdiry;
			tymax = (box.min.y - origin.y) * invdiry;
		}

		if ((tmin > tymax) || (tymin > tmax)) return null;

		// These lines also handle the case where tmin or tmax is NaN
		// (result of 0 * Infinity). x !== x returns true if x is NaN

		if (tymin > tmin || tmin !== tmin ) tmin = tymin;

		if (tymax < tmax || tmax !== tmax ) tmax = tymax;

		if (invdirz >= 0) {

			tzmin = (box.min.z - origin.z) * invdirz;
			tzmax = (box.max.z - origin.z) * invdirz;

		} else {

			tzmin = (box.max.z - origin.z) * invdirz;
			tzmax = (box.min.z - origin.z) * invdirz;
		}

		if ((tmin > tzmax) || (tzmin > tmax)) return null;

		if (tzmin > tmin || tmin !== tmin ) tmin = tzmin;

		if (tzmax < tmax || tmax !== tmax ) tmax = tzmax;

		//return point closest to the ray (positive side)

		if ( tmax < 0 ) return null;

		return this.at( tmin >= 0 ? tmin : tmax, optionalTarget );

	},

	intersectTriangle: function() {

		// Compute the offset origin, edges, and normal.
		var diff = new THREE.Vector3();
		var edge1 = new THREE.Vector3();
		var edge2 = new THREE.Vector3();
		var normal = new THREE.Vector3();

		return function ( a, b, c, backfaceCulling, optionalTarget ) {

			// from http://www.geometrictools.com/LibMathematics/Intersection/Wm5IntrRay3Triangle3.cpp

			edge1.subVectors( b, a );
			edge2.subVectors( c, a );
			normal.crossVectors( edge1, edge2 );

			// Solve Q + t*D = b1*E1 + b2*E2 (Q = kDiff, D = ray direction,
			// E1 = kEdge1, E2 = kEdge2, N = Cross(E1,E2)) by
			//   |Dot(D,N)|*b1 = sign(Dot(D,N))*Dot(D,Cross(Q,E2))
			//   |Dot(D,N)|*b2 = sign(Dot(D,N))*Dot(D,Cross(E1,Q))
			//   |Dot(D,N)|*t = -sign(Dot(D,N))*Dot(Q,N)
			var DdN = this.direction.dot( normal );
			var sign;

			if ( DdN > 0 ) {

				if ( backfaceCulling ) return null;
				sign = 1;

			} else if ( DdN < 0 ) {

				sign = - 1;
				DdN = - DdN;

			} else {

				return null;

			}

			diff.subVectors( this.origin, a );
			var DdQxE2 = sign * this.direction.dot( edge2.crossVectors( diff, edge2 ) );

			// b1 < 0, no intersection
			if ( DdQxE2 < 0 ) {

				return null;

			}

			var DdE1xQ = sign * this.direction.dot( edge1.cross( diff ) );

			// b2 < 0, no intersection
			if ( DdE1xQ < 0 ) {

				return null;

			}

			// b1+b2 > 1, no intersection
			if ( DdQxE2 + DdE1xQ > DdN ) {

				return null;

			}

			// Line intersects triangle, check if ray does.
			var QdN = - sign * diff.dot( normal );

			// t < 0, no intersection
			if ( QdN < 0 ) {

				return null;

			}

			// Ray intersects triangle.
			return this.at( QdN / DdN, optionalTarget );

		}

	}(),

	applyMatrix4: function ( matrix4 ) {

		this.direction.add( this.origin ).applyMatrix4( matrix4 );
		this.origin.applyMatrix4( matrix4 );
		this.direction.sub( this.origin );
		this.direction.normalize();

		return this;
	},

	equals: function ( ray ) {

		return ray.origin.equals( this.origin ) && ray.direction.equals( this.direction );

	},

	clone: function () {

		return new THREE.Ray().copy( this );

	}

};

/**
 * @author bhouston / http://exocortex.com
 * @author mrdoob / http://mrdoob.com/
 */

THREE.Sphere = function ( center, radius ) {

	this.center = ( center !== undefined ) ? center : new THREE.Vector3();
	this.radius = ( radius !== undefined ) ? radius : 0;

};

THREE.Sphere.prototype = {

	constructor: THREE.Sphere,

	set: function ( center, radius ) {

		this.center.copy( center );
		this.radius = radius;

		return this;
	},


	setFromPoints: function () {

		var box = new THREE.Box3();

		return function ( points, optionalCenter )  {

			var center = this.center;

			if ( optionalCenter !== undefined ) {

				center.copy( optionalCenter );

			} else {

				box.setFromPoints( points ).center( center );

			}

			var maxRadiusSq = 0;

			for ( var i = 0, il = points.length; i < il; i ++ ) {

				maxRadiusSq = Math.max( maxRadiusSq, center.distanceToSquared( points[ i ] ) );

			}

			this.radius = Math.sqrt( maxRadiusSq );

			return this;

 		};

	}(),

	copy: function ( sphere ) {

		this.center.copy( sphere.center );
		this.radius = sphere.radius;

		return this;

	},

	empty: function () {

		return ( this.radius <= 0 );

	},

	containsPoint: function ( point ) {

		return ( point.distanceToSquared( this.center ) <= ( this.radius * this.radius ) );

	},

	distanceToPoint: function ( point ) {

		return ( point.distanceTo( this.center ) - this.radius );

	},

	intersectsSphere: function ( sphere ) {

		var radiusSum = this.radius + sphere.radius;

		return sphere.center.distanceToSquared( this.center ) <= ( radiusSum * radiusSum );

	},

	clampPoint: function ( point, optionalTarget ) {

		var deltaLengthSq = this.center.distanceToSquared( point );

		var result = optionalTarget || new THREE.Vector3();
		result.copy( point );

		if ( deltaLengthSq > ( this.radius * this.radius ) ) {

			result.sub( this.center ).normalize();
			result.multiplyScalar( this.radius ).add( this.center );

		}

		return result;

	},

	getBoundingBox: function ( optionalTarget ) {

		var box = optionalTarget || new THREE.Box3();

		box.set( this.center, this.center );
		box.expandByScalar( this.radius );

		return box;

	},

	applyMatrix4: function ( matrix ) {

		this.center.applyMatrix4( matrix );
		this.radius = this.radius * matrix.getMaxScaleOnAxis();

		return this;

	},

	translate: function ( offset ) {

		this.center.add( offset );

		return this;

	},

	equals: function ( sphere ) {

		return sphere.center.equals( this.center ) && ( sphere.radius === this.radius );

	},

	clone: function () {

		return new THREE.Sphere().copy( this );

	}

};

/**
 * @author mrdoob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 * @author bhouston / http://exocortex.com
 */

THREE.Frustum = function ( p0, p1, p2, p3, p4, p5 ) {

	this.planes = [

		( p0 !== undefined ) ? p0 : new THREE.Plane(),
		( p1 !== undefined ) ? p1 : new THREE.Plane(),
		( p2 !== undefined ) ? p2 : new THREE.Plane(),
		( p3 !== undefined ) ? p3 : new THREE.Plane(),
		( p4 !== undefined ) ? p4 : new THREE.Plane(),
		( p5 !== undefined ) ? p5 : new THREE.Plane()

	];

};

THREE.Frustum.prototype = {

	constructor: THREE.Frustum,

	set: function ( p0, p1, p2, p3, p4, p5 ) {

		var planes = this.planes;

		planes[0].copy( p0 );
		planes[1].copy( p1 );
		planes[2].copy( p2 );
		planes[3].copy( p3 );
		planes[4].copy( p4 );
		planes[5].copy( p5 );

		return this;

	},

	copy: function ( frustum ) {

		var planes = this.planes;

		for( var i = 0; i < 6; i ++ ) {

			planes[i].copy( frustum.planes[i] );

		}

		return this;

	},

	setFromMatrix: function ( m ) {

		var planes = this.planes;
		var me = m.elements;
		var me0 = me[0], me1 = me[1], me2 = me[2], me3 = me[3];
		var me4 = me[4], me5 = me[5], me6 = me[6], me7 = me[7];
		var me8 = me[8], me9 = me[9], me10 = me[10], me11 = me[11];
		var me12 = me[12], me13 = me[13], me14 = me[14], me15 = me[15];

		planes[ 0 ].setComponents( me3 - me0, me7 - me4, me11 - me8, me15 - me12 ).normalize();
		planes[ 1 ].setComponents( me3 + me0, me7 + me4, me11 + me8, me15 + me12 ).normalize();
		planes[ 2 ].setComponents( me3 + me1, me7 + me5, me11 + me9, me15 + me13 ).normalize();
		planes[ 3 ].setComponents( me3 - me1, me7 - me5, me11 - me9, me15 - me13 ).normalize();
		planes[ 4 ].setComponents( me3 - me2, me7 - me6, me11 - me10, me15 - me14 ).normalize();
		planes[ 5 ].setComponents( me3 + me2, me7 + me6, me11 + me10, me15 + me14 ).normalize();

		return this;

	},

	intersectsObject: function () {

		var sphere = new THREE.Sphere();

		return function ( object ) {

			var geometry = object.geometry;

			if ( geometry.boundingSphere === null ) geometry.computeBoundingSphere();

			sphere.copy( geometry.boundingSphere );
			sphere.applyMatrix4( object.matrixWorld );

			return this.intersectsSphere( sphere );

		};

	}(),

	intersectsSphere: function ( sphere ) {

		var planes = this.planes;
		var center = sphere.center;
		var negRadius = -sphere.radius;

		for ( var i = 0; i < 6; i ++ ) {

			var distance = planes[ i ].distanceToPoint( center );

			if ( distance < negRadius ) {

				return false;

			}

		}

		return true;

	},

	intersectsBox : function() {

		var p1 = new THREE.Vector3(),
			p2 = new THREE.Vector3();

		return function( box ) {

			var planes = this.planes;

			for ( var i = 0; i < 6 ; i ++ ) {

				var plane = planes[i];

				p1.x = plane.normal.x > 0 ? box.min.x : box.max.x;
				p2.x = plane.normal.x > 0 ? box.max.x : box.min.x;
				p1.y = plane.normal.y > 0 ? box.min.y : box.max.y;
				p2.y = plane.normal.y > 0 ? box.max.y : box.min.y;
				p1.z = plane.normal.z > 0 ? box.min.z : box.max.z;
				p2.z = plane.normal.z > 0 ? box.max.z : box.min.z;

				var d1 = plane.distanceToPoint( p1 );
				var d2 = plane.distanceToPoint( p2 );

				// if both outside plane, no intersection

				if ( d1 < 0 && d2 < 0 ) {

					return false;

				}
			}

			return true;
		};

	}(),


	containsPoint: function ( point ) {

		var planes = this.planes;

		for ( var i = 0; i < 6; i ++ ) {

			if ( planes[ i ].distanceToPoint( point ) < 0 ) {

				return false;

			}

		}

		return true;

	},

	clone: function () {

		return new THREE.Frustum().copy( this );

	}

};

/**
 * @author bhouston / http://exocortex.com
 */

THREE.Plane = function ( normal, constant ) {

	this.normal = ( normal !== undefined ) ? normal : new THREE.Vector3( 1, 0, 0 );
	this.constant = ( constant !== undefined ) ? constant : 0;

};

THREE.Plane.prototype = {

	constructor: THREE.Plane,

	set: function ( normal, constant ) {

		this.normal.copy( normal );
		this.constant = constant;

		return this;

	},

	setComponents: function ( x, y, z, w ) {

		this.normal.set( x, y, z );
		this.constant = w;

		return this;

	},

	setFromNormalAndCoplanarPoint: function ( normal, point ) {

		this.normal.copy( normal );
		this.constant = - point.dot( this.normal );	// must be this.normal, not normal, as this.normal is normalized

		return this;

	},

	setFromCoplanarPoints: function() {

		var v1 = new THREE.Vector3();
		var v2 = new THREE.Vector3();

		return function ( a, b, c ) {

			var normal = v1.subVectors( c, b ).cross( v2.subVectors( a, b ) ).normalize();

			// Q: should an error be thrown if normal is zero (e.g. degenerate plane)?

			this.setFromNormalAndCoplanarPoint( normal, a );

			return this;

		};

	}(),


	copy: function ( plane ) {

		this.normal.copy( plane.normal );
		this.constant = plane.constant;

		return this;

	},

	normalize: function () {

		// Note: will lead to a divide by zero if the plane is invalid.

		var inverseNormalLength = 1.0 / this.normal.length();
		this.normal.multiplyScalar( inverseNormalLength );
		this.constant *= inverseNormalLength;

		return this;

	},

	negate: function () {

		this.constant *= -1;
		this.normal.negate();

		return this;

	},

	distanceToPoint: function ( point ) {

		return this.normal.dot( point ) + this.constant;

	},

	distanceToSphere: function ( sphere ) {

		return this.distanceToPoint( sphere.center ) - sphere.radius;

	},

	projectPoint: function ( point, optionalTarget ) {

		return this.orthoPoint( point, optionalTarget ).sub( point ).negate();

	},

	orthoPoint: function ( point, optionalTarget ) {

		var perpendicularMagnitude = this.distanceToPoint( point );

		var result = optionalTarget || new THREE.Vector3();
		return result.copy( this.normal ).multiplyScalar( perpendicularMagnitude );

	},

	isIntersectionLine: function ( line ) {

		// Note: this tests if a line intersects the plane, not whether it (or its end-points) are coplanar with it.

		var startSign = this.distanceToPoint( line.start );
		var endSign = this.distanceToPoint( line.end );

		return ( startSign < 0 && endSign > 0 ) || ( endSign < 0 && startSign > 0 );

	},

	intersectLine: function() {

		var v1 = new THREE.Vector3();

		return function ( line, optionalTarget ) {

			var result = optionalTarget || new THREE.Vector3();

			var direction = line.delta( v1 );

			var denominator = this.normal.dot( direction );

			if ( denominator == 0 ) {

				// line is coplanar, return origin
				if( this.distanceToPoint( line.start ) == 0 ) {

					return result.copy( line.start );

				}

				// Unsure if this is the correct method to handle this case.
				return undefined;

			}

			var t = - ( line.start.dot( this.normal ) + this.constant ) / denominator;

			if( t < 0 || t > 1 ) {

				return undefined;

			}

			return result.copy( direction ).multiplyScalar( t ).add( line.start );

		};

	}(),


	coplanarPoint: function ( optionalTarget ) {

		var result = optionalTarget || new THREE.Vector3();
		return result.copy( this.normal ).multiplyScalar( - this.constant );

	},

	applyMatrix4: function() {

		var v1 = new THREE.Vector3();
		var v2 = new THREE.Vector3();
		var m1 = new THREE.Matrix3();

		return function ( matrix, optionalNormalMatrix ) {

			// compute new normal based on theory here:
			// http://www.songho.ca/opengl/gl_normaltransform.html
			var normalMatrix = optionalNormalMatrix || m1.getNormalMatrix( matrix );
			var newNormal = v1.copy( this.normal ).applyMatrix3( normalMatrix );

			var newCoplanarPoint = this.coplanarPoint( v2 );
			newCoplanarPoint.applyMatrix4( matrix );

			this.setFromNormalAndCoplanarPoint( newNormal, newCoplanarPoint );

			return this;

		};

	}(),

	translate: function ( offset ) {

		this.constant = this.constant - offset.dot( this.normal );

		return this;

	},

	equals: function ( plane ) {

		return plane.normal.equals( this.normal ) && ( plane.constant == this.constant );

	},

	clone: function () {

		return new THREE.Plane().copy( this );

	}

};

/**
 * @author alteredq / http://alteredqualia.com/
 * @author mrdoob / http://mrdoob.com/
 */

THREE.Math = {

	PI2: Math.PI * 2,

	generateUUID: function () {

		// http://www.broofa.com/Tools/Math.uuid.htm

		var chars = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz'.split('');
		var uuid = new Array(36);
		var rnd = 0, r;

		return function () {

			for ( var i = 0; i < 36; i ++ ) {

				if ( i == 8 || i == 13 || i == 18 || i == 23 ) {

					uuid[ i ] = '-';

				} else if ( i == 14 ) {

					uuid[ i ] = '4';

				} else {

					if (rnd <= 0x02) rnd = 0x2000000 + (Math.random()*0x1000000)|0;
					r = rnd & 0xf;
					rnd = rnd >> 4;
					uuid[i] = chars[(i == 19) ? (r & 0x3) | 0x8 : r];

				}
			}

			return uuid.join('');

		};

	}(),

	// Clamp value to range <a, b>

	clamp: function ( x, a, b ) {

		return ( x < a ) ? a : ( ( x > b ) ? b : x );

	},

	// Clamp value to range <a, inf)

	clampBottom: function ( x, a ) {

		return x < a ? a : x;

	},

	// Linear mapping from range <a1, a2> to range <b1, b2>

	mapLinear: function ( x, a1, a2, b1, b2 ) {

		return b1 + ( x - a1 ) * ( b2 - b1 ) / ( a2 - a1 );

	},

	// http://en.wikipedia.org/wiki/Smoothstep

	smoothstep: function ( x, min, max ) {

		if ( x <= min ) return 0;
		if ( x >= max ) return 1;

		x = ( x - min )/( max - min );

		return x*x*(3 - 2*x);

	},

	smootherstep: function ( x, min, max ) {

		if ( x <= min ) return 0;
		if ( x >= max ) return 1;

		x = ( x - min )/( max - min );

		return x*x*x*(x*(x*6 - 15) + 10);

	},

	// Random float from <0, 1> with 16 bits of randomness
	// (standard Math.random() creates repetitive patterns when applied over larger space)

	random16: function () {

		return ( 65280 * Math.random() + 255 * Math.random() ) / 65535;

	},

	// Random integer from <low, high> interval

	randInt: function ( low, high ) {

		return low + Math.floor( Math.random() * ( high - low + 1 ) );

	},

	// Random float from <low, high> interval

	randFloat: function ( low, high ) {

		return low + Math.random() * ( high - low );

	},

	// Random float from <-range/2, range/2> interval

	randFloatSpread: function ( range ) {

		return range * ( 0.5 - Math.random() );

	},

	sign: function ( x ) {

		return ( x < 0 ) ? -1 : ( ( x > 0 ) ? 1 : 0 );

	},

	degToRad: function() {

		var degreeToRadiansFactor = Math.PI / 180;

		return function ( degrees ) {

			return degrees * degreeToRadiansFactor;

		};

	}(),

	radToDeg: function() {

		var radianToDegreesFactor = 180 / Math.PI;

		return function ( radians ) {

			return radians * radianToDegreesFactor;

		};

	}()

};

/**
 * Spline from Tween.js, slightly optimized (and trashed)
 * http://sole.github.com/tween.js/examples/05_spline.html
 *
 * @author mrdoob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 */

THREE.Spline = function ( points ) {

	this.points = points;

	var c = [], v3 = { x: 0, y: 0, z: 0 },
	point, intPoint, weight, w2, w3,
	pa, pb, pc, pd;

	this.initFromArray = function( a ) {

		this.points = [];

		for ( var i = 0; i < a.length; i++ ) {

			this.points[ i ] = { x: a[ i ][ 0 ], y: a[ i ][ 1 ], z: a[ i ][ 2 ] };

		}

	};

	this.getPoint = function ( k ) {

		point = ( this.points.length - 1 ) * k;
		intPoint = Math.floor( point );
		weight = point - intPoint;

		c[ 0 ] = intPoint === 0 ? intPoint : intPoint - 1;
		c[ 1 ] = intPoint;
		c[ 2 ] = intPoint  > this.points.length - 2 ? this.points.length - 1 : intPoint + 1;
		c[ 3 ] = intPoint  > this.points.length - 3 ? this.points.length - 1 : intPoint + 2;

		pa = this.points[ c[ 0 ] ];
		pb = this.points[ c[ 1 ] ];
		pc = this.points[ c[ 2 ] ];
		pd = this.points[ c[ 3 ] ];

		w2 = weight * weight;
		w3 = weight * w2;

		v3.x = interpolate( pa.x, pb.x, pc.x, pd.x, weight, w2, w3 );
		v3.y = interpolate( pa.y, pb.y, pc.y, pd.y, weight, w2, w3 );
		v3.z = interpolate( pa.z, pb.z, pc.z, pd.z, weight, w2, w3 );

		return v3;

	};

	this.getControlPointsArray = function () {

		var i, p, l = this.points.length,
			coords = [];

		for ( i = 0; i < l; i ++ ) {

			p = this.points[ i ];
			coords[ i ] = [ p.x, p.y, p.z ];

		}

		return coords;

	};

	// approximate length by summing linear segments

	this.getLength = function ( nSubDivisions ) {

		var i, index, nSamples, position,
			point = 0, intPoint = 0, oldIntPoint = 0,
			oldPosition = new THREE.Vector3(),
			tmpVec = new THREE.Vector3(),
			chunkLengths = [],
			totalLength = 0;

		// first point has 0 length

		chunkLengths[ 0 ] = 0;

		if ( !nSubDivisions ) nSubDivisions = 100;

		nSamples = this.points.length * nSubDivisions;

		oldPosition.copy( this.points[ 0 ] );

		for ( i = 1; i < nSamples; i ++ ) {

			index = i / nSamples;

			position = this.getPoint( index );
			tmpVec.copy( position );

			totalLength += tmpVec.distanceTo( oldPosition );

			oldPosition.copy( position );

			point = ( this.points.length - 1 ) * index;
			intPoint = Math.floor( point );

			if ( intPoint != oldIntPoint ) {

				chunkLengths[ intPoint ] = totalLength;
				oldIntPoint = intPoint;

			}

		}

		// last point ends with total length

		chunkLengths[ chunkLengths.length ] = totalLength;

		return { chunks: chunkLengths, total: totalLength };

	};

	this.reparametrizeByArcLength = function ( samplingCoef ) {

		var i, j,
			index, indexCurrent, indexNext,
			linearDistance, realDistance,
			sampling, position,
			newpoints = [],
			tmpVec = new THREE.Vector3(),
			sl = this.getLength();

		newpoints.push( tmpVec.copy( this.points[ 0 ] ).clone() );

		for ( i = 1; i < this.points.length; i++ ) {

			//tmpVec.copy( this.points[ i - 1 ] );
			//linearDistance = tmpVec.distanceTo( this.points[ i ] );

			realDistance = sl.chunks[ i ] - sl.chunks[ i - 1 ];

			sampling = Math.ceil( samplingCoef * realDistance / sl.total );

			indexCurrent = ( i - 1 ) / ( this.points.length - 1 );
			indexNext = i / ( this.points.length - 1 );

			for ( j = 1; j < sampling - 1; j++ ) {

				index = indexCurrent + j * ( 1 / sampling ) * ( indexNext - indexCurrent );

				position = this.getPoint( index );
				newpoints.push( tmpVec.copy( position ).clone() );

			}

			newpoints.push( tmpVec.copy( this.points[ i ] ).clone() );

		}

		this.points = newpoints;

	};

	// Catmull-Rom

	function interpolate( p0, p1, p2, p3, t, t2, t3 ) {

		var v0 = ( p2 - p0 ) * 0.5,
			v1 = ( p3 - p1 ) * 0.5;

		return ( 2 * ( p1 - p2 ) + v0 + v1 ) * t3 + ( - 3 * ( p1 - p2 ) - 2 * v0 - v1 ) * t2 + v0 * t + p1;

	};

};

/**
 * @author bhouston / http://exocortex.com
 * @author mrdoob / http://mrdoob.com/
 */

THREE.Triangle = function ( a, b, c ) {

	this.a = ( a !== undefined ) ? a : new THREE.Vector3();
	this.b = ( b !== undefined ) ? b : new THREE.Vector3();
	this.c = ( c !== undefined ) ? c : new THREE.Vector3();

};

THREE.Triangle.normal = function() {

	var v0 = new THREE.Vector3();

	return function ( a, b, c, optionalTarget ) {

		var result = optionalTarget || new THREE.Vector3();

		result.subVectors( c, b );
		v0.subVectors( a, b );
		result.cross( v0 );

		var resultLengthSq = result.lengthSq();
		if( resultLengthSq > 0 ) {

			return result.multiplyScalar( 1 / Math.sqrt( resultLengthSq ) );

		}

		return result.set( 0, 0, 0 );

	};

}();

// static/instance method to calculate barycoordinates
// based on: http://www.blackpawn.com/texts/pointinpoly/default.html
THREE.Triangle.barycoordFromPoint = function() {

	var v0 = new THREE.Vector3();
	var v1 = new THREE.Vector3();
	var v2 = new THREE.Vector3();

	return function ( point, a, b, c, optionalTarget ) {

		v0.subVectors( c, a );
		v1.subVectors( b, a );
		v2.subVectors( point, a );

		var dot00 = v0.dot( v0 );
		var dot01 = v0.dot( v1 );
		var dot02 = v0.dot( v2 );
		var dot11 = v1.dot( v1 );
		var dot12 = v1.dot( v2 );

		var denom = ( dot00 * dot11 - dot01 * dot01 );

		var result = optionalTarget || new THREE.Vector3();

		// colinear or singular triangle
		if( denom == 0 ) {
			// arbitrary location outside of triangle?
			// not sure if this is the best idea, maybe should be returning undefined
			return result.set( -2, -1, -1 );
		}

		var invDenom = 1 / denom;
		var u = ( dot11 * dot02 - dot01 * dot12 ) * invDenom;
		var v = ( dot00 * dot12 - dot01 * dot02 ) * invDenom;

		// barycoordinates must always sum to 1
		return result.set( 1 - u - v, v, u );

	};

}();

THREE.Triangle.containsPoint = function() {

	var v1 = new THREE.Vector3();

	return function ( point, a, b, c ) {

		var result = THREE.Triangle.barycoordFromPoint( point, a, b, c, v1 );

		return ( result.x >= 0 ) && ( result.y >= 0 ) && ( ( result.x + result.y ) <= 1 );

	};

}();

THREE.Triangle.prototype = {

	constructor: THREE.Triangle,

	set: function ( a, b, c ) {

		this.a.copy( a );
		this.b.copy( b );
		this.c.copy( c );

		return this;

	},

	setFromPointsAndIndices: function ( points, i0, i1, i2 ) {

		this.a.copy( points[i0] );
		this.b.copy( points[i1] );
		this.c.copy( points[i2] );

		return this;

	},

	copy: function ( triangle ) {

		this.a.copy( triangle.a );
		this.b.copy( triangle.b );
		this.c.copy( triangle.c );

		return this;

	},

	area: function() {

		var v0 = new THREE.Vector3();
		var v1 = new THREE.Vector3();

		return function () {

			v0.subVectors( this.c, this.b );
			v1.subVectors( this.a, this.b );

			return v0.cross( v1 ).length() * 0.5;

		};

	}(),

	midpoint: function ( optionalTarget ) {

		var result = optionalTarget || new THREE.Vector3();
		return result.addVectors( this.a, this.b ).add( this.c ).multiplyScalar( 1 / 3 );

	},

	normal: function ( optionalTarget ) {

		return THREE.Triangle.normal( this.a, this.b, this.c, optionalTarget );

	},

	plane: function ( optionalTarget ) {

		var result = optionalTarget || new THREE.Plane();

		return result.setFromCoplanarPoints( this.a, this.b, this.c );

	},

	barycoordFromPoint: function ( point, optionalTarget ) {

		return THREE.Triangle.barycoordFromPoint( point, this.a, this.b, this.c, optionalTarget );

	},

	containsPoint: function ( point ) {

		return THREE.Triangle.containsPoint( point, this.a, this.b, this.c );

	},

	equals: function ( triangle ) {

		return triangle.a.equals( this.a ) && triangle.b.equals( this.b ) && triangle.c.equals( this.c );

	},

	clone: function () {

		return new THREE.Triangle().copy( this );

	}

};

/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.Vertex = function ( v ) {

	console.warn( 'THREE.Vertex has been DEPRECATED. Use THREE.Vector3 instead.')
	return v;

};

/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.UV = function ( u, v ) {

	console.warn( 'THREE.UV has been DEPRECATED. Use THREE.Vector2 instead.')
	return new THREE.Vector2( u, v );

};

/**
 * @author alteredq / http://alteredqualia.com/
 */

THREE.Clock = function ( autoStart ) {

	this.autoStart = ( autoStart !== undefined ) ? autoStart : true;

	this.startTime = 0;
	this.oldTime = 0;
	this.elapsedTime = 0;

	this.running = false;

};

THREE.Clock.prototype = {

	constructor: THREE.Clock,

	start: function () {

		this.startTime = self.performance !== undefined && self.performance.now !== undefined
					? self.performance.now()
					: Date.now();

		this.oldTime = this.startTime;
		this.running = true;
	},

	stop: function () {

		this.getElapsedTime();
		this.running = false;

	},

	getElapsedTime: function () {

		this.getDelta();
		return this.elapsedTime;

	},

	getDelta: function () {

		var diff = 0;

		if ( this.autoStart && ! this.running ) {

			this.start();

		}

		if ( this.running ) {

			var newTime = self.performance !== undefined && self.performance.now !== undefined
					? self.performance.now()
					: Date.now();

			diff = 0.001 * ( newTime - this.oldTime );
			this.oldTime = newTime;

			this.elapsedTime += diff;

		}

		return diff;

	}

};

/**
 * https://github.com/mrdoob/eventdispatcher.js/
 */

THREE.EventDispatcher = function () {}

THREE.EventDispatcher.prototype = {

	constructor: THREE.EventDispatcher,

	apply: function ( object ) {

		object.addEventListener = THREE.EventDispatcher.prototype.addEventListener;
		object.hasEventListener = THREE.EventDispatcher.prototype.hasEventListener;
		object.removeEventListener = THREE.EventDispatcher.prototype.removeEventListener;
		object.dispatchEvent = THREE.EventDispatcher.prototype.dispatchEvent;

	},

	addEventListener: function ( type, listener ) {

		if ( this._listeners === undefined ) this._listeners = {};

		var listeners = this._listeners;

		if ( listeners[ type ] === undefined ) {

			listeners[ type ] = [];

		}

		if ( listeners[ type ].indexOf( listener ) === - 1 ) {

			listeners[ type ].push( listener );

		}

	},

	hasEventListener: function ( type, listener ) {

		if ( this._listeners === undefined ) return false;

		var listeners = this._listeners;

		if ( listeners[ type ] !== undefined && listeners[ type ].indexOf( listener ) !== - 1 ) {

			return true;

		}

		return false;

	},

	removeEventListener: function ( type, listener ) {

		if ( this._listeners === undefined ) return;

		var listeners = this._listeners;
		var listenerArray = listeners[ type ];

		if ( listenerArray !== undefined ) {

			var index = listenerArray.indexOf( listener );

			if ( index !== - 1 ) {

				listenerArray.splice( index, 1 );

			}

		}

	},

	dispatchEvent: function () {

		var array = [];

		return function ( event ) {

			if ( this._listeners === undefined ) return;

			var listeners = this._listeners;
			var listenerArray = listeners[ event.type ];

			if ( listenerArray !== undefined ) {

				event.target = this;

				var length = listenerArray.length;

				for ( var i = 0; i < length; i ++ ) {

					array[ i ] = listenerArray[ i ];

				}

				for ( var i = 0; i < length; i ++ ) {

					array[ i ].call( this, event );

				}

			}

		};

	}()

};

/**
 * @author mrdoob / http://mrdoob.com/
 * @author bhouston / http://exocortex.com/
 * @author stephomi / http://stephaneginier.com/
 */

( function ( THREE ) {

	THREE.Raycaster = function ( origin, direction, near, far ) {

		this.ray = new THREE.Ray( origin, direction );
		// direction is assumed to be normalized (for accurate distance calculations)

		this.near = near || 0;
		this.far = far || Infinity;

	};

	var sphere = new THREE.Sphere();
	var localRay = new THREE.Ray();
	var facePlane = new THREE.Plane();
	var intersectPoint = new THREE.Vector3();
	var matrixPosition = new THREE.Vector3();

	var inverseMatrix = new THREE.Matrix4();

	var descSort = function ( a, b ) {

		return a.distance - b.distance;

	};

	var vA = new THREE.Vector3();
	var vB = new THREE.Vector3();
	var vC = new THREE.Vector3();

	var intersectObject = function ( object, raycaster, intersects ) {

		if ( object instanceof THREE.Sprite ) {

			matrixPosition.setFromMatrixPosition( object.matrixWorld );
			var distance = raycaster.ray.distanceToPoint( matrixPosition );

			if ( distance > object.scale.x ) {

				return intersects;

			}

			intersects.push( {

				distance: distance,
				point: object.position,
				face: null,
				object: object

			} );

		} else if ( object instanceof THREE.LOD ) {

			matrixPosition.setFromMatrixPosition( object.matrixWorld );
			var distance = raycaster.ray.origin.distanceTo( matrixPosition );

			intersectObject( object.getObjectForDistance( distance ), raycaster, intersects );

		} else if ( object instanceof THREE.Mesh ) {

			var geometry = object.geometry;

			// Checking boundingSphere distance to ray

			if ( geometry.boundingSphere === null ) geometry.computeBoundingSphere();

			sphere.copy( geometry.boundingSphere );
			sphere.applyMatrix4( object.matrixWorld );

			if ( raycaster.ray.isIntersectionSphere( sphere ) === false ) {

				return intersects;

			}

			// Check boundingBox before continuing

			inverseMatrix.getInverse( object.matrixWorld );
			localRay.copy( raycaster.ray ).applyMatrix4( inverseMatrix );

			if ( geometry.boundingBox !== null ) {

				if ( localRay.isIntersectionBox( geometry.boundingBox ) === false )  {

					return intersects;

				}

			}

			if ( geometry instanceof THREE.BufferGeometry ) {

				var material = object.material;

				if ( material === undefined ) return intersects;
				if ( geometry.dynamic === false ) return intersects;

				var a, b, c;
				var precision = raycaster.precision;

				if ( geometry.attributes.index !== undefined ) {

					var offsets = geometry.offsets;
					var indices = geometry.attributes.index.array;
					var positions = geometry.attributes.position.array;
					var offLength = geometry.offsets.length;

					var fl = geometry.attributes.index.array.length / 3;

					for ( var oi = 0; oi < offLength; ++oi ) {

						var start = offsets[ oi ].start;
						var count = offsets[ oi ].count;
						var index = offsets[ oi ].index;

						for ( var i = start, il = start + count; i < il; i += 3 ) {

							a = index + indices[ i ];
							b = index + indices[ i + 1 ];
							c = index + indices[ i + 2 ];

							vA.set(
								positions[ a * 3 ],
								positions[ a * 3 + 1 ],
								positions[ a * 3 + 2 ]
							);
							vB.set(
								positions[ b * 3 ],
								positions[ b * 3 + 1 ],
								positions[ b * 3 + 2 ]
							);
							vC.set(
								positions[ c * 3 ],
								positions[ c * 3 + 1 ],
								positions[ c * 3 + 2 ]
							);


							if ( material.side === THREE.BackSide ) {

								var intersectionPoint = localRay.intersectTriangle( vC, vB, vA, true );

							} else {

								var intersectionPoint = localRay.intersectTriangle( vA, vB, vC, material.side !== THREE.DoubleSide );

							}

							if ( intersectionPoint === null ) continue;

							intersectionPoint.applyMatrix4( object.matrixWorld );

							var distance = raycaster.ray.origin.distanceTo( intersectionPoint );

							if ( distance < precision || distance < raycaster.near || distance > raycaster.far ) continue;

							intersects.push( {

								distance: distance,
								point: intersectionPoint,
								face: null,
								faceIndex: null,
								object: object

							} );

						}

					}

				} else {

					var offsets = geometry.offsets;
					var positions = geometry.attributes.position.array;
					var offLength = geometry.offsets.length;

					var fl = geometry.attributes.position.array.length;

					for ( var i = 0; i < fl; i += 3 ) {

						a = i;
						b = i + 1;
						c = i + 2;

						vA.set(
							positions[ a * 3 ],
							positions[ a * 3 + 1 ],
							positions[ a * 3 + 2 ]
						);
						vB.set(
							positions[ b * 3 ],
							positions[ b * 3 + 1 ],
							positions[ b * 3 + 2 ]
						);
						vC.set(
							positions[ c * 3 ],
							positions[ c * 3 + 1 ],
							positions[ c * 3 + 2 ]
						);


						if ( material.side === THREE.BackSide ) {

							var intersectionPoint = localRay.intersectTriangle( vC, vB, vA, true );

						} else {

							var intersectionPoint = localRay.intersectTriangle( vA, vB, vC, material.side !== THREE.DoubleSide );

						}

						if ( intersectionPoint === null ) continue;

						intersectionPoint.applyMatrix4( object.matrixWorld );

						var distance = raycaster.ray.origin.distanceTo( intersectionPoint );

						if ( distance < precision || distance < raycaster.near || distance > raycaster.far ) continue;

						intersects.push( {

							distance: distance,
							point: intersectionPoint,
							face: null,
							faceIndex: null,
							object: object

						} );

					}

				}

			} else if ( geometry instanceof THREE.Geometry ) {

				var isFaceMaterial = object.material instanceof THREE.MeshFaceMaterial;
				var objectMaterials = isFaceMaterial === true ? object.material.materials : null;

				var a, b, c, d;
				var precision = raycaster.precision;

				var vertices = geometry.vertices;

				for ( var f = 0, fl = geometry.faces.length; f < fl; f ++ ) {

					var face = geometry.faces[ f ];

					var material = isFaceMaterial === true ? objectMaterials[ face.materialIndex ] : object.material;

					if ( material === undefined ) continue;

					a = vertices[ face.a ];
					b = vertices[ face.b ];
					c = vertices[ face.c ];

					if ( material.morphTargets === true ) {

						var morphTargets = geometry.morphTargets;
						var morphInfluences = object.morphTargetInfluences;

						vA.set( 0, 0, 0 );
						vB.set( 0, 0, 0 );
						vC.set( 0, 0, 0 );

						for ( var t = 0, tl = morphTargets.length; t < tl; t ++ ) {

							var influence = morphInfluences[ t ];

							if ( influence === 0 ) continue;

							var targets = morphTargets[ t ].vertices;

							vA.x += ( targets[ face.a ].x - a.x ) * influence;
							vA.y += ( targets[ face.a ].y - a.y ) * influence;
							vA.z += ( targets[ face.a ].z - a.z ) * influence;

							vB.x += ( targets[ face.b ].x - b.x ) * influence;
							vB.y += ( targets[ face.b ].y - b.y ) * influence;
							vB.z += ( targets[ face.b ].z - b.z ) * influence;

							vC.x += ( targets[ face.c ].x - c.x ) * influence;
							vC.y += ( targets[ face.c ].y - c.y ) * influence;
							vC.z += ( targets[ face.c ].z - c.z ) * influence;

						}

						vA.add( a );
						vB.add( b );
						vC.add( c );

						a = vA;
						b = vB;
						c = vC;

					}

					if ( material.side === THREE.BackSide ) {

						var intersectionPoint = localRay.intersectTriangle( c, b, a, true );

					} else {

						var intersectionPoint = localRay.intersectTriangle( a, b, c, material.side !== THREE.DoubleSide );

					}

					if ( intersectionPoint === null ) continue;

					intersectionPoint.applyMatrix4( object.matrixWorld );

					var distance = raycaster.ray.origin.distanceTo( intersectionPoint );

					if ( distance < precision || distance < raycaster.near || distance > raycaster.far ) continue;

					intersects.push( {

						distance: distance,
						point: intersectionPoint,
						face: face,
						faceIndex: f,
						object: object

					} );

				}

			}

		} else if ( object instanceof THREE.Line ) {

			var precision = raycaster.linePrecision;
			var precisionSq = precision * precision;

			var geometry = object.geometry;

			if ( geometry.boundingSphere === null ) geometry.computeBoundingSphere();

			// Checking boundingSphere distance to ray

			sphere.copy( geometry.boundingSphere );
			sphere.applyMatrix4( object.matrixWorld );

			if ( raycaster.ray.isIntersectionSphere( sphere ) === false ) {

				return intersects;

			}

			inverseMatrix.getInverse( object.matrixWorld );
			localRay.copy( raycaster.ray ).applyMatrix4( inverseMatrix );

			/* if ( geometry instanceof THREE.BufferGeometry ) {

			} else */ if ( geometry instanceof THREE.Geometry ) {

				var vertices = geometry.vertices;
				var nbVertices = vertices.length;
				var interSegment = new THREE.Vector3();
				var interRay = new THREE.Vector3();
				var step = object.type === THREE.LineStrip ? 1 : 2;

				for ( var i = 0; i < nbVertices - 1; i = i + step ) {

					var distSq = localRay.distanceSqToSegment( vertices[ i ], vertices[ i + 1 ], interRay, interSegment );

					if ( distSq > precisionSq ) continue;

					var distance = localRay.origin.distanceTo( interRay );

					if ( distance < raycaster.near || distance > raycaster.far ) continue;

					intersects.push( {

						distance: distance,
						// What do we want? intersection point on the ray or on the segment??
						// point: raycaster.ray.at( distance ),
						point: interSegment.clone().applyMatrix4( object.matrixWorld ),
						face: null,
						faceIndex: null,
						object: object

					} );

				}

			}

		}

	};

	var intersectDescendants = function ( object, raycaster, intersects ) {

		var descendants = object.getDescendants();

		for ( var i = 0, l = descendants.length; i < l; i ++ ) {

			intersectObject( descendants[ i ], raycaster, intersects );

		}
	};

	//

	THREE.Raycaster.prototype.precision = 0.0001;
	THREE.Raycaster.prototype.linePrecision = 1;

	THREE.Raycaster.prototype.set = function ( origin, direction ) {

		this.ray.set( origin, direction );
		// direction is assumed to be normalized (for accurate distance calculations)

	};

	THREE.Raycaster.prototype.intersectObject = function ( object, recursive ) {

		var intersects = [];

		if ( recursive === true ) {

			intersectDescendants( object, this, intersects );

		}

		intersectObject( object, this, intersects );

		intersects.sort( descSort );

		return intersects;

	};

	THREE.Raycaster.prototype.intersectObjects = function ( objects, recursive ) {

		var intersects = [];

		for ( var i = 0, l = objects.length; i < l; i ++ ) {

			intersectObject( objects[ i ], this, intersects );

			if ( recursive === true ) {

				intersectDescendants( objects[ i ], this, intersects );

			}

		}

		intersects.sort( descSort );

		return intersects;

	};

}( THREE ) );

/**
 * @author mrdoob / http://mrdoob.com/
 * @author mikael emtinger / http://gomo.se/
 * @author alteredq / http://alteredqualia.com/
 * @author WestLangley / http://github.com/WestLangley
 */

THREE.Object3D = function () {

	this.id = THREE.Object3DIdCount ++;
	this.uuid = THREE.Math.generateUUID();

	this.name = '';

	this.parent = undefined;
	this.children = [];

	this.up = new THREE.Vector3( 0, 1, 0 );

	this.position = new THREE.Vector3();
	this._rotation = new THREE.Euler();
	this._quaternion = new THREE.Quaternion();
	this.scale = new THREE.Vector3( 1, 1, 1 );

	// keep rotation and quaternion in sync

	this._rotation._quaternion = this.quaternion;
	this._quaternion._euler = this.rotation;

	this.renderDepth = null;

	this.rotationAutoUpdate = true;

	this.matrix = new THREE.Matrix4();
	this.matrixWorld = new THREE.Matrix4();

	this.matrixAutoUpdate = true;
	this.matrixWorldNeedsUpdate = true;

	this.visible = true;

	this.castShadow = false;
	this.receiveShadow = false;

	this.frustumCulled = true;

	this.userData = {};

};


THREE.Object3D.prototype = {

	constructor: THREE.Object3D,

	get rotation () {
		return this._rotation;
	},

	set rotation ( value ) {

		this._rotation = value;
		this._rotation._quaternion = this._quaternion;
		this._quaternion._euler = this._rotation;
		this._rotation._updateQuaternion();

	},

	get quaternion () {
		return this._quaternion;
	},

	set quaternion ( value ) {

		this._quaternion = value;
		this._quaternion._euler = this._rotation;
		this._rotation._quaternion = this._quaternion;
		this._quaternion._updateEuler();

	},

	get eulerOrder () {

		console.warn( 'DEPRECATED: Object3D\'s .eulerOrder has been moved to Object3D\'s .rotation.order.' );

		return this.rotation.order;

	},

	set eulerOrder ( value ) {

		console.warn( 'DEPRECATED: Object3D\'s .eulerOrder has been moved to Object3D\'s .rotation.order.' );

		this.rotation.order = value;

	},

	get useQuaternion () {

		console.warn( 'DEPRECATED: Object3D\'s .useQuaternion has been removed. The library now uses quaternions by default.' );

	},

	set useQuaternion ( value ) {

		console.warn( 'DEPRECATED: Object3D\'s .useQuaternion has been removed. The library now uses quaternions by default.' );

	},

	applyMatrix: function ( matrix ) {

		this.matrix.multiplyMatrices( matrix, this.matrix );

		this.matrix.decompose( this.position, this.quaternion, this.scale );

	},

	setRotationFromAxisAngle: function ( axis, angle ) {

		// assumes axis is normalized

		this.quaternion.setFromAxisAngle( axis, angle );

	},

	setRotationFromEuler: function ( euler ) {

		this.quaternion.setFromEuler( euler, true );

	},

	setRotationFromMatrix: function ( m ) {

		// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)

		this.quaternion.setFromRotationMatrix( m );

	},

	setRotationFromQuaternion: function ( q ) {

		// assumes q is normalized

		this.quaternion.copy( q );

	},

	rotateOnAxis: function() {

		// rotate object on axis in object space
		// axis is assumed to be normalized

		var q1 = new THREE.Quaternion();

		return function ( axis, angle ) {

			q1.setFromAxisAngle( axis, angle );

			this.quaternion.multiply( q1 );

			return this;

		}

	}(),

	rotateX: function () {

		var v1 = new THREE.Vector3( 1, 0, 0 );

		return function ( angle ) {

			return this.rotateOnAxis( v1, angle );

		};

	}(),

	rotateY: function () {

		var v1 = new THREE.Vector3( 0, 1, 0 );

		return function ( angle ) {

			return this.rotateOnAxis( v1, angle );

		};

	}(),

	rotateZ: function () {

		var v1 = new THREE.Vector3( 0, 0, 1 );

		return function ( angle ) {

			return this.rotateOnAxis( v1, angle );

		};

	}(),

	translateOnAxis: function () {

		// translate object by distance along axis in object space
		// axis is assumed to be normalized

		var v1 = new THREE.Vector3();

		return function ( axis, distance ) {

			v1.copy( axis );

			v1.applyQuaternion( this.quaternion );

			this.position.add( v1.multiplyScalar( distance ) );

			return this;

		}

	}(),

	translate: function ( distance, axis ) {

		console.warn( 'DEPRECATED: Object3D\'s .translate() has been removed. Use .translateOnAxis( axis, distance ) instead. Note args have been changed.' );
		return this.translateOnAxis( axis, distance );

	},

	translateX: function () {

		var v1 = new THREE.Vector3( 1, 0, 0 );

		return function ( distance ) {

			return this.translateOnAxis( v1, distance );

		};

	}(),

	translateY: function () {

		var v1 = new THREE.Vector3( 0, 1, 0 );

		return function ( distance ) {

			return this.translateOnAxis( v1, distance );

		};

	}(),

	translateZ: function () {

		var v1 = new THREE.Vector3( 0, 0, 1 );

		return function ( distance ) {

			return this.translateOnAxis( v1, distance );

		};

	}(),

	localToWorld: function ( vector ) {

		return vector.applyMatrix4( this.matrixWorld );

	},

	worldToLocal: function () {

		var m1 = new THREE.Matrix4();

		return function ( vector ) {

			return vector.applyMatrix4( m1.getInverse( this.matrixWorld ) );

		};

	}(),

	lookAt: function () {

		// This routine does not support objects with rotated and/or translated parent(s)

		var m1 = new THREE.Matrix4();

		return function ( vector ) {

			m1.lookAt( vector, this.position, this.up );

			this.quaternion.setFromRotationMatrix( m1 );

		};

	}(),

	add: function ( object ) {

		if ( object === this ) {

			console.warn( 'THREE.Object3D.add: An object can\'t be added as a child of itself.' );
			return;

		}

		if ( object instanceof THREE.Object3D ) {

			if ( object.parent !== undefined ) {

				object.parent.remove( object );

			}

			object.parent = this;
			object.dispatchEvent( { type: 'added' } );

			this.children.push( object );

			// add to scene

			var scene = this;

			while ( scene.parent !== undefined ) {

				scene = scene.parent;

			}

			if ( scene !== undefined && scene instanceof THREE.Scene )  {

				scene.__addObject( object );

			}

		}

	},

	remove: function ( object ) {

		var index = this.children.indexOf( object );

		if ( index !== - 1 ) {

			object.parent = undefined;
			object.dispatchEvent( { type: 'removed' } );

			this.children.splice( index, 1 );

			// remove from scene

			var scene = this;

			while ( scene.parent !== undefined ) {

				scene = scene.parent;

			}

			if ( scene !== undefined && scene instanceof THREE.Scene ) {

				scene.__removeObject( object );

			}

		}

	},

	traverse: function ( callback ) {

		callback( this );

		for ( var i = 0, l = this.children.length; i < l; i ++ ) {

			this.children[ i ].traverse( callback );

		}

	},

	getObjectById: function ( id, recursive ) {

		for ( var i = 0, l = this.children.length; i < l; i ++ ) {

			var child = this.children[ i ];

			if ( child.id === id ) {

				return child;

			}

			if ( recursive === true ) {

				child = child.getObjectById( id, recursive );

				if ( child !== undefined ) {

					return child;

				}

			}

		}

		return undefined;

	},

	getObjectByName: function ( name, recursive ) {

		for ( var i = 0, l = this.children.length; i < l; i ++ ) {

			var child = this.children[ i ];

			if ( child.name === name ) {

				return child;

			}

			if ( recursive === true ) {

				child = child.getObjectByName( name, recursive );

				if ( child !== undefined ) {

					return child;

				}

			}

		}

		return undefined;

	},

	getChildByName: function ( name, recursive ) {

		console.warn( 'DEPRECATED: Object3D\'s .getChildByName() has been renamed to .getObjectByName().' );
		return this.getObjectByName( name, recursive );

	},

	getDescendants: function ( array ) {

		if ( array === undefined ) array = [];

		Array.prototype.push.apply( array, this.children );

		for ( var i = 0, l = this.children.length; i < l; i ++ ) {

			this.children[ i ].getDescendants( array );

		}

		return array;

	},

	updateMatrix: function () {

		this.matrix.compose( this.position, this.quaternion, this.scale );

		this.matrixWorldNeedsUpdate = true;

	},

	updateMatrixWorld: function ( force ) {

		if ( this.matrixAutoUpdate === true ) this.updateMatrix();

		if ( this.matrixWorldNeedsUpdate === true || force === true ) {

			if ( this.parent === undefined ) {

				this.matrixWorld.copy( this.matrix );

			} else {

				this.matrixWorld.multiplyMatrices( this.parent.matrixWorld, this.matrix );

			}

			this.matrixWorldNeedsUpdate = false;

			force = true;

		}

		// update children

		for ( var i = 0, l = this.children.length; i < l; i ++ ) {

			this.children[ i ].updateMatrixWorld( force );

		}

	},

	clone: function ( object, recursive ) {

		if ( object === undefined ) object = new THREE.Object3D();
		if ( recursive === undefined ) recursive = true;

		object.name = this.name;

		object.up.copy( this.up );

		object.position.copy( this.position );
		object.quaternion.copy( this.quaternion );
		object.scale.copy( this.scale );

		object.renderDepth = this.renderDepth;

		object.rotationAutoUpdate = this.rotationAutoUpdate;

		object.matrix.copy( this.matrix );
		object.matrixWorld.copy( this.matrixWorld );

		object.matrixAutoUpdate = this.matrixAutoUpdate;
		object.matrixWorldNeedsUpdate = this.matrixWorldNeedsUpdate;

		object.visible = this.visible;

		object.castShadow = this.castShadow;
		object.receiveShadow = this.receiveShadow;

		object.frustumCulled = this.frustumCulled;

		object.userData = JSON.parse( JSON.stringify( this.userData ) );

		if ( recursive === true ) {

			for ( var i = 0; i < this.children.length; i ++ ) {

				var child = this.children[ i ];
				object.add( child.clone() );

			}

		}

		return object;

	}

};

THREE.EventDispatcher.prototype.apply( THREE.Object3D.prototype );

THREE.Object3DIdCount = 0;

/**
 * @author mrdoob / http://mrdoob.com/
 * @author supereggbert / http://www.paulbrunt.co.uk/
 * @author julianwa / https://github.com/julianwa
 */

THREE.Projector = function () {

	var _object, _objectCount, _objectPool = [], _objectPoolLength = 0,
	_vertex, _vertexCount, _vertexPool = [], _vertexPoolLength = 0,
	_face, _face3Count, _face3Pool = [], _face3PoolLength = 0,
	_line, _lineCount, _linePool = [], _linePoolLength = 0,
	_sprite, _spriteCount, _spritePool = [], _spritePoolLength = 0,

	_renderData = { objects: [], sprites: [], lights: [], elements: [] },

	_vA = new THREE.Vector3(),
	_vB = new THREE.Vector3(),
	_vC = new THREE.Vector3(),

	_vector3 = new THREE.Vector3(),
	_vector4 = new THREE.Vector4(),

	_clipBox = new THREE.Box3( new THREE.Vector3( -1, -1, -1 ), new THREE.Vector3( 1, 1, 1 ) ),
	_boundingBox = new THREE.Box3(),
	_points3 = new Array( 3 ),
	_points4 = new Array( 4 ),

	_viewMatrix = new THREE.Matrix4(),
	_viewProjectionMatrix = new THREE.Matrix4(),

	_modelMatrix,
	_modelViewProjectionMatrix = new THREE.Matrix4(),

	_normalMatrix = new THREE.Matrix3(),
	_normalViewMatrix = new THREE.Matrix3(),

	_centroid = new THREE.Vector3(),

	_frustum = new THREE.Frustum(),

	_clippedVertex1PositionScreen = new THREE.Vector4(),
	_clippedVertex2PositionScreen = new THREE.Vector4();

	this.projectVector = function ( vector, camera ) {

		camera.matrixWorldInverse.getInverse( camera.matrixWorld );

		_viewProjectionMatrix.multiplyMatrices( camera.projectionMatrix, camera.matrixWorldInverse );

		return vector.applyProjection( _viewProjectionMatrix );

	};

	this.unprojectVector = function () {

		var projectionMatrixInverse = new THREE.Matrix4();

		return function ( vector, camera ) {

			projectionMatrixInverse.getInverse( camera.projectionMatrix );
			_viewProjectionMatrix.multiplyMatrices( camera.matrixWorld, projectionMatrixInverse );

			return vector.applyProjection( _viewProjectionMatrix );

		};

	}();

	this.pickingRay = function ( vector, camera ) {

		// set two vectors with opposing z values
		vector.z = -1.0;
		var end = new THREE.Vector3( vector.x, vector.y, 1.0 );

		this.unprojectVector( vector, camera );
		this.unprojectVector( end, camera );

		// find direction from vector to end
		end.sub( vector ).normalize();

		return new THREE.Raycaster( vector, end );

	};

	var getObject = function ( object ) {

		_object = getNextObjectInPool();
		_object.id = object.id;
		_object.object = object;

		if ( object.renderDepth !== null ) {

			_object.z = object.renderDepth;

		} else {

			_vector3.setFromMatrixPosition( object.matrixWorld );
			_vector3.applyProjection( _viewProjectionMatrix );
			_object.z = _vector3.z;

		}

		return _object;

	};

	var projectVertex = function ( vertex ) {

		var position = vertex.position;
		var positionWorld = vertex.positionWorld;
		var positionScreen = vertex.positionScreen;

		positionWorld.copy( position ).applyMatrix4( _modelMatrix );
		positionScreen.copy( positionWorld ).applyMatrix4( _viewProjectionMatrix );

		var invW = 1 / positionScreen.w;

		positionScreen.x *= invW;
		positionScreen.y *= invW;
		positionScreen.z *= invW;

		vertex.visible = positionScreen.x >= -1 && positionScreen.x <= 1 &&
				 positionScreen.y >= -1 && positionScreen.y <= 1 &&
				 positionScreen.z >= -1 && positionScreen.z <= 1;

	};

	var projectObject = function ( object ) {

		if ( object.visible === false ) return;

		if ( object instanceof THREE.Light ) {

			_renderData.lights.push( object );

		} else if ( object instanceof THREE.Mesh || object instanceof THREE.Line ) {

			if ( object.frustumCulled === false || _frustum.intersectsObject( object ) === true ) {

				_renderData.objects.push( getObject( object ) );

			}

		} else if ( object instanceof THREE.Sprite ) {

			_renderData.sprites.push( getObject( object ) );

		}

		for ( var i = 0, l = object.children.length; i < l; i ++ ) {

			projectObject( object.children[ i ] );

		}

	};

	var projectGraph = function ( root, sortObjects ) {

		_objectCount = 0;

		_renderData.objects.length = 0;
		_renderData.sprites.length = 0;
		_renderData.lights.length = 0;

		projectObject( root );

		if ( sortObjects === true ) {

			_renderData.objects.sort( painterSort );

		}

	};

	this.projectScene = function ( scene, camera, sortObjects, sortElements ) {

		var visible = false,
		object, geometry, vertices, faces, face, faceVertexNormals, faceVertexUvs, uvs,
		v1, v2, v3, v4, isFaceMaterial, objectMaterials;

		_face3Count = 0;
		_lineCount = 0;
		_spriteCount = 0;

		_renderData.elements.length = 0;

		if ( scene.autoUpdate === true ) scene.updateMatrixWorld();
		if ( camera.parent === undefined ) camera.updateMatrixWorld();

		_viewMatrix.copy( camera.matrixWorldInverse.getInverse( camera.matrixWorld ) );
		_viewProjectionMatrix.multiplyMatrices( camera.projectionMatrix, _viewMatrix );

		_normalViewMatrix.getNormalMatrix( _viewMatrix );

		_frustum.setFromMatrix( _viewProjectionMatrix );

		projectGraph( scene, sortObjects );

		for ( var o = 0, ol = _renderData.objects.length; o < ol; o ++ ) {

			object = _renderData.objects[ o ].object;

			_modelMatrix = object.matrixWorld;

			_vertexCount = 0;

			if ( object instanceof THREE.Mesh ) {

				geometry = object.geometry;

				vertices = geometry.vertices;
				faces = geometry.faces;
				faceVertexUvs = geometry.faceVertexUvs;

				_normalMatrix.getNormalMatrix( _modelMatrix );

				isFaceMaterial = object.material instanceof THREE.MeshFaceMaterial;
				objectMaterials = isFaceMaterial === true ? object.material : null;

				for ( var v = 0, vl = vertices.length; v < vl; v ++ ) {

					_vertex = getNextVertexInPool();
					_vertex.position.copy( vertices[ v ] );

					projectVertex( _vertex );

				}

				for ( var f = 0, fl = faces.length; f < fl; f ++ ) {

					face = faces[ f ];

					var material = isFaceMaterial === true
						? objectMaterials.materials[ face.materialIndex ]
						: object.material;

					if ( material === undefined ) continue;

					var side = material.side;

					v1 = _vertexPool[ face.a ];
					v2 = _vertexPool[ face.b ];
					v3 = _vertexPool[ face.c ];

					if ( material.morphTargets === true ) {

						var morphTargets = geometry.morphTargets;
						var morphInfluences = object.morphTargetInfluences;

						var v1p = v1.position;
						var v2p = v2.position;
						var v3p = v3.position;

						_vA.set( 0, 0, 0 );
						_vB.set( 0, 0, 0 );
						_vC.set( 0, 0, 0 );

						for ( var t = 0, tl = morphTargets.length; t < tl; t ++ ) {

							var influence = morphInfluences[ t ];

							if ( influence === 0 ) continue;

							var targets = morphTargets[ t ].vertices;

							_vA.x += ( targets[ face.a ].x - v1p.x ) * influence;
							_vA.y += ( targets[ face.a ].y - v1p.y ) * influence;
							_vA.z += ( targets[ face.a ].z - v1p.z ) * influence;

							_vB.x += ( targets[ face.b ].x - v2p.x ) * influence;
							_vB.y += ( targets[ face.b ].y - v2p.y ) * influence;
							_vB.z += ( targets[ face.b ].z - v2p.z ) * influence;

							_vC.x += ( targets[ face.c ].x - v3p.x ) * influence;
							_vC.y += ( targets[ face.c ].y - v3p.y ) * influence;
							_vC.z += ( targets[ face.c ].z - v3p.z ) * influence;

						}

						v1.position.add( _vA );
						v2.position.add( _vB );
						v3.position.add( _vC );

						projectVertex( v1 );
						projectVertex( v2 );
						projectVertex( v3 );

					}

					_points3[ 0 ] = v1.positionScreen;
					_points3[ 1 ] = v2.positionScreen;
					_points3[ 2 ] = v3.positionScreen;

					if ( v1.visible === true || v2.visible === true || v3.visible === true ||
						_clipBox.isIntersectionBox( _boundingBox.setFromPoints( _points3 ) ) ) {

						visible = ( ( v3.positionScreen.x - v1.positionScreen.x ) *
							    ( v2.positionScreen.y - v1.positionScreen.y ) -
							    ( v3.positionScreen.y - v1.positionScreen.y ) *
							    ( v2.positionScreen.x - v1.positionScreen.x ) ) < 0;

						if ( side === THREE.DoubleSide || visible === ( side === THREE.FrontSide ) ) {

							_face = getNextFace3InPool();

							_face.id = object.id;
							_face.v1.copy( v1 );
							_face.v2.copy( v2 );
							_face.v3.copy( v3 );

						} else {

							continue;

						}

					} else {

						continue;

					}

					_face.normalModel.copy( face.normal );

					if ( visible === false && ( side === THREE.BackSide || side === THREE.DoubleSide ) ) {

						_face.normalModel.negate();

					}

					_face.normalModel.applyMatrix3( _normalMatrix ).normalize();

					_face.normalModelView.copy( _face.normalModel ).applyMatrix3( _normalViewMatrix );

					_face.centroidModel.copy( face.centroid ).applyMatrix4( _modelMatrix );

					faceVertexNormals = face.vertexNormals;

					for ( var n = 0, nl = Math.min( faceVertexNormals.length, 3 ); n < nl; n ++ ) {

						var normalModel = _face.vertexNormalsModel[ n ];
						normalModel.copy( faceVertexNormals[ n ] );

						if ( visible === false && ( side === THREE.BackSide || side === THREE.DoubleSide ) ) {

							normalModel.negate();

						}

						normalModel.applyMatrix3( _normalMatrix ).normalize();

						var normalModelView = _face.vertexNormalsModelView[ n ];
						normalModelView.copy( normalModel ).applyMatrix3( _normalViewMatrix );

					}

					_face.vertexNormalsLength = faceVertexNormals.length;

					for ( var c = 0, cl = Math.min( faceVertexUvs.length, 3 ); c < cl; c ++ ) {

						uvs = faceVertexUvs[ c ][ f ];

						if ( uvs === undefined ) continue;

						for ( var u = 0, ul = uvs.length; u < ul; u ++ ) {

							_face.uvs[ c ][ u ] = uvs[ u ];

						}

					}

					_face.color = face.color;
					_face.material = material;

					_centroid.copy( _face.centroidModel ).applyProjection( _viewProjectionMatrix );

					_face.z = _centroid.z;

					_renderData.elements.push( _face );

				}

			} else if ( object instanceof THREE.Line ) {

				_modelViewProjectionMatrix.multiplyMatrices( _viewProjectionMatrix, _modelMatrix );

				vertices = object.geometry.vertices;

				v1 = getNextVertexInPool();
				v1.positionScreen.copy( vertices[ 0 ] ).applyMatrix4( _modelViewProjectionMatrix );

				// Handle LineStrip and LinePieces
				var step = object.type === THREE.LinePieces ? 2 : 1;

				for ( v = 1, vl = vertices.length; v < vl; v ++ ) {

					v1 = getNextVertexInPool();
					v1.positionScreen.copy( vertices[ v ] ).applyMatrix4( _modelViewProjectionMatrix );

					if ( ( v + 1 ) % step > 0 ) continue;

					v2 = _vertexPool[ _vertexCount - 2 ];

					_clippedVertex1PositionScreen.copy( v1.positionScreen );
					_clippedVertex2PositionScreen.copy( v2.positionScreen );

					if ( clipLine( _clippedVertex1PositionScreen, _clippedVertex2PositionScreen ) === true ) {

						// Perform the perspective divide
						_clippedVertex1PositionScreen.multiplyScalar( 1 / _clippedVertex1PositionScreen.w );
						_clippedVertex2PositionScreen.multiplyScalar( 1 / _clippedVertex2PositionScreen.w );

						_line = getNextLineInPool();

						_line.id = object.id;
						_line.v1.positionScreen.copy( _clippedVertex1PositionScreen );
						_line.v2.positionScreen.copy( _clippedVertex2PositionScreen );

						_line.z = Math.max( _clippedVertex1PositionScreen.z, _clippedVertex2PositionScreen.z );

						_line.material = object.material;

						if ( object.material.vertexColors === THREE.VertexColors ) {

							_line.vertexColors[ 0 ].copy( object.geometry.colors[ v ] );
							_line.vertexColors[ 1 ].copy( object.geometry.colors[ v - 1 ] );

						}

						_renderData.elements.push( _line );

					}

				}

			}

		}

		for ( o = 0, ol = _renderData.sprites.length; o < ol; o++ ) {

			object = _renderData.sprites[ o ].object;

			_modelMatrix = object.matrixWorld;

			_vector4.set( _modelMatrix.elements[12], _modelMatrix.elements[13], _modelMatrix.elements[14], 1 );
			_vector4.applyMatrix4( _viewProjectionMatrix );

			var invW = 1 / _vector4.w;

			_vector4.z *= invW;

			if ( _vector4.z >= -1 && _vector4.z <= 1 ) {

				_sprite = getNextSpriteInPool();
				_sprite.id = object.id;
				_sprite.x = _vector4.x * invW;
				_sprite.y = _vector4.y * invW;
				_sprite.z = _vector4.z;
				_sprite.object = object;

				_sprite.rotation = object.rotation;

				_sprite.scale.x = object.scale.x * Math.abs( _sprite.x - ( _vector4.x + camera.projectionMatrix.elements[0] ) / ( _vector4.w + camera.projectionMatrix.elements[12] ) );
				_sprite.scale.y = object.scale.y * Math.abs( _sprite.y - ( _vector4.y + camera.projectionMatrix.elements[5] ) / ( _vector4.w + camera.projectionMatrix.elements[13] ) );

				_sprite.material = object.material;

				_renderData.elements.push( _sprite );

			}

		}

		if ( sortElements === true ) _renderData.elements.sort( painterSort );

		return _renderData;

	};

	// Pools

	function getNextObjectInPool() {

		if ( _objectCount === _objectPoolLength ) {

			var object = new THREE.RenderableObject();
			_objectPool.push( object );
			_objectPoolLength ++;
			_objectCount ++;
			return object;

		}

		return _objectPool[ _objectCount ++ ];

	}

	function getNextVertexInPool() {

		if ( _vertexCount === _vertexPoolLength ) {

			var vertex = new THREE.RenderableVertex();
			_vertexPool.push( vertex );
			_vertexPoolLength ++;
			_vertexCount ++;
			return vertex;

		}

		return _vertexPool[ _vertexCount ++ ];

	}

	function getNextFace3InPool() {

		if ( _face3Count === _face3PoolLength ) {

			var face = new THREE.RenderableFace3();
			_face3Pool.push( face );
			_face3PoolLength ++;
			_face3Count ++;
			return face;

		}

		return _face3Pool[ _face3Count ++ ];


	}

	function getNextLineInPool() {

		if ( _lineCount === _linePoolLength ) {

			var line = new THREE.RenderableLine();
			_linePool.push( line );
			_linePoolLength ++;
			_lineCount ++
			return line;

		}

		return _linePool[ _lineCount ++ ];

	}

	function getNextSpriteInPool() {

		if ( _spriteCount === _spritePoolLength ) {

			var sprite = new THREE.RenderableSprite();
			_spritePool.push( sprite );
			_spritePoolLength ++;
			_spriteCount ++
			return sprite;

		}

		return _spritePool[ _spriteCount ++ ];

	}

	//

	function painterSort( a, b ) {

		if ( a.z !== b.z ) {

			return b.z - a.z;

		} else if ( a.id !== b.id ) {

			return a.id - b.id;

		} else {

			return 0;

		}

	}

	function clipLine( s1, s2 ) {

		var alpha1 = 0, alpha2 = 1,

		// Calculate the boundary coordinate of each vertex for the near and far clip planes,
		// Z = -1 and Z = +1, respectively.
		bc1near =  s1.z + s1.w,
		bc2near =  s2.z + s2.w,
		bc1far =  - s1.z + s1.w,
		bc2far =  - s2.z + s2.w;

		if ( bc1near >= 0 && bc2near >= 0 && bc1far >= 0 && bc2far >= 0 ) {

			// Both vertices lie entirely within all clip planes.
			return true;

		} else if ( ( bc1near < 0 && bc2near < 0) || (bc1far < 0 && bc2far < 0 ) ) {

			// Both vertices lie entirely outside one of the clip planes.
			return false;

		} else {

			// The line segment spans at least one clip plane.

			if ( bc1near < 0 ) {

				// v1 lies outside the near plane, v2 inside
				alpha1 = Math.max( alpha1, bc1near / ( bc1near - bc2near ) );

			} else if ( bc2near < 0 ) {

				// v2 lies outside the near plane, v1 inside
				alpha2 = Math.min( alpha2, bc1near / ( bc1near - bc2near ) );

			}

			if ( bc1far < 0 ) {

				// v1 lies outside the far plane, v2 inside
				alpha1 = Math.max( alpha1, bc1far / ( bc1far - bc2far ) );

			} else if ( bc2far < 0 ) {

				// v2 lies outside the far plane, v2 inside
				alpha2 = Math.min( alpha2, bc1far / ( bc1far - bc2far ) );

			}

			if ( alpha2 < alpha1 ) {

				// The line segment spans two boundaries, but is outside both of them.
				// (This can't happen when we're only clipping against just near/far but good
				//  to leave the check here for future usage if other clip planes are added.)
				return false;

			} else {

				// Update the s1 and s2 vertices to match the clipped line segment.
				s1.lerp( s2, alpha1 );
				s2.lerp( s1, 1 - alpha2 );

				return true;

			}

		}

	}

};

/**
 * @author mrdoob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 */

THREE.Face3 = function ( a, b, c, normal, color, materialIndex ) {

	this.a = a;
	this.b = b;
	this.c = c;

	this.normal = normal instanceof THREE.Vector3 ? normal : new THREE.Vector3();
	this.vertexNormals = normal instanceof Array ? normal : [ ];

	this.color = color instanceof THREE.Color ? color : new THREE.Color();
	this.vertexColors = color instanceof Array ? color : [];

	this.vertexTangents = [];

	this.materialIndex = materialIndex !== undefined ? materialIndex : 0;

	this.centroid = new THREE.Vector3();

};

THREE.Face3.prototype = {

	constructor: THREE.Face3,

	clone: function () {

		var face = new THREE.Face3( this.a, this.b, this.c );

		face.normal.copy( this.normal );
		face.color.copy( this.color );
		face.centroid.copy( this.centroid );

		face.materialIndex = this.materialIndex;

		var i, il;
		for ( i = 0, il = this.vertexNormals.length; i < il; i ++ ) face.vertexNormals[ i ] = this.vertexNormals[ i ].clone();
		for ( i = 0, il = this.vertexColors.length; i < il; i ++ ) face.vertexColors[ i ] = this.vertexColors[ i ].clone();
		for ( i = 0, il = this.vertexTangents.length; i < il; i ++ ) face.vertexTangents[ i ] = this.vertexTangents[ i ].clone();

		return face;

	}

};

/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.Face4 = function ( a, b, c, d, normal, color, materialIndex ) {

	console.warn( 'THREE.Face4 has been removed. A THREE.Face3 will be created instead.')

	return new THREE.Face3( a, b, c, normal, color, materialIndex );

};

/**
 * @author mrdoob / http://mrdoob.com/
 * @author kile / http://kile.stravaganza.org/
 * @author alteredq / http://alteredqualia.com/
 * @author mikael emtinger / http://gomo.se/
 * @author zz85 / http://www.lab4games.net/zz85/blog
 * @author bhouston / http://exocortex.com
 */

THREE.Geometry = function () {

	this.id = THREE.GeometryIdCount ++;
	this.uuid = THREE.Math.generateUUID();

	this.name = '';

	this.vertices = [];
	this.colors = [];  // one-to-one vertex colors, used in ParticleSystem and Line

	this.faces = [];

	this.faceVertexUvs = [[]];

	this.morphTargets = [];
	this.morphColors = [];
	this.morphNormals = [];

	this.skinWeights = [];
	this.skinIndices = [];

	this.lineDistances = [];

	this.boundingBox = null;
	this.boundingSphere = null;

	this.hasTangents = false;

	this.dynamic = true; // the intermediate typed arrays will be deleted when set to false

	// update flags

	this.verticesNeedUpdate = false;
	this.elementsNeedUpdate = false;
	this.uvsNeedUpdate = false;
	this.normalsNeedUpdate = false;
	this.tangentsNeedUpdate = false;
	this.colorsNeedUpdate = false;
	this.lineDistancesNeedUpdate = false;

	this.buffersNeedUpdate = false;

};

THREE.Geometry.prototype = {

	constructor: THREE.Geometry,

	applyMatrix: function ( matrix ) {

		var normalMatrix = new THREE.Matrix3().getNormalMatrix( matrix );

		for ( var i = 0, il = this.vertices.length; i < il; i ++ ) {

			var vertex = this.vertices[ i ];
			vertex.applyMatrix4( matrix );

		}

		for ( var i = 0, il = this.faces.length; i < il; i ++ ) {

			var face = this.faces[ i ];
			face.normal.applyMatrix3( normalMatrix ).normalize();

			for ( var j = 0, jl = face.vertexNormals.length; j < jl; j ++ ) {

				face.vertexNormals[ j ].applyMatrix3( normalMatrix ).normalize();

			}

			face.centroid.applyMatrix4( matrix );

		}

		if ( this.boundingBox instanceof THREE.Box3 ) {

			this.computeBoundingBox();

		}

		if ( this.boundingSphere instanceof THREE.Sphere ) {

			this.computeBoundingSphere();

		}

	},

	computeCentroids: function () {

		var f, fl, face;

		for ( f = 0, fl = this.faces.length; f < fl; f ++ ) {

			face = this.faces[ f ];
			face.centroid.set( 0, 0, 0 );

			face.centroid.add( this.vertices[ face.a ] );
			face.centroid.add( this.vertices[ face.b ] );
			face.centroid.add( this.vertices[ face.c ] );
			face.centroid.divideScalar( 3 );

		}

	},

	computeFaceNormals: function () {

		var cb = new THREE.Vector3(), ab = new THREE.Vector3();

		for ( var f = 0, fl = this.faces.length; f < fl; f ++ ) {

			var face = this.faces[ f ];

			var vA = this.vertices[ face.a ];
			var vB = this.vertices[ face.b ];
			var vC = this.vertices[ face.c ];

			cb.subVectors( vC, vB );
			ab.subVectors( vA, vB );
			cb.cross( ab );

			cb.normalize();

			face.normal.copy( cb );

		}

	},

	computeVertexNormals: function ( areaWeighted ) {

		var v, vl, f, fl, face, vertices;

		vertices = new Array( this.vertices.length );

		for ( v = 0, vl = this.vertices.length; v < vl; v ++ ) {

			vertices[ v ] = new THREE.Vector3();

		}

		if ( areaWeighted ) {

			// vertex normals weighted by triangle areas
			// http://www.iquilezles.org/www/articles/normals/normals.htm

			var vA, vB, vC, vD;
			var cb = new THREE.Vector3(), ab = new THREE.Vector3(),
				db = new THREE.Vector3(), dc = new THREE.Vector3(), bc = new THREE.Vector3();

			for ( f = 0, fl = this.faces.length; f < fl; f ++ ) {

				face = this.faces[ f ];

				vA = this.vertices[ face.a ];
				vB = this.vertices[ face.b ];
				vC = this.vertices[ face.c ];

				cb.subVectors( vC, vB );
				ab.subVectors( vA, vB );
				cb.cross( ab );

				vertices[ face.a ].add( cb );
				vertices[ face.b ].add( cb );
				vertices[ face.c ].add( cb );

			}

		} else {

			for ( f = 0, fl = this.faces.length; f < fl; f ++ ) {

				face = this.faces[ f ];

				vertices[ face.a ].add( face.normal );
				vertices[ face.b ].add( face.normal );
				vertices[ face.c ].add( face.normal );

			}

		}

		for ( v = 0, vl = this.vertices.length; v < vl; v ++ ) {

			vertices[ v ].normalize();

		}

		for ( f = 0, fl = this.faces.length; f < fl; f ++ ) {

			face = this.faces[ f ];

			face.vertexNormals[ 0 ] = vertices[ face.a ].clone();
			face.vertexNormals[ 1 ] = vertices[ face.b ].clone();
			face.vertexNormals[ 2 ] = vertices[ face.c ].clone();

		}

	},

	computeMorphNormals: function () {

		var i, il, f, fl, face;

		// save original normals
		// - create temp variables on first access
		//   otherwise just copy (for faster repeated calls)

		for ( f = 0, fl = this.faces.length; f < fl; f ++ ) {

			face = this.faces[ f ];

			if ( ! face.__originalFaceNormal ) {

				face.__originalFaceNormal = face.normal.clone();

			} else {

				face.__originalFaceNormal.copy( face.normal );

			}

			if ( ! face.__originalVertexNormals ) face.__originalVertexNormals = [];

			for ( i = 0, il = face.vertexNormals.length; i < il; i ++ ) {

				if ( ! face.__originalVertexNormals[ i ] ) {

					face.__originalVertexNormals[ i ] = face.vertexNormals[ i ].clone();

				} else {

					face.__originalVertexNormals[ i ].copy( face.vertexNormals[ i ] );

				}

			}

		}

		// use temp geometry to compute face and vertex normals for each morph

		var tmpGeo = new THREE.Geometry();
		tmpGeo.faces = this.faces;

		for ( i = 0, il = this.morphTargets.length; i < il; i ++ ) {

			// create on first access

			if ( ! this.morphNormals[ i ] ) {

				this.morphNormals[ i ] = {};
				this.morphNormals[ i ].faceNormals = [];
				this.morphNormals[ i ].vertexNormals = [];

				var dstNormalsFace = this.morphNormals[ i ].faceNormals;
				var dstNormalsVertex = this.morphNormals[ i ].vertexNormals;

				var faceNormal, vertexNormals;

				for ( f = 0, fl = this.faces.length; f < fl; f ++ ) {

					face = this.faces[ f ];

					faceNormal = new THREE.Vector3();
					vertexNormals = { a: new THREE.Vector3(), b: new THREE.Vector3(), c: new THREE.Vector3() };

					dstNormalsFace.push( faceNormal );
					dstNormalsVertex.push( vertexNormals );

				}

			}

			var morphNormals = this.morphNormals[ i ];

			// set vertices to morph target

			tmpGeo.vertices = this.morphTargets[ i ].vertices;

			// compute morph normals

			tmpGeo.computeFaceNormals();
			tmpGeo.computeVertexNormals();

			// store morph normals

			var faceNormal, vertexNormals;

			for ( f = 0, fl = this.faces.length; f < fl; f ++ ) {

				face = this.faces[ f ];

				faceNormal = morphNormals.faceNormals[ f ];
				vertexNormals = morphNormals.vertexNormals[ f ];

				faceNormal.copy( face.normal );

				vertexNormals.a.copy( face.vertexNormals[ 0 ] );
				vertexNormals.b.copy( face.vertexNormals[ 1 ] );
				vertexNormals.c.copy( face.vertexNormals[ 2 ] );

			}

		}

		// restore original normals

		for ( f = 0, fl = this.faces.length; f < fl; f ++ ) {

			face = this.faces[ f ];

			face.normal = face.__originalFaceNormal;
			face.vertexNormals = face.__originalVertexNormals;

		}

	},

	computeTangents: function () {

		// based on http://www.terathon.com/code/tangent.html
		// tangents go to vertices

		var f, fl, v, vl, i, il, vertexIndex,
			face, uv, vA, vB, vC, uvA, uvB, uvC,
			x1, x2, y1, y2, z1, z2,
			s1, s2, t1, t2, r, t, test,
			tan1 = [], tan2 = [],
			sdir = new THREE.Vector3(), tdir = new THREE.Vector3(),
			tmp = new THREE.Vector3(), tmp2 = new THREE.Vector3(),
			n = new THREE.Vector3(), w;

		for ( v = 0, vl = this.vertices.length; v < vl; v ++ ) {

			tan1[ v ] = new THREE.Vector3();
			tan2[ v ] = new THREE.Vector3();

		}

		function handleTriangle( context, a, b, c, ua, ub, uc ) {

			vA = context.vertices[ a ];
			vB = context.vertices[ b ];
			vC = context.vertices[ c ];

			uvA = uv[ ua ];
			uvB = uv[ ub ];
			uvC = uv[ uc ];

			x1 = vB.x - vA.x;
			x2 = vC.x - vA.x;
			y1 = vB.y - vA.y;
			y2 = vC.y - vA.y;
			z1 = vB.z - vA.z;
			z2 = vC.z - vA.z;

			s1 = uvB.x - uvA.x;
			s2 = uvC.x - uvA.x;
			t1 = uvB.y - uvA.y;
			t2 = uvC.y - uvA.y;

			r = 1.0 / ( s1 * t2 - s2 * t1 );
			sdir.set( ( t2 * x1 - t1 * x2 ) * r,
					  ( t2 * y1 - t1 * y2 ) * r,
					  ( t2 * z1 - t1 * z2 ) * r );
			tdir.set( ( s1 * x2 - s2 * x1 ) * r,
					  ( s1 * y2 - s2 * y1 ) * r,
					  ( s1 * z2 - s2 * z1 ) * r );

			tan1[ a ].add( sdir );
			tan1[ b ].add( sdir );
			tan1[ c ].add( sdir );

			tan2[ a ].add( tdir );
			tan2[ b ].add( tdir );
			tan2[ c ].add( tdir );

		}

		for ( f = 0, fl = this.faces.length; f < fl; f ++ ) {

			face = this.faces[ f ];
			uv = this.faceVertexUvs[ 0 ][ f ]; // use UV layer 0 for tangents

			handleTriangle( this, face.a, face.b, face.c, 0, 1, 2 );

		}

		var faceIndex = [ 'a', 'b', 'c', 'd' ];

		for ( f = 0, fl = this.faces.length; f < fl; f ++ ) {

			face = this.faces[ f ];

			for ( i = 0; i < Math.min( face.vertexNormals.length, 3 ); i++ ) {

				n.copy( face.vertexNormals[ i ] );

				vertexIndex = face[ faceIndex[ i ] ];

				t = tan1[ vertexIndex ];

				// Gram-Schmidt orthogonalize

				tmp.copy( t );
				tmp.sub( n.multiplyScalar( n.dot( t ) ) ).normalize();

				// Calculate handedness

				tmp2.crossVectors( face.vertexNormals[ i ], t );
				test = tmp2.dot( tan2[ vertexIndex ] );
				w = (test < 0.0) ? -1.0 : 1.0;

				face.vertexTangents[ i ] = new THREE.Vector4( tmp.x, tmp.y, tmp.z, w );

			}

		}

		this.hasTangents = true;

	},

	computeLineDistances: function ( ) {

		var d = 0;
		var vertices = this.vertices;

		for ( var i = 0, il = vertices.length; i < il; i ++ ) {

			if ( i > 0 ) {

				d += vertices[ i ].distanceTo( vertices[ i - 1 ] );

			}

			this.lineDistances[ i ] = d;

		}

	},

	computeBoundingBox: function () {

		if ( this.boundingBox === null ) {

			this.boundingBox = new THREE.Box3();

		}

		this.boundingBox.setFromPoints( this.vertices );

	},

	computeBoundingSphere: function () {

		if ( this.boundingSphere === null ) {

			this.boundingSphere = new THREE.Sphere();

		}

		this.boundingSphere.setFromPoints( this.vertices );

	},

	/*
	 * Checks for duplicate vertices with hashmap.
	 * Duplicated vertices are removed
	 * and faces' vertices are updated.
	 */

	mergeVertices: function () {

		var verticesMap = {}; // Hashmap for looking up vertice by position coordinates (and making sure they are unique)
		var unique = [], changes = [];

		var v, key;
		var precisionPoints = 4; // number of decimal points, eg. 4 for epsilon of 0.0001
		var precision = Math.pow( 10, precisionPoints );
		var i,il, face;
		var indices, k, j, jl, u;

		for ( i = 0, il = this.vertices.length; i < il; i ++ ) {

			v = this.vertices[ i ];
			key = Math.round( v.x * precision ) + '_' + Math.round( v.y * precision ) + '_' + Math.round( v.z * precision );

			if ( verticesMap[ key ] === undefined ) {

				verticesMap[ key ] = i;
				unique.push( this.vertices[ i ] );
				changes[ i ] = unique.length - 1;

			} else {

				//console.log('Duplicate vertex found. ', i, ' could be using ', verticesMap[key]);
				changes[ i ] = changes[ verticesMap[ key ] ];

			}

		};


		// if faces are completely degenerate after merging vertices, we
		// have to remove them from the geometry.
		var faceIndicesToRemove = [];

		for( i = 0, il = this.faces.length; i < il; i ++ ) {

			face = this.faces[ i ];

			face.a = changes[ face.a ];
			face.b = changes[ face.b ];
			face.c = changes[ face.c ];

			indices = [ face.a, face.b, face.c ];

			var dupIndex = -1;

			// if any duplicate vertices are found in a Face3
			// we have to remove the face as nothing can be saved
			for ( var n = 0; n < 3; n ++ ) {
				if ( indices[ n ] == indices[ ( n + 1 ) % 3 ] ) {

					dupIndex = n;
					faceIndicesToRemove.push( i );
					break;

				}
			}

		}

		for ( i = faceIndicesToRemove.length - 1; i >= 0; i -- ) {
			var idx = faceIndicesToRemove[ i ];

			this.faces.splice( idx, 1 );

			for ( j = 0, jl = this.faceVertexUvs.length; j < jl; j ++ ) {

				this.faceVertexUvs[ j ].splice( idx, 1 );

			}

		}

		// Use unique set of vertices

		var diff = this.vertices.length - unique.length;
		this.vertices = unique;
		return diff;

	},

	clone: function () {

		var geometry = new THREE.Geometry();

		var vertices = this.vertices;

		for ( var i = 0, il = vertices.length; i < il; i ++ ) {

			geometry.vertices.push( vertices[ i ].clone() );

		}

		var faces = this.faces;

		for ( var i = 0, il = faces.length; i < il; i ++ ) {

			geometry.faces.push( faces[ i ].clone() );

		}

		var uvs = this.faceVertexUvs[ 0 ];

		for ( var i = 0, il = uvs.length; i < il; i ++ ) {

			var uv = uvs[ i ], uvCopy = [];

			for ( var j = 0, jl = uv.length; j < jl; j ++ ) {

				uvCopy.push( new THREE.Vector2( uv[ j ].x, uv[ j ].y ) );

			}

			geometry.faceVertexUvs[ 0 ].push( uvCopy );

		}

		return geometry;

	},

	dispose: function () {

		this.dispatchEvent( { type: 'dispose' } );

	}

};

THREE.EventDispatcher.prototype.apply( THREE.Geometry.prototype );

THREE.GeometryIdCount = 0;

/**
 * @author alteredq / http://alteredqualia.com/
 */

THREE.BufferGeometry = function () {

	this.id = THREE.GeometryIdCount ++;
	this.uuid = THREE.Math.generateUUID();

	this.name = '';

	// attributes

	this.attributes = {};

	// attributes typed arrays are kept only if dynamic flag is set

	this.dynamic = true;

	// offsets for chunks when using indexed elements

	this.offsets = [];

	// boundings

	this.boundingBox = null;
	this.boundingSphere = null;

	this.hasTangents = false;

	// for compatibility

	this.morphTargets = [];

};

THREE.BufferGeometry.prototype = {

	constructor: THREE.BufferGeometry,

	addAttribute: function( name, type, numItems, itemSize ) {

		this.attributes[ name ] = {

			itemSize: itemSize,
			array: new type( numItems * itemSize )

		};

	},

	applyMatrix: function ( matrix ) {

		var positionArray;
		var normalArray;

		if ( this.attributes[ "position" ] ) positionArray = this.attributes[ "position" ].array;
		if ( this.attributes[ "normal" ] ) normalArray = this.attributes[ "normal" ].array;

		if ( positionArray !== undefined ) {

			matrix.multiplyVector3Array( positionArray );
			this.verticesNeedUpdate = true;

		}

		if ( normalArray !== undefined ) {

			var normalMatrix = new THREE.Matrix3().getNormalMatrix( matrix );

			normalMatrix.multiplyVector3Array( normalArray );

			this.normalizeNormals();

			this.normalsNeedUpdate = true;

		}

	},

	computeBoundingBox: function () {

		if ( this.boundingBox === null ) {

			this.boundingBox = new THREE.Box3();

		}

		var positions = this.attributes[ "position" ].array;

		if ( positions ) {

			var bb = this.boundingBox;
			var x, y, z;

			if( positions.length >= 3 ) {
				bb.min.x = bb.max.x = positions[ 0 ];
				bb.min.y = bb.max.y = positions[ 1 ];
				bb.min.z = bb.max.z = positions[ 2 ];
			}

			for ( var i = 3, il = positions.length; i < il; i += 3 ) {

				x = positions[ i ];
				y = positions[ i + 1 ];
				z = positions[ i + 2 ];

				// bounding box

				if ( x < bb.min.x ) {

					bb.min.x = x;

				} else if ( x > bb.max.x ) {

					bb.max.x = x;

				}

				if ( y < bb.min.y ) {

					bb.min.y = y;

				} else if ( y > bb.max.y ) {

					bb.max.y = y;

				}

				if ( z < bb.min.z ) {

					bb.min.z = z;

				} else if ( z > bb.max.z ) {

					bb.max.z = z;

				}

			}

		}

		if ( positions === undefined || positions.length === 0 ) {

			this.boundingBox.min.set( 0, 0, 0 );
			this.boundingBox.max.set( 0, 0, 0 );

		}

	},

	computeBoundingSphere: function () {

		var box = new THREE.Box3();
		var vector = new THREE.Vector3();

		return function () {

			if ( this.boundingSphere === null ) {

				this.boundingSphere = new THREE.Sphere();

			}

			var positions = this.attributes[ "position" ].array;

			if ( positions ) {

				box.makeEmpty();

				var center = this.boundingSphere.center;

				for ( var i = 0, il = positions.length; i < il; i += 3 ) {

					vector.set( positions[ i ], positions[ i + 1 ], positions[ i + 2 ] );
					box.addPoint( vector );

				}

				box.center( center );

				var maxRadiusSq = 0;

				for ( var i = 0, il = positions.length; i < il; i += 3 ) {

					vector.set( positions[ i ], positions[ i + 1 ], positions[ i + 2 ] );
					maxRadiusSq = Math.max( maxRadiusSq, center.distanceToSquared( vector ) );

				}

				this.boundingSphere.radius = Math.sqrt( maxRadiusSq );

			}

		}

	}(),

	computeVertexNormals: function () {

		if ( this.attributes[ "position" ] ) {

			var i, il;
			var j, jl;

			var nVertexElements = this.attributes[ "position" ].array.length;

			if ( this.attributes[ "normal" ] === undefined ) {

				this.attributes[ "normal" ] = {

					itemSize: 3,
					array: new Float32Array( nVertexElements )

				};

			} else {

				// reset existing normals to zero

				for ( i = 0, il = this.attributes[ "normal" ].array.length; i < il; i ++ ) {

					this.attributes[ "normal" ].array[ i ] = 0;

				}

			}

			var positions = this.attributes[ "position" ].array;
			var normals = this.attributes[ "normal" ].array;

			var vA, vB, vC, x, y, z,

			pA = new THREE.Vector3(),
			pB = new THREE.Vector3(),
			pC = new THREE.Vector3(),

			cb = new THREE.Vector3(),
			ab = new THREE.Vector3();

			// indexed elements

			if ( this.attributes[ "index" ] ) {

				var indices = this.attributes[ "index" ].array;

				var offsets = this.offsets;

				for ( j = 0, jl = offsets.length; j < jl; ++ j ) {

					var start = offsets[ j ].start;
					var count = offsets[ j ].count;
					var index = offsets[ j ].index;

					for ( i = start, il = start + count; i < il; i += 3 ) {

						vA = index + indices[ i ];
						vB = index + indices[ i + 1 ];
						vC = index + indices[ i + 2 ];

						x = positions[ vA * 3 ];
						y = positions[ vA * 3 + 1 ];
						z = positions[ vA * 3 + 2 ];
						pA.set( x, y, z );

						x = positions[ vB * 3 ];
						y = positions[ vB * 3 + 1 ];
						z = positions[ vB * 3 + 2 ];
						pB.set( x, y, z );

						x = positions[ vC * 3 ];
						y = positions[ vC * 3 + 1 ];
						z = positions[ vC * 3 + 2 ];
						pC.set( x, y, z );

						cb.subVectors( pC, pB );
						ab.subVectors( pA, pB );
						cb.cross( ab );

						normals[ vA * 3 ]     += cb.x;
						normals[ vA * 3 + 1 ] += cb.y;
						normals[ vA * 3 + 2 ] += cb.z;

						normals[ vB * 3 ]     += cb.x;
						normals[ vB * 3 + 1 ] += cb.y;
						normals[ vB * 3 + 2 ] += cb.z;

						normals[ vC * 3 ]     += cb.x;
						normals[ vC * 3 + 1 ] += cb.y;
						normals[ vC * 3 + 2 ] += cb.z;

					}

				}

			// non-indexed elements (unconnected triangle soup)

			} else {

				for ( i = 0, il = positions.length; i < il; i += 9 ) {

					x = positions[ i ];
					y = positions[ i + 1 ];
					z = positions[ i + 2 ];
					pA.set( x, y, z );

					x = positions[ i + 3 ];
					y = positions[ i + 4 ];
					z = positions[ i + 5 ];
					pB.set( x, y, z );

					x = positions[ i + 6 ];
					y = positions[ i + 7 ];
					z = positions[ i + 8 ];
					pC.set( x, y, z );

					cb.subVectors( pC, pB );
					ab.subVectors( pA, pB );
					cb.cross( ab );

					normals[ i ] 	 = cb.x;
					normals[ i + 1 ] = cb.y;
					normals[ i + 2 ] = cb.z;

					normals[ i + 3 ] = cb.x;
					normals[ i + 4 ] = cb.y;
					normals[ i + 5 ] = cb.z;

					normals[ i + 6 ] = cb.x;
					normals[ i + 7 ] = cb.y;
					normals[ i + 8 ] = cb.z;

				}

			}

			this.normalizeNormals();

			this.normalsNeedUpdate = true;

		}

	},

	normalizeNormals: function () {

		var normals = this.attributes[ "normal" ].array;

		var x, y, z, n;

		for ( var i = 0, il = normals.length; i < il; i += 3 ) {

			x = normals[ i ];
			y = normals[ i + 1 ];
			z = normals[ i + 2 ];

			n = 1.0 / Math.sqrt( x * x + y * y + z * z );

			normals[ i ] 	 *= n;
			normals[ i + 1 ] *= n;
			normals[ i + 2 ] *= n;

		}

	},

	computeTangents: function () {

		// based on http://www.terathon.com/code/tangent.html
		// (per vertex tangents)

		if ( this.attributes[ "index" ] === undefined ||
			 this.attributes[ "position" ] === undefined ||
			 this.attributes[ "normal" ] === undefined ||
			 this.attributes[ "uv" ] === undefined ) {

			console.warn( "Missing required attributes (index, position, normal or uv) in BufferGeometry.computeTangents()" );
			return;

		}

		var indices = this.attributes[ "index" ].array;
		var positions = this.attributes[ "position" ].array;
		var normals = this.attributes[ "normal" ].array;
		var uvs = this.attributes[ "uv" ].array;

		var nVertices = positions.length / 3;

		if ( this.attributes[ "tangent" ] === undefined ) {

			var nTangentElements = 4 * nVertices;

			this.attributes[ "tangent" ] = {

				itemSize: 4,
				array: new Float32Array( nTangentElements )

			};

		}

		var tangents = this.attributes[ "tangent" ].array;

		var tan1 = [], tan2 = [];

		for ( var k = 0; k < nVertices; k ++ ) {

			tan1[ k ] = new THREE.Vector3();
			tan2[ k ] = new THREE.Vector3();

		}

		var xA, yA, zA,
			xB, yB, zB,
			xC, yC, zC,

			uA, vA,
			uB, vB,
			uC, vC,

			x1, x2, y1, y2, z1, z2,
			s1, s2, t1, t2, r;

		var sdir = new THREE.Vector3(), tdir = new THREE.Vector3();

		function handleTriangle( a, b, c ) {

			xA = positions[ a * 3 ];
			yA = positions[ a * 3 + 1 ];
			zA = positions[ a * 3 + 2 ];

			xB = positions[ b * 3 ];
			yB = positions[ b * 3 + 1 ];
			zB = positions[ b * 3 + 2 ];

			xC = positions[ c * 3 ];
			yC = positions[ c * 3 + 1 ];
			zC = positions[ c * 3 + 2 ];

			uA = uvs[ a * 2 ];
			vA = uvs[ a * 2 + 1 ];

			uB = uvs[ b * 2 ];
			vB = uvs[ b * 2 + 1 ];

			uC = uvs[ c * 2 ];
			vC = uvs[ c * 2 + 1 ];

			x1 = xB - xA;
			x2 = xC - xA;

			y1 = yB - yA;
			y2 = yC - yA;

			z1 = zB - zA;
			z2 = zC - zA;

			s1 = uB - uA;
			s2 = uC - uA;

			t1 = vB - vA;
			t2 = vC - vA;

			r = 1.0 / ( s1 * t2 - s2 * t1 );

			sdir.set(
				( t2 * x1 - t1 * x2 ) * r,
				( t2 * y1 - t1 * y2 ) * r,
				( t2 * z1 - t1 * z2 ) * r
			);

			tdir.set(
				( s1 * x2 - s2 * x1 ) * r,
				( s1 * y2 - s2 * y1 ) * r,
				( s1 * z2 - s2 * z1 ) * r
			);

			tan1[ a ].add( sdir );
			tan1[ b ].add( sdir );
			tan1[ c ].add( sdir );

			tan2[ a ].add( tdir );
			tan2[ b ].add( tdir );
			tan2[ c ].add( tdir );

		}

		var i, il;
		var j, jl;
		var iA, iB, iC;

		var offsets = this.offsets;

		for ( j = 0, jl = offsets.length; j < jl; ++ j ) {

			var start = offsets[ j ].start;
			var count = offsets[ j ].count;
			var index = offsets[ j ].index;

			for ( i = start, il = start + count; i < il; i += 3 ) {

				iA = index + indices[ i ];
				iB = index + indices[ i + 1 ];
				iC = index + indices[ i + 2 ];

				handleTriangle( iA, iB, iC );

			}

		}

		var tmp = new THREE.Vector3(), tmp2 = new THREE.Vector3();
		var n = new THREE.Vector3(), n2 = new THREE.Vector3();
		var w, t, test;

		function handleVertex( v ) {

			n.x = normals[ v * 3 ];
			n.y = normals[ v * 3 + 1 ];
			n.z = normals[ v * 3 + 2 ];

			n2.copy( n );

			t = tan1[ v ];

			// Gram-Schmidt orthogonalize

			tmp.copy( t );
			tmp.sub( n.multiplyScalar( n.dot( t ) ) ).normalize();

			// Calculate handedness

			tmp2.crossVectors( n2, t );
			test = tmp2.dot( tan2[ v ] );
			w = ( test < 0.0 ) ? -1.0 : 1.0;

			tangents[ v * 4 ]     = tmp.x;
			tangents[ v * 4 + 1 ] = tmp.y;
			tangents[ v * 4 + 2 ] = tmp.z;
			tangents[ v * 4 + 3 ] = w;

		}

		for ( j = 0, jl = offsets.length; j < jl; ++ j ) {

			var start = offsets[ j ].start;
			var count = offsets[ j ].count;
			var index = offsets[ j ].index;

			for ( i = start, il = start + count; i < il; i += 3 ) {

				iA = index + indices[ i ];
				iB = index + indices[ i + 1 ];
				iC = index + indices[ i + 2 ];

				handleVertex( iA );
				handleVertex( iB );
				handleVertex( iC );

			}

		}

		this.hasTangents = true;
		this.tangentsNeedUpdate = true;

	},

	clone: function () {

		var geometry = new THREE.BufferGeometry();

		var types = [ Int8Array, Uint8Array, Uint8ClampedArray, Int16Array, Uint16Array, Int32Array, Uint32Array, Float32Array, Float64Array ];

		for ( var attr in this.attributes ) {

			var sourceAttr = this.attributes[ attr ];
			var sourceArray = sourceAttr.array;

			var attribute = {

				itemSize: sourceAttr.itemSize,
				numItems: sourceAttr.numItems,
				array: null

			};

			for ( var i = 0, il = types.length; i < il; i ++ ) {

				var type = types[ i ];

				if ( sourceArray instanceof type ) {

					attribute.array = new type( sourceArray );
					break;

				}

			}

			geometry.attributes[ attr ] = attribute;

		}

		for ( var i = 0, il = this.offsets.length; i < il; i ++ ) {

			var offset = this.offsets[ i ];

			geometry.offsets.push( {

				start: offset.start,
				index: offset.index,
				count: offset.count

			} );

		}

		return geometry;

	},

	dispose: function () {

		this.dispatchEvent( { type: 'dispose' } );

	}

};

THREE.EventDispatcher.prototype.apply( THREE.BufferGeometry.prototype );

/**
 * @author mrdoob / http://mrdoob.com/
 * @author mikael emtinger / http://gomo.se/
 * @author WestLangley / http://github.com/WestLangley
*/

THREE.Camera = function () {

	THREE.Object3D.call( this );

	this.matrixWorldInverse = new THREE.Matrix4();
	this.projectionMatrix = new THREE.Matrix4();

};

THREE.Camera.prototype = Object.create( THREE.Object3D.prototype );

THREE.Camera.prototype.lookAt = function () {

	// This routine does not support cameras with rotated and/or translated parent(s)

	var m1 = new THREE.Matrix4();

	return function ( vector ) {

		m1.lookAt( this.position, vector, this.up );

		this.quaternion.setFromRotationMatrix( m1 );

	};

}();

THREE.Camera.prototype.clone = function (camera) {

	if ( camera === undefined ) camera = new THREE.Camera();

	THREE.Object3D.prototype.clone.call( this, camera );

	camera.matrixWorldInverse.copy( this.matrixWorldInverse );
	camera.projectionMatrix.copy( this.projectionMatrix );

	return camera;
};

/**
 * @author alteredq / http://alteredqualia.com/
 */

THREE.OrthographicCamera = function ( left, right, top, bottom, near, far ) {

	THREE.Camera.call( this );

	this.left = left;
	this.right = right;
	this.top = top;
	this.bottom = bottom;

	this.near = ( near !== undefined ) ? near : 0.1;
	this.far = ( far !== undefined ) ? far : 2000;

	this.updateProjectionMatrix();

};

THREE.OrthographicCamera.prototype = Object.create( THREE.Camera.prototype );

THREE.OrthographicCamera.prototype.updateProjectionMatrix = function () {

	this.projectionMatrix.makeOrthographic( this.left, this.right, this.top, this.bottom, this.near, this.far );

};

THREE.OrthographicCamera.prototype.clone = function () {

	var camera = new THREE.OrthographicCamera();

	THREE.Camera.prototype.clone.call( this, camera );

	camera.left = this.left;
	camera.right = this.right;
	camera.top = this.top;
	camera.bottom = this.bottom;

	camera.near = this.near;
	camera.far = this.far;

	return camera;
};

/**
 * @author mrdoob / http://mrdoob.com/
 * @author greggman / http://games.greggman.com/
 * @author zz85 / http://www.lab4games.net/zz85/blog
 */

THREE.PerspectiveCamera = function ( fov, aspect, near, far ) {

	THREE.Camera.call( this );

	this.fov = fov !== undefined ? fov : 50;
	this.aspect = aspect !== undefined ? aspect : 1;
	this.near = near !== undefined ? near : 0.1;
	this.far = far !== undefined ? far : 2000;

	this.updateProjectionMatrix();

};

THREE.PerspectiveCamera.prototype = Object.create( THREE.Camera.prototype );


/**
 * Uses Focal Length (in mm) to estimate and set FOV
 * 35mm (fullframe) camera is used if frame size is not specified;
 * Formula based on http://www.bobatkins.com/photography/technical/field_of_view.html
 */

THREE.PerspectiveCamera.prototype.setLens = function ( focalLength, frameHeight ) {

	if ( frameHeight === undefined ) frameHeight = 24;

	this.fov = 2 * THREE.Math.radToDeg( Math.atan( frameHeight / ( focalLength * 2 ) ) );
	this.updateProjectionMatrix();

}


/**
 * Sets an offset in a larger frustum. This is useful for multi-window or
 * multi-monitor/multi-machine setups.
 *
 * For example, if you have 3x2 monitors and each monitor is 1920x1080 and
 * the monitors are in grid like this
 *
 *   +---+---+---+
 *   | A | B | C |
 *   +---+---+---+
 *   | D | E | F |
 *   +---+---+---+
 *
 * then for each monitor you would call it like this
 *
 *   var w = 1920;
 *   var h = 1080;
 *   var fullWidth = w * 3;
 *   var fullHeight = h * 2;
 *
 *   --A--
 *   camera.setOffset( fullWidth, fullHeight, w * 0, h * 0, w, h );
 *   --B--
 *   camera.setOffset( fullWidth, fullHeight, w * 1, h * 0, w, h );
 *   --C--
 *   camera.setOffset( fullWidth, fullHeight, w * 2, h * 0, w, h );
 *   --D--
 *   camera.setOffset( fullWidth, fullHeight, w * 0, h * 1, w, h );
 *   --E--
 *   camera.setOffset( fullWidth, fullHeight, w * 1, h * 1, w, h );
 *   --F--
 *   camera.setOffset( fullWidth, fullHeight, w * 2, h * 1, w, h );
 *
 *   Note there is no reason monitors have to be the same size or in a grid.
 */

THREE.PerspectiveCamera.prototype.setViewOffset = function ( fullWidth, fullHeight, x, y, width, height ) {

	this.fullWidth = fullWidth;
	this.fullHeight = fullHeight;
	this.x = x;
	this.y = y;
	this.width = width;
	this.height = height;

	this.updateProjectionMatrix();

};


THREE.PerspectiveCamera.prototype.updateProjectionMatrix = function () {

	if ( this.fullWidth ) {

		var aspect = this.fullWidth / this.fullHeight;
		var top = Math.tan( THREE.Math.degToRad( this.fov * 0.5 ) ) * this.near;
		var bottom = -top;
		var left = aspect * bottom;
		var right = aspect * top;
		var width = Math.abs( right - left );
		var height = Math.abs( top - bottom );

		this.projectionMatrix.makeFrustum(
			left + this.x * width / this.fullWidth,
			left + ( this.x + this.width ) * width / this.fullWidth,
			top - ( this.y + this.height ) * height / this.fullHeight,
			top - this.y * height / this.fullHeight,
			this.near,
			this.far
		);

	} else {

		this.projectionMatrix.makePerspective( this.fov, this.aspect, this.near, this.far );

	}

};

THREE.PerspectiveCamera.prototype.clone = function () {

	var camera = new THREE.PerspectiveCamera();

	THREE.Camera.prototype.clone.call( this, camera );

	camera.fov = this.fov;
	camera.aspect = this.aspect;
	camera.near = this.near;
	camera.far = this.far;

	return camera;
};

/**
 * @author mrdoob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 */

THREE.Light = function ( hex ) {

	THREE.Object3D.call( this );

	this.color = new THREE.Color( hex );

};

THREE.Light.prototype = Object.create( THREE.Object3D.prototype );

THREE.Light.prototype.clone = function ( light ) {

	if ( light === undefined ) light = new THREE.Light();

	THREE.Object3D.prototype.clone.call( this, light );

	light.color.copy( this.color );

	return light;

};

/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.AmbientLight = function ( hex ) {

	THREE.Light.call( this, hex );

};

THREE.AmbientLight.prototype = Object.create( THREE.Light.prototype );

THREE.AmbientLight.prototype.clone = function () {

	var light = new THREE.AmbientLight();

	THREE.Light.prototype.clone.call( this, light );

	return light;

};

/**
 * @author MPanknin / http://www.redplant.de/
 * @author alteredq / http://alteredqualia.com/
 */

THREE.AreaLight = function ( hex, intensity ) {

	THREE.Light.call( this, hex );

	this.normal = new THREE.Vector3( 0, -1, 0 );
	this.right = new THREE.Vector3( 1, 0, 0 );

	this.intensity = ( intensity !== undefined ) ? intensity : 1;

	this.width = 1.0;
	this.height = 1.0;

	this.constantAttenuation = 1.5;
	this.linearAttenuation = 0.5;
	this.quadraticAttenuation = 0.1;

};

THREE.AreaLight.prototype = Object.create( THREE.Light.prototype );


/**
 * @author mrdoob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 */

THREE.DirectionalLight = function ( hex, intensity ) {

	THREE.Light.call( this, hex );

	this.position.set( 0, 1, 0 );
	this.target = new THREE.Object3D();

	this.intensity = ( intensity !== undefined ) ? intensity : 1;

	this.castShadow = false;
	this.onlyShadow = false;

	//

	this.shadowCameraNear = 50;
	this.shadowCameraFar = 5000;

	this.shadowCameraLeft = -500;
	this.shadowCameraRight = 500;
	this.shadowCameraTop = 500;
	this.shadowCameraBottom = -500;

	this.shadowCameraVisible = false;

	this.shadowBias = 0;
	this.shadowDarkness = 0.5;

	this.shadowMapWidth = 512;
	this.shadowMapHeight = 512;

	//

	this.shadowCascade = false;

	this.shadowCascadeOffset = new THREE.Vector3( 0, 0, -1000 );
	this.shadowCascadeCount = 2;

	this.shadowCascadeBias = [ 0, 0, 0 ];
	this.shadowCascadeWidth = [ 512, 512, 512 ];
	this.shadowCascadeHeight = [ 512, 512, 512 ];

	this.shadowCascadeNearZ = [ -1.000, 0.990, 0.998 ];
	this.shadowCascadeFarZ  = [  0.990, 0.998, 1.000 ];

	this.shadowCascadeArray = [];

	//

	this.shadowMap = null;
	this.shadowMapSize = null;
	this.shadowCamera = null;
	this.shadowMatrix = null;

};

THREE.DirectionalLight.prototype = Object.create( THREE.Light.prototype );

THREE.DirectionalLight.prototype.clone = function () {

	var light = new THREE.DirectionalLight();

	THREE.Light.prototype.clone.call( this, light );

	light.target = this.target.clone();

	light.intensity = this.intensity;

	light.castShadow = this.castShadow;
	light.onlyShadow = this.onlyShadow;

	return light;

};

/**
 * @author alteredq / http://alteredqualia.com/
 */

THREE.HemisphereLight = function ( skyColorHex, groundColorHex, intensity ) {

	THREE.Light.call( this, skyColorHex );

	this.position.set( 0, 100, 0 );

	this.groundColor = new THREE.Color( groundColorHex );
	this.intensity = ( intensity !== undefined ) ? intensity : 1;

};

THREE.HemisphereLight.prototype = Object.create( THREE.Light.prototype );

THREE.HemisphereLight.prototype.clone = function () {

	var light = new THREE.HemisphereLight();

	THREE.Light.prototype.clone.call( this, light );

	light.groundColor.copy( this.groundColor );
	light.intensity = this.intensity;

	return light;

};

/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.PointLight = function ( hex, intensity, distance ) {

	THREE.Light.call( this, hex );

	this.intensity = ( intensity !== undefined ) ? intensity : 1;
	this.distance = ( distance !== undefined ) ? distance : 0;

};

THREE.PointLight.prototype = Object.create( THREE.Light.prototype );

THREE.PointLight.prototype.clone = function () {

	var light = new THREE.PointLight();

	THREE.Light.prototype.clone.call( this, light );

	light.intensity = this.intensity;
	light.distance = this.distance;

	return light;

};

/**
 * @author alteredq / http://alteredqualia.com/
 */

THREE.SpotLight = function ( hex, intensity, distance, angle, exponent ) {

	THREE.Light.call( this, hex );

	this.position.set( 0, 1, 0 );
	this.target = new THREE.Object3D();

	this.intensity = ( intensity !== undefined ) ? intensity : 1;
	this.distance = ( distance !== undefined ) ? distance : 0;
	this.angle = ( angle !== undefined ) ? angle : Math.PI / 3;
	this.exponent = ( exponent !== undefined ) ? exponent : 10;

	this.castShadow = false;
	this.onlyShadow = false;

	//

	this.shadowCameraNear = 50;
	this.shadowCameraFar = 5000;
	this.shadowCameraFov = 50;

	this.shadowCameraVisible = false;

	this.shadowBias = 0;
	this.shadowDarkness = 0.5;

	this.shadowMapWidth = 512;
	this.shadowMapHeight = 512;

	//

	this.shadowMap = null;
	this.shadowMapSize = null;
	this.shadowCamera = null;
	this.shadowMatrix = null;

};

THREE.SpotLight.prototype = Object.create( THREE.Light.prototype );

THREE.SpotLight.prototype.clone = function () {

	var light = new THREE.SpotLight();

	THREE.Light.prototype.clone.call( this, light );

	light.target = this.target.clone();

	light.intensity = this.intensity;
	light.distance = this.distance;
	light.angle = this.angle;
	light.exponent = this.exponent;

	light.castShadow = this.castShadow;
	light.onlyShadow = this.onlyShadow;

	return light;

};

/**
 * @author alteredq / http://alteredqualia.com/
 */

THREE.Loader = function ( showStatus ) {

	this.showStatus = showStatus;
	this.statusDomElement = showStatus ? THREE.Loader.prototype.addStatusElement() : null;

	this.onLoadStart = function () {};
	this.onLoadProgress = function () {};
	this.onLoadComplete = function () {};

};

THREE.Loader.prototype = {

	constructor: THREE.Loader,

	crossOrigin: undefined,

	addStatusElement: function () {

		var e = document.createElement( "div" );

		e.style.position = "absolute";
		e.style.right = "0px";
		e.style.top = "0px";
		e.style.fontSize = "0.8em";
		e.style.textAlign = "left";
		e.style.background = "rgba(0,0,0,0.25)";
		e.style.color = "#fff";
		e.style.width = "120px";
		e.style.padding = "0.5em 0.5em 0.5em 0.5em";
		e.style.zIndex = 1000;

		e.innerHTML = "Loading ...";

		return e;

	},

	updateProgress: function ( progress ) {

		var message = "Loaded ";

		if ( progress.total ) {

			message += ( 100 * progress.loaded / progress.total ).toFixed(0) + "%";


		} else {

			message += ( progress.loaded / 1000 ).toFixed(2) + " KB";

		}

		this.statusDomElement.innerHTML = message;

	},

	extractUrlBase: function ( url ) {

		var parts = url.split( '/' );
		parts.pop();
		return ( parts.length < 1 ? '.' : parts.join( '/' ) ) + '/';

	},

	initMaterials: function ( materials, texturePath ) {

		var array = [];

		for ( var i = 0; i < materials.length; ++ i ) {

			array[ i ] = THREE.Loader.prototype.createMaterial( materials[ i ], texturePath );

		}

		return array;

	},

	needsTangents: function ( materials ) {

		for( var i = 0, il = materials.length; i < il; i ++ ) {

			var m = materials[ i ];

			if ( m instanceof THREE.ShaderMaterial ) return true;

		}

		return false;

	},

	createMaterial: function ( m, texturePath ) {

		var _this = this;

		function is_pow2( n ) {

			var l = Math.log( n ) / Math.LN2;
			return Math.floor( l ) == l;

		}

		function nearest_pow2( n ) {

			var l = Math.log( n ) / Math.LN2;
			return Math.pow( 2, Math.round(  l ) );

		}

		function load_image( where, url ) {

			var image = new Image();

			image.onload = function () {

				if ( !is_pow2( this.width ) || !is_pow2( this.height ) ) {

					var width = nearest_pow2( this.width );
					var height = nearest_pow2( this.height );

					where.image.width = width;
					where.image.height = height;
					where.image.getContext( '2d' ).drawImage( this, 0, 0, width, height );

				} else {

					where.image = this;

				}

				where.needsUpdate = true;

			};

			if ( _this.crossOrigin !== undefined ) image.crossOrigin = _this.crossOrigin;
			image.src = url;

		}

		function create_texture( where, name, sourceFile, repeat, offset, wrap, anisotropy ) {

			var isCompressed = /\.dds$/i.test( sourceFile );
			var fullPath = texturePath + "/" + sourceFile;

			if ( isCompressed ) {

				var texture = THREE.ImageUtils.loadCompressedTexture( fullPath );

				where[ name ] = texture;

			} else {

				var texture = document.createElement( 'canvas' );

				where[ name ] = new THREE.Texture( texture );

			}

			where[ name ].sourceFile = sourceFile;

			if( repeat ) {

				where[ name ].repeat.set( repeat[ 0 ], repeat[ 1 ] );

				if ( repeat[ 0 ] !== 1 ) where[ name ].wrapS = THREE.RepeatWrapping;
				if ( repeat[ 1 ] !== 1 ) where[ name ].wrapT = THREE.RepeatWrapping;

			}

			if ( offset ) {

				where[ name ].offset.set( offset[ 0 ], offset[ 1 ] );

			}

			if ( wrap ) {

				var wrapMap = {
					"repeat": THREE.RepeatWrapping,
					"mirror": THREE.MirroredRepeatWrapping
				}

				if ( wrapMap[ wrap[ 0 ] ] !== undefined ) where[ name ].wrapS = wrapMap[ wrap[ 0 ] ];
				if ( wrapMap[ wrap[ 1 ] ] !== undefined ) where[ name ].wrapT = wrapMap[ wrap[ 1 ] ];

			}

			if ( anisotropy ) {

				where[ name ].anisotropy = anisotropy;

			}

			if ( ! isCompressed ) {

				load_image( where[ name ], fullPath );

			}

		}

		function rgb2hex( rgb ) {

			return ( rgb[ 0 ] * 255 << 16 ) + ( rgb[ 1 ] * 255 << 8 ) + rgb[ 2 ] * 255;

		}

		// defaults

		var mtype = "MeshLambertMaterial";
		var mpars = { color: 0xeeeeee, opacity: 1.0, map: null, lightMap: null, normalMap: null, bumpMap: null, wireframe: false };

		// parameters from model file

		if ( m.shading ) {

			var shading = m.shading.toLowerCase();

			if ( shading === "phong" ) mtype = "MeshPhongMaterial";
			else if ( shading === "basic" ) mtype = "MeshBasicMaterial";

		}

		if ( m.blending !== undefined && THREE[ m.blending ] !== undefined ) {

			mpars.blending = THREE[ m.blending ];

		}

		if ( m.transparent !== undefined || m.opacity < 1.0 ) {

			mpars.transparent = m.transparent;

		}

		if ( m.depthTest !== undefined ) {

			mpars.depthTest = m.depthTest;

		}

		if ( m.depthWrite !== undefined ) {

			mpars.depthWrite = m.depthWrite;

		}

		if ( m.visible !== undefined ) {

			mpars.visible = m.visible;

		}

		if ( m.flipSided !== undefined ) {

			mpars.side = THREE.BackSide;

		}

		if ( m.doubleSided !== undefined ) {

			mpars.side = THREE.DoubleSide;

		}

		if ( m.wireframe !== undefined ) {

			mpars.wireframe = m.wireframe;

		}

		if ( m.vertexColors !== undefined ) {

			if ( m.vertexColors === "face" ) {

				mpars.vertexColors = THREE.FaceColors;

			} else if ( m.vertexColors ) {

				mpars.vertexColors = THREE.VertexColors;

			}

		}

		// colors

		if ( m.colorDiffuse ) {

			mpars.color = rgb2hex( m.colorDiffuse );

		} else if ( m.DbgColor ) {

			mpars.color = m.DbgColor;

		}

		if ( m.colorSpecular ) {

			mpars.specular = rgb2hex( m.colorSpecular );

		}

		if ( m.colorAmbient ) {

			mpars.ambient = rgb2hex( m.colorAmbient );

		}

		// modifiers

		if ( m.transparency ) {

			mpars.opacity = m.transparency;

		}

		if ( m.specularCoef ) {

			mpars.shininess = m.specularCoef;

		}

		// textures

		if ( m.mapDiffuse && texturePath ) {

			create_texture( mpars, "map", m.mapDiffuse, m.mapDiffuseRepeat, m.mapDiffuseOffset, m.mapDiffuseWrap, m.mapDiffuseAnisotropy );

		}

		if ( m.mapLight && texturePath ) {

			create_texture( mpars, "lightMap", m.mapLight, m.mapLightRepeat, m.mapLightOffset, m.mapLightWrap, m.mapLightAnisotropy );

		}

		if ( m.mapBump && texturePath ) {

			create_texture( mpars, "bumpMap", m.mapBump, m.mapBumpRepeat, m.mapBumpOffset, m.mapBumpWrap, m.mapBumpAnisotropy );

		}

		if ( m.mapNormal && texturePath ) {

			create_texture( mpars, "normalMap", m.mapNormal, m.mapNormalRepeat, m.mapNormalOffset, m.mapNormalWrap, m.mapNormalAnisotropy );

		}

		if ( m.mapSpecular && texturePath ) {

			create_texture( mpars, "specularMap", m.mapSpecular, m.mapSpecularRepeat, m.mapSpecularOffset, m.mapSpecularWrap, m.mapSpecularAnisotropy );

		}

		//

		if ( m.mapBumpScale ) {

			mpars.bumpScale = m.mapBumpScale;

		}

		// special case for normal mapped material

		if ( m.mapNormal ) {

			var shader = THREE.ShaderLib[ "normalmap" ];
			var uniforms = THREE.UniformsUtils.clone( shader.uniforms );

			uniforms[ "tNormal" ].value = mpars.normalMap;

			if ( m.mapNormalFactor ) {

				uniforms[ "uNormalScale" ].value.set( m.mapNormalFactor, m.mapNormalFactor );

			}

			if ( mpars.map ) {

				uniforms[ "tDiffuse" ].value = mpars.map;
				uniforms[ "enableDiffuse" ].value = true;

			}

			if ( mpars.specularMap ) {

				uniforms[ "tSpecular" ].value = mpars.specularMap;
				uniforms[ "enableSpecular" ].value = true;

			}

			if ( mpars.lightMap ) {

				uniforms[ "tAO" ].value = mpars.lightMap;
				uniforms[ "enableAO" ].value = true;

			}

			// for the moment don't handle displacement texture

			uniforms[ "diffuse" ].value.setHex( mpars.color );
			uniforms[ "specular" ].value.setHex( mpars.specular );
			uniforms[ "ambient" ].value.setHex( mpars.ambient );

			uniforms[ "shininess" ].value = mpars.shininess;

			if ( mpars.opacity !== undefined ) {

				uniforms[ "opacity" ].value = mpars.opacity;

			}

			var parameters = { fragmentShader: shader.fragmentShader, vertexShader: shader.vertexShader, uniforms: uniforms, lights: true, fog: true };
			var material = new THREE.ShaderMaterial( parameters );

			if ( mpars.transparent ) {

				material.transparent = true;

			}

		} else {

			var material = new THREE[ mtype ]( mpars );

		}

		if ( m.DbgName !== undefined ) material.name = m.DbgName;

		return material;

	}

};

/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.XHRLoader = function ( manager ) {

	this.manager = ( manager !== undefined ) ? manager : THREE.DefaultLoadingManager;

};

THREE.XHRLoader.prototype = {

	constructor: THREE.XHRLoader,

	load: function ( url, onLoad, onProgress, onError ) {

		var scope = this;
		var request = new XMLHttpRequest();

		if ( onLoad !== undefined ) {

			request.addEventListener( 'load', function ( event ) {

				onLoad( event.target.responseText );
				scope.manager.itemEnd( url );

			}, false );

		}

		if ( onProgress !== undefined ) {

			request.addEventListener( 'progress', function ( event ) {

				onProgress( event );

			}, false );

		}

		if ( onError !== undefined ) {

			request.addEventListener( 'error', function ( event ) {

				onError( event );

			}, false );

		}

		if ( this.crossOrigin !== undefined ) request.crossOrigin = this.crossOrigin;

		request.open( 'GET', url, true );
		request.send( null );

		scope.manager.itemStart( url );

	},

	setCrossOrigin: function ( value ) {

		this.crossOrigin = value;

	}

};

/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.ImageLoader = function ( manager ) {

	this.manager = ( manager !== undefined ) ? manager : THREE.DefaultLoadingManager;

};

THREE.ImageLoader.prototype = {

	constructor: THREE.ImageLoader,

	load: function ( url, onLoad, onProgress, onError ) {

		var scope = this;
		var image = document.createElement( 'img' );

		if ( onLoad !== undefined ) {

			image.addEventListener( 'load', function ( event ) {

				scope.manager.itemEnd( url );
				onLoad( this );

			}, false );

		}

		if ( onProgress !== undefined ) {

			image.addEventListener( 'progress', function ( event ) {

				onProgress( event );

			}, false );

		}

		if ( onError !== undefined ) {

			image.addEventListener( 'error', function ( event ) {

				onError( event );

			}, false );

		}

		if ( this.crossOrigin !== undefined ) image.crossOrigin = this.crossOrigin;

		image.src = url;

		scope.manager.itemStart( url );

		return image;

	},

	setCrossOrigin: function ( value ) {

		this.crossOrigin = value;

	}

}

/**
 * @author mrdoob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 */

THREE.JSONLoader = function ( showStatus ) {

	THREE.Loader.call( this, showStatus );

	this.withCredentials = false;

};

THREE.JSONLoader.prototype = Object.create( THREE.Loader.prototype );

THREE.JSONLoader.prototype.load = function ( url, callback, texturePath ) {

	var scope = this;

	// todo: unify load API to for easier SceneLoader use

	texturePath = texturePath && ( typeof texturePath === "string" ) ? texturePath : this.extractUrlBase( url );

	this.onLoadStart();
	this.loadAjaxJSON( this, url, callback, texturePath );

};

THREE.JSONLoader.prototype.loadAjaxJSON = function ( context, url, callback, texturePath, callbackProgress ) {

	var xhr = new XMLHttpRequest();

	var length = 0;

	xhr.onreadystatechange = function () {

		if ( xhr.readyState === xhr.DONE ) {

			if ( xhr.status === 200 || xhr.status === 0 ) {

				if ( xhr.responseText ) {

					var json = JSON.parse( xhr.responseText );
					var result = context.parse( json, texturePath );
					callback( result.geometry, result.materials );

				} else {

					console.warn( "THREE.JSONLoader: [" + url + "] seems to be unreachable or file there is empty" );

				}

				// in context of more complex asset initialization
				// do not block on single failed file
				// maybe should go even one more level up

				context.onLoadComplete();

			} else {

				console.error( "THREE.JSONLoader: Couldn't load [" + url + "] [" + xhr.status + "]" );

			}

		} else if ( xhr.readyState === xhr.LOADING ) {

			if ( callbackProgress ) {

				if ( length === 0 ) {

					length = xhr.getResponseHeader( "Content-Length" );

				}

				callbackProgress( { total: length, loaded: xhr.responseText.length } );

			}

		} else if ( xhr.readyState === xhr.HEADERS_RECEIVED ) {

			if ( callbackProgress !== undefined ) {

				length = xhr.getResponseHeader( "Content-Length" );

			}

		}

	};

	xhr.open( "GET", url, true );
	xhr.withCredentials = this.withCredentials;
	xhr.send( null );

};

THREE.JSONLoader.prototype.parse = function ( json, texturePath ) {

	var scope = this,
	geometry = new THREE.Geometry(),
	scale = ( json.scale !== undefined ) ? 1.0 / json.scale : 1.0;

	parseModel( scale );

	parseSkin();
	parseMorphing( scale );

	geometry.computeCentroids();
	geometry.computeFaceNormals();
	geometry.computeBoundingSphere();

	function parseModel( scale ) {

		function isBitSet( value, position ) {

			return value & ( 1 << position );

		}

		var i, j, fi,

		offset, zLength,

		colorIndex, normalIndex, uvIndex, materialIndex,

		type,
		isQuad,
		hasMaterial,
		hasFaceVertexUv,
		hasFaceNormal, hasFaceVertexNormal,
		hasFaceColor, hasFaceVertexColor,

		vertex, face, faceA, faceB, color, hex, normal,

		uvLayer, uv, u, v,

		faces = json.faces,
		vertices = json.vertices,
		normals = json.normals,
		colors = json.colors,

		nUvLayers = 0;

		if ( json.uvs !== undefined ) {

			// disregard empty arrays

			for ( i = 0; i < json.uvs.length; i++ ) {

				if ( json.uvs[ i ].length ) nUvLayers ++;

			}

			for ( i = 0; i < nUvLayers; i++ ) {

				geometry.faceVertexUvs[ i ] = [];

			}

		}

		offset = 0;
		zLength = vertices.length;

		while ( offset < zLength ) {

			vertex = new THREE.Vector3();

			vertex.x = vertices[ offset ++ ] * scale;
			vertex.y = vertices[ offset ++ ] * scale;
			vertex.z = vertices[ offset ++ ] * scale;

			geometry.vertices.push( vertex );

		}

		offset = 0;
		zLength = faces.length;

		while ( offset < zLength ) {

			type = faces[ offset ++ ];


			isQuad              = isBitSet( type, 0 );
			hasMaterial         = isBitSet( type, 1 );
			hasFaceVertexUv     = isBitSet( type, 3 );
			hasFaceNormal       = isBitSet( type, 4 );
			hasFaceVertexNormal = isBitSet( type, 5 );
			hasFaceColor	    = isBitSet( type, 6 );
			hasFaceVertexColor  = isBitSet( type, 7 );

			// console.log("type", type, "bits", isQuad, hasMaterial, hasFaceVertexUv, hasFaceNormal, hasFaceVertexNormal, hasFaceColor, hasFaceVertexColor);

			if ( isQuad ) {

				faceA = new THREE.Face3();
				faceA.a = faces[ offset ];
				faceA.b = faces[ offset + 1 ];
				faceA.c = faces[ offset + 3 ];

				faceB = new THREE.Face3();
				faceB.a = faces[ offset + 1 ];
				faceB.b = faces[ offset + 2 ];
				faceB.c = faces[ offset + 3 ];

				offset += 4;

				if ( hasMaterial ) {

					materialIndex = faces[ offset ++ ];
					faceA.materialIndex = materialIndex;
					faceB.materialIndex = materialIndex;

				}

				// to get face <=> uv index correspondence

				fi = geometry.faces.length;

				if ( hasFaceVertexUv ) {

					for ( i = 0; i < nUvLayers; i++ ) {

						uvLayer = json.uvs[ i ];

						geometry.faceVertexUvs[ i ][ fi ] = [];
						geometry.faceVertexUvs[ i ][ fi + 1 ] = []

						for ( j = 0; j < 4; j ++ ) {

							uvIndex = faces[ offset ++ ];

							u = uvLayer[ uvIndex * 2 ];
							v = uvLayer[ uvIndex * 2 + 1 ];

							uv = new THREE.Vector2( u, v );

							if ( j !== 2 ) geometry.faceVertexUvs[ i ][ fi ].push( uv );
							if ( j !== 0 ) geometry.faceVertexUvs[ i ][ fi + 1 ].push( uv );

						}

					}

				}

				if ( hasFaceNormal ) {

					normalIndex = faces[ offset ++ ] * 3;

					faceA.normal.set(
						normals[ normalIndex ++ ],
						normals[ normalIndex ++ ],
						normals[ normalIndex ]
					);

					faceB.normal.copy( faceA.normal );

				}

				if ( hasFaceVertexNormal ) {

					for ( i = 0; i < 4; i++ ) {

						normalIndex = faces[ offset ++ ] * 3;

						normal = new THREE.Vector3(
							normals[ normalIndex ++ ],
							normals[ normalIndex ++ ],
							normals[ normalIndex ]
						);


						if ( i !== 2 ) faceA.vertexNormals.push( normal );
						if ( i !== 0 ) faceB.vertexNormals.push( normal );

					}

				}


				if ( hasFaceColor ) {

					colorIndex = faces[ offset ++ ];
					hex = colors[ colorIndex ];

					faceA.color.setHex( hex );
					faceB.color.setHex( hex );

				}


				if ( hasFaceVertexColor ) {

					for ( i = 0; i < 4; i++ ) {

						colorIndex = faces[ offset ++ ];
						hex = colors[ colorIndex ];

						if ( i !== 2 ) faceA.vertexColors.push( new THREE.Color( hex ) );
						if ( i !== 0 ) faceB.vertexColors.push( new THREE.Color( hex ) );

					}

				}

				geometry.faces.push( faceA );
				geometry.faces.push( faceB );

			} else {

				face = new THREE.Face3();
				face.a = faces[ offset ++ ];
				face.b = faces[ offset ++ ];
				face.c = faces[ offset ++ ];

				if ( hasMaterial ) {

					materialIndex = faces[ offset ++ ];
					face.materialIndex = materialIndex;

				}

				// to get face <=> uv index correspondence

				fi = geometry.faces.length;

				if ( hasFaceVertexUv ) {

					for ( i = 0; i < nUvLayers; i++ ) {

						uvLayer = json.uvs[ i ];

						geometry.faceVertexUvs[ i ][ fi ] = [];

						for ( j = 0; j < 3; j ++ ) {

							uvIndex = faces[ offset ++ ];

							u = uvLayer[ uvIndex * 2 ];
							v = uvLayer[ uvIndex * 2 + 1 ];

							uv = new THREE.Vector2( u, v );

							geometry.faceVertexUvs[ i ][ fi ].push( uv );

						}

					}

				}

				if ( hasFaceNormal ) {

					normalIndex = faces[ offset ++ ] * 3;

					face.normal.set(
						normals[ normalIndex ++ ],
						normals[ normalIndex ++ ],
						normals[ normalIndex ]
					);

				}

				if ( hasFaceVertexNormal ) {

					for ( i = 0; i < 3; i++ ) {

						normalIndex = faces[ offset ++ ] * 3;

						normal = new THREE.Vector3(
							normals[ normalIndex ++ ],
							normals[ normalIndex ++ ],
							normals[ normalIndex ]
						);

						face.vertexNormals.push( normal );

					}

				}


				if ( hasFaceColor ) {

					colorIndex = faces[ offset ++ ];
					face.color.setHex( colors[ colorIndex ] );

				}


				if ( hasFaceVertexColor ) {

					for ( i = 0; i < 3; i++ ) {

						colorIndex = faces[ offset ++ ];
						face.vertexColors.push( new THREE.Color( colors[ colorIndex ] ) );

					}

				}

				geometry.faces.push( face );

			}

		}

	};

	function parseSkin() {

		var i, l, x, y, z, w, a, b, c, d;

		if ( json.skinWeights ) {

			for ( i = 0, l = json.skinWeights.length; i < l; i += 2 ) {

				x = json.skinWeights[ i     ];
				y = json.skinWeights[ i + 1 ];
				z = 0;
				w = 0;

				geometry.skinWeights.push( new THREE.Vector4( x, y, z, w ) );

			}

		}

		if ( json.skinIndices ) {

			for ( i = 0, l = json.skinIndices.length; i < l; i += 2 ) {

				a = json.skinIndices[ i     ];
				b = json.skinIndices[ i + 1 ];
				c = 0;
				d = 0;

				geometry.skinIndices.push( new THREE.Vector4( a, b, c, d ) );

			}

		}

		geometry.bones = json.bones;
		// could change this to json.animations[0] or remove completely
		geometry.animation = json.animation;
		geometry.animations = json.animations;
	};

	function parseMorphing( scale ) {

		if ( json.morphTargets !== undefined ) {

			var i, l, v, vl, dstVertices, srcVertices;

			for ( i = 0, l = json.morphTargets.length; i < l; i ++ ) {

				geometry.morphTargets[ i ] = {};
				geometry.morphTargets[ i ].name = json.morphTargets[ i ].name;
				geometry.morphTargets[ i ].vertices = [];

				dstVertices = geometry.morphTargets[ i ].vertices;
				srcVertices = json.morphTargets [ i ].vertices;

				for( v = 0, vl = srcVertices.length; v < vl; v += 3 ) {

					var vertex = new THREE.Vector3();
					vertex.x = srcVertices[ v ] * scale;
					vertex.y = srcVertices[ v + 1 ] * scale;
					vertex.z = srcVertices[ v + 2 ] * scale;

					dstVertices.push( vertex );

				}

			}

		}

		if ( json.morphColors !== undefined ) {

			var i, l, c, cl, dstColors, srcColors, color;

			for ( i = 0, l = json.morphColors.length; i < l; i++ ) {

				geometry.morphColors[ i ] = {};
				geometry.morphColors[ i ].name = json.morphColors[ i ].name;
				geometry.morphColors[ i ].colors = [];

				dstColors = geometry.morphColors[ i ].colors;
				srcColors = json.morphColors [ i ].colors;

				for ( c = 0, cl = srcColors.length; c < cl; c += 3 ) {

					color = new THREE.Color( 0xffaa00 );
					color.setRGB( srcColors[ c ], srcColors[ c + 1 ], srcColors[ c + 2 ] );
					dstColors.push( color );

				}

			}

		}

	};

	if ( json.materials === undefined ) {

		return { geometry: geometry };

	} else {

		var materials = this.initMaterials( json.materials, texturePath );

		if ( this.needsTangents( materials ) ) {

			geometry.computeTangents();

		}

		return { geometry: geometry, materials: materials };

	}

};

/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.LoadingManager = function ( onLoad, onProgress, onError ) {

	var scope = this;

	var loaded = 0, total = 0;

	this.onLoad = onLoad;
	this.onProgress = onProgress;
	this.onError = onError;

	this.itemStart = function ( url ) {

		total ++;

	};

	this.itemEnd = function ( url ) {

		loaded ++;

		if ( scope.onProgress !== undefined ) {

			scope.onProgress( url, loaded, total );

		}

		if ( loaded === total && scope.onLoad !== undefined ) {

			scope.onLoad();

		}

	};

};

THREE.DefaultLoadingManager = new THREE.LoadingManager();

/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.BufferGeometryLoader = function ( manager ) {

	this.manager = ( manager !== undefined ) ? manager : THREE.DefaultLoadingManager;

};

THREE.BufferGeometryLoader.prototype = {

	constructor: THREE.BufferGeometryLoader,

	load: function ( url, onLoad, onProgress, onError ) {

		var scope = this;

		var loader = new THREE.XHRLoader();
		loader.setCrossOrigin( this.crossOrigin );
		loader.load( url, function ( text ) {

			onLoad( scope.parse( JSON.parse( text ) ) );

		} );

	},

	setCrossOrigin: function ( value ) {

		this.crossOrigin = value;

	},

	parse: function ( json ) {

		var geometry = new THREE.BufferGeometry();

		var attributes = json.attributes;
		var offsets = json.offsets;
		var boundingSphere = json.boundingSphere;

		for ( var key in attributes ) {

			var attribute = attributes[ key ];

			geometry.attributes[ key ] = {
				itemSize: attribute.itemSize,
				array: new self[ attribute.type ]( attribute.array )
			}

		}

		if ( offsets !== undefined ) {

			geometry.offsets = JSON.parse( JSON.stringify( offsets ) );

		}

		if ( boundingSphere !== undefined ) {

			geometry.boundingSphere = new THREE.Sphere(
				new THREE.Vector3().fromArray( boundingSphere.center !== undefined ? boundingSphere.center : [ 0, 0, 0 ] ),
				boundingSphere.radius
			);

		}

		return geometry;

	}

};

/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.GeometryLoader = function ( manager ) {

	this.manager = ( manager !== undefined ) ? manager : THREE.DefaultLoadingManager;

};

THREE.GeometryLoader.prototype = {

	constructor: THREE.GeometryLoader,

	load: function ( url, onLoad, onProgress, onError ) {

		var scope = this;

		var loader = new THREE.XHRLoader();
		loader.setCrossOrigin( this.crossOrigin );
		loader.load( url, function ( text ) {

			onLoad( scope.parse( JSON.parse( text ) ) );

		} );

	},

	setCrossOrigin: function ( value ) {

		this.crossOrigin = value;

	},

	parse: function ( json ) {



	}

};

/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.MaterialLoader = function ( manager ) {

	this.manager = ( manager !== undefined ) ? manager : THREE.DefaultLoadingManager;

};

THREE.MaterialLoader.prototype = {

	constructor: THREE.MaterialLoader,

	load: function ( url, onLoad, onProgress, onError ) {

		var scope = this;

		var loader = new THREE.XHRLoader();
		loader.setCrossOrigin( this.crossOrigin );
		loader.load( url, function ( text ) {

			onLoad( scope.parse( JSON.parse( text ) ) );

		} );

	},

	setCrossOrigin: function ( value ) {

		this.crossOrigin = value;

	},

	parse: function ( json ) {

		var material = new THREE[ json.type ];

		if ( json.color !== undefined ) material.color.setHex( json.color );
		if ( json.ambient !== undefined ) material.ambient.setHex( json.ambient );
		if ( json.emissive !== undefined ) material.emissive.setHex( json.emissive );
		if ( json.specular !== undefined ) material.specular.setHex( json.specular );
		if ( json.shininess !== undefined ) material.shininess = json.shininess;
		if ( json.vertexColors !== undefined ) material.vertexColors = json.vertexColors;
		if ( json.blending !== undefined ) material.blending = json.blending;
		if ( json.side !== undefined ) material.side = json.side;
		if ( json.opacity !== undefined ) material.opacity = json.opacity;
		if ( json.transparent !== undefined ) material.transparent = json.transparent;
		if ( json.wireframe !== undefined ) material.wireframe = json.wireframe;

		if ( json.materials !== undefined ) {

			for ( var i = 0, l = json.materials.length; i < l; i ++ ) {

				material.materials.push( this.parse( json.materials[ i ] ) );

			}

		}

		return material;

	}

};

/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.ObjectLoader = function ( manager ) {

	this.manager = ( manager !== undefined ) ? manager : THREE.DefaultLoadingManager;

};

THREE.ObjectLoader.prototype = {

	constructor: THREE.ObjectLoader,

	load: function ( url, onLoad, onProgress, onError ) {

		var scope = this;

		var loader = new THREE.XHRLoader( scope.manager );
		loader.setCrossOrigin( this.crossOrigin );
		loader.load( url, function ( text ) {

			onLoad( scope.parse( JSON.parse( text ) ) );

		} );

	},

	setCrossOrigin: function ( value ) {

		this.crossOrigin = value;

	},

	parse: function ( json ) {

		var geometries = this.parseGeometries( json.geometries );
		var materials = this.parseMaterials( json.materials );
		var object = this.parseObject( json.object, geometries, materials );

		return object;

	},

	parseGeometries: function ( json ) {

		var geometries = {};

		if ( json !== undefined ) {

			var geometryLoader = new THREE.JSONLoader();
			var bufferGeometryLoader = new THREE.BufferGeometryLoader();

			for ( var i = 0, l = json.length; i < l; i ++ ) {

				var geometry;
				var data = json[ i ];

				switch ( data.type ) {

					case 'PlaneGeometry':

						geometry = new THREE.PlaneGeometry(
							data.width,
							data.height,
							data.widthSegments,
							data.heightSegments
						);

						break;

					case 'CircleGeometry':

						geometry = new THREE.CircleGeometry(
							data.radius,
							data.segments
						);

						break;

					case 'CubeGeometry':

						geometry = new THREE.CubeGeometry(
							data.width,
							data.height,
							data.depth,
							data.widthSegments,
							data.heightSegments,
							data.depthSegments
						);

						break;

					case 'CylinderGeometry':

						geometry = new THREE.CylinderGeometry(
							data.radiusTop,
							data.radiusBottom,
							data.height,
							data.radialSegments,
							data.heightSegments,
							data.openEnded
						);

						break;

					case 'SphereGeometry':

						geometry = new THREE.SphereGeometry(
							data.radius,
							data.widthSegments,
							data.heightSegments,
							data.phiStart,
							data.phiLength,
							data.thetaStart,
							data.thetaLength
						);

						break;

					case 'IcosahedronGeometry':

						geometry = new THREE.IcosahedronGeometry(
							data.radius,
							data.detail
						);

						break;

					case 'TorusGeometry':

						geometry = new THREE.TorusGeometry(
							data.radius,
							data.tube,
							data.radialSegments,
							data.tubularSegments,
							data.arc
						);

						break;

					case 'TorusKnotGeometry':

						geometry = new THREE.TorusKnotGeometry(
							data.radius,
							data.tube,
							data.radialSegments,
							data.tubularSegments,
							data.p,
							data.q,
							data.heightScale
						);

						break;

					case 'BufferGeometry':

						geometry = bufferGeometryLoader.parse( data.data );

						break;

					case 'Geometry':

						geometry = geometryLoader.parse( data.data ).geometry;

						break;

				}

				geometry.uuid = data.uuid;

				if ( data.name !== undefined ) geometry.name = data.name;

				geometries[ data.uuid ] = geometry;

			}

		}

		return geometries;

	},

	parseMaterials: function ( json ) {

		var materials = {};

		if ( json !== undefined ) {

			var loader = new THREE.MaterialLoader();

			for ( var i = 0, l = json.length; i < l; i ++ ) {

				var data = json[ i ];
				var material = loader.parse( data );

				material.uuid = data.uuid;

				if ( data.name !== undefined ) material.name = data.name;

				materials[ data.uuid ] = material;

			}

		}

		return materials;

	},

	parseObject: function () {

		var matrix = new THREE.Matrix4();

		return function ( data, geometries, materials ) {

			var object;

			switch ( data.type ) {

				case 'Scene':

					object = new THREE.Scene();

					break;

				case 'PerspectiveCamera':

					object = new THREE.PerspectiveCamera( data.fov, data.aspect, data.near, data.far );

					break;

				case 'OrthographicCamera':

					object = new THREE.OrthographicCamera( data.left, data.right, data.top, data.bottom, data.near, data.far );

					break;

				case 'AmbientLight':

					object = new THREE.AmbientLight( data.color );

					break;

				case 'DirectionalLight':

					object = new THREE.DirectionalLight( data.color, data.intensity );

					break;

				case 'PointLight':

					object = new THREE.PointLight( data.color, data.intensity, data.distance );

					break;

				case 'SpotLight':

					object = new THREE.SpotLight( data.color, data.intensity, data.distance, data.angle, data.exponent );

					break;

				case 'HemisphereLight':

					object = new THREE.HemisphereLight( data.color, data.groundColor, data.intensity );

					break;

				case 'Mesh':

					var geometry = geometries[ data.geometry ];
					var material = materials[ data.material ];

					if ( geometry === undefined ) {

						console.error( 'THREE.ObjectLoader: Undefined geometry ' + data.geometry );

					}

					if ( material === undefined ) {

						console.error( 'THREE.ObjectLoader: Undefined material ' + data.material );

					}

					object = new THREE.Mesh( geometry, material );

					break;

				case 'Sprite':

					var material = materials[ data.material ];

					if ( material === undefined ) {

						console.error( 'THREE.ObjectLoader: Undefined material ' + data.material );

					}

					object = new THREE.Sprite( material );

					break;

				default:

					object = new THREE.Object3D();

			}

			object.uuid = data.uuid;

			if ( data.name !== undefined ) object.name = data.name;
			if ( data.matrix !== undefined ) {

				matrix.fromArray( data.matrix );
				matrix.decompose( object.position, object.quaternion, object.scale );

			} else {

				if ( data.position !== undefined ) object.position.fromArray( data.position );
				if ( data.rotation !== undefined ) object.rotation.fromArray( data.rotation );
				if ( data.scale !== undefined ) object.scale.fromArray( data.scale );

			}

			if ( data.visible !== undefined ) object.visible = data.visible;
			if ( data.userData !== undefined ) object.userData = data.userData;

			if ( data.children !== undefined ) {

				for ( var child in data.children ) {

					object.add( this.parseObject( data.children[ child ], geometries, materials ) );

				}

			}

			return object;

		}

	}()

};

/**
 * @author alteredq / http://alteredqualia.com/
 */

THREE.SceneLoader = function () {

	this.onLoadStart = function () {};
	this.onLoadProgress = function() {};
	this.onLoadComplete = function () {};

	this.callbackSync = function () {};
	this.callbackProgress = function () {};

	this.geometryHandlers = {};
	this.hierarchyHandlers = {};

	this.addGeometryHandler( "ascii", THREE.JSONLoader );

};

THREE.SceneLoader.prototype = {

	constructor: THREE.SceneLoader,

	load: function ( url, onLoad, onProgress, onError ) {

		var scope = this;

		var loader = new THREE.XHRLoader( scope.manager );
		loader.setCrossOrigin( this.crossOrigin );
		loader.load( url, function ( text ) {

			scope.parse( JSON.parse( text ), onLoad, url );

		} );

	},

	setCrossOrigin: function ( value ) {

		this.crossOrigin = value;

	},

	addGeometryHandler: function ( typeID, loaderClass ) {

		this.geometryHandlers[ typeID ] = { "loaderClass": loaderClass };

	},

	addHierarchyHandler: function ( typeID, loaderClass ) {

		this.hierarchyHandlers[ typeID ] = { "loaderClass": loaderClass };

	},

	parse: function ( json, callbackFinished, url ) {

		var scope = this;

		var urlBase = THREE.Loader.prototype.extractUrlBase( url );

		var geometry, material, camera, fog,
			texture, images, color,
			light, hex, intensity,
			counter_models, counter_textures,
			total_models, total_textures,
			result;

		var target_array = [];

		var data = json;

		// async geometry loaders

		for ( var typeID in this.geometryHandlers ) {

			var loaderClass = this.geometryHandlers[ typeID ][ "loaderClass" ];
			this.geometryHandlers[ typeID ][ "loaderObject" ] = new loaderClass();

		}

		// async hierachy loaders

		for ( var typeID in this.hierarchyHandlers ) {

			var loaderClass = this.hierarchyHandlers[ typeID ][ "loaderClass" ];
			this.hierarchyHandlers[ typeID ][ "loaderObject" ] = new loaderClass();

		}

		counter_models = 0;
		counter_textures = 0;

		result = {

			scene: new THREE.Scene(),
			geometries: {},
			face_materials: {},
			materials: {},
			textures: {},
			objects: {},
			cameras: {},
			lights: {},
			fogs: {},
			empties: {},
			groups: {}

		};

		if ( data.transform ) {

			var position = data.transform.position,
				rotation = data.transform.rotation,
				scale = data.transform.scale;

			if ( position ) {

				result.scene.position.fromArray( position );

			}

			if ( rotation ) {

				result.scene.rotation.fromArray( rotation );

			}

			if ( scale ) {

				result.scene.scale.fromArray( scale );

			}

			if ( position || rotation || scale ) {

				result.scene.updateMatrix();
				result.scene.updateMatrixWorld();

			}

		}

		function get_url( source_url, url_type ) {

			if ( url_type == "relativeToHTML" ) {

				return source_url;

			} else {

				return urlBase + "/" + source_url;

			}

		};

		// toplevel loader function, delegates to handle_children

		function handle_objects() {

			handle_children( result.scene, data.objects );

		}

		// handle all the children from the loaded json and attach them to given parent

		function handle_children( parent, children ) {

			var mat, dst, pos, rot, scl, quat;

			for ( var objID in children ) {

				// check by id if child has already been handled,
				// if not, create new object

				var object = result.objects[ objID ];
				var objJSON = children[ objID ];

				if ( object === undefined ) {

					// meshes

					if ( objJSON.type && ( objJSON.type in scope.hierarchyHandlers ) ) {

						if ( objJSON.loading === undefined ) {

							var reservedTypes = {
								"type": 1, "url": 1, "material": 1,
								"position": 1, "rotation": 1, "scale" : 1,
								"visible": 1, "children": 1, "userData": 1,
								"skin": 1, "morph": 1, "mirroredLoop": 1, "duration": 1
							};

							var loaderParameters = {};

							for ( var parType in objJSON ) {

								if ( ! ( parType in reservedTypes ) ) {

									loaderParameters[ parType ] = objJSON[ parType ];

								}

							}

							material = result.materials[ objJSON.material ];

							objJSON.loading = true;

							var loader = scope.hierarchyHandlers[ objJSON.type ][ "loaderObject" ];

							// ColladaLoader

							if ( loader.options ) {

								loader.load( get_url( objJSON.url, data.urlBaseType ), create_callback_hierachy( objID, parent, material, objJSON ) );

							// UTF8Loader
							// OBJLoader

							} else {

								loader.load( get_url( objJSON.url, data.urlBaseType ), create_callback_hierachy( objID, parent, material, objJSON ), loaderParameters );

							}

						}

					} else if ( objJSON.geometry !== undefined ) {

						geometry = result.geometries[ objJSON.geometry ];

						// geometry already loaded

						if ( geometry ) {

							var needsTangents = false;

							material = result.materials[ objJSON.material ];
							needsTangents = material instanceof THREE.ShaderMaterial;

							pos = objJSON.position;
							rot = objJSON.rotation;
							scl = objJSON.scale;
							mat = objJSON.matrix;
							quat = objJSON.quaternion;

							// use materials from the model file
							// if there is no material specified in the object

							if ( ! objJSON.material ) {

								material = new THREE.MeshFaceMaterial( result.face_materials[ objJSON.geometry ] );

							}

							// use materials from the model file
							// if there is just empty face material
							// (must create new material as each model has its own face material)

							if ( ( material instanceof THREE.MeshFaceMaterial ) && material.materials.length === 0 ) {

								material = new THREE.MeshFaceMaterial( result.face_materials[ objJSON.geometry ] );

							}

							if ( material instanceof THREE.MeshFaceMaterial ) {

								for ( var i = 0; i < material.materials.length; i ++ ) {

									needsTangents = needsTangents || ( material.materials[ i ] instanceof THREE.ShaderMaterial );

								}

							}

							if ( needsTangents ) {

								geometry.computeTangents();

							}

							if ( objJSON.skin ) {

								object = new THREE.SkinnedMesh( geometry, material );

							} else if ( objJSON.morph ) {

								object = new THREE.MorphAnimMesh( geometry, material );

								if ( objJSON.duration !== undefined ) {

									object.duration = objJSON.duration;

								}

								if ( objJSON.time !== undefined ) {

									object.time = objJSON.time;

								}

								if ( objJSON.mirroredLoop !== undefined ) {

									object.mirroredLoop = objJSON.mirroredLoop;

								}

								if ( material.morphNormals ) {

									geometry.computeMorphNormals();

								}

							} else {

								object = new THREE.Mesh( geometry, material );

							}

							object.name = objID;

							if ( mat ) {

								object.matrixAutoUpdate = false;
								object.matrix.set(
									mat[0],  mat[1],  mat[2],  mat[3],
									mat[4],  mat[5],  mat[6],  mat[7],
									mat[8],  mat[9],  mat[10], mat[11],
									mat[12], mat[13], mat[14], mat[15]
								);

							} else {

								object.position.fromArray( pos );

								if ( quat ) {

									object.quaternion.fromArray( quat );

								} else {

									object.rotation.fromArray( rot );

								}

								object.scale.fromArray( scl );

							}

							object.visible = objJSON.visible;
							object.castShadow = objJSON.castShadow;
							object.receiveShadow = objJSON.receiveShadow;

							parent.add( object );

							result.objects[ objID ] = object;

						}

					// lights

					} else if ( objJSON.type === "AmbientLight" || objJSON.type === "PointLight" ||
						objJSON.type === "DirectionalLight" || objJSON.type === "SpotLight" ||
						objJSON.type === "HemisphereLight" || objJSON.type === "AreaLight" ) {

						var color = objJSON.color;
						var intensity = objJSON.intensity;
						var distance = objJSON.distance;
						var position = objJSON.position;
						var rotation = objJSON.rotation;

						switch ( objJSON.type ) {

							case 'AmbientLight':
								light = new THREE.AmbientLight( color );
								break;

							case 'PointLight':
								light = new THREE.PointLight( color, intensity, distance );
								light.position.fromArray( position );
								break;

							case 'DirectionalLight':
								light = new THREE.DirectionalLight( color, intensity );
								light.position.fromArray( objJSON.direction );
								break;

							case 'SpotLight':
								light = new THREE.SpotLight( color, intensity, distance, 1 );
								light.angle = objJSON.angle;
								light.position.fromArray( position );
								light.target.set( position[ 0 ], position[ 1 ] - distance, position[ 2 ] );
								light.target.applyEuler( new THREE.Euler( rotation[ 0 ], rotation[ 1 ], rotation[ 2 ], 'XYZ' ) );
								break;

							case 'HemisphereLight':
								light = new THREE.DirectionalLight( color, intensity, distance );
								light.target.set( position[ 0 ], position[ 1 ] - distance, position[ 2 ] );
								light.target.applyEuler( new THREE.Euler( rotation[ 0 ], rotation[ 1 ], rotation[ 2 ], 'XYZ' ) );
								break;

							case 'AreaLight':
								light = new THREE.AreaLight(color, intensity);
								light.position.fromArray( position );
								light.width = objJSON.size;
								light.height = objJSON.size_y;
								break;

						}

						parent.add( light );

						light.name = objID;
						result.lights[ objID ] = light;
						result.objects[ objID ] = light;

					// cameras

					} else if ( objJSON.type === "PerspectiveCamera" || objJSON.type === "OrthographicCamera" ) {

						pos = objJSON.position;
						rot = objJSON.rotation;
						quat = objJSON.quaternion;

						if ( objJSON.type === "PerspectiveCamera" ) {

							camera = new THREE.PerspectiveCamera( objJSON.fov, objJSON.aspect, objJSON.near, objJSON.far );

						} else if ( objJSON.type === "OrthographicCamera" ) {

							camera = new THREE.OrthographicCamera( objJSON.left, objJSON.right, objJSON.top, objJSON.bottom, objJSON.near, objJSON.far );

						}

						camera.name = objID;
						camera.position.fromArray( pos );

						if ( quat !== undefined ) {

							camera.quaternion.fromArray( quat );

						} else if ( rot !== undefined ) {

							camera.rotation.fromArray( rot );

						}

						parent.add( camera );

						result.cameras[ objID ] = camera;
						result.objects[ objID ] = camera;

					// pure Object3D

					} else {

						pos = objJSON.position;
						rot = objJSON.rotation;
						scl = objJSON.scale;
						quat = objJSON.quaternion;

						object = new THREE.Object3D();
						object.name = objID;
						object.position.fromArray( pos );

						if ( quat ) {

							object.quaternion.fromArray( quat );

						} else {

							object.rotation.fromArray( rot );

						}

						object.scale.fromArray( scl );
						object.visible = ( objJSON.visible !== undefined ) ? objJSON.visible : false;

						parent.add( object );

						result.objects[ objID ] = object;
						result.empties[ objID ] = object;

					}

					if ( object ) {

						if ( objJSON.userData !== undefined ) {

							for ( var key in objJSON.userData ) {

								var value = objJSON.userData[ key ];
								object.userData[ key ] = value;

							}

						}

						if ( objJSON.groups !== undefined ) {

							for ( var i = 0; i < objJSON.groups.length; i ++ ) {

								var groupID = objJSON.groups[ i ];

								if ( result.groups[ groupID ] === undefined ) {

									result.groups[ groupID ] = [];

								}

								result.groups[ groupID ].push( objID );

							}

						}

					}

				}

				if ( object !== undefined && objJSON.children !== undefined ) {

					handle_children( object, objJSON.children );

				}

			}

		};

		function handle_mesh( geo, mat, id ) {

			result.geometries[ id ] = geo;
			result.face_materials[ id ] = mat;
			handle_objects();

		};

		function handle_hierarchy( node, id, parent, material, obj ) {

			var p = obj.position;
			var r = obj.rotation;
			var q = obj.quaternion;
			var s = obj.scale;

			node.position.fromArray( p );

			if ( q ) {

				node.quaternion.fromArray( q );

			} else {

				node.rotation.fromArray( r );

			}

			node.scale.fromArray( s );

			// override children materials
			// if object material was specified in JSON explicitly

			if ( material ) {

				node.traverse( function ( child ) {

					child.material = material;

				} );

			}

			// override children visibility
			// with root node visibility as specified in JSON

			var visible = ( obj.visible !== undefined ) ? obj.visible : true;

			node.traverse( function ( child ) {

				child.visible = visible;

			} );

			parent.add( node );

			node.name = id;

			result.objects[ id ] = node;
			handle_objects();

		};

		function create_callback_geometry( id ) {

			return function ( geo, mat ) {

				geo.name = id;

				handle_mesh( geo, mat, id );

				counter_models -= 1;

				scope.onLoadComplete();

				async_callback_gate();

			}

		};

		function create_callback_hierachy( id, parent, material, obj ) {

			return function ( event ) {

				var result;

				// loaders which use EventDispatcher

				if ( event.content ) {

					result = event.content;

				// ColladaLoader

				} else if ( event.dae ) {

					result = event.scene;


				// UTF8Loader

				} else {

					result = event;

				}

				handle_hierarchy( result, id, parent, material, obj );

				counter_models -= 1;

				scope.onLoadComplete();

				async_callback_gate();

			}

		};

		function create_callback_embed( id ) {

			return function ( geo, mat ) {

				geo.name = id;

				result.geometries[ id ] = geo;
				result.face_materials[ id ] = mat;

			}

		};

		function async_callback_gate() {

			var progress = {

				totalModels : total_models,
				totalTextures : total_textures,
				loadedModels : total_models - counter_models,
				loadedTextures : total_textures - counter_textures

			};

			scope.callbackProgress( progress, result );

			scope.onLoadProgress();

			if ( counter_models === 0 && counter_textures === 0 ) {

				finalize();
				callbackFinished( result );

			}

		};

		function finalize() {

			// take care of targets which could be asynchronously loaded objects

			for ( var i = 0; i < target_array.length; i ++ ) {

				var ta = target_array[ i ];

				var target = result.objects[ ta.targetName ];

				if ( target ) {

					ta.object.target = target;

				} else {

					// if there was error and target of specified name doesn't exist in the scene file
					// create instead dummy target
					// (target must be added to scene explicitly as parent is already added)

					ta.object.target = new THREE.Object3D();
					result.scene.add( ta.object.target );

				}

				ta.object.target.userData.targetInverse = ta.object;

			}

		};

		var callbackTexture = function ( count ) {

			counter_textures -= count;
			async_callback_gate();

			scope.onLoadComplete();

		};

		// must use this instead of just directly calling callbackTexture
		// because of closure in the calling context loop

		var generateTextureCallback = function ( count ) {

			return function () {

				callbackTexture( count );

			};

		};

		function traverse_json_hierarchy( objJSON, callback ) {

			callback( objJSON );

			if ( objJSON.children !== undefined ) {

				for ( var objChildID in objJSON.children ) {

					traverse_json_hierarchy( objJSON.children[ objChildID ], callback );

				}

			}

		};

		// first go synchronous elements

		// fogs

		var fogID, fogJSON;

		for ( fogID in data.fogs ) {

			fogJSON = data.fogs[ fogID ];

			if ( fogJSON.type === "linear" ) {

				fog = new THREE.Fog( 0x000000, fogJSON.near, fogJSON.far );

			} else if ( fogJSON.type === "exp2" ) {

				fog = new THREE.FogExp2( 0x000000, fogJSON.density );

			}

			color = fogJSON.color;
			fog.color.setRGB( color[0], color[1], color[2] );

			result.fogs[ fogID ] = fog;

		}

		// now come potentially asynchronous elements

		// geometries

		// count how many geometries will be loaded asynchronously

		var geoID, geoJSON;

		for ( geoID in data.geometries ) {

			geoJSON = data.geometries[ geoID ];

			if ( geoJSON.type in this.geometryHandlers ) {

				counter_models += 1;

				scope.onLoadStart();

			}

		}

		// count how many hierarchies will be loaded asynchronously

		for ( var objID in data.objects ) {

			traverse_json_hierarchy( data.objects[ objID ], function ( objJSON ) {

				if ( objJSON.type && ( objJSON.type in scope.hierarchyHandlers ) ) {

					counter_models += 1;

					scope.onLoadStart();

				}

			});

		}

		total_models = counter_models;

		for ( geoID in data.geometries ) {

			geoJSON = data.geometries[ geoID ];

			if ( geoJSON.type === "cube" ) {

				geometry = new THREE.CubeGeometry( geoJSON.width, geoJSON.height, geoJSON.depth, geoJSON.widthSegments, geoJSON.heightSegments, geoJSON.depthSegments );
				geometry.name = geoID;
				result.geometries[ geoID ] = geometry;

			} else if ( geoJSON.type === "plane" ) {

				geometry = new THREE.PlaneGeometry( geoJSON.width, geoJSON.height, geoJSON.widthSegments, geoJSON.heightSegments );
				geometry.name = geoID;
				result.geometries[ geoID ] = geometry;

			} else if ( geoJSON.type === "sphere" ) {

				geometry = new THREE.SphereGeometry( geoJSON.radius, geoJSON.widthSegments, geoJSON.heightSegments );
				geometry.name = geoID;
				result.geometries[ geoID ] = geometry;

			} else if ( geoJSON.type === "cylinder" ) {

				geometry = new THREE.CylinderGeometry( geoJSON.topRad, geoJSON.botRad, geoJSON.height, geoJSON.radSegs, geoJSON.heightSegs );
				geometry.name = geoID;
				result.geometries[ geoID ] = geometry;

			} else if ( geoJSON.type === "torus" ) {

				geometry = new THREE.TorusGeometry( geoJSON.radius, geoJSON.tube, geoJSON.segmentsR, geoJSON.segmentsT );
				geometry.name = geoID;
				result.geometries[ geoID ] = geometry;

			} else if ( geoJSON.type === "icosahedron" ) {

				geometry = new THREE.IcosahedronGeometry( geoJSON.radius, geoJSON.subdivisions );
				geometry.name = geoID;
				result.geometries[ geoID ] = geometry;

			} else if ( geoJSON.type in this.geometryHandlers ) {

				var loaderParameters = {};

				for ( var parType in geoJSON ) {

					if ( parType !== "type" && parType !== "url" ) {

						loaderParameters[ parType ] = geoJSON[ parType ];

					}

				}

				var loader = this.geometryHandlers[ geoJSON.type ][ "loaderObject" ];
				loader.load( get_url( geoJSON.url, data.urlBaseType ), create_callback_geometry( geoID ), loaderParameters );

			} else if ( geoJSON.type === "embedded" ) {

				var modelJson = data.embeds[ geoJSON.id ],
					texture_path = "";

				// pass metadata along to jsonLoader so it knows the format version

				modelJson.metadata = data.metadata;

				if ( modelJson ) {

					var jsonLoader = this.geometryHandlers[ "ascii" ][ "loaderObject" ];
					var model = jsonLoader.parse( modelJson, texture_path );
					create_callback_embed( geoID )( model.geometry, model.materials );

				}

			}

		}

		// textures

		// count how many textures will be loaded asynchronously

		var textureID, textureJSON;

		for ( textureID in data.textures ) {

			textureJSON = data.textures[ textureID ];

			if ( textureJSON.url instanceof Array ) {

				counter_textures += textureJSON.url.length;

				for( var n = 0; n < textureJSON.url.length; n ++ ) {

					scope.onLoadStart();

				}

			} else {

				counter_textures += 1;

				scope.onLoadStart();

			}

		}

		total_textures = counter_textures;

		for ( textureID in data.textures ) {

			textureJSON = data.textures[ textureID ];

			if ( textureJSON.mapping !== undefined && THREE[ textureJSON.mapping ] !== undefined ) {

				textureJSON.mapping = new THREE[ textureJSON.mapping ]();

			}

			if ( textureJSON.url instanceof Array ) {

				var count = textureJSON.url.length;
				var url_array = [];

				for( var i = 0; i < count; i ++ ) {

					url_array[ i ] = get_url( textureJSON.url[ i ], data.urlBaseType );

				}

				var isCompressed = /\.dds$/i.test( url_array[ 0 ] );

				if ( isCompressed ) {

					texture = THREE.ImageUtils.loadCompressedTextureCube( url_array, textureJSON.mapping, generateTextureCallback( count ) );

				} else {

					texture = THREE.ImageUtils.loadTextureCube( url_array, textureJSON.mapping, generateTextureCallback( count ) );

				}

			} else {

				var isCompressed = /\.dds$/i.test( textureJSON.url );
				var fullUrl = get_url( textureJSON.url, data.urlBaseType );
				var textureCallback = generateTextureCallback( 1 );

				if ( isCompressed ) {

					texture = THREE.ImageUtils.loadCompressedTexture( fullUrl, textureJSON.mapping, textureCallback );

				} else {

					texture = THREE.ImageUtils.loadTexture( fullUrl, textureJSON.mapping, textureCallback );

				}

				if ( THREE[ textureJSON.minFilter ] !== undefined )
					texture.minFilter = THREE[ textureJSON.minFilter ];

				if ( THREE[ textureJSON.magFilter ] !== undefined )
					texture.magFilter = THREE[ textureJSON.magFilter ];

				if ( textureJSON.anisotropy ) texture.anisotropy = textureJSON.anisotropy;

				if ( textureJSON.repeat ) {

					texture.repeat.set( textureJSON.repeat[ 0 ], textureJSON.repeat[ 1 ] );

					if ( textureJSON.repeat[ 0 ] !== 1 ) texture.wrapS = THREE.RepeatWrapping;
					if ( textureJSON.repeat[ 1 ] !== 1 ) texture.wrapT = THREE.RepeatWrapping;

				}

				if ( textureJSON.offset ) {

					texture.offset.set( textureJSON.offset[ 0 ], textureJSON.offset[ 1 ] );

				}

				// handle wrap after repeat so that default repeat can be overriden

				if ( textureJSON.wrap ) {

					var wrapMap = {
						"repeat": THREE.RepeatWrapping,
						"mirror": THREE.MirroredRepeatWrapping
					}

					if ( wrapMap[ textureJSON.wrap[ 0 ] ] !== undefined ) texture.wrapS = wrapMap[ textureJSON.wrap[ 0 ] ];
					if ( wrapMap[ textureJSON.wrap[ 1 ] ] !== undefined ) texture.wrapT = wrapMap[ textureJSON.wrap[ 1 ] ];

				}

			}

			result.textures[ textureID ] = texture;

		}

		// materials

		var matID, matJSON;
		var parID;

		for ( matID in data.materials ) {

			matJSON = data.materials[ matID ];

			for ( parID in matJSON.parameters ) {

				if ( parID === "envMap" || parID === "map" || parID === "lightMap" || parID === "bumpMap" ) {

					matJSON.parameters[ parID ] = result.textures[ matJSON.parameters[ parID ] ];

				} else if ( parID === "shading" ) {

					matJSON.parameters[ parID ] = ( matJSON.parameters[ parID ] === "flat" ) ? THREE.FlatShading : THREE.SmoothShading;

				} else if ( parID === "side" ) {

					if ( matJSON.parameters[ parID ] == "double" ) {

						matJSON.parameters[ parID ] = THREE.DoubleSide;

					} else if ( matJSON.parameters[ parID ] == "back" ) {

						matJSON.parameters[ parID ] = THREE.BackSide;

					} else {

						matJSON.parameters[ parID ] = THREE.FrontSide;

					}

				} else if ( parID === "blending" ) {

					matJSON.parameters[ parID ] = matJSON.parameters[ parID ] in THREE ? THREE[ matJSON.parameters[ parID ] ] : THREE.NormalBlending;

				} else if ( parID === "combine" ) {

					matJSON.parameters[ parID ] = matJSON.parameters[ parID ] in THREE ? THREE[ matJSON.parameters[ parID ] ] : THREE.MultiplyOperation;

				} else if ( parID === "vertexColors" ) {

					if ( matJSON.parameters[ parID ] == "face" ) {

						matJSON.parameters[ parID ] = THREE.FaceColors;

					// default to vertex colors if "vertexColors" is anything else face colors or 0 / null / false

					} else if ( matJSON.parameters[ parID ] ) {

						matJSON.parameters[ parID ] = THREE.VertexColors;

					}

				} else if ( parID === "wrapRGB" ) {

					var v3 = matJSON.parameters[ parID ];
					matJSON.parameters[ parID ] = new THREE.Vector3( v3[ 0 ], v3[ 1 ], v3[ 2 ] );

				}

			}

			if ( matJSON.parameters.opacity !== undefined && matJSON.parameters.opacity < 1.0 ) {

				matJSON.parameters.transparent = true;

			}

			if ( matJSON.parameters.normalMap ) {

				var shader = THREE.ShaderLib[ "normalmap" ];
				var uniforms = THREE.UniformsUtils.clone( shader.uniforms );

				var diffuse = matJSON.parameters.color;
				var specular = matJSON.parameters.specular;
				var ambient = matJSON.parameters.ambient;
				var shininess = matJSON.parameters.shininess;

				uniforms[ "tNormal" ].value = result.textures[ matJSON.parameters.normalMap ];

				if ( matJSON.parameters.normalScale ) {

					uniforms[ "uNormalScale" ].value.set( matJSON.parameters.normalScale[ 0 ], matJSON.parameters.normalScale[ 1 ] );

				}

				if ( matJSON.parameters.map ) {

					uniforms[ "tDiffuse" ].value = matJSON.parameters.map;
					uniforms[ "enableDiffuse" ].value = true;

				}

				if ( matJSON.parameters.envMap ) {

					uniforms[ "tCube" ].value = matJSON.parameters.envMap;
					uniforms[ "enableReflection" ].value = true;
					uniforms[ "reflectivity" ].value = matJSON.parameters.reflectivity;

				}

				if ( matJSON.parameters.lightMap ) {

					uniforms[ "tAO" ].value = matJSON.parameters.lightMap;
					uniforms[ "enableAO" ].value = true;

				}

				if ( matJSON.parameters.specularMap ) {

					uniforms[ "tSpecular" ].value = result.textures[ matJSON.parameters.specularMap ];
					uniforms[ "enableSpecular" ].value = true;

				}

				if ( matJSON.parameters.displacementMap ) {

					uniforms[ "tDisplacement" ].value = result.textures[ matJSON.parameters.displacementMap ];
					uniforms[ "enableDisplacement" ].value = true;

					uniforms[ "uDisplacementBias" ].value = matJSON.parameters.displacementBias;
					uniforms[ "uDisplacementScale" ].value = matJSON.parameters.displacementScale;

				}

				uniforms[ "diffuse" ].value.setHex( diffuse );
				uniforms[ "specular" ].value.setHex( specular );
				uniforms[ "ambient" ].value.setHex( ambient );

				uniforms[ "shininess" ].value = shininess;

				if ( matJSON.parameters.opacity ) {

					uniforms[ "opacity" ].value = matJSON.parameters.opacity;

				}

				var parameters = { fragmentShader: shader.fragmentShader, vertexShader: shader.vertexShader, uniforms: uniforms, lights: true, fog: true };

				material = new THREE.ShaderMaterial( parameters );

			} else {

				material = new THREE[ matJSON.type ]( matJSON.parameters );

			}

			material.name = matID;

			result.materials[ matID ] = material;

		}

		// second pass through all materials to initialize MeshFaceMaterials
		// that could be referring to other materials out of order

		for ( matID in data.materials ) {

			matJSON = data.materials[ matID ];

			if ( matJSON.parameters.materials ) {

				var materialArray = [];

				for ( var i = 0; i < matJSON.parameters.materials.length; i ++ ) {

					var label = matJSON.parameters.materials[ i ];
					materialArray.push( result.materials[ label ] );

				}

				result.materials[ matID ].materials = materialArray;

			}

		}

		// objects ( synchronous init of procedural primitives )

		handle_objects();

		// defaults

		if ( result.cameras && data.defaults.camera ) {

			result.currentCamera = result.cameras[ data.defaults.camera ];

		}

		if ( result.fogs && data.defaults.fog ) {

			result.scene.fog = result.fogs[ data.defaults.fog ];

		}

		// synchronous callback

		scope.callbackSync( result );

		// just in case there are no async elements

		async_callback_gate();

	}

}

/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.TextureLoader = function ( manager ) {

	this.manager = ( manager !== undefined ) ? manager : THREE.DefaultLoadingManager;

};

THREE.TextureLoader.prototype = {

	constructor: THREE.TextureLoader,

	load: function ( url, onLoad, onProgress, onError ) {

		var scope = this;

		var loader = new THREE.ImageLoader( scope.manager );
		loader.setCrossOrigin( this.crossOrigin );
		loader.load( url, function ( image ) {

			var texture = new THREE.Texture( image );
			texture.needsUpdate = true;

			if ( onLoad !== undefined ) {

				onLoad( texture );

			}

		} );

	},

	setCrossOrigin: function ( value ) {

		this.crossOrigin = value;

	}

};

/**
 * @author mrdoob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 */

THREE.Material = function () {

	this.id = THREE.MaterialIdCount ++;
	this.uuid = THREE.Math.generateUUID();

	this.name = '';

	this.side = THREE.FrontSide;

	this.opacity = 1;
	this.transparent = false;

	this.blending = THREE.NormalBlending;

	this.blendSrc = THREE.SrcAlphaFactor;
	this.blendDst = THREE.OneMinusSrcAlphaFactor;
	this.blendEquation = THREE.AddEquation;

	this.depthTest = true;
	this.depthWrite = true;

	this.polygonOffset = false;
	this.polygonOffsetFactor = 0;
	this.polygonOffsetUnits = 0;

	this.alphaTest = 0;

	this.overdraw = 0; // Overdrawn pixels (typically between 0 and 1) for fixing antialiasing gaps in CanvasRenderer

	this.visible = true;

	this.needsUpdate = true;

};

THREE.Material.prototype = {

	constructor: THREE.Material,

	setValues: function ( values ) {

		if ( values === undefined ) return;

		for ( var key in values ) {

			var newValue = values[ key ];

			if ( newValue === undefined ) {

				console.warn( 'THREE.Material: \'' + key + '\' parameter is undefined.' );
				continue;

			}

			if ( key in this ) {

				var currentValue = this[ key ];

				if ( currentValue instanceof THREE.Color ) {

					currentValue.set( newValue );

				} else if ( currentValue instanceof THREE.Vector3 && newValue instanceof THREE.Vector3 ) {

					currentValue.copy( newValue );

				} else if ( key == 'overdraw') {

					// ensure overdraw is backwards-compatable with legacy boolean type
					this[ key ] = Number(newValue);

				} else {

					this[ key ] = newValue;

				}

			}

		}

	},

	clone: function ( material ) {

		if ( material === undefined ) material = new THREE.Material();

		material.name = this.name;

		material.side = this.side;

		material.opacity = this.opacity;
		material.transparent = this.transparent;

		material.blending = this.blending;

		material.blendSrc = this.blendSrc;
		material.blendDst = this.blendDst;
		material.blendEquation = this.blendEquation;

		material.depthTest = this.depthTest;
		material.depthWrite = this.depthWrite;

		material.polygonOffset = this.polygonOffset;
		material.polygonOffsetFactor = this.polygonOffsetFactor;
		material.polygonOffsetUnits = this.polygonOffsetUnits;

		material.alphaTest = this.alphaTest;

		material.overdraw = this.overdraw;

		material.visible = this.visible;

		return material;

	},

	dispose: function () {

		this.dispatchEvent( { type: 'dispose' } );

	}

};

THREE.EventDispatcher.prototype.apply( THREE.Material.prototype );

THREE.MaterialIdCount = 0;

/**
 * @author mrdoob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 *
 * parameters = {
 *  color: <hex>,
 *  opacity: <float>,
 *
 *  blending: THREE.NormalBlending,
 *  depthTest: <bool>,
 *  depthWrite: <bool>,
 *
 *  linewidth: <float>,
 *  linecap: "round",
 *  linejoin: "round",
 *
 *  vertexColors: <bool>
 *
 *  fog: <bool>
 * }
 */

THREE.LineBasicMaterial = function ( parameters ) {

	THREE.Material.call( this );

	this.color = new THREE.Color( 0xffffff );

	this.linewidth = 1;
	this.linecap = 'round';
	this.linejoin = 'round';

	this.vertexColors = false;

	this.fog = true;

	this.setValues( parameters );

};

THREE.LineBasicMaterial.prototype = Object.create( THREE.Material.prototype );

THREE.LineBasicMaterial.prototype.clone = function () {

	var material = new THREE.LineBasicMaterial();

	THREE.Material.prototype.clone.call( this, material );

	material.color.copy( this.color );

	material.linewidth = this.linewidth;
	material.linecap = this.linecap;
	material.linejoin = this.linejoin;

	material.vertexColors = this.vertexColors;

	material.fog = this.fog;

	return material;

};

/**
 * @author alteredq / http://alteredqualia.com/
 *
 * parameters = {
 *  color: <hex>,
 *  opacity: <float>,
 *
 *  blending: THREE.NormalBlending,
 *  depthTest: <bool>,
 *  depthWrite: <bool>,
 *
 *  linewidth: <float>,
 *
 *  scale: <float>,
 *  dashSize: <float>,
 *  gapSize: <float>,
 *
 *  vertexColors: <bool>
 *
 *  fog: <bool>
 * }
 */

THREE.LineDashedMaterial = function ( parameters ) {

	THREE.Material.call( this );

	this.color = new THREE.Color( 0xffffff );

	this.linewidth = 1;

	this.scale = 1;
	this.dashSize = 3;
	this.gapSize = 1;

	this.vertexColors = false;

	this.fog = true;

	this.setValues( parameters );

};

THREE.LineDashedMaterial.prototype = Object.create( THREE.Material.prototype );

THREE.LineDashedMaterial.prototype.clone = function () {

	var material = new THREE.LineDashedMaterial();

	THREE.Material.prototype.clone.call( this, material );

	material.color.copy( this.color );

	material.linewidth = this.linewidth;

	material.scale = this.scale;
	material.dashSize = this.dashSize;
	material.gapSize = this.gapSize;

	material.vertexColors = this.vertexColors;

	material.fog = this.fog;

	return material;

};

/**
 * @author mrdoob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 *
 * parameters = {
 *  color: <hex>,
 *  opacity: <float>,
 *  map: new THREE.Texture( <Image> ),
 *
 *  lightMap: new THREE.Texture( <Image> ),
 *
 *  specularMap: new THREE.Texture( <Image> ),
 *
 *  envMap: new THREE.TextureCube( [posx, negx, posy, negy, posz, negz] ),
 *  combine: THREE.Multiply,
 *  reflectivity: <float>,
 *  refractionRatio: <float>,
 *
 *  shading: THREE.SmoothShading,
 *  blending: THREE.NormalBlending,
 *  depthTest: <bool>,
 *  depthWrite: <bool>,
 *
 *  wireframe: <boolean>,
 *  wireframeLinewidth: <float>,
 *
 *  vertexColors: THREE.NoColors / THREE.VertexColors / THREE.FaceColors,
 *
 *  skinning: <bool>,
 *  morphTargets: <bool>,
 *
 *  fog: <bool>
 * }
 */

THREE.MeshBasicMaterial = function ( parameters ) {

	THREE.Material.call( this );

	this.color = new THREE.Color( 0xffffff ); // emissive

	this.map = null;

	this.lightMap = null;

	this.specularMap = null;

	this.envMap = null;
	this.combine = THREE.MultiplyOperation;
	this.reflectivity = 1;
	this.refractionRatio = 0.98;

	this.fog = true;

	this.shading = THREE.SmoothShading;

	this.wireframe = false;
	this.wireframeLinewidth = 1;
	this.wireframeLinecap = 'round';
	this.wireframeLinejoin = 'round';

	this.vertexColors = THREE.NoColors;

	this.skinning = false;
	this.morphTargets = false;

	this.setValues( parameters );

};

THREE.MeshBasicMaterial.prototype = Object.create( THREE.Material.prototype );

THREE.MeshBasicMaterial.prototype.clone = function () {

	var material = new THREE.MeshBasicMaterial();

	THREE.Material.prototype.clone.call( this, material );

	material.color.copy( this.color );

	material.map = this.map;

	material.lightMap = this.lightMap;

	material.specularMap = this.specularMap;

	material.envMap = this.envMap;
	material.combine = this.combine;
	material.reflectivity = this.reflectivity;
	material.refractionRatio = this.refractionRatio;

	material.fog = this.fog;

	material.shading = this.shading;

	material.wireframe = this.wireframe;
	material.wireframeLinewidth = this.wireframeLinewidth;
	material.wireframeLinecap = this.wireframeLinecap;
	material.wireframeLinejoin = this.wireframeLinejoin;

	material.vertexColors = this.vertexColors;

	material.skinning = this.skinning;
	material.morphTargets = this.morphTargets;

	return material;

};

/**
 * @author mrdoob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 *
 * parameters = {
 *  color: <hex>,
 *  ambient: <hex>,
 *  emissive: <hex>,
 *  opacity: <float>,
 *
 *  map: new THREE.Texture( <Image> ),
 *
 *  lightMap: new THREE.Texture( <Image> ),
 *
 *  specularMap: new THREE.Texture( <Image> ),
 *
 *  envMap: new THREE.TextureCube( [posx, negx, posy, negy, posz, negz] ),
 *  combine: THREE.Multiply,
 *  reflectivity: <float>,
 *  refractionRatio: <float>,
 *
 *  shading: THREE.SmoothShading,
 *  blending: THREE.NormalBlending,
 *  depthTest: <bool>,
 *  depthWrite: <bool>,
 *
 *  wireframe: <boolean>,
 *  wireframeLinewidth: <float>,
 *
 *  vertexColors: THREE.NoColors / THREE.VertexColors / THREE.FaceColors,
 *
 *  skinning: <bool>,
 *  morphTargets: <bool>,
 *  morphNormals: <bool>,
 *
 *	fog: <bool>
 * }
 */

THREE.MeshLambertMaterial = function ( parameters ) {

	THREE.Material.call( this );

	this.color = new THREE.Color( 0xffffff ); // diffuse
	this.ambient = new THREE.Color( 0xffffff );
	this.emissive = new THREE.Color( 0x000000 );

	this.wrapAround = false;
	this.wrapRGB = new THREE.Vector3( 1, 1, 1 );

	this.map = null;

	this.lightMap = null;

	this.specularMap = null;

	this.envMap = null;
	this.combine = THREE.MultiplyOperation;
	this.reflectivity = 1;
	this.refractionRatio = 0.98;

	this.fog = true;

	this.shading = THREE.SmoothShading;

	this.wireframe = false;
	this.wireframeLinewidth = 1;
	this.wireframeLinecap = 'round';
	this.wireframeLinejoin = 'round';

	this.vertexColors = THREE.NoColors;

	this.skinning = false;
	this.morphTargets = false;
	this.morphNormals = false;

	this.setValues( parameters );

};

THREE.MeshLambertMaterial.prototype = Object.create( THREE.Material.prototype );

THREE.MeshLambertMaterial.prototype.clone = function () {

	var material = new THREE.MeshLambertMaterial();

	THREE.Material.prototype.clone.call( this, material );

	material.color.copy( this.color );
	material.ambient.copy( this.ambient );
	material.emissive.copy( this.emissive );

	material.wrapAround = this.wrapAround;
	material.wrapRGB.copy( this.wrapRGB );

	material.map = this.map;

	material.lightMap = this.lightMap;

	material.specularMap = this.specularMap;

	material.envMap = this.envMap;
	material.combine = this.combine;
	material.reflectivity = this.reflectivity;
	material.refractionRatio = this.refractionRatio;

	material.fog = this.fog;

	material.shading = this.shading;

	material.wireframe = this.wireframe;
	material.wireframeLinewidth = this.wireframeLinewidth;
	material.wireframeLinecap = this.wireframeLinecap;
	material.wireframeLinejoin = this.wireframeLinejoin;

	material.vertexColors = this.vertexColors;

	material.skinning = this.skinning;
	material.morphTargets = this.morphTargets;
	material.morphNormals = this.morphNormals;

	return material;

};

/**
 * @author mrdoob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 *
 * parameters = {
 *  color: <hex>,
 *  ambient: <hex>,
 *  emissive: <hex>,
 *  specular: <hex>,
 *  shininess: <float>,
 *  opacity: <float>,
 *
 *  map: new THREE.Texture( <Image> ),
 *
 *  lightMap: new THREE.Texture( <Image> ),
 *
 *  bumpMap: new THREE.Texture( <Image> ),
 *  bumpScale: <float>,
 *
 *  normalMap: new THREE.Texture( <Image> ),
 *  normalScale: <Vector2>,
 *
 *  specularMap: new THREE.Texture( <Image> ),
 *
 *  envMap: new THREE.TextureCube( [posx, negx, posy, negy, posz, negz] ),
 *  combine: THREE.Multiply,
 *  reflectivity: <float>,
 *  refractionRatio: <float>,
 *
 *  shading: THREE.SmoothShading,
 *  blending: THREE.NormalBlending,
 *  depthTest: <bool>,
 *  depthWrite: <bool>,
 *
 *  wireframe: <boolean>,
 *  wireframeLinewidth: <float>,
 *
 *  vertexColors: THREE.NoColors / THREE.VertexColors / THREE.FaceColors,
 *
 *  skinning: <bool>,
 *  morphTargets: <bool>,
 *  morphNormals: <bool>,
 *
 *	fog: <bool>
 * }
 */

THREE.MeshPhongMaterial = function ( parameters ) {

	THREE.Material.call( this );

	this.color = new THREE.Color( 0xffffff ); // diffuse
	this.ambient = new THREE.Color( 0xffffff );
	this.emissive = new THREE.Color( 0x000000 );
	this.specular = new THREE.Color( 0x111111 );
	this.shininess = 30;

	this.metal = false;
	this.perPixel = true;

	this.wrapAround = false;
	this.wrapRGB = new THREE.Vector3( 1, 1, 1 );

	this.map = null;

	this.lightMap = null;

	this.bumpMap = null;
	this.bumpScale = 1;

	this.normalMap = null;
	this.normalScale = new THREE.Vector2( 1, 1 );

	this.specularMap = null;

	this.envMap = null;
	this.combine = THREE.MultiplyOperation;
	this.reflectivity = 1;
	this.refractionRatio = 0.98;

	this.fog = true;

	this.shading = THREE.SmoothShading;

	this.wireframe = false;
	this.wireframeLinewidth = 1;
	this.wireframeLinecap = 'round';
	this.wireframeLinejoin = 'round';

	this.vertexColors = THREE.NoColors;

	this.skinning = false;
	this.morphTargets = false;
	this.morphNormals = false;

	this.setValues( parameters );

};

THREE.MeshPhongMaterial.prototype = Object.create( THREE.Material.prototype );

THREE.MeshPhongMaterial.prototype.clone = function () {

	var material = new THREE.MeshPhongMaterial();

	THREE.Material.prototype.clone.call( this, material );

	material.color.copy( this.color );
	material.ambient.copy( this.ambient );
	material.emissive.copy( this.emissive );
	material.specular.copy( this.specular );
	material.shininess = this.shininess;

	material.metal = this.metal;
	material.perPixel = this.perPixel;

	material.wrapAround = this.wrapAround;
	material.wrapRGB.copy( this.wrapRGB );

	material.map = this.map;

	material.lightMap = this.lightMap;

	material.bumpMap = this.bumpMap;
	material.bumpScale = this.bumpScale;

	material.normalMap = this.normalMap;
	material.normalScale.copy( this.normalScale );

	material.specularMap = this.specularMap;

	material.envMap = this.envMap;
	material.combine = this.combine;
	material.reflectivity = this.reflectivity;
	material.refractionRatio = this.refractionRatio;

	material.fog = this.fog;

	material.shading = this.shading;

	material.wireframe = this.wireframe;
	material.wireframeLinewidth = this.wireframeLinewidth;
	material.wireframeLinecap = this.wireframeLinecap;
	material.wireframeLinejoin = this.wireframeLinejoin;

	material.vertexColors = this.vertexColors;

	material.skinning = this.skinning;
	material.morphTargets = this.morphTargets;
	material.morphNormals = this.morphNormals;

	return material;

};

/**
 * @author mrdoob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 *
 * parameters = {
 *  opacity: <float>,
 *
 *  blending: THREE.NormalBlending,
 *  depthTest: <bool>,
 *  depthWrite: <bool>,
 *
 *  wireframe: <boolean>,
 *  wireframeLinewidth: <float>
 * }
 */

THREE.MeshDepthMaterial = function ( parameters ) {

	THREE.Material.call( this );

	this.wireframe = false;
	this.wireframeLinewidth = 1;

	this.setValues( parameters );

};

THREE.MeshDepthMaterial.prototype = Object.create( THREE.Material.prototype );

THREE.MeshDepthMaterial.prototype.clone = function () {

	var material = new THREE.MeshDepthMaterial();

	THREE.Material.prototype.clone.call( this, material );

	material.wireframe = this.wireframe;
	material.wireframeLinewidth = this.wireframeLinewidth;

	return material;

};

/**
 * @author mrdoob / http://mrdoob.com/
 *
 * parameters = {
 *  opacity: <float>,
 *
 *  shading: THREE.FlatShading,
 *  blending: THREE.NormalBlending,
 *  depthTest: <bool>,
 *  depthWrite: <bool>,
 *
 *  wireframe: <boolean>,
 *  wireframeLinewidth: <float>
 * }
 */

THREE.MeshNormalMaterial = function ( parameters ) {

	THREE.Material.call( this, parameters );

	this.shading = THREE.FlatShading;

	this.wireframe = false;
	this.wireframeLinewidth = 1;

	this.morphTargets = false;

	this.setValues( parameters );

};

THREE.MeshNormalMaterial.prototype = Object.create( THREE.Material.prototype );

THREE.MeshNormalMaterial.prototype.clone = function () {

	var material = new THREE.MeshNormalMaterial();

	THREE.Material.prototype.clone.call( this, material );

	material.shading = this.shading;

	material.wireframe = this.wireframe;
	material.wireframeLinewidth = this.wireframeLinewidth;

	return material;

};

/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.MeshFaceMaterial = function ( materials ) {

	this.materials = materials instanceof Array ? materials : [];

};

THREE.MeshFaceMaterial.prototype.clone = function () {

	var material = new THREE.MeshFaceMaterial();

	for ( var i = 0; i < this.materials.length; i ++ ) {

		material.materials.push( this.materials[ i ].clone() );

	}

	return material;

};

/**
 * @author mrdoob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 *
 * parameters = {
 *  color: <hex>,
 *  opacity: <float>,
 *  map: new THREE.Texture( <Image> ),
 *
 *  size: <float>,
 *
 *  blending: THREE.NormalBlending,
 *  depthTest: <bool>,
 *  depthWrite: <bool>,
 *
 *  vertexColors: <bool>,
 *
 *  fog: <bool>
 * }
 */

THREE.ParticleSystemMaterial = function ( parameters ) {

	THREE.Material.call( this );

	this.color = new THREE.Color( 0xffffff );

	this.map = null;

	this.size = 1;
	this.sizeAttenuation = true;

	this.vertexColors = false;

	this.fog = true;

	this.setValues( parameters );

};

THREE.ParticleSystemMaterial.prototype = Object.create( THREE.Material.prototype );

THREE.ParticleSystemMaterial.prototype.clone = function () {

	var material = new THREE.ParticleSystemMaterial();

	THREE.Material.prototype.clone.call( this, material );

	material.color.copy( this.color );

	material.map = this.map;

	material.size = this.size;
	material.sizeAttenuation = this.sizeAttenuation;

	material.vertexColors = this.vertexColors;

	material.fog = this.fog;

	return material;

};

// backwards compatibility

THREE.ParticleBasicMaterial = THREE.ParticleSystemMaterial;

/**
 * @author alteredq / http://alteredqualia.com/
 *
 * parameters = {
 *  fragmentShader: <string>,
 *  vertexShader: <string>,
 *
 *  uniforms: { "parameter1": { type: "f", value: 1.0 }, "parameter2": { type: "i" value2: 2 } },
 *
 *  defines: { "label" : "value" },
 *
 *  shading: THREE.SmoothShading,
 *  blending: THREE.NormalBlending,
 *  depthTest: <bool>,
 *  depthWrite: <bool>,
 *
 *  wireframe: <boolean>,
 *  wireframeLinewidth: <float>,
 *
 *  lights: <bool>,
 *
 *  vertexColors: THREE.NoColors / THREE.VertexColors / THREE.FaceColors,
 *
 *  skinning: <bool>,
 *  morphTargets: <bool>,
 *  morphNormals: <bool>,
 *
 *	fog: <bool>
 * }
 */

THREE.ShaderMaterial = function ( parameters ) {

	THREE.Material.call( this );

	this.fragmentShader = "void main() {}";
	this.vertexShader = "void main() {}";
	this.uniforms = {};
	this.defines = {};
	this.attributes = null;

	this.shading = THREE.SmoothShading;

	this.linewidth = 1;

	this.wireframe = false;
	this.wireframeLinewidth = 1;

	this.fog = false; // set to use scene fog

	this.lights = false; // set to use scene lights

	this.vertexColors = THREE.NoColors; // set to use "color" attribute stream

	this.skinning = false; // set to use skinning attribute streams

	this.morphTargets = false; // set to use morph targets
	this.morphNormals = false; // set to use morph normals

	// When rendered geometry doesn't include these attributes but the material does,
	// use these default values in WebGL. This avoids errors when buffer data is missing.
	this.defaultAttributeValues = {
		"color" : [ 1, 1, 1],
		"uv" : [ 0, 0 ],
		"uv2" : [ 0, 0 ]
	};

	// By default, bind position to attribute index 0. In WebGL, attribute 0
	// should always be used to avoid potentially expensive emulation.
	this.index0AttributeName = "position";

	this.setValues( parameters );

};

THREE.ShaderMaterial.prototype = Object.create( THREE.Material.prototype );

THREE.ShaderMaterial.prototype.clone = function () {

	var material = new THREE.ShaderMaterial();

	THREE.Material.prototype.clone.call( this, material );

	material.fragmentShader = this.fragmentShader;
	material.vertexShader = this.vertexShader;

	material.uniforms = THREE.UniformsUtils.clone( this.uniforms );

	material.attributes = this.attributes;
	material.defines = this.defines;

	material.shading = this.shading;

	material.wireframe = this.wireframe;
	material.wireframeLinewidth = this.wireframeLinewidth;

	material.fog = this.fog;

	material.lights = this.lights;

	material.vertexColors = this.vertexColors;

	material.skinning = this.skinning;

	material.morphTargets = this.morphTargets;
	material.morphNormals = this.morphNormals;

	return material;

};

/**
 * @author alteredq / http://alteredqualia.com/
 *
 * parameters = {
 *  color: <hex>,
 *  opacity: <float>,
 *  map: new THREE.Texture( <Image> ),
 *
 *  blending: THREE.NormalBlending,
 *  depthTest: <bool>,
 *  depthWrite: <bool>,
 *
 *	uvOffset: new THREE.Vector2(),
 *	uvScale: new THREE.Vector2(),
 *
 *  fog: <bool>
 * }
 */

THREE.SpriteMaterial = function ( parameters ) {

	THREE.Material.call( this );

	// defaults

	this.color = new THREE.Color( 0xffffff );
	this.map = null;

	this.rotation = 0;

	this.fog = false;

	// set parameters

	this.setValues( parameters );

};

THREE.SpriteMaterial.prototype = Object.create( THREE.Material.prototype );

THREE.SpriteMaterial.prototype.clone = function () {

	var material = new THREE.SpriteMaterial();

	THREE.Material.prototype.clone.call( this, material );

	material.color.copy( this.color );
	material.map = this.map;

	material.rotation = this.rotation;

	material.fog = this.fog;

	return material;

};

/**
 * @author mrdoob / http://mrdoob.com/
 *
 * parameters = {
 *  color: <hex>,
 *  program: <function>,
 *  opacity: <float>,
 *  blending: THREE.NormalBlending
 * }
 */

THREE.SpriteCanvasMaterial = function ( parameters ) {

	THREE.Material.call( this );

	this.color = new THREE.Color( 0xffffff );
	this.program = function ( context, color ) {};

	this.setValues( parameters );

};

THREE.SpriteCanvasMaterial.prototype = Object.create( THREE.Material.prototype );

THREE.SpriteCanvasMaterial.prototype.clone = function () {

	var material = new THREE.SpriteCanvasMaterial();

	THREE.Material.prototype.clone.call( this, material );

	material.color.copy( this.color );
	material.program = this.program;

	return material;

};

// backwards compatibility

THREE.ParticleCanvasMaterial = THREE.SpriteCanvasMaterial;
/**
 * @author mrdoob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 * @author szimek / https://github.com/szimek/
 */

THREE.Texture = function ( image, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy ) {

	this.id = THREE.TextureIdCount ++;
	this.uuid = THREE.Math.generateUUID();

	this.name = '';

	this.image = image;
	this.mipmaps = [];

	this.mapping = mapping !== undefined ? mapping : new THREE.UVMapping();

	this.wrapS = wrapS !== undefined ? wrapS : THREE.ClampToEdgeWrapping;
	this.wrapT = wrapT !== undefined ? wrapT : THREE.ClampToEdgeWrapping;

	this.magFilter = magFilter !== undefined ? magFilter : THREE.LinearFilter;
	this.minFilter = minFilter !== undefined ? minFilter : THREE.LinearMipMapLinearFilter;

	this.anisotropy = anisotropy !== undefined ? anisotropy : 1;

	this.format = format !== undefined ? format : THREE.RGBAFormat;
	this.type = type !== undefined ? type : THREE.UnsignedByteType;

	this.offset = new THREE.Vector2( 0, 0 );
	this.repeat = new THREE.Vector2( 1, 1 );

	this.generateMipmaps = true;
	this.premultiplyAlpha = false;
	this.flipY = true;
	this.unpackAlignment = 4; // valid values: 1, 2, 4, 8 (see http://www.khronos.org/opengles/sdk/docs/man/xhtml/glPixelStorei.xml)

	this._needsUpdate = false;
	this.onUpdate = null;

};

THREE.Texture.prototype = {

	constructor: THREE.Texture,

	get needsUpdate () {

		return this._needsUpdate;

	},

	set needsUpdate ( value ) {

		if ( value === true ) this.update();

		this._needsUpdate = value;

	},

	clone: function ( texture ) {

		if ( texture === undefined ) texture = new THREE.Texture();

		texture.image = this.image;
		texture.mipmaps = this.mipmaps.slice(0);

		texture.mapping = this.mapping;

		texture.wrapS = this.wrapS;
		texture.wrapT = this.wrapT;

		texture.magFilter = this.magFilter;
		texture.minFilter = this.minFilter;

		texture.anisotropy = this.anisotropy;

		texture.format = this.format;
		texture.type = this.type;

		texture.offset.copy( this.offset );
		texture.repeat.copy( this.repeat );

		texture.generateMipmaps = this.generateMipmaps;
		texture.premultiplyAlpha = this.premultiplyAlpha;
		texture.flipY = this.flipY;
		texture.unpackAlignment = this.unpackAlignment;

		return texture;

	},

	update: function () {

		this.dispatchEvent( { type: 'update' } );

	},

	dispose: function () {

		this.dispatchEvent( { type: 'dispose' } );

	}

};

THREE.EventDispatcher.prototype.apply( THREE.Texture.prototype );

THREE.TextureIdCount = 0;

/**
 * @author alteredq / http://alteredqualia.com/
 */

THREE.CompressedTexture = function ( mipmaps, width, height, format, type, mapping, wrapS, wrapT, magFilter, minFilter, anisotropy ) {

	THREE.Texture.call( this, null, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy );

	this.image = { width: width, height: height };
	this.mipmaps = mipmaps;

	this.generateMipmaps = false; // WebGL currently can't generate mipmaps for compressed textures, they must be embedded in DDS file

};

THREE.CompressedTexture.prototype = Object.create( THREE.Texture.prototype );

THREE.CompressedTexture.prototype.clone = function () {

	var texture = new THREE.CompressedTexture();

	THREE.Texture.prototype.clone.call( this, texture );

	return texture;

};

/**
 * @author alteredq / http://alteredqualia.com/
 */

THREE.DataTexture = function ( data, width, height, format, type, mapping, wrapS, wrapT, magFilter, minFilter, anisotropy ) {

	THREE.Texture.call( this, null, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy );

	this.image = { data: data, width: width, height: height };

};

THREE.DataTexture.prototype = Object.create( THREE.Texture.prototype );

THREE.DataTexture.prototype.clone = function () {

	var texture = new THREE.DataTexture();

	THREE.Texture.prototype.clone.call( this, texture );

	return texture;

};

/**
 * @author alteredq / http://alteredqualia.com/
 */

THREE.ParticleSystem = function ( geometry, material ) {

	THREE.Object3D.call( this );

	this.geometry = geometry !== undefined ? geometry : new THREE.Geometry();
	this.material = material !== undefined ? material : new THREE.ParticleSystemMaterial( { color: Math.random() * 0xffffff } );

	this.sortParticles = false;
	this.frustumCulled = false;

};

THREE.ParticleSystem.prototype = Object.create( THREE.Object3D.prototype );

THREE.ParticleSystem.prototype.clone = function ( object ) {

	if ( object === undefined ) object = new THREE.ParticleSystem( this.geometry, this.material );

	object.sortParticles = this.sortParticles;

	THREE.Object3D.prototype.clone.call( this, object );

	return object;

};

/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.Line = function ( geometry, material, type ) {

	THREE.Object3D.call( this );

	this.geometry = geometry !== undefined ? geometry : new THREE.Geometry();
	this.material = material !== undefined ? material : new THREE.LineBasicMaterial( { color: Math.random() * 0xffffff } );

	this.type = ( type !== undefined ) ? type : THREE.LineStrip;

};

THREE.LineStrip = 0;
THREE.LinePieces = 1;

THREE.Line.prototype = Object.create( THREE.Object3D.prototype );

THREE.Line.prototype.clone = function ( object ) {

	if ( object === undefined ) object = new THREE.Line( this.geometry, this.material, this.type );

	THREE.Object3D.prototype.clone.call( this, object );

	return object;

};

/**
 * @author mrdoob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 * @author mikael emtinger / http://gomo.se/
 * @author jonobr1 / http://jonobr1.com/
 */

THREE.Mesh = function ( geometry, material ) {

	THREE.Object3D.call( this );

	this.geometry = geometry !== undefined ? geometry : new THREE.Geometry();
	this.material = material !== undefined ? material : new THREE.MeshBasicMaterial( { color: Math.random() * 0xffffff } );

	this.updateMorphTargets();

};

THREE.Mesh.prototype = Object.create( THREE.Object3D.prototype );

THREE.Mesh.prototype.updateMorphTargets = function () {

	if ( this.geometry.morphTargets.length > 0 ) {

		this.morphTargetBase = -1;
		this.morphTargetForcedOrder = [];
		this.morphTargetInfluences = [];
		this.morphTargetDictionary = {};

		for ( var m = 0, ml = this.geometry.morphTargets.length; m < ml; m ++ ) {

			this.morphTargetInfluences.push( 0 );
			this.morphTargetDictionary[ this.geometry.morphTargets[ m ].name ] = m;

		}

	}

};

THREE.Mesh.prototype.getMorphTargetIndexByName = function ( name ) {

	if ( this.morphTargetDictionary[ name ] !== undefined ) {

		return this.morphTargetDictionary[ name ];

	}

	console.log( "THREE.Mesh.getMorphTargetIndexByName: morph target " + name + " does not exist. Returning 0." );

	return 0;

};

THREE.Mesh.prototype.clone = function ( object ) {

	if ( object === undefined ) object = new THREE.Mesh( this.geometry, this.material );

	THREE.Object3D.prototype.clone.call( this, object );

	return object;

};

/**
 * @author mikael emtinger / http://gomo.se/
 * @author alteredq / http://alteredqualia.com/
 */

THREE.Bone = function( belongsToSkin ) {

	THREE.Object3D.call( this );

	this.skin = belongsToSkin;
	this.skinMatrix = new THREE.Matrix4();

};

THREE.Bone.prototype = Object.create( THREE.Object3D.prototype );

THREE.Bone.prototype.update = function ( parentSkinMatrix, forceUpdate ) {

	// update local

	if ( this.matrixAutoUpdate ) {

		forceUpdate |= this.updateMatrix();

	}

	// update skin matrix

	if ( forceUpdate || this.matrixWorldNeedsUpdate ) {

		if( parentSkinMatrix ) {

			this.skinMatrix.multiplyMatrices( parentSkinMatrix, this.matrix );

		} else {

			this.skinMatrix.copy( this.matrix );

		}

		this.matrixWorldNeedsUpdate = false;
		forceUpdate = true;

	}

	// update children

	var child, i, l = this.children.length;

	for ( i = 0; i < l; i ++ ) {

		this.children[ i ].update( this.skinMatrix, forceUpdate );

	}

};


/**
 * @author mikael emtinger / http://gomo.se/
 * @author alteredq / http://alteredqualia.com/
 */

THREE.SkinnedMesh = function ( geometry, material, useVertexTexture ) {

	THREE.Mesh.call( this, geometry, material );

	//

	this.useVertexTexture = useVertexTexture !== undefined ? useVertexTexture : true;

	// init bones

	this.identityMatrix = new THREE.Matrix4();

	this.bones = [];
	this.boneMatrices = [];

	var b, bone, gbone, p, q, s;

	if ( this.geometry && this.geometry.bones !== undefined ) {

		for ( b = 0; b < this.geometry.bones.length; b ++ ) {

			gbone = this.geometry.bones[ b ];

			p = gbone.pos;
			q = gbone.rotq;
			s = gbone.scl;

			bone = this.addBone();

			bone.name = gbone.name;
			bone.position.set( p[0], p[1], p[2] );
			bone.quaternion.set( q[0], q[1], q[2], q[3] );

			if ( s !== undefined ) {

				bone.scale.set( s[0], s[1], s[2] );

			} else {

				bone.scale.set( 1, 1, 1 );

			}

		}

		for ( b = 0; b < this.bones.length; b ++ ) {

			gbone = this.geometry.bones[ b ];
			bone = this.bones[ b ];

			if ( gbone.parent === -1 ) {

				this.add( bone );

			} else {

				this.bones[ gbone.parent ].add( bone );

			}

		}

		//

		var nBones = this.bones.length;

		if ( this.useVertexTexture ) {

			// layout (1 matrix = 4 pixels)
			//	RGBA RGBA RGBA RGBA (=> column1, column2, column3, column4)
			//  with  8x8  pixel texture max   16 bones  (8 * 8  / 4)
			//  	 16x16 pixel texture max   64 bones (16 * 16 / 4)
			//  	 32x32 pixel texture max  256 bones (32 * 32 / 4)
			//  	 64x64 pixel texture max 1024 bones (64 * 64 / 4)

			var size;

			if ( nBones > 256 )
				size = 64;
			else if ( nBones > 64 )
				size = 32;
			else if ( nBones > 16 )
				size = 16;
			else
				size = 8;

			this.boneTextureWidth = size;
			this.boneTextureHeight = size;

			this.boneMatrices = new Float32Array( this.boneTextureWidth * this.boneTextureHeight * 4 ); // 4 floats per RGBA pixel
			this.boneTexture = new THREE.DataTexture( this.boneMatrices, this.boneTextureWidth, this.boneTextureHeight, THREE.RGBAFormat, THREE.FloatType );
			this.boneTexture.minFilter = THREE.NearestFilter;
			this.boneTexture.magFilter = THREE.NearestFilter;
			this.boneTexture.generateMipmaps = false;
			this.boneTexture.flipY = false;

		} else {

			this.boneMatrices = new Float32Array( 16 * nBones );

		}

		this.pose();

	}

};

THREE.SkinnedMesh.prototype = Object.create( THREE.Mesh.prototype );

THREE.SkinnedMesh.prototype.addBone = function( bone ) {

	if ( bone === undefined ) {

		bone = new THREE.Bone( this );

	}

	this.bones.push( bone );

	return bone;

};

THREE.SkinnedMesh.prototype.updateMatrixWorld = function () {

	var offsetMatrix = new THREE.Matrix4();

	return function ( force ) {

		this.matrixAutoUpdate && this.updateMatrix();

		// update matrixWorld

		if ( this.matrixWorldNeedsUpdate || force ) {

			if ( this.parent ) {

				this.matrixWorld.multiplyMatrices( this.parent.matrixWorld, this.matrix );

			} else {

				this.matrixWorld.copy( this.matrix );

			}

			this.matrixWorldNeedsUpdate = false;

			force = true;

		}

		// update children

		for ( var i = 0, l = this.children.length; i < l; i ++ ) {

			var child = this.children[ i ];

			if ( child instanceof THREE.Bone ) {

				child.update( this.identityMatrix, false );

			} else {

				child.updateMatrixWorld( true );

			}

		}

		// make a snapshot of the bones' rest position

		if ( this.boneInverses == undefined ) {

			this.boneInverses = [];

			for ( var b = 0, bl = this.bones.length; b < bl; b ++ ) {

				var inverse = new THREE.Matrix4();

				inverse.getInverse( this.bones[ b ].skinMatrix );

				this.boneInverses.push( inverse );

			}

		}

		// flatten bone matrices to array

		for ( var b = 0, bl = this.bones.length; b < bl; b ++ ) {

			// compute the offset between the current and the original transform;

			// TODO: we could get rid of this multiplication step if the skinMatrix
			// was already representing the offset; however, this requires some
			// major changes to the animation system

			offsetMatrix.multiplyMatrices( this.bones[ b ].skinMatrix, this.boneInverses[ b ] );
			offsetMatrix.flattenToArrayOffset( this.boneMatrices, b * 16 );

		}

		if ( this.useVertexTexture ) {

			this.boneTexture.needsUpdate = true;

		}

	};

}();

THREE.SkinnedMesh.prototype.pose = function () {

	this.updateMatrixWorld( true );

	this.normalizeSkinWeights();

};

THREE.SkinnedMesh.prototype.normalizeSkinWeights = function () {

	if ( this.geometry instanceof THREE.Geometry ) {

		for ( var i = 0; i < this.geometry.skinIndices.length; i ++ ) {

			var sw = this.geometry.skinWeights[ i ];

			var scale = 1.0 / sw.lengthManhattan();

			if ( scale !== Infinity ) {

				sw.multiplyScalar( scale );

			} else {

				sw.set( 1 ); // this will be normalized by the shader anyway

			}

		}

	} else {

		// skinning weights assumed to be normalized for THREE.BufferGeometry

	}

};

THREE.SkinnedMesh.prototype.clone = function ( object ) {

	if ( object === undefined ) {

		object = new THREE.SkinnedMesh( this.geometry, this.material, this.useVertexTexture );

	}

	THREE.Mesh.prototype.clone.call( this, object );

	return object;

};

/**
 * @author alteredq / http://alteredqualia.com/
 */

THREE.MorphAnimMesh = function ( geometry, material ) {

	THREE.Mesh.call( this, geometry, material );

	// API

	this.duration = 1000; // milliseconds
	this.mirroredLoop = false;
	this.time = 0;

	// internals

	this.lastKeyframe = 0;
	this.currentKeyframe = 0;

	this.direction = 1;
	this.directionBackwards = false;

	this.setFrameRange( 0, this.geometry.morphTargets.length - 1 );

};

THREE.MorphAnimMesh.prototype = Object.create( THREE.Mesh.prototype );

THREE.MorphAnimMesh.prototype.setFrameRange = function ( start, end ) {

	this.startKeyframe = start;
	this.endKeyframe = end;

	this.length = this.endKeyframe - this.startKeyframe + 1;

};

THREE.MorphAnimMesh.prototype.setDirectionForward = function () {

	this.direction = 1;
	this.directionBackwards = false;

};

THREE.MorphAnimMesh.prototype.setDirectionBackward = function () {

	this.direction = -1;
	this.directionBackwards = true;

};

THREE.MorphAnimMesh.prototype.parseAnimations = function () {

	var geometry = this.geometry;

	if ( ! geometry.animations ) geometry.animations = {};

	var firstAnimation, animations = geometry.animations;

	var pattern = /([a-z]+)(\d+)/;

	for ( var i = 0, il = geometry.morphTargets.length; i < il; i ++ ) {

		var morph = geometry.morphTargets[ i ];
		var parts = morph.name.match( pattern );

		if ( parts && parts.length > 1 ) {

			var label = parts[ 1 ];
			var num = parts[ 2 ];

			if ( ! animations[ label ] ) animations[ label ] = { start: Infinity, end: -Infinity };

			var animation = animations[ label ];

			if ( i < animation.start ) animation.start = i;
			if ( i > animation.end ) animation.end = i;

			if ( ! firstAnimation ) firstAnimation = label;

		}

	}

	geometry.firstAnimation = firstAnimation;

};

THREE.MorphAnimMesh.prototype.setAnimationLabel = function ( label, start, end ) {

	if ( ! this.geometry.animations ) this.geometry.animations = {};

	this.geometry.animations[ label ] = { start: start, end: end };

};

THREE.MorphAnimMesh.prototype.playAnimation = function ( label, fps ) {

	var animation = this.geometry.animations[ label ];

	if ( animation ) {

		this.setFrameRange( animation.start, animation.end );
		this.duration = 1000 * ( ( animation.end - animation.start ) / fps );
		this.time = 0;

	} else {

		console.warn( "animation[" + label + "] undefined" );

	}

};

THREE.MorphAnimMesh.prototype.updateAnimation = function ( delta ) {

	var frameTime = this.duration / this.length;

	this.time += this.direction * delta;

	if ( this.mirroredLoop ) {

		if ( this.time > this.duration || this.time < 0 ) {

			this.direction *= -1;

			if ( this.time > this.duration ) {

				this.time = this.duration;
				this.directionBackwards = true;

			}

			if ( this.time < 0 ) {

				this.time = 0;
				this.directionBackwards = false;

			}

		}

	} else {

		this.time = this.time % this.duration;

		if ( this.time < 0 ) this.time += this.duration;

	}

	var keyframe = this.startKeyframe + THREE.Math.clamp( Math.floor( this.time / frameTime ), 0, this.length - 1 );

	if ( keyframe !== this.currentKeyframe ) {

		this.morphTargetInfluences[ this.lastKeyframe ] = 0;
		this.morphTargetInfluences[ this.currentKeyframe ] = 1;

		this.morphTargetInfluences[ keyframe ] = 0;

		this.lastKeyframe = this.currentKeyframe;
		this.currentKeyframe = keyframe;

	}

	var mix = ( this.time % frameTime ) / frameTime;

	if ( this.directionBackwards ) {

		mix = 1 - mix;

	}

	this.morphTargetInfluences[ this.currentKeyframe ] = mix;
	this.morphTargetInfluences[ this.lastKeyframe ] = 1 - mix;

};

THREE.MorphAnimMesh.prototype.clone = function ( object ) {

	if ( object === undefined ) object = new THREE.MorphAnimMesh( this.geometry, this.material );

	object.duration = this.duration;
	object.mirroredLoop = this.mirroredLoop;
	object.time = this.time;

	object.lastKeyframe = this.lastKeyframe;
	object.currentKeyframe = this.currentKeyframe;

	object.direction = this.direction;
	object.directionBackwards = this.directionBackwards;

	THREE.Mesh.prototype.clone.call( this, object );

	return object;

};

/**
 * @author mikael emtinger / http://gomo.se/
 * @author alteredq / http://alteredqualia.com/
 * @author mrdoob / http://mrdoob.com/
 */

THREE.LOD = function () {

	THREE.Object3D.call( this );

	this.objects = [];

};


THREE.LOD.prototype = Object.create( THREE.Object3D.prototype );

THREE.LOD.prototype.addLevel = function ( object, distance ) {

	if ( distance === undefined ) distance = 0;

	distance = Math.abs( distance );

	for ( var l = 0; l < this.objects.length; l ++ ) {

		if ( distance < this.objects[ l ].distance ) {

			break;

		}

	}

	this.objects.splice( l, 0, { distance: distance, object: object } );
	this.add( object );

};

THREE.LOD.prototype.getObjectForDistance = function ( distance ) {

	for ( var i = 1, l = this.objects.length; i < l; i ++ ) {

		if ( distance < this.objects[ i ].distance ) {

			break;

		}

	}

	return this.objects[ i - 1 ].object;

};

THREE.LOD.prototype.update = function () {

	var v1 = new THREE.Vector3();
	var v2 = new THREE.Vector3();

	return function ( camera ) {

		if ( this.objects.length > 1 ) {

			v1.setFromMatrixPosition( camera.matrixWorld );
			v2.setFromMatrixPosition( this.matrixWorld );

			var distance = v1.distanceTo( v2 );

			this.objects[ 0 ].object.visible = true;

			for ( var i = 1, l = this.objects.length; i < l; i ++ ) {

				if ( distance >= this.objects[ i ].distance ) {

					this.objects[ i - 1 ].object.visible = false;
					this.objects[ i     ].object.visible = true;

				} else {

					break;

				}

			}

			for( ; i < l; i ++ ) {

				this.objects[ i ].object.visible = false;

			}

		}

	};

}();

THREE.LOD.prototype.clone = function () {

	// TODO

};

/**
 * @author mikael emtinger / http://gomo.se/
 * @author alteredq / http://alteredqualia.com/
 */

THREE.Sprite = function ( material ) {

	THREE.Object3D.call( this );

	this.material = ( material !== undefined ) ? material : new THREE.SpriteMaterial();

};

THREE.Sprite.prototype = Object.create( THREE.Object3D.prototype );

/*
 * Custom update matrix
 */

THREE.Sprite.prototype.updateMatrix = function () {

	this.matrix.compose( this.position, this.quaternion, this.scale );

	this.matrixWorldNeedsUpdate = true;

};

THREE.Sprite.prototype.clone = function ( object ) {

	if ( object === undefined ) object = new THREE.Sprite( this.material );

	THREE.Object3D.prototype.clone.call( this, object );

	return object;

};

// Backwards compatibility

THREE.Particle = THREE.Sprite;
/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.Scene = function () {

	THREE.Object3D.call( this );

	this.fog = null;
	this.overrideMaterial = null;

	this.autoUpdate = true; // checked by the renderer
	this.matrixAutoUpdate = false;

	this.__lights = [];

	this.__objectsAdded = [];
	this.__objectsRemoved = [];

};

THREE.Scene.prototype = Object.create( THREE.Object3D.prototype );

THREE.Scene.prototype.__addObject = function ( object ) {

	if ( object instanceof THREE.Light ) {

		if ( this.__lights.indexOf( object ) === - 1 ) {

			this.__lights.push( object );

		}

		if ( object.target && object.target.parent === undefined ) {

			this.add( object.target );

		}

	} else if ( !( object instanceof THREE.Camera || object instanceof THREE.Bone ) ) {

		this.__objectsAdded.push( object );

		// check if previously removed

		var i = this.__objectsRemoved.indexOf( object );

		if ( i !== -1 ) {

			this.__objectsRemoved.splice( i, 1 );

		}

	}

	this.dispatchEvent( { type: 'objectAdded', object: object } );
	object.dispatchEvent( { type: 'addedToScene', scene: this } );

	for ( var c = 0; c < object.children.length; c ++ ) {

		this.__addObject( object.children[ c ] );

	}

};

THREE.Scene.prototype.__removeObject = function ( object ) {

	if ( object instanceof THREE.Light ) {

		var i = this.__lights.indexOf( object );

		if ( i !== -1 ) {

			this.__lights.splice( i, 1 );

		}

		if ( object.shadowCascadeArray ) {

			for ( var x = 0; x < object.shadowCascadeArray.length; x ++ ) {

				this.__removeObject( object.shadowCascadeArray[ x ] );

			}

		}

	} else if ( !( object instanceof THREE.Camera ) ) {

		this.__objectsRemoved.push( object );

		// check if previously added

		var i = this.__objectsAdded.indexOf( object );

		if ( i !== -1 ) {

			this.__objectsAdded.splice( i, 1 );

		}

	}

	this.dispatchEvent( { type: 'objectRemoved', object: object } );
	object.dispatchEvent( { type: 'removedFromScene', scene: this } );

	for ( var c = 0; c < object.children.length; c ++ ) {

		this.__removeObject( object.children[ c ] );

	}

};

THREE.Scene.prototype.clone = function ( object ) {

	if ( object === undefined ) object = new THREE.Scene();

	THREE.Object3D.prototype.clone.call(this, object);

	if ( this.fog !== null ) object.fog = this.fog.clone();
	if ( this.overrideMaterial !== null ) object.overrideMaterial = this.overrideMaterial.clone();

	object.autoUpdate = this.autoUpdate;
	object.matrixAutoUpdate = this.matrixAutoUpdate;

	return object;

};

/**
 * @author mrdoob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 */

THREE.Fog = function ( hex, near, far ) {

	this.name = '';

	this.color = new THREE.Color( hex );

	this.near = ( near !== undefined ) ? near : 1;
	this.far = ( far !== undefined ) ? far : 1000;

};

THREE.Fog.prototype.clone = function () {

	return new THREE.Fog( this.color.getHex(), this.near, this.far );

};

/**
 * @author mrdoob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 */

THREE.FogExp2 = function ( hex, density ) {

	this.name = '';

	this.color = new THREE.Color( hex );
	this.density = ( density !== undefined ) ? density : 0.00025;

};

THREE.FogExp2.prototype.clone = function () {

	return new THREE.FogExp2( this.color.getHex(), this.density );

};

/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.CanvasRenderer = function ( parameters ) {

//	console.log( 'THREE.CanvasRenderer', THREE.REVISION );

	var smoothstep = THREE.Math.smoothstep;

	parameters = parameters || {};

	var _this = this,
	_renderData, _elements, _lights,
	_projector = new THREE.Projector(),

	_canvas = parameters.canvas !== undefined
			? parameters.canvas
			: document.createElement( 'canvas' ),

	_canvasWidth = _canvas.width,
	_canvasHeight = _canvas.height,
	_canvasWidthHalf = Math.floor( _canvasWidth / 2 ),
	_canvasHeightHalf = Math.floor( _canvasHeight / 2 ),

	_context = _canvas.getContext( '2d' ),

	_clearColor = new THREE.Color( 0x000000 ),
	_clearAlpha = 0,

	_contextGlobalAlpha = 1,
	_contextGlobalCompositeOperation = 0,
	_contextStrokeStyle = null,
	_contextFillStyle = null,
	_contextLineWidth = null,
	_contextLineCap = null,
	_contextLineJoin = null,
	_contextDashSize = null,
	_contextGapSize = 0,

	_camera,

	_v1, _v2, _v3, _v4,
	_v5 = new THREE.RenderableVertex(),
	_v6 = new THREE.RenderableVertex(),

	_v1x, _v1y, _v2x, _v2y, _v3x, _v3y,
	_v4x, _v4y, _v5x, _v5y, _v6x, _v6y,

	_color = new THREE.Color(),
	_color1 = new THREE.Color(),
	_color2 = new THREE.Color(),
	_color3 = new THREE.Color(),
	_color4 = new THREE.Color(),

	_diffuseColor = new THREE.Color(),
	_emissiveColor = new THREE.Color(),

	_lightColor = new THREE.Color(),

	_patterns = {},

	_near, _far,

	_image, _uvs,
	_uv1x, _uv1y, _uv2x, _uv2y, _uv3x, _uv3y,

	_clipBox = new THREE.Box2(),
	_clearBox = new THREE.Box2(),
	_elemBox = new THREE.Box2(),

	_ambientLight = new THREE.Color(),
	_directionalLights = new THREE.Color(),
	_pointLights = new THREE.Color(),

	_vector3 = new THREE.Vector3(), // Needed for PointLight

	_pixelMap, _pixelMapContext, _pixelMapImage, _pixelMapData,
	_gradientMap, _gradientMapContext, _gradientMapQuality = 16;

	_pixelMap = document.createElement( 'canvas' );
	_pixelMap.width = _pixelMap.height = 2;

	_pixelMapContext = _pixelMap.getContext( '2d' );
	_pixelMapContext.fillStyle = 'rgba(0,0,0,1)';
	_pixelMapContext.fillRect( 0, 0, 2, 2 );

	_pixelMapImage = _pixelMapContext.getImageData( 0, 0, 2, 2 );
	_pixelMapData = _pixelMapImage.data;

	_gradientMap = document.createElement( 'canvas' );
	_gradientMap.width = _gradientMap.height = _gradientMapQuality;

	_gradientMapContext = _gradientMap.getContext( '2d' );
	_gradientMapContext.translate( - _gradientMapQuality / 2, - _gradientMapQuality / 2 );
	_gradientMapContext.scale( _gradientMapQuality, _gradientMapQuality );

	_gradientMapQuality --; // Fix UVs

	// dash+gap fallbacks for Firefox and everything else

	if ( _context.setLineDash === undefined ) {

		if ( _context.mozDash !== undefined ) {

			_context.setLineDash = function ( values ) {

				_context.mozDash = values[ 0 ] !== null ? values : null;

			}

		} else {

			_context.setLineDash = function () {}

		}

	}

	this.domElement = _canvas;

	this.devicePixelRatio = parameters.devicePixelRatio !== undefined
				? parameters.devicePixelRatio
				: self.devicePixelRatio !== undefined
					? self.devicePixelRatio
					: 1;

	this.autoClear = true;
	this.sortObjects = true;
	this.sortElements = true;

	this.info = {

		render: {

			vertices: 0,
			faces: 0

		}

	}

	// WebGLRenderer compatibility

	this.supportsVertexTextures = function () {};
	this.setFaceCulling = function () {};

	this.setSize = function ( width, height, updateStyle ) {

		_canvasWidth = width * this.devicePixelRatio;
		_canvasHeight = height * this.devicePixelRatio;

		_canvasWidthHalf = Math.floor( _canvasWidth / 2 );
		_canvasHeightHalf = Math.floor( _canvasHeight / 2 );

		_canvas.width = _canvasWidth;
		_canvas.height = _canvasHeight;

		if ( this.devicePixelRatio !== 1 && updateStyle !== false ) {

			_canvas.style.width = width + 'px';
			_canvas.style.height = height + 'px';

		}

		_clipBox.set(
			new THREE.Vector2( - _canvasWidthHalf, - _canvasHeightHalf ),
			new THREE.Vector2( _canvasWidthHalf, _canvasHeightHalf )
		);

		_clearBox.set(
			new THREE.Vector2( - _canvasWidthHalf, - _canvasHeightHalf ),
			new THREE.Vector2( _canvasWidthHalf, _canvasHeightHalf )
		);

		_contextGlobalAlpha = 1;
		_contextGlobalCompositeOperation = 0;
		_contextStrokeStyle = null;
		_contextFillStyle = null;
		_contextLineWidth = null;
		_contextLineCap = null;
		_contextLineJoin = null;

	};

	this.setClearColor = function ( color, alpha ) {

		_clearColor.set( color );
		_clearAlpha = alpha !== undefined ? alpha : 1;

		_clearBox.set(
			new THREE.Vector2( - _canvasWidthHalf, - _canvasHeightHalf ),
			new THREE.Vector2( _canvasWidthHalf, _canvasHeightHalf )
		);

	};

	this.setClearColorHex = function ( hex, alpha ) {

		console.warn( 'DEPRECATED: .setClearColorHex() is being removed. Use .setClearColor() instead.' );
		this.setClearColor( hex, alpha );

	};

	this.getMaxAnisotropy = function () {

		return 0;

	};

	this.clear = function () {

		_context.setTransform( 1, 0, 0, - 1, _canvasWidthHalf, _canvasHeightHalf );

		if ( _clearBox.empty() === false ) {

			_clearBox.intersect( _clipBox );
			_clearBox.expandByScalar( 2 );

			if ( _clearAlpha < 1 ) {

				_context.clearRect(
					_clearBox.min.x | 0,
					_clearBox.min.y | 0,
					( _clearBox.max.x - _clearBox.min.x ) | 0,
					( _clearBox.max.y - _clearBox.min.y ) | 0
				);

			}

			if ( _clearAlpha > 0 ) {

				setBlending( THREE.NormalBlending );
				setOpacity( 1 );

				setFillStyle( 'rgba(' + Math.floor( _clearColor.r * 255 ) + ',' + Math.floor( _clearColor.g * 255 ) + ',' + Math.floor( _clearColor.b * 255 ) + ',' + _clearAlpha + ')' );

				_context.fillRect(
					_clearBox.min.x | 0,
					_clearBox.min.y | 0,
					( _clearBox.max.x - _clearBox.min.x ) | 0,
					( _clearBox.max.y - _clearBox.min.y ) | 0
				);

			}

			_clearBox.makeEmpty();

		}

	};

	// compatibility

	this.clearColor = function () {};
	this.clearDepth = function () {};
	this.clearStencil = function () {};

	this.render = function ( scene, camera ) {

		if ( camera instanceof THREE.Camera === false ) {

			console.error( 'THREE.CanvasRenderer.render: camera is not an instance of THREE.Camera.' );
			return;

		}

		if ( this.autoClear === true ) this.clear();

		_context.setTransform( 1, 0, 0, - 1, _canvasWidthHalf, _canvasHeightHalf );

		_this.info.render.vertices = 0;
		_this.info.render.faces = 0;

		_renderData = _projector.projectScene( scene, camera, this.sortObjects, this.sortElements );
		_elements = _renderData.elements;
		_lights = _renderData.lights;
		_camera = camera;

		/* DEBUG
		setFillStyle( 'rgba( 0, 255, 255, 0.5 )' );
		_context.fillRect( _clipBox.min.x, _clipBox.min.y, _clipBox.max.x - _clipBox.min.x, _clipBox.max.y - _clipBox.min.y );
		*/

		calculateLights();

		for ( var e = 0, el = _elements.length; e < el; e++ ) {

			var element = _elements[ e ];

			var material = element.material;

			if ( material === undefined || material.visible === false ) continue;

			_elemBox.makeEmpty();

			if ( element instanceof THREE.RenderableSprite ) {

				_v1 = element;
				_v1.x *= _canvasWidthHalf; _v1.y *= _canvasHeightHalf;

				renderSprite( _v1, element, material );

			} else if ( element instanceof THREE.RenderableLine ) {

				_v1 = element.v1; _v2 = element.v2;

				_v1.positionScreen.x *= _canvasWidthHalf; _v1.positionScreen.y *= _canvasHeightHalf;
				_v2.positionScreen.x *= _canvasWidthHalf; _v2.positionScreen.y *= _canvasHeightHalf;

				_elemBox.setFromPoints( [
					_v1.positionScreen,
					_v2.positionScreen
				] );

				if ( _clipBox.isIntersectionBox( _elemBox ) === true ) {

					renderLine( _v1, _v2, element, material );

				}

			} else if ( element instanceof THREE.RenderableFace3 ) {

				_v1 = element.v1; _v2 = element.v2; _v3 = element.v3;

				if ( _v1.positionScreen.z < -1 || _v1.positionScreen.z > 1 ) continue;
				if ( _v2.positionScreen.z < -1 || _v2.positionScreen.z > 1 ) continue;
				if ( _v3.positionScreen.z < -1 || _v3.positionScreen.z > 1 ) continue;

				_v1.positionScreen.x *= _canvasWidthHalf; _v1.positionScreen.y *= _canvasHeightHalf;
				_v2.positionScreen.x *= _canvasWidthHalf; _v2.positionScreen.y *= _canvasHeightHalf;
				_v3.positionScreen.x *= _canvasWidthHalf; _v3.positionScreen.y *= _canvasHeightHalf;

				if ( material.overdraw > 0 ) {

					expand( _v1.positionScreen, _v2.positionScreen, material.overdraw );
					expand( _v2.positionScreen, _v3.positionScreen, material.overdraw );
					expand( _v3.positionScreen, _v1.positionScreen, material.overdraw );

				}

				_elemBox.setFromPoints( [
					_v1.positionScreen,
					_v2.positionScreen,
					_v3.positionScreen
				] );

				if ( _clipBox.isIntersectionBox( _elemBox ) === true ) {

					renderFace3( _v1, _v2, _v3, 0, 1, 2, element, material );

				}

			}

			/* DEBUG
			setLineWidth( 1 );
			setStrokeStyle( 'rgba( 0, 255, 0, 0.5 )' );
			_context.strokeRect( _elemBox.min.x, _elemBox.min.y, _elemBox.max.x - _elemBox.min.x, _elemBox.max.y - _elemBox.min.y );
			*/

			_clearBox.union( _elemBox );

		}

		/* DEBUG
		setLineWidth( 1 );
		setStrokeStyle( 'rgba( 255, 0, 0, 0.5 )' );
		_context.strokeRect( _clearBox.min.x, _clearBox.min.y, _clearBox.max.x - _clearBox.min.x, _clearBox.max.y - _clearBox.min.y );
		*/

		_context.setTransform( 1, 0, 0, 1, 0, 0 );

	};

	//

	function calculateLights() {

		_ambientLight.setRGB( 0, 0, 0 );
		_directionalLights.setRGB( 0, 0, 0 );
		_pointLights.setRGB( 0, 0, 0 );

		for ( var l = 0, ll = _lights.length; l < ll; l ++ ) {

			var light = _lights[ l ];
			var lightColor = light.color;

			if ( light instanceof THREE.AmbientLight ) {

				_ambientLight.add( lightColor );

			} else if ( light instanceof THREE.DirectionalLight ) {

				// for sprites

				_directionalLights.add( lightColor );

			} else if ( light instanceof THREE.PointLight ) {

				// for sprites

				_pointLights.add( lightColor );

			}

		}

	}

	function calculateLight( position, normal, color ) {

		for ( var l = 0, ll = _lights.length; l < ll; l ++ ) {

			var light = _lights[ l ];

			_lightColor.copy( light.color );

			if ( light instanceof THREE.DirectionalLight ) {

				var lightPosition = _vector3.setFromMatrixPosition( light.matrixWorld ).normalize();

				var amount = normal.dot( lightPosition );

				if ( amount <= 0 ) continue;

				amount *= light.intensity;

				color.add( _lightColor.multiplyScalar( amount ) );

			} else if ( light instanceof THREE.PointLight ) {

				var lightPosition = _vector3.setFromMatrixPosition( light.matrixWorld );

				var amount = normal.dot( _vector3.subVectors( lightPosition, position ).normalize() );

				if ( amount <= 0 ) continue;

				amount *= light.distance == 0 ? 1 : 1 - Math.min( position.distanceTo( lightPosition ) / light.distance, 1 );

				if ( amount == 0 ) continue;

				amount *= light.intensity;

				color.add( _lightColor.multiplyScalar( amount ) );

			}

		}

	}

	function renderSprite( v1, element, material ) {

		setOpacity( material.opacity );
		setBlending( material.blending );

		var scaleX = element.scale.x * _canvasWidthHalf;
		var scaleY = element.scale.y * _canvasHeightHalf;

		var dist = 0.5 * Math.sqrt( scaleX * scaleX + scaleY * scaleY ); // allow for rotated sprite
		_elemBox.min.set( v1.x - dist, v1.y - dist );
		_elemBox.max.set( v1.x + dist, v1.y + dist );

		if ( _clipBox.isIntersectionBox( _elemBox ) === false ) {

			_elemBox.makeEmpty();
			return;

		}

		if ( material instanceof THREE.SpriteMaterial ||
			 material instanceof THREE.ParticleSystemMaterial ) { // Backwards compatibility

			var texture = material.map;

			if ( texture !== null ) {

				if ( texture.hasEventListener( 'update', onTextureUpdate ) === false ) {

					if ( texture.image !== undefined && texture.image.width > 0 ) {

						textureToPattern( texture );

					}

					texture.addEventListener( 'update', onTextureUpdate );

				}

				var pattern = _patterns[ texture.id ];

				if ( pattern !== undefined ) {

					setFillStyle( pattern );

				} else {

					setFillStyle( 'rgba( 0, 0, 0, 1 )' );

				}

				//

				var bitmap = texture.image;

				var ox = bitmap.width * texture.offset.x;
				var oy = bitmap.height * texture.offset.y;

				var sx = bitmap.width * texture.repeat.x;
				var sy = bitmap.height * texture.repeat.y;

				var cx = scaleX / sx;
				var cy = scaleY / sy;

				_context.save();
				_context.translate( v1.x, v1.y );
				if ( material.rotation !== 0 ) _context.rotate( material.rotation );
				_context.translate( - scaleX / 2, - scaleY / 2 );
				_context.scale( cx, cy );
				_context.translate( - ox, - oy );
				_context.fillRect( ox, oy, sx, sy );
				_context.restore();

			} else { // no texture

				setFillStyle( material.color.getStyle() );

				_context.save();
				_context.translate( v1.x, v1.y );
				if ( material.rotation !== 0 ) _context.rotate( material.rotation );
				_context.scale( scaleX, - scaleY );
				_context.fillRect( - 0.5, - 0.5, 1, 1 );
				_context.restore();

			}

		} else if ( material instanceof THREE.SpriteCanvasMaterial ) {

			setStrokeStyle( material.color.getStyle() );
			setFillStyle( material.color.getStyle() );

			_context.save();
			_context.translate( v1.x, v1.y );
			if ( material.rotation !== 0 ) _context.rotate( material.rotation );
			_context.scale( scaleX, scaleY );

			material.program( _context );

			_context.restore();

		}

		/* DEBUG
		setStrokeStyle( 'rgb(255,255,0)' );
		_context.beginPath();
		_context.moveTo( v1.x - 10, v1.y );
		_context.lineTo( v1.x + 10, v1.y );
		_context.moveTo( v1.x, v1.y - 10 );
		_context.lineTo( v1.x, v1.y + 10 );
		_context.stroke();
		*/

	}

	function renderLine( v1, v2, element, material ) {

		setOpacity( material.opacity );
		setBlending( material.blending );

		_context.beginPath();
		_context.moveTo( v1.positionScreen.x, v1.positionScreen.y );
		_context.lineTo( v2.positionScreen.x, v2.positionScreen.y );

		if ( material instanceof THREE.LineBasicMaterial ) {

			setLineWidth( material.linewidth );
			setLineCap( material.linecap );
			setLineJoin( material.linejoin );

			if ( material.vertexColors !== THREE.VertexColors ) {

				setStrokeStyle( material.color.getStyle() );

			} else {

				var colorStyle1 = element.vertexColors[0].getStyle();
				var colorStyle2 = element.vertexColors[1].getStyle();

				if ( colorStyle1 === colorStyle2 ) {

					setStrokeStyle( colorStyle1 );

				} else {

					try {

						var grad = _context.createLinearGradient(
							v1.positionScreen.x,
							v1.positionScreen.y,
							v2.positionScreen.x,
							v2.positionScreen.y
						);
						grad.addColorStop( 0, colorStyle1 );
						grad.addColorStop( 1, colorStyle2 );

					} catch ( exception ) {

						grad = colorStyle1;

					}

					setStrokeStyle( grad );

				}

			}

			_context.stroke();
			_elemBox.expandByScalar( material.linewidth * 2 );

		} else if ( material instanceof THREE.LineDashedMaterial ) {

			setLineWidth( material.linewidth );
			setLineCap( material.linecap );
			setLineJoin( material.linejoin );
			setStrokeStyle( material.color.getStyle() );
			setDashAndGap( material.dashSize, material.gapSize );

			_context.stroke();

			_elemBox.expandByScalar( material.linewidth * 2 );

			setDashAndGap( null, null );

		}

	}

	function renderFace3( v1, v2, v3, uv1, uv2, uv3, element, material ) {

		_this.info.render.vertices += 3;
		_this.info.render.faces ++;

		setOpacity( material.opacity );
		setBlending( material.blending );

		_v1x = v1.positionScreen.x; _v1y = v1.positionScreen.y;
		_v2x = v2.positionScreen.x; _v2y = v2.positionScreen.y;
		_v3x = v3.positionScreen.x; _v3y = v3.positionScreen.y;

		drawTriangle( _v1x, _v1y, _v2x, _v2y, _v3x, _v3y );

		if ( ( material instanceof THREE.MeshLambertMaterial || material instanceof THREE.MeshPhongMaterial ) && material.map === null ) {

			_diffuseColor.copy( material.color );
			_emissiveColor.copy( material.emissive );

			if ( material.vertexColors === THREE.FaceColors ) {

				_diffuseColor.multiply( element.color );

			}

			if ( material.wireframe === false && material.shading === THREE.SmoothShading && element.vertexNormalsLength === 3 ) {

				_color1.copy( _ambientLight );
				_color2.copy( _ambientLight );
				_color3.copy( _ambientLight );

				calculateLight( element.v1.positionWorld, element.vertexNormalsModel[ 0 ], _color1 );
				calculateLight( element.v2.positionWorld, element.vertexNormalsModel[ 1 ], _color2 );
				calculateLight( element.v3.positionWorld, element.vertexNormalsModel[ 2 ], _color3 );

				_color1.multiply( _diffuseColor ).add( _emissiveColor );
				_color2.multiply( _diffuseColor ).add( _emissiveColor );
				_color3.multiply( _diffuseColor ).add( _emissiveColor );
				_color4.addColors( _color2, _color3 ).multiplyScalar( 0.5 );

				_image = getGradientTexture( _color1, _color2, _color3, _color4 );

				clipImage( _v1x, _v1y, _v2x, _v2y, _v3x, _v3y, 0, 0, 1, 0, 0, 1, _image );

			} else {

				_color.copy( _ambientLight );

				calculateLight( element.centroidModel, element.normalModel, _color );

				_color.multiply( _diffuseColor ).add( _emissiveColor );

				material.wireframe === true
					? strokePath( _color, material.wireframeLinewidth, material.wireframeLinecap, material.wireframeLinejoin )
					: fillPath( _color );

			}

		} else if ( material instanceof THREE.MeshBasicMaterial || material instanceof THREE.MeshLambertMaterial || material instanceof THREE.MeshPhongMaterial ) {

			if ( material.map !== null ) {

				if ( material.map.mapping instanceof THREE.UVMapping ) {

					_uvs = element.uvs[ 0 ];
					patternPath( _v1x, _v1y, _v2x, _v2y, _v3x, _v3y, _uvs[ uv1 ].x, _uvs[ uv1 ].y, _uvs[ uv2 ].x, _uvs[ uv2 ].y, _uvs[ uv3 ].x, _uvs[ uv3 ].y, material.map );

				}


			} else if ( material.envMap !== null ) {

				if ( material.envMap.mapping instanceof THREE.SphericalReflectionMapping ) {

					_vector3.copy( element.vertexNormalsModelView[ uv1 ] );
					_uv1x = 0.5 * _vector3.x + 0.5;
					_uv1y = 0.5 * _vector3.y + 0.5;

					_vector3.copy( element.vertexNormalsModelView[ uv2 ] );
					_uv2x = 0.5 * _vector3.x + 0.5;
					_uv2y = 0.5 * _vector3.y + 0.5;

					_vector3.copy( element.vertexNormalsModelView[ uv3 ] );
					_uv3x = 0.5 * _vector3.x + 0.5;
					_uv3y = 0.5 * _vector3.y + 0.5;

					patternPath( _v1x, _v1y, _v2x, _v2y, _v3x, _v3y, _uv1x, _uv1y, _uv2x, _uv2y, _uv3x, _uv3y, material.envMap );

				}/* else if ( material.envMap.mapping === THREE.SphericalRefractionMapping ) {



				}*/


			} else {

				_color.copy( material.color );

				if ( material.vertexColors === THREE.FaceColors ) {

					_color.multiply( element.color );

				}

				material.wireframe === true
					? strokePath( _color, material.wireframeLinewidth, material.wireframeLinecap, material.wireframeLinejoin )
					: fillPath( _color );

			}

		} else if ( material instanceof THREE.MeshDepthMaterial ) {

			_near = _camera.near;
			_far = _camera.far;

			_color1.r = _color1.g = _color1.b = 1 - smoothstep( v1.positionScreen.z * v1.positionScreen.w, _near, _far );
			_color2.r = _color2.g = _color2.b = 1 - smoothstep( v2.positionScreen.z * v2.positionScreen.w, _near, _far );
			_color3.r = _color3.g = _color3.b = 1 - smoothstep( v3.positionScreen.z * v3.positionScreen.w, _near, _far );
			_color4.addColors( _color2, _color3 ).multiplyScalar( 0.5 );

			_image = getGradientTexture( _color1, _color2, _color3, _color4 );

			clipImage( _v1x, _v1y, _v2x, _v2y, _v3x, _v3y, 0, 0, 1, 0, 0, 1, _image );

		} else if ( material instanceof THREE.MeshNormalMaterial ) {

			var normal;

			if ( material.shading === THREE.FlatShading ) {

				normal = element.normalModelView;

				_color.setRGB( normal.x, normal.y, normal.z ).multiplyScalar( 0.5 ).addScalar( 0.5 );

				material.wireframe === true
					? strokePath( _color, material.wireframeLinewidth, material.wireframeLinecap, material.wireframeLinejoin )
					: fillPath( _color );

			} else if ( material.shading === THREE.SmoothShading ) {

				normal = element.vertexNormalsModelView[ uv1 ];
				_color1.setRGB( normal.x, normal.y, normal.z ).multiplyScalar( 0.5 ).addScalar( 0.5 );

				normal = element.vertexNormalsModelView[ uv2 ];
				_color2.setRGB( normal.x, normal.y, normal.z ).multiplyScalar( 0.5 ).addScalar( 0.5 );

				normal = element.vertexNormalsModelView[ uv3 ];
				_color3.setRGB( normal.x, normal.y, normal.z ).multiplyScalar( 0.5 ).addScalar( 0.5 );

				_color4.addColors( _color2, _color3 ).multiplyScalar( 0.5 );

				_image = getGradientTexture( _color1, _color2, _color3, _color4 );

				clipImage( _v1x, _v1y, _v2x, _v2y, _v3x, _v3y, 0, 0, 1, 0, 0, 1, _image );

			}

		}

	}

	//

	function drawTriangle( x0, y0, x1, y1, x2, y2 ) {

		_context.beginPath();
		_context.moveTo( x0, y0 );
		_context.lineTo( x1, y1 );
		_context.lineTo( x2, y2 );
		_context.closePath();

	}

	function strokePath( color, linewidth, linecap, linejoin ) {

		setLineWidth( linewidth );
		setLineCap( linecap );
		setLineJoin( linejoin );
		setStrokeStyle( color.getStyle() );

		_context.stroke();

		_elemBox.expandByScalar( linewidth * 2 );

	}

	function fillPath( color ) {

		setFillStyle( color.getStyle() );
		_context.fill();

	}

	function onTextureUpdate ( event ) {

		textureToPattern( event.target );

	}

	function textureToPattern( texture ) {

		var repeatX = texture.wrapS === THREE.RepeatWrapping;
		var repeatY = texture.wrapT === THREE.RepeatWrapping;

		var image = texture.image;

		var canvas = document.createElement( 'canvas' );
		canvas.width = image.width;
		canvas.height = image.height;

		var context = canvas.getContext( '2d' );
		context.setTransform( 1, 0, 0, - 1, 0, image.height );
		context.drawImage( image, 0, 0 );

		_patterns[ texture.id ] = _context.createPattern(
			canvas, repeatX === true && repeatY === true
				? 'repeat'
				: repeatX === true && repeatY === false
					? 'repeat-x'
					: repeatX === false && repeatY === true
						? 'repeat-y'
						: 'no-repeat'
		);

	}

	function patternPath( x0, y0, x1, y1, x2, y2, u0, v0, u1, v1, u2, v2, texture ) {

		if ( texture instanceof THREE.DataTexture ) return;

		if ( texture.hasEventListener( 'update', onTextureUpdate ) === false ) {

			if ( texture.image !== undefined && texture.image.width > 0 ) {

				textureToPattern( texture );

			}

			texture.addEventListener( 'update', onTextureUpdate );

		}

		var pattern = _patterns[ texture.id ];

		if ( pattern !== undefined ) {

			setFillStyle( pattern );

		} else {

			setFillStyle( 'rgba(0,0,0,1)' );
			_context.fill();

			return;

		}

		// http://extremelysatisfactorytotalitarianism.com/blog/?p=2120

		var a, b, c, d, e, f, det, idet,
		offsetX = texture.offset.x / texture.repeat.x,
		offsetY = texture.offset.y / texture.repeat.y,
		width = texture.image.width * texture.repeat.x,
		height = texture.image.height * texture.repeat.y;

		u0 = ( u0 + offsetX ) * width;
		v0 = ( v0 + offsetY ) * height;

		u1 = ( u1 + offsetX ) * width;
		v1 = ( v1 + offsetY ) * height;

		u2 = ( u2 + offsetX ) * width;
		v2 = ( v2 + offsetY ) * height;

		x1 -= x0; y1 -= y0;
		x2 -= x0; y2 -= y0;

		u1 -= u0; v1 -= v0;
		u2 -= u0; v2 -= v0;

		det = u1 * v2 - u2 * v1;

		if ( det === 0 ) return;

		idet = 1 / det;

		a = ( v2 * x1 - v1 * x2 ) * idet;
		b = ( v2 * y1 - v1 * y2 ) * idet;
		c = ( u1 * x2 - u2 * x1 ) * idet;
		d = ( u1 * y2 - u2 * y1 ) * idet;

		e = x0 - a * u0 - c * v0;
		f = y0 - b * u0 - d * v0;

		_context.save();
		_context.transform( a, b, c, d, e, f );
		_context.fill();
		_context.restore();

	}

	function clipImage( x0, y0, x1, y1, x2, y2, u0, v0, u1, v1, u2, v2, image ) {

		// http://extremelysatisfactorytotalitarianism.com/blog/?p=2120

		var a, b, c, d, e, f, det, idet,
		width = image.width - 1,
		height = image.height - 1;

		u0 *= width; v0 *= height;
		u1 *= width; v1 *= height;
		u2 *= width; v2 *= height;

		x1 -= x0; y1 -= y0;
		x2 -= x0; y2 -= y0;

		u1 -= u0; v1 -= v0;
		u2 -= u0; v2 -= v0;

		det = u1 * v2 - u2 * v1;

		idet = 1 / det;

		a = ( v2 * x1 - v1 * x2 ) * idet;
		b = ( v2 * y1 - v1 * y2 ) * idet;
		c = ( u1 * x2 - u2 * x1 ) * idet;
		d = ( u1 * y2 - u2 * y1 ) * idet;

		e = x0 - a * u0 - c * v0;
		f = y0 - b * u0 - d * v0;

		_context.save();
		_context.transform( a, b, c, d, e, f );
		_context.clip();
		_context.drawImage( image, 0, 0 );
		_context.restore();

	}

	function getGradientTexture( color1, color2, color3, color4 ) {

		// http://mrdoob.com/blog/post/710

		_pixelMapData[ 0 ] = ( color1.r * 255 ) | 0;
		_pixelMapData[ 1 ] = ( color1.g * 255 ) | 0;
		_pixelMapData[ 2 ] = ( color1.b * 255 ) | 0;

		_pixelMapData[ 4 ] = ( color2.r * 255 ) | 0;
		_pixelMapData[ 5 ] = ( color2.g * 255 ) | 0;
		_pixelMapData[ 6 ] = ( color2.b * 255 ) | 0;

		_pixelMapData[ 8 ] = ( color3.r * 255 ) | 0;
		_pixelMapData[ 9 ] = ( color3.g * 255 ) | 0;
		_pixelMapData[ 10 ] = ( color3.b * 255 ) | 0;

		_pixelMapData[ 12 ] = ( color4.r * 255 ) | 0;
		_pixelMapData[ 13 ] = ( color4.g * 255 ) | 0;
		_pixelMapData[ 14 ] = ( color4.b * 255 ) | 0;

		_pixelMapContext.putImageData( _pixelMapImage, 0, 0 );
		_gradientMapContext.drawImage( _pixelMap, 0, 0 );

		return _gradientMap;

	}

	// Hide anti-alias gaps

	function expand( v1, v2, pixels ) {

		var x = v2.x - v1.x, y = v2.y - v1.y,
		det = x * x + y * y, idet;

		if ( det === 0 ) return;

		idet = pixels / Math.sqrt( det );

		x *= idet; y *= idet;

		v2.x += x; v2.y += y;
		v1.x -= x; v1.y -= y;

	}

	// Context cached methods.

	function setOpacity( value ) {

		if ( _contextGlobalAlpha !== value ) {

			_context.globalAlpha = value;
			_contextGlobalAlpha = value;

		}

	}

	function setBlending( value ) {

		if ( _contextGlobalCompositeOperation !== value ) {

			if ( value === THREE.NormalBlending ) {

				_context.globalCompositeOperation = 'source-over';

			} else if ( value === THREE.AdditiveBlending ) {

				_context.globalCompositeOperation = 'lighter';

			} else if ( value === THREE.SubtractiveBlending ) {

				_context.globalCompositeOperation = 'darker';

			}

			_contextGlobalCompositeOperation = value;

		}

	}

	function setLineWidth( value ) {

		if ( _contextLineWidth !== value ) {

			_context.lineWidth = value;
			_contextLineWidth = value;

		}

	}

	function setLineCap( value ) {

		// "butt", "round", "square"

		if ( _contextLineCap !== value ) {

			_context.lineCap = value;
			_contextLineCap = value;

		}

	}

	function setLineJoin( value ) {

		// "round", "bevel", "miter"

		if ( _contextLineJoin !== value ) {

			_context.lineJoin = value;
			_contextLineJoin = value;

		}

	}

	function setStrokeStyle( value ) {

		if ( _contextStrokeStyle !== value ) {

			_context.strokeStyle = value;
			_contextStrokeStyle = value;

		}

	}

	function setFillStyle( value ) {

		if ( _contextFillStyle !== value ) {

			_context.fillStyle = value;
			_contextFillStyle = value;

		}

	}

	function setDashAndGap( dashSizeValue, gapSizeValue ) {

		if ( _contextDashSize !== dashSizeValue || _contextGapSize !== gapSizeValue ) {

			_context.setLineDash( [ dashSizeValue, gapSizeValue ] );
			_contextDashSize = dashSizeValue;
			_contextGapSize = gapSizeValue;

		}

	}

};

/**
 * Shader chunks for WebLG Shader library
 *
 * @author alteredq / http://alteredqualia.com/
 * @author mrdoob / http://mrdoob.com/
 * @author mikael emtinger / http://gomo.se/
 */

THREE.ShaderChunk = {

	// FOG

	fog_pars_fragment: [

		"#ifdef USE_FOG",

			"uniform vec3 fogColor;",

			"#ifdef FOG_EXP2",

				"uniform float fogDensity;",

			"#else",

				"uniform float fogNear;",
				"uniform float fogFar;",

			"#endif",

		"#endif"

	].join("\n"),

	fog_fragment: [

		"#ifdef USE_FOG",

			"float depth = gl_FragCoord.z / gl_FragCoord.w;",

			"#ifdef FOG_EXP2",

				"const float LOG2 = 1.442695;",
				"float fogFactor = exp2( - fogDensity * fogDensity * depth * depth * LOG2 );",
				"fogFactor = 1.0 - clamp( fogFactor, 0.0, 1.0 );",

			"#else",

				"float fogFactor = smoothstep( fogNear, fogFar, depth );",

			"#endif",

			"gl_FragColor = mix( gl_FragColor, vec4( fogColor, gl_FragColor.w ), fogFactor );",

		"#endif"

	].join("\n"),

	// ENVIRONMENT MAP

	envmap_pars_fragment: [

		"#ifdef USE_ENVMAP",

			"uniform float reflectivity;",
			"uniform samplerCube envMap;",
			"uniform float flipEnvMap;",
			"uniform int combine;",

			"#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP )",

				"uniform bool useRefract;",
				"uniform float refractionRatio;",

			"#else",

				"varying vec3 vReflect;",

			"#endif",

		"#endif"

	].join("\n"),

	envmap_fragment: [

		"#ifdef USE_ENVMAP",

			"vec3 reflectVec;",

			"#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP )",

				"vec3 cameraToVertex = normalize( vWorldPosition - cameraPosition );",

				"if ( useRefract ) {",

					"reflectVec = refract( cameraToVertex, normal, refractionRatio );",

				"} else { ",

					"reflectVec = reflect( cameraToVertex, normal );",

				"}",

			"#else",

				"reflectVec = vReflect;",

			"#endif",

			"#ifdef DOUBLE_SIDED",

				"float flipNormal = ( -1.0 + 2.0 * float( gl_FrontFacing ) );",
				"vec4 cubeColor = textureCube( envMap, flipNormal * vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );",

			"#else",

				"vec4 cubeColor = textureCube( envMap, vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );",

			"#endif",

			"#ifdef GAMMA_INPUT",

				"cubeColor.xyz *= cubeColor.xyz;",

			"#endif",

			"if ( combine == 1 ) {",

				"gl_FragColor.xyz = mix( gl_FragColor.xyz, cubeColor.xyz, specularStrength * reflectivity );",

			"} else if ( combine == 2 ) {",

				"gl_FragColor.xyz += cubeColor.xyz * specularStrength * reflectivity;",

			"} else {",

				"gl_FragColor.xyz = mix( gl_FragColor.xyz, gl_FragColor.xyz * cubeColor.xyz, specularStrength * reflectivity );",

			"}",

		"#endif"

	].join("\n"),

	envmap_pars_vertex: [

		"#if defined( USE_ENVMAP ) && ! defined( USE_BUMPMAP ) && ! defined( USE_NORMALMAP )",

			"varying vec3 vReflect;",

			"uniform float refractionRatio;",
			"uniform bool useRefract;",

		"#endif"

	].join("\n"),

	worldpos_vertex : [

		"#if defined( USE_ENVMAP ) || defined( PHONG ) || defined( LAMBERT ) || defined ( USE_SHADOWMAP )",

			"#ifdef USE_SKINNING",

				"vec4 worldPosition = modelMatrix * skinned;",

			"#endif",

			"#if defined( USE_MORPHTARGETS ) && ! defined( USE_SKINNING )",

				"vec4 worldPosition = modelMatrix * vec4( morphed, 1.0 );",

			"#endif",

			"#if ! defined( USE_MORPHTARGETS ) && ! defined( USE_SKINNING )",

				"vec4 worldPosition = modelMatrix * vec4( position, 1.0 );",

			"#endif",

		"#endif"

	].join("\n"),

	envmap_vertex : [

		"#if defined( USE_ENVMAP ) && ! defined( USE_BUMPMAP ) && ! defined( USE_NORMALMAP )",

			"vec3 worldNormal = mat3( modelMatrix[ 0 ].xyz, modelMatrix[ 1 ].xyz, modelMatrix[ 2 ].xyz ) * objectNormal;",
			"worldNormal = normalize( worldNormal );",

			"vec3 cameraToVertex = normalize( worldPosition.xyz - cameraPosition );",

			"if ( useRefract ) {",

				"vReflect = refract( cameraToVertex, worldNormal, refractionRatio );",

			"} else {",

				"vReflect = reflect( cameraToVertex, worldNormal );",

			"}",

		"#endif"

	].join("\n"),

	// COLOR MAP (particles)

	map_particle_pars_fragment: [

		"#ifdef USE_MAP",

			"uniform sampler2D map;",

		"#endif"

	].join("\n"),


	map_particle_fragment: [

		"#ifdef USE_MAP",

			"gl_FragColor = gl_FragColor * texture2D( map, vec2( gl_PointCoord.x, 1.0 - gl_PointCoord.y ) );",

		"#endif"

	].join("\n"),

	// COLOR MAP (triangles)

	map_pars_vertex: [

		"#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP )",

			"varying vec2 vUv;",
			"uniform vec4 offsetRepeat;",

		"#endif"

	].join("\n"),

	map_pars_fragment: [

		"#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP )",

			"varying vec2 vUv;",

		"#endif",

		"#ifdef USE_MAP",

			"uniform sampler2D map;",

		"#endif"

	].join("\n"),

	map_vertex: [

		"#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP )",

			"vUv = uv * offsetRepeat.zw + offsetRepeat.xy;",

		"#endif"

	].join("\n"),

	map_fragment: [

		"#ifdef USE_MAP",

			"vec4 texelColor = texture2D( map, vUv );",

			"#ifdef GAMMA_INPUT",

				"texelColor.xyz *= texelColor.xyz;",

			"#endif",

			"gl_FragColor = gl_FragColor * texelColor;",

		"#endif"

	].join("\n"),

	// LIGHT MAP

	lightmap_pars_fragment: [

		"#ifdef USE_LIGHTMAP",

			"varying vec2 vUv2;",
			"uniform sampler2D lightMap;",

		"#endif"

	].join("\n"),

	lightmap_pars_vertex: [

		"#ifdef USE_LIGHTMAP",

			"varying vec2 vUv2;",

		"#endif"

	].join("\n"),

	lightmap_fragment: [

		"#ifdef USE_LIGHTMAP",

			"gl_FragColor = gl_FragColor * texture2D( lightMap, vUv2 );",

		"#endif"

	].join("\n"),

	lightmap_vertex: [

		"#ifdef USE_LIGHTMAP",

			"vUv2 = uv2;",

		"#endif"

	].join("\n"),

	// BUMP MAP

	bumpmap_pars_fragment: [

		"#ifdef USE_BUMPMAP",

			"uniform sampler2D bumpMap;",
			"uniform float bumpScale;",

			// Derivative maps - bump mapping unparametrized surfaces by Morten Mikkelsen
			//	http://mmikkelsen3d.blogspot.sk/2011/07/derivative-maps.html

			// Evaluate the derivative of the height w.r.t. screen-space using forward differencing (listing 2)

			"vec2 dHdxy_fwd() {",

				"vec2 dSTdx = dFdx( vUv );",
				"vec2 dSTdy = dFdy( vUv );",

				"float Hll = bumpScale * texture2D( bumpMap, vUv ).x;",
				"float dBx = bumpScale * texture2D( bumpMap, vUv + dSTdx ).x - Hll;",
				"float dBy = bumpScale * texture2D( bumpMap, vUv + dSTdy ).x - Hll;",

				"return vec2( dBx, dBy );",

			"}",

			"vec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy ) {",

				"vec3 vSigmaX = dFdx( surf_pos );",
				"vec3 vSigmaY = dFdy( surf_pos );",
				"vec3 vN = surf_norm;",		// normalized

				"vec3 R1 = cross( vSigmaY, vN );",
				"vec3 R2 = cross( vN, vSigmaX );",

				"float fDet = dot( vSigmaX, R1 );",

				"vec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );",
				"return normalize( abs( fDet ) * surf_norm - vGrad );",

			"}",

		"#endif"

	].join("\n"),

	// NORMAL MAP

	normalmap_pars_fragment: [

		"#ifdef USE_NORMALMAP",

			"uniform sampler2D normalMap;",
			"uniform vec2 normalScale;",

			// Per-Pixel Tangent Space Normal Mapping
			// http://hacksoflife.blogspot.ch/2009/11/per-pixel-tangent-space-normal-mapping.html

			"vec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm ) {",

				"vec3 q0 = dFdx( eye_pos.xyz );",
				"vec3 q1 = dFdy( eye_pos.xyz );",
				"vec2 st0 = dFdx( vUv.st );",
				"vec2 st1 = dFdy( vUv.st );",

				"vec3 S = normalize(  q0 * st1.t - q1 * st0.t );",
				"vec3 T = normalize( -q0 * st1.s + q1 * st0.s );",
				"vec3 N = normalize( surf_norm );",

				"vec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;",
				"mapN.xy = normalScale * mapN.xy;",
				"mat3 tsn = mat3( S, T, N );",
				"return normalize( tsn * mapN );",

			"}",

		"#endif"

	].join("\n"),

	// SPECULAR MAP

	specularmap_pars_fragment: [

		"#ifdef USE_SPECULARMAP",

			"uniform sampler2D specularMap;",

		"#endif"

	].join("\n"),

	specularmap_fragment: [

		"float specularStrength;",

		"#ifdef USE_SPECULARMAP",

			"vec4 texelSpecular = texture2D( specularMap, vUv );",
			"specularStrength = texelSpecular.r;",

		"#else",

			"specularStrength = 1.0;",

		"#endif"

	].join("\n"),

	// LIGHTS LAMBERT

	lights_lambert_pars_vertex: [

		"uniform vec3 ambient;",
		"uniform vec3 diffuse;",
		"uniform vec3 emissive;",

		"uniform vec3 ambientLightColor;",

		"#if MAX_DIR_LIGHTS > 0",

			"uniform vec3 directionalLightColor[ MAX_DIR_LIGHTS ];",
			"uniform vec3 directionalLightDirection[ MAX_DIR_LIGHTS ];",

		"#endif",

		"#if MAX_HEMI_LIGHTS > 0",

			"uniform vec3 hemisphereLightSkyColor[ MAX_HEMI_LIGHTS ];",
			"uniform vec3 hemisphereLightGroundColor[ MAX_HEMI_LIGHTS ];",
			"uniform vec3 hemisphereLightDirection[ MAX_HEMI_LIGHTS ];",

		"#endif",

		"#if MAX_POINT_LIGHTS > 0",

			"uniform vec3 pointLightColor[ MAX_POINT_LIGHTS ];",
			"uniform vec3 pointLightPosition[ MAX_POINT_LIGHTS ];",
			"uniform float pointLightDistance[ MAX_POINT_LIGHTS ];",

		"#endif",

		"#if MAX_SPOT_LIGHTS > 0",

			"uniform vec3 spotLightColor[ MAX_SPOT_LIGHTS ];",
			"uniform vec3 spotLightPosition[ MAX_SPOT_LIGHTS ];",
			"uniform vec3 spotLightDirection[ MAX_SPOT_LIGHTS ];",
			"uniform float spotLightDistance[ MAX_SPOT_LIGHTS ];",
			"uniform float spotLightAngleCos[ MAX_SPOT_LIGHTS ];",
			"uniform float spotLightExponent[ MAX_SPOT_LIGHTS ];",

		"#endif",

		"#ifdef WRAP_AROUND",

			"uniform vec3 wrapRGB;",

		"#endif"

	].join("\n"),

	lights_lambert_vertex: [

		"vLightFront = vec3( 0.0 );",

		"#ifdef DOUBLE_SIDED",

			"vLightBack = vec3( 0.0 );",

		"#endif",

		"transformedNormal = normalize( transformedNormal );",

		"#if MAX_DIR_LIGHTS > 0",

		"for( int i = 0; i < MAX_DIR_LIGHTS; i ++ ) {",

			"vec4 lDirection = viewMatrix * vec4( directionalLightDirection[ i ], 0.0 );",
			"vec3 dirVector = normalize( lDirection.xyz );",

			"float dotProduct = dot( transformedNormal, dirVector );",
			"vec3 directionalLightWeighting = vec3( max( dotProduct, 0.0 ) );",

			"#ifdef DOUBLE_SIDED",

				"vec3 directionalLightWeightingBack = vec3( max( -dotProduct, 0.0 ) );",

				"#ifdef WRAP_AROUND",

					"vec3 directionalLightWeightingHalfBack = vec3( max( -0.5 * dotProduct + 0.5, 0.0 ) );",

				"#endif",

			"#endif",

			"#ifdef WRAP_AROUND",

				"vec3 directionalLightWeightingHalf = vec3( max( 0.5 * dotProduct + 0.5, 0.0 ) );",
				"directionalLightWeighting = mix( directionalLightWeighting, directionalLightWeightingHalf, wrapRGB );",

				"#ifdef DOUBLE_SIDED",

					"directionalLightWeightingBack = mix( directionalLightWeightingBack, directionalLightWeightingHalfBack, wrapRGB );",

				"#endif",

			"#endif",

			"vLightFront += directionalLightColor[ i ] * directionalLightWeighting;",

			"#ifdef DOUBLE_SIDED",

				"vLightBack += directionalLightColor[ i ] * directionalLightWeightingBack;",

			"#endif",

		"}",

		"#endif",

		"#if MAX_POINT_LIGHTS > 0",

			"for( int i = 0; i < MAX_POINT_LIGHTS; i ++ ) {",

				"vec4 lPosition = viewMatrix * vec4( pointLightPosition[ i ], 1.0 );",
				"vec3 lVector = lPosition.xyz - mvPosition.xyz;",

				"float lDistance = 1.0;",
				"if ( pointLightDistance[ i ] > 0.0 )",
					"lDistance = 1.0 - min( ( length( lVector ) / pointLightDistance[ i ] ), 1.0 );",

				"lVector = normalize( lVector );",
				"float dotProduct = dot( transformedNormal, lVector );",

				"vec3 pointLightWeighting = vec3( max( dotProduct, 0.0 ) );",

				"#ifdef DOUBLE_SIDED",

					"vec3 pointLightWeightingBack = vec3( max( -dotProduct, 0.0 ) );",

					"#ifdef WRAP_AROUND",

						"vec3 pointLightWeightingHalfBack = vec3( max( -0.5 * dotProduct + 0.5, 0.0 ) );",

					"#endif",

				"#endif",

				"#ifdef WRAP_AROUND",

					"vec3 pointLightWeightingHalf = vec3( max( 0.5 * dotProduct + 0.5, 0.0 ) );",
					"pointLightWeighting = mix( pointLightWeighting, pointLightWeightingHalf, wrapRGB );",

					"#ifdef DOUBLE_SIDED",

						"pointLightWeightingBack = mix( pointLightWeightingBack, pointLightWeightingHalfBack, wrapRGB );",

					"#endif",

				"#endif",

				"vLightFront += pointLightColor[ i ] * pointLightWeighting * lDistance;",

				"#ifdef DOUBLE_SIDED",

					"vLightBack += pointLightColor[ i ] * pointLightWeightingBack * lDistance;",

				"#endif",

			"}",

		"#endif",

		"#if MAX_SPOT_LIGHTS > 0",

			"for( int i = 0; i < MAX_SPOT_LIGHTS; i ++ ) {",

				"vec4 lPosition = viewMatrix * vec4( spotLightPosition[ i ], 1.0 );",
				"vec3 lVector = lPosition.xyz - mvPosition.xyz;",

				"float spotEffect = dot( spotLightDirection[ i ], normalize( spotLightPosition[ i ] - worldPosition.xyz ) );",

				"if ( spotEffect > spotLightAngleCos[ i ] ) {",

					"spotEffect = max( pow( spotEffect, spotLightExponent[ i ] ), 0.0 );",

					"float lDistance = 1.0;",
					"if ( spotLightDistance[ i ] > 0.0 )",
						"lDistance = 1.0 - min( ( length( lVector ) / spotLightDistance[ i ] ), 1.0 );",

					"lVector = normalize( lVector );",

					"float dotProduct = dot( transformedNormal, lVector );",
					"vec3 spotLightWeighting = vec3( max( dotProduct, 0.0 ) );",

					"#ifdef DOUBLE_SIDED",

						"vec3 spotLightWeightingBack = vec3( max( -dotProduct, 0.0 ) );",

						"#ifdef WRAP_AROUND",

							"vec3 spotLightWeightingHalfBack = vec3( max( -0.5 * dotProduct + 0.5, 0.0 ) );",

						"#endif",

					"#endif",

					"#ifdef WRAP_AROUND",

						"vec3 spotLightWeightingHalf = vec3( max( 0.5 * dotProduct + 0.5, 0.0 ) );",
						"spotLightWeighting = mix( spotLightWeighting, spotLightWeightingHalf, wrapRGB );",

						"#ifdef DOUBLE_SIDED",

							"spotLightWeightingBack = mix( spotLightWeightingBack, spotLightWeightingHalfBack, wrapRGB );",

						"#endif",

					"#endif",

					"vLightFront += spotLightColor[ i ] * spotLightWeighting * lDistance * spotEffect;",

					"#ifdef DOUBLE_SIDED",

						"vLightBack += spotLightColor[ i ] * spotLightWeightingBack * lDistance * spotEffect;",

					"#endif",

				"}",

			"}",

		"#endif",

		"#if MAX_HEMI_LIGHTS > 0",

			"for( int i = 0; i < MAX_HEMI_LIGHTS; i ++ ) {",

				"vec4 lDirection = viewMatrix * vec4( hemisphereLightDirection[ i ], 0.0 );",
				"vec3 lVector = normalize( lDirection.xyz );",

				"float dotProduct = dot( transformedNormal, lVector );",

				"float hemiDiffuseWeight = 0.5 * dotProduct + 0.5;",
				"float hemiDiffuseWeightBack = -0.5 * dotProduct + 0.5;",

				"vLightFront += mix( hemisphereLightGroundColor[ i ], hemisphereLightSkyColor[ i ], hemiDiffuseWeight );",

				"#ifdef DOUBLE_SIDED",

					"vLightBack += mix( hemisphereLightGroundColor[ i ], hemisphereLightSkyColor[ i ], hemiDiffuseWeightBack );",

				"#endif",

			"}",

		"#endif",

		"vLightFront = vLightFront * diffuse + ambient * ambientLightColor + emissive;",

		"#ifdef DOUBLE_SIDED",

			"vLightBack = vLightBack * diffuse + ambient * ambientLightColor + emissive;",

		"#endif"

	].join("\n"),

	// LIGHTS PHONG

	lights_phong_pars_vertex: [

		"#ifndef PHONG_PER_PIXEL",

		"#if MAX_POINT_LIGHTS > 0",

			"uniform vec3 pointLightPosition[ MAX_POINT_LIGHTS ];",
			"uniform float pointLightDistance[ MAX_POINT_LIGHTS ];",

			"varying vec4 vPointLight[ MAX_POINT_LIGHTS ];",

		"#endif",

		"#if MAX_SPOT_LIGHTS > 0",

			"uniform vec3 spotLightPosition[ MAX_SPOT_LIGHTS ];",
			"uniform float spotLightDistance[ MAX_SPOT_LIGHTS ];",

			"varying vec4 vSpotLight[ MAX_SPOT_LIGHTS ];",

		"#endif",

		"#endif",

		"#if MAX_SPOT_LIGHTS > 0 || defined( USE_BUMPMAP )",

			"varying vec3 vWorldPosition;",

		"#endif"

	].join("\n"),


	lights_phong_vertex: [

		"#ifndef PHONG_PER_PIXEL",

		"#if MAX_POINT_LIGHTS > 0",

			"for( int i = 0; i < MAX_POINT_LIGHTS; i ++ ) {",

				"vec4 lPosition = viewMatrix * vec4( pointLightPosition[ i ], 1.0 );",
				"vec3 lVector = lPosition.xyz - mvPosition.xyz;",

				"float lDistance = 1.0;",
				"if ( pointLightDistance[ i ] > 0.0 )",
					"lDistance = 1.0 - min( ( length( lVector ) / pointLightDistance[ i ] ), 1.0 );",

				"vPointLight[ i ] = vec4( lVector, lDistance );",

			"}",

		"#endif",

		"#if MAX_SPOT_LIGHTS > 0",

			"for( int i = 0; i < MAX_SPOT_LIGHTS; i ++ ) {",

				"vec4 lPosition = viewMatrix * vec4( spotLightPosition[ i ], 1.0 );",
				"vec3 lVector = lPosition.xyz - mvPosition.xyz;",

				"float lDistance = 1.0;",
				"if ( spotLightDistance[ i ] > 0.0 )",
					"lDistance = 1.0 - min( ( length( lVector ) / spotLightDistance[ i ] ), 1.0 );",

				"vSpotLight[ i ] = vec4( lVector, lDistance );",

			"}",

		"#endif",

		"#endif",

		"#if MAX_SPOT_LIGHTS > 0 || defined( USE_BUMPMAP )",

			"vWorldPosition = worldPosition.xyz;",

		"#endif"

	].join("\n"),

	lights_phong_pars_fragment: [

		"uniform vec3 ambientLightColor;",

		"#if MAX_DIR_LIGHTS > 0",

			"uniform vec3 directionalLightColor[ MAX_DIR_LIGHTS ];",
			"uniform vec3 directionalLightDirection[ MAX_DIR_LIGHTS ];",

		"#endif",

		"#if MAX_HEMI_LIGHTS > 0",

			"uniform vec3 hemisphereLightSkyColor[ MAX_HEMI_LIGHTS ];",
			"uniform vec3 hemisphereLightGroundColor[ MAX_HEMI_LIGHTS ];",
			"uniform vec3 hemisphereLightDirection[ MAX_HEMI_LIGHTS ];",

		"#endif",

		"#if MAX_POINT_LIGHTS > 0",

			"uniform vec3 pointLightColor[ MAX_POINT_LIGHTS ];",

			"#ifdef PHONG_PER_PIXEL",

				"uniform vec3 pointLightPosition[ MAX_POINT_LIGHTS ];",
				"uniform float pointLightDistance[ MAX_POINT_LIGHTS ];",

			"#else",

				"varying vec4 vPointLight[ MAX_POINT_LIGHTS ];",

			"#endif",

		"#endif",

		"#if MAX_SPOT_LIGHTS > 0",

			"uniform vec3 spotLightColor[ MAX_SPOT_LIGHTS ];",
			"uniform vec3 spotLightPosition[ MAX_SPOT_LIGHTS ];",
			"uniform vec3 spotLightDirection[ MAX_SPOT_LIGHTS ];",
			"uniform float spotLightAngleCos[ MAX_SPOT_LIGHTS ];",
			"uniform float spotLightExponent[ MAX_SPOT_LIGHTS ];",

			"#ifdef PHONG_PER_PIXEL",

				"uniform float spotLightDistance[ MAX_SPOT_LIGHTS ];",

			"#else",

				"varying vec4 vSpotLight[ MAX_SPOT_LIGHTS ];",

			"#endif",

		"#endif",

		"#if MAX_SPOT_LIGHTS > 0 || defined( USE_BUMPMAP )",

			"varying vec3 vWorldPosition;",

		"#endif",

		"#ifdef WRAP_AROUND",

			"uniform vec3 wrapRGB;",

		"#endif",

		"varying vec3 vViewPosition;",
		"varying vec3 vNormal;"

	].join("\n"),

	lights_phong_fragment: [

		"vec3 normal = normalize( vNormal );",
		"vec3 viewPosition = normalize( vViewPosition );",

		"#ifdef DOUBLE_SIDED",

			"normal = normal * ( -1.0 + 2.0 * float( gl_FrontFacing ) );",

		"#endif",

		"#ifdef USE_NORMALMAP",

			"normal = perturbNormal2Arb( -vViewPosition, normal );",

		"#elif defined( USE_BUMPMAP )",

			"normal = perturbNormalArb( -vViewPosition, normal, dHdxy_fwd() );",

		"#endif",

		"#if MAX_POINT_LIGHTS > 0",

			"vec3 pointDiffuse  = vec3( 0.0 );",
			"vec3 pointSpecular = vec3( 0.0 );",

			"for ( int i = 0; i < MAX_POINT_LIGHTS; i ++ ) {",

				"#ifdef PHONG_PER_PIXEL",

					"vec4 lPosition = viewMatrix * vec4( pointLightPosition[ i ], 1.0 );",
					"vec3 lVector = lPosition.xyz + vViewPosition.xyz;",

					"float lDistance = 1.0;",
					"if ( pointLightDistance[ i ] > 0.0 )",
						"lDistance = 1.0 - min( ( length( lVector ) / pointLightDistance[ i ] ), 1.0 );",

					"lVector = normalize( lVector );",

				"#else",

					"vec3 lVector = normalize( vPointLight[ i ].xyz );",
					"float lDistance = vPointLight[ i ].w;",

				"#endif",

				// diffuse

				"float dotProduct = dot( normal, lVector );",

				"#ifdef WRAP_AROUND",

					"float pointDiffuseWeightFull = max( dotProduct, 0.0 );",
					"float pointDiffuseWeightHalf = max( 0.5 * dotProduct + 0.5, 0.0 );",

					"vec3 pointDiffuseWeight = mix( vec3 ( pointDiffuseWeightFull ), vec3( pointDiffuseWeightHalf ), wrapRGB );",

				"#else",

					"float pointDiffuseWeight = max( dotProduct, 0.0 );",

				"#endif",

				"pointDiffuse  += diffuse * pointLightColor[ i ] * pointDiffuseWeight * lDistance;",

				// specular

				"vec3 pointHalfVector = normalize( lVector + viewPosition );",
				"float pointDotNormalHalf = max( dot( normal, pointHalfVector ), 0.0 );",
				"float pointSpecularWeight = specularStrength * max( pow( pointDotNormalHalf, shininess ), 0.0 );",

				// 2.0 => 2.0001 is hack to work around ANGLE bug

				"float specularNormalization = ( shininess + 2.0001 ) / 8.0;",

				"vec3 schlick = specular + vec3( 1.0 - specular ) * pow( 1.0 - dot( lVector, pointHalfVector ), 5.0 );",
				"pointSpecular += schlick * pointLightColor[ i ] * pointSpecularWeight * pointDiffuseWeight * lDistance * specularNormalization;",

			"}",

		"#endif",

		"#if MAX_SPOT_LIGHTS > 0",

			"vec3 spotDiffuse  = vec3( 0.0 );",
			"vec3 spotSpecular = vec3( 0.0 );",

			"for ( int i = 0; i < MAX_SPOT_LIGHTS; i ++ ) {",

				"#ifdef PHONG_PER_PIXEL",

					"vec4 lPosition = viewMatrix * vec4( spotLightPosition[ i ], 1.0 );",
					"vec3 lVector = lPosition.xyz + vViewPosition.xyz;",

					"float lDistance = 1.0;",
					"if ( spotLightDistance[ i ] > 0.0 )",
						"lDistance = 1.0 - min( ( length( lVector ) / spotLightDistance[ i ] ), 1.0 );",

					"lVector = normalize( lVector );",

				"#else",

					"vec3 lVector = normalize( vSpotLight[ i ].xyz );",
					"float lDistance = vSpotLight[ i ].w;",

				"#endif",

				"float spotEffect = dot( spotLightDirection[ i ], normalize( spotLightPosition[ i ] - vWorldPosition ) );",

				"if ( spotEffect > spotLightAngleCos[ i ] ) {",

					"spotEffect = max( pow( spotEffect, spotLightExponent[ i ] ), 0.0 );",

					// diffuse

					"float dotProduct = dot( normal, lVector );",

					"#ifdef WRAP_AROUND",

						"float spotDiffuseWeightFull = max( dotProduct, 0.0 );",
						"float spotDiffuseWeightHalf = max( 0.5 * dotProduct + 0.5, 0.0 );",

						"vec3 spotDiffuseWeight = mix( vec3 ( spotDiffuseWeightFull ), vec3( spotDiffuseWeightHalf ), wrapRGB );",

					"#else",

						"float spotDiffuseWeight = max( dotProduct, 0.0 );",

					"#endif",

					"spotDiffuse += diffuse * spotLightColor[ i ] * spotDiffuseWeight * lDistance * spotEffect;",

					// specular

					"vec3 spotHalfVector = normalize( lVector + viewPosition );",
					"float spotDotNormalHalf = max( dot( normal, spotHalfVector ), 0.0 );",
					"float spotSpecularWeight = specularStrength * max( pow( spotDotNormalHalf, shininess ), 0.0 );",

					// 2.0 => 2.0001 is hack to work around ANGLE bug

					"float specularNormalization = ( shininess + 2.0001 ) / 8.0;",

					"vec3 schlick = specular + vec3( 1.0 - specular ) * pow( 1.0 - dot( lVector, spotHalfVector ), 5.0 );",
					"spotSpecular += schlick * spotLightColor[ i ] * spotSpecularWeight * spotDiffuseWeight * lDistance * specularNormalization * spotEffect;",

				"}",

			"}",

		"#endif",

		"#if MAX_DIR_LIGHTS > 0",

			"vec3 dirDiffuse  = vec3( 0.0 );",
			"vec3 dirSpecular = vec3( 0.0 );" ,

			"for( int i = 0; i < MAX_DIR_LIGHTS; i ++ ) {",

				"vec4 lDirection = viewMatrix * vec4( directionalLightDirection[ i ], 0.0 );",
				"vec3 dirVector = normalize( lDirection.xyz );",

				// diffuse

				"float dotProduct = dot( normal, dirVector );",

				"#ifdef WRAP_AROUND",

					"float dirDiffuseWeightFull = max( dotProduct, 0.0 );",
					"float dirDiffuseWeightHalf = max( 0.5 * dotProduct + 0.5, 0.0 );",

					"vec3 dirDiffuseWeight = mix( vec3( dirDiffuseWeightFull ), vec3( dirDiffuseWeightHalf ), wrapRGB );",

				"#else",

					"float dirDiffuseWeight = max( dotProduct, 0.0 );",

				"#endif",

				"dirDiffuse  += diffuse * directionalLightColor[ i ] * dirDiffuseWeight;",

				// specular

				"vec3 dirHalfVector = normalize( dirVector + viewPosition );",
				"float dirDotNormalHalf = max( dot( normal, dirHalfVector ), 0.0 );",
				"float dirSpecularWeight = specularStrength * max( pow( dirDotNormalHalf, shininess ), 0.0 );",

					/*
				// fresnel term from skin shader
				"const float F0 = 0.128;",

				"float base = 1.0 - dot( viewPosition, dirHalfVector );",
				"float exponential = pow( base, 5.0 );",

				"float fresnel = exponential + F0 * ( 1.0 - exponential );",
				*/

				/*
				// fresnel term from fresnel shader
				"const float mFresnelBias = 0.08;",
				"const float mFresnelScale = 0.3;",
				"const float mFresnelPower = 5.0;",

				"float fresnel = mFresnelBias + mFresnelScale * pow( 1.0 + dot( normalize( -viewPosition ), normal ), mFresnelPower );",
				*/

				// 2.0 => 2.0001 is hack to work around ANGLE bug

				"float specularNormalization = ( shininess + 2.0001 ) / 8.0;",

				//"dirSpecular += specular * directionalLightColor[ i ] * dirSpecularWeight * dirDiffuseWeight * specularNormalization * fresnel;",

				"vec3 schlick = specular + vec3( 1.0 - specular ) * pow( 1.0 - dot( dirVector, dirHalfVector ), 5.0 );",
				"dirSpecular += schlick * directionalLightColor[ i ] * dirSpecularWeight * dirDiffuseWeight * specularNormalization;",


			"}",

		"#endif",

		"#if MAX_HEMI_LIGHTS > 0",

			"vec3 hemiDiffuse  = vec3( 0.0 );",
			"vec3 hemiSpecular = vec3( 0.0 );" ,

			"for( int i = 0; i < MAX_HEMI_LIGHTS; i ++ ) {",

				"vec4 lDirection = viewMatrix * vec4( hemisphereLightDirection[ i ], 0.0 );",
				"vec3 lVector = normalize( lDirection.xyz );",

				// diffuse

				"float dotProduct = dot( normal, lVector );",
				"float hemiDiffuseWeight = 0.5 * dotProduct + 0.5;",

				"vec3 hemiColor = mix( hemisphereLightGroundColor[ i ], hemisphereLightSkyColor[ i ], hemiDiffuseWeight );",

				"hemiDiffuse += diffuse * hemiColor;",

				// specular (sky light)

				"vec3 hemiHalfVectorSky = normalize( lVector + viewPosition );",
				"float hemiDotNormalHalfSky = 0.5 * dot( normal, hemiHalfVectorSky ) + 0.5;",
				"float hemiSpecularWeightSky = specularStrength * max( pow( hemiDotNormalHalfSky, shininess ), 0.0 );",

				// specular (ground light)

				"vec3 lVectorGround = -lVector;",

				"vec3 hemiHalfVectorGround = normalize( lVectorGround + viewPosition );",
				"float hemiDotNormalHalfGround = 0.5 * dot( normal, hemiHalfVectorGround ) + 0.5;",
				"float hemiSpecularWeightGround = specularStrength * max( pow( hemiDotNormalHalfGround, shininess ), 0.0 );",

				"float dotProductGround = dot( normal, lVectorGround );",

				// 2.0 => 2.0001 is hack to work around ANGLE bug

				"float specularNormalization = ( shininess + 2.0001 ) / 8.0;",

				"vec3 schlickSky = specular + vec3( 1.0 - specular ) * pow( 1.0 - dot( lVector, hemiHalfVectorSky ), 5.0 );",
				"vec3 schlickGround = specular + vec3( 1.0 - specular ) * pow( 1.0 - dot( lVectorGround, hemiHalfVectorGround ), 5.0 );",
				"hemiSpecular += hemiColor * specularNormalization * ( schlickSky * hemiSpecularWeightSky * max( dotProduct, 0.0 ) + schlickGround * hemiSpecularWeightGround * max( dotProductGround, 0.0 ) );",

			"}",

		"#endif",

		"vec3 totalDiffuse = vec3( 0.0 );",
		"vec3 totalSpecular = vec3( 0.0 );",

		"#if MAX_DIR_LIGHTS > 0",

			"totalDiffuse += dirDiffuse;",
			"totalSpecular += dirSpecular;",

		"#endif",

		"#if MAX_HEMI_LIGHTS > 0",

			"totalDiffuse += hemiDiffuse;",
			"totalSpecular += hemiSpecular;",

		"#endif",

		"#if MAX_POINT_LIGHTS > 0",

			"totalDiffuse += pointDiffuse;",
			"totalSpecular += pointSpecular;",

		"#endif",

		"#if MAX_SPOT_LIGHTS > 0",

			"totalDiffuse += spotDiffuse;",
			"totalSpecular += spotSpecular;",

		"#endif",

		"#ifdef METAL",

			"gl_FragColor.xyz = gl_FragColor.xyz * ( emissive + totalDiffuse + ambientLightColor * ambient + totalSpecular );",

		"#else",

			"gl_FragColor.xyz = gl_FragColor.xyz * ( emissive + totalDiffuse + ambientLightColor * ambient ) + totalSpecular;",

		"#endif"

	].join("\n"),

	// VERTEX COLORS

	color_pars_fragment: [

		"#ifdef USE_COLOR",

			"varying vec3 vColor;",

		"#endif"

	].join("\n"),


	color_fragment: [

		"#ifdef USE_COLOR",

			"gl_FragColor = gl_FragColor * vec4( vColor, 1.0 );",

		"#endif"

	].join("\n"),

	color_pars_vertex: [

		"#ifdef USE_COLOR",

			"varying vec3 vColor;",

		"#endif"

	].join("\n"),


	color_vertex: [

		"#ifdef USE_COLOR",

			"#ifdef GAMMA_INPUT",

				"vColor = color * color;",

			"#else",

				"vColor = color;",

			"#endif",

		"#endif"

	].join("\n"),

	// SKINNING

	skinning_pars_vertex: [

		"#ifdef USE_SKINNING",

			"#ifdef BONE_TEXTURE",

				"uniform sampler2D boneTexture;",
				"uniform int boneTextureWidth;",
				"uniform int boneTextureHeight;",

				"mat4 getBoneMatrix( const in float i ) {",

					"float j = i * 4.0;",
					"float x = mod( j, float( boneTextureWidth ) );",
					"float y = floor( j / float( boneTextureWidth ) );",

					"float dx = 1.0 / float( boneTextureWidth );",
					"float dy = 1.0 / float( boneTextureHeight );",

					"y = dy * ( y + 0.5 );",

					"vec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );",
					"vec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );",
					"vec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );",
					"vec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );",

					"mat4 bone = mat4( v1, v2, v3, v4 );",

					"return bone;",

				"}",

			"#else",

				"uniform mat4 boneGlobalMatrices[ MAX_BONES ];",

				"mat4 getBoneMatrix( const in float i ) {",

					"mat4 bone = boneGlobalMatrices[ int(i) ];",
					"return bone;",

				"}",

			"#endif",

		"#endif"

	].join("\n"),

	skinbase_vertex: [

		"#ifdef USE_SKINNING",

			"mat4 boneMatX = getBoneMatrix( skinIndex.x );",
			"mat4 boneMatY = getBoneMatrix( skinIndex.y );",

		"#endif"

	].join("\n"),

	skinning_vertex: [

		"#ifdef USE_SKINNING",

			"#ifdef USE_MORPHTARGETS",

			"vec4 skinVertex = vec4( morphed, 1.0 );",

			"#else",

			"vec4 skinVertex = vec4( position, 1.0 );",

			"#endif",

			"vec4 skinned  = boneMatX * skinVertex * skinWeight.x;",
			"skinned 	  += boneMatY * skinVertex * skinWeight.y;",

		"#endif"

	].join("\n"),

	// MORPHING

	morphtarget_pars_vertex: [

		"#ifdef USE_MORPHTARGETS",

			"#ifndef USE_MORPHNORMALS",

			"uniform float morphTargetInfluences[ 8 ];",

			"#else",

			"uniform float morphTargetInfluences[ 4 ];",

			"#endif",

		"#endif"

	].join("\n"),

	morphtarget_vertex: [

		"#ifdef USE_MORPHTARGETS",

			"vec3 morphed = vec3( 0.0 );",
			"morphed += ( morphTarget0 - position ) * morphTargetInfluences[ 0 ];",
			"morphed += ( morphTarget1 - position ) * morphTargetInfluences[ 1 ];",
			"morphed += ( morphTarget2 - position ) * morphTargetInfluences[ 2 ];",
			"morphed += ( morphTarget3 - position ) * morphTargetInfluences[ 3 ];",

			"#ifndef USE_MORPHNORMALS",

			"morphed += ( morphTarget4 - position ) * morphTargetInfluences[ 4 ];",
			"morphed += ( morphTarget5 - position ) * morphTargetInfluences[ 5 ];",
			"morphed += ( morphTarget6 - position ) * morphTargetInfluences[ 6 ];",
			"morphed += ( morphTarget7 - position ) * morphTargetInfluences[ 7 ];",

			"#endif",

			"morphed += position;",

		"#endif"

	].join("\n"),

	default_vertex : [

		"vec4 mvPosition;",

		"#ifdef USE_SKINNING",

			"mvPosition = modelViewMatrix * skinned;",

		"#endif",

		"#if !defined( USE_SKINNING ) && defined( USE_MORPHTARGETS )",

			"mvPosition = modelViewMatrix * vec4( morphed, 1.0 );",

		"#endif",

		"#if !defined( USE_SKINNING ) && ! defined( USE_MORPHTARGETS )",

			"mvPosition = modelViewMatrix * vec4( position, 1.0 );",

		"#endif",

		"gl_Position = projectionMatrix * mvPosition;"

	].join("\n"),

	morphnormal_vertex: [

		"#ifdef USE_MORPHNORMALS",

			"vec3 morphedNormal = vec3( 0.0 );",

			"morphedNormal +=  ( morphNormal0 - normal ) * morphTargetInfluences[ 0 ];",
			"morphedNormal +=  ( morphNormal1 - normal ) * morphTargetInfluences[ 1 ];",
			"morphedNormal +=  ( morphNormal2 - normal ) * morphTargetInfluences[ 2 ];",
			"morphedNormal +=  ( morphNormal3 - normal ) * morphTargetInfluences[ 3 ];",

			"morphedNormal += normal;",

		"#endif"

	].join("\n"),

	skinnormal_vertex: [

		"#ifdef USE_SKINNING",

			"mat4 skinMatrix = skinWeight.x * boneMatX;",
			"skinMatrix 	+= skinWeight.y * boneMatY;",

			"#ifdef USE_MORPHNORMALS",

			"vec4 skinnedNormal = skinMatrix * vec4( morphedNormal, 0.0 );",

			"#else",

			"vec4 skinnedNormal = skinMatrix * vec4( normal, 0.0 );",

			"#endif",

		"#endif"

	].join("\n"),

	defaultnormal_vertex: [

		"vec3 objectNormal;",

		"#ifdef USE_SKINNING",

			"objectNormal = skinnedNormal.xyz;",

		"#endif",

		"#if !defined( USE_SKINNING ) && defined( USE_MORPHNORMALS )",

			"objectNormal = morphedNormal;",

		"#endif",

		"#if !defined( USE_SKINNING ) && ! defined( USE_MORPHNORMALS )",

			"objectNormal = normal;",

		"#endif",

		"#ifdef FLIP_SIDED",

			"objectNormal = -objectNormal;",

		"#endif",

		"vec3 transformedNormal = normalMatrix * objectNormal;"

	].join("\n"),

	// SHADOW MAP

	// based on SpiderGL shadow map and Fabien Sanglard's GLSL shadow mapping examples
	//  http://spidergl.org/example.php?id=6
	// 	http://fabiensanglard.net/shadowmapping

	shadowmap_pars_fragment: [

		"#ifdef USE_SHADOWMAP",

			"uniform sampler2D shadowMap[ MAX_SHADOWS ];",
			"uniform vec2 shadowMapSize[ MAX_SHADOWS ];",

			"uniform float shadowDarkness[ MAX_SHADOWS ];",
			"uniform float shadowBias[ MAX_SHADOWS ];",

			"varying vec4 vShadowCoord[ MAX_SHADOWS ];",

			"float unpackDepth( const in vec4 rgba_depth ) {",

				"const vec4 bit_shift = vec4( 1.0 / ( 256.0 * 256.0 * 256.0 ), 1.0 / ( 256.0 * 256.0 ), 1.0 / 256.0, 1.0 );",
				"float depth = dot( rgba_depth, bit_shift );",
				"return depth;",

			"}",

		"#endif"

	].join("\n"),

	shadowmap_fragment: [

		"#ifdef USE_SHADOWMAP",

			"#ifdef SHADOWMAP_DEBUG",

				"vec3 frustumColors[3];",
				"frustumColors[0] = vec3( 1.0, 0.5, 0.0 );",
				"frustumColors[1] = vec3( 0.0, 1.0, 0.8 );",
				"frustumColors[2] = vec3( 0.0, 0.5, 1.0 );",

			"#endif",

			"#ifdef SHADOWMAP_CASCADE",

				"int inFrustumCount = 0;",

			"#endif",

			"float fDepth;",
			"vec3 shadowColor = vec3( 1.0 );",

			"for( int i = 0; i < MAX_SHADOWS; i ++ ) {",

				"vec3 shadowCoord = vShadowCoord[ i ].xyz / vShadowCoord[ i ].w;",

				// "if ( something && something )" 		 breaks ATI OpenGL shader compiler
				// "if ( all( something, something ) )"  using this instead

				"bvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );",
				"bool inFrustum = all( inFrustumVec );",

				// don't shadow pixels outside of light frustum
				// use just first frustum (for cascades)
				// don't shadow pixels behind far plane of light frustum

				"#ifdef SHADOWMAP_CASCADE",

					"inFrustumCount += int( inFrustum );",
					"bvec3 frustumTestVec = bvec3( inFrustum, inFrustumCount == 1, shadowCoord.z <= 1.0 );",

				"#else",

					"bvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );",

				"#endif",

				"bool frustumTest = all( frustumTestVec );",

				"if ( frustumTest ) {",

					"shadowCoord.z += shadowBias[ i ];",

					"#if defined( SHADOWMAP_TYPE_PCF )",

						// Percentage-close filtering
						// (9 pixel kernel)
						// http://fabiensanglard.net/shadowmappingPCF/

						"float shadow = 0.0;",

						/*
						// nested loops breaks shader compiler / validator on some ATI cards when using OpenGL
						// must enroll loop manually

						"for ( float y = -1.25; y <= 1.25; y += 1.25 )",
							"for ( float x = -1.25; x <= 1.25; x += 1.25 ) {",

								"vec4 rgbaDepth = texture2D( shadowMap[ i ], vec2( x * xPixelOffset, y * yPixelOffset ) + shadowCoord.xy );",

								// doesn't seem to produce any noticeable visual difference compared to simple "texture2D" lookup
								//"vec4 rgbaDepth = texture2DProj( shadowMap[ i ], vec4( vShadowCoord[ i ].w * ( vec2( x * xPixelOffset, y * yPixelOffset ) + shadowCoord.xy ), 0.05, vShadowCoord[ i ].w ) );",

								"float fDepth = unpackDepth( rgbaDepth );",

								"if ( fDepth < shadowCoord.z )",
									"shadow += 1.0;",

						"}",

						"shadow /= 9.0;",

						*/

						"const float shadowDelta = 1.0 / 9.0;",

						"float xPixelOffset = 1.0 / shadowMapSize[ i ].x;",
						"float yPixelOffset = 1.0 / shadowMapSize[ i ].y;",

						"float dx0 = -1.25 * xPixelOffset;",
						"float dy0 = -1.25 * yPixelOffset;",
						"float dx1 = 1.25 * xPixelOffset;",
						"float dy1 = 1.25 * yPixelOffset;",

						"fDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx0, dy0 ) ) );",
						"if ( fDepth < shadowCoord.z ) shadow += shadowDelta;",

						"fDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( 0.0, dy0 ) ) );",
						"if ( fDepth < shadowCoord.z ) shadow += shadowDelta;",

						"fDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx1, dy0 ) ) );",
						"if ( fDepth < shadowCoord.z ) shadow += shadowDelta;",

						"fDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx0, 0.0 ) ) );",
						"if ( fDepth < shadowCoord.z ) shadow += shadowDelta;",

						"fDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy ) );",
						"if ( fDepth < shadowCoord.z ) shadow += shadowDelta;",

						"fDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx1, 0.0 ) ) );",
						"if ( fDepth < shadowCoord.z ) shadow += shadowDelta;",

						"fDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx0, dy1 ) ) );",
						"if ( fDepth < shadowCoord.z ) shadow += shadowDelta;",

						"fDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( 0.0, dy1 ) ) );",
						"if ( fDepth < shadowCoord.z ) shadow += shadowDelta;",

						"fDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx1, dy1 ) ) );",
						"if ( fDepth < shadowCoord.z ) shadow += shadowDelta;",

						"shadowColor = shadowColor * vec3( ( 1.0 - shadowDarkness[ i ] * shadow ) );",

					"#elif defined( SHADOWMAP_TYPE_PCF_SOFT )",

						// Percentage-close filtering
						// (9 pixel kernel)
						// http://fabiensanglard.net/shadowmappingPCF/

						"float shadow = 0.0;",

						"float xPixelOffset = 1.0 / shadowMapSize[ i ].x;",
						"float yPixelOffset = 1.0 / shadowMapSize[ i ].y;",

						"float dx0 = -1.0 * xPixelOffset;",
						"float dy0 = -1.0 * yPixelOffset;",
						"float dx1 = 1.0 * xPixelOffset;",
						"float dy1 = 1.0 * yPixelOffset;",

						"mat3 shadowKernel;",
						"mat3 depthKernel;",

						"depthKernel[0][0] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx0, dy0 ) ) );",
						"depthKernel[0][1] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx0, 0.0 ) ) );",
						"depthKernel[0][2] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx0, dy1 ) ) );",
						"depthKernel[1][0] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( 0.0, dy0 ) ) );",
						"depthKernel[1][1] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy ) );",
						"depthKernel[1][2] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( 0.0, dy1 ) ) );",
						"depthKernel[2][0] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx1, dy0 ) ) );",
						"depthKernel[2][1] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx1, 0.0 ) ) );",
						"depthKernel[2][2] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx1, dy1 ) ) );",

						"vec3 shadowZ = vec3( shadowCoord.z );",
						"shadowKernel[0] = vec3(lessThan(depthKernel[0], shadowZ ));",
						"shadowKernel[0] *= vec3(0.25);",

						"shadowKernel[1] = vec3(lessThan(depthKernel[1], shadowZ ));",
						"shadowKernel[1] *= vec3(0.25);",

						"shadowKernel[2] = vec3(lessThan(depthKernel[2], shadowZ ));",
						"shadowKernel[2] *= vec3(0.25);",

						"vec2 fractionalCoord = 1.0 - fract( shadowCoord.xy * shadowMapSize[i].xy );",

						"shadowKernel[0] = mix( shadowKernel[1], shadowKernel[0], fractionalCoord.x );",
						"shadowKernel[1] = mix( shadowKernel[2], shadowKernel[1], fractionalCoord.x );",

						"vec4 shadowValues;",
						"shadowValues.x = mix( shadowKernel[0][1], shadowKernel[0][0], fractionalCoord.y );",
						"shadowValues.y = mix( shadowKernel[0][2], shadowKernel[0][1], fractionalCoord.y );",
						"shadowValues.z = mix( shadowKernel[1][1], shadowKernel[1][0], fractionalCoord.y );",
						"shadowValues.w = mix( shadowKernel[1][2], shadowKernel[1][1], fractionalCoord.y );",

						"shadow = dot( shadowValues, vec4( 1.0 ) );",

						"shadowColor = shadowColor * vec3( ( 1.0 - shadowDarkness[ i ] * shadow ) );",

					"#else",

						"vec4 rgbaDepth = texture2D( shadowMap[ i ], shadowCoord.xy );",
						"float fDepth = unpackDepth( rgbaDepth );",

						"if ( fDepth < shadowCoord.z )",

							// spot with multiple shadows is darker

							"shadowColor = shadowColor * vec3( 1.0 - shadowDarkness[ i ] );",

							// spot with multiple shadows has the same color as single shadow spot

							//"shadowColor = min( shadowColor, vec3( shadowDarkness[ i ] ) );",

					"#endif",

				"}",


				"#ifdef SHADOWMAP_DEBUG",

					"#ifdef SHADOWMAP_CASCADE",

						"if ( inFrustum && inFrustumCount == 1 ) gl_FragColor.xyz *= frustumColors[ i ];",

					"#else",

						"if ( inFrustum ) gl_FragColor.xyz *= frustumColors[ i ];",

					"#endif",

				"#endif",

			"}",

			"#ifdef GAMMA_OUTPUT",

				"shadowColor *= shadowColor;",

			"#endif",

			"gl_FragColor.xyz = gl_FragColor.xyz * shadowColor;",

		"#endif"

	].join("\n"),

	shadowmap_pars_vertex: [

		"#ifdef USE_SHADOWMAP",

			"varying vec4 vShadowCoord[ MAX_SHADOWS ];",
			"uniform mat4 shadowMatrix[ MAX_SHADOWS ];",

		"#endif"

	].join("\n"),

	shadowmap_vertex: [

		"#ifdef USE_SHADOWMAP",

			"for( int i = 0; i < MAX_SHADOWS; i ++ ) {",

				"vShadowCoord[ i ] = shadowMatrix[ i ] * worldPosition;",

			"}",

		"#endif"

	].join("\n"),

	// ALPHATEST

	alphatest_fragment: [

		"#ifdef ALPHATEST",

			"if ( gl_FragColor.a < ALPHATEST ) discard;",

		"#endif"

	].join("\n"),

	// LINEAR SPACE

	linear_to_gamma_fragment: [

		"#ifdef GAMMA_OUTPUT",

			"gl_FragColor.xyz = sqrt( gl_FragColor.xyz );",

		"#endif"

	].join("\n")


};
/**
 * Uniform Utilities
 */

THREE.UniformsUtils = {

	merge: function ( uniforms ) {

		var u, p, tmp, merged = {};

		for ( u = 0; u < uniforms.length; u ++ ) {

			tmp = this.clone( uniforms[ u ] );

			for ( p in tmp ) {

				merged[ p ] = tmp[ p ];

			}

		}

		return merged;

	},

	clone: function ( uniforms_src ) {

		var u, p, parameter, parameter_src, uniforms_dst = {};

		for ( u in uniforms_src ) {

			uniforms_dst[ u ] = {};

			for ( p in uniforms_src[ u ] ) {

				parameter_src = uniforms_src[ u ][ p ];

				if ( parameter_src instanceof THREE.Color ||
					 parameter_src instanceof THREE.Vector2 ||
					 parameter_src instanceof THREE.Vector3 ||
					 parameter_src instanceof THREE.Vector4 ||
					 parameter_src instanceof THREE.Matrix4 ||
					 parameter_src instanceof THREE.Texture ) {

					uniforms_dst[ u ][ p ] = parameter_src.clone();

				} else if ( parameter_src instanceof Array ) {

					uniforms_dst[ u ][ p ] = parameter_src.slice();

				} else {

					uniforms_dst[ u ][ p ] = parameter_src;

				}

			}

		}

		return uniforms_dst;

	}

};
/**
 * Uniforms library for shared webgl shaders
 */

THREE.UniformsLib = {

	common: {

		"diffuse" : { type: "c", value: new THREE.Color( 0xeeeeee ) },
		"opacity" : { type: "f", value: 1.0 },

		"map" : { type: "t", value: null },
		"offsetRepeat" : { type: "v4", value: new THREE.Vector4( 0, 0, 1, 1 ) },

		"lightMap" : { type: "t", value: null },
		"specularMap" : { type: "t", value: null },

		"envMap" : { type: "t", value: null },
		"flipEnvMap" : { type: "f", value: -1 },
		"useRefract" : { type: "i", value: 0 },
		"reflectivity" : { type: "f", value: 1.0 },
		"refractionRatio" : { type: "f", value: 0.98 },
		"combine" : { type: "i", value: 0 },

		"morphTargetInfluences" : { type: "f", value: 0 }

	},

	bump: {

		"bumpMap" : { type: "t", value: null },
		"bumpScale" : { type: "f", value: 1 }

	},

	normalmap: {

		"normalMap" : { type: "t", value: null },
		"normalScale" : { type: "v2", value: new THREE.Vector2( 1, 1 ) }
	},

	fog : {

		"fogDensity" : { type: "f", value: 0.00025 },
		"fogNear" : { type: "f", value: 1 },
		"fogFar" : { type: "f", value: 2000 },
		"fogColor" : { type: "c", value: new THREE.Color( 0xffffff ) }

	},

	lights: {

		"ambientLightColor" : { type: "fv", value: [] },

		"directionalLightDirection" : { type: "fv", value: [] },
		"directionalLightColor" : { type: "fv", value: [] },

		"hemisphereLightDirection" : { type: "fv", value: [] },
		"hemisphereLightSkyColor" : { type: "fv", value: [] },
		"hemisphereLightGroundColor" : { type: "fv", value: [] },

		"pointLightColor" : { type: "fv", value: [] },
		"pointLightPosition" : { type: "fv", value: [] },
		"pointLightDistance" : { type: "fv1", value: [] },

		"spotLightColor" : { type: "fv", value: [] },
		"spotLightPosition" : { type: "fv", value: [] },
		"spotLightDirection" : { type: "fv", value: [] },
		"spotLightDistance" : { type: "fv1", value: [] },
		"spotLightAngleCos" : { type: "fv1", value: [] },
		"spotLightExponent" : { type: "fv1", value: [] }

	},

	particle: {

		"psColor" : { type: "c", value: new THREE.Color( 0xeeeeee ) },
		"opacity" : { type: "f", value: 1.0 },
		"size" : { type: "f", value: 1.0 },
		"scale" : { type: "f", value: 1.0 },
		"map" : { type: "t", value: null },

		"fogDensity" : { type: "f", value: 0.00025 },
		"fogNear" : { type: "f", value: 1 },
		"fogFar" : { type: "f", value: 2000 },
		"fogColor" : { type: "c", value: new THREE.Color( 0xffffff ) }

	},

	shadowmap: {

		"shadowMap": { type: "tv", value: [] },
		"shadowMapSize": { type: "v2v", value: [] },

		"shadowBias" : { type: "fv1", value: [] },
		"shadowDarkness": { type: "fv1", value: [] },

		"shadowMatrix" : { type: "m4v", value: [] }

	}

};
/**
 * Webgl Shader Library for three.js
 *
 * @author alteredq / http://alteredqualia.com/
 * @author mrdoob / http://mrdoob.com/
 * @author mikael emtinger / http://gomo.se/
 */


THREE.ShaderLib = {

	'basic': {

		uniforms: THREE.UniformsUtils.merge( [

			THREE.UniformsLib[ "common" ],
			THREE.UniformsLib[ "fog" ],
			THREE.UniformsLib[ "shadowmap" ]

		] ),

		vertexShader: [

			THREE.ShaderChunk[ "map_pars_vertex" ],
			THREE.ShaderChunk[ "lightmap_pars_vertex" ],
			THREE.ShaderChunk[ "envmap_pars_vertex" ],
			THREE.ShaderChunk[ "color_pars_vertex" ],
			THREE.ShaderChunk[ "morphtarget_pars_vertex" ],
			THREE.ShaderChunk[ "skinning_pars_vertex" ],
			THREE.ShaderChunk[ "shadowmap_pars_vertex" ],

			"void main() {",

				THREE.ShaderChunk[ "map_vertex" ],
				THREE.ShaderChunk[ "lightmap_vertex" ],
				THREE.ShaderChunk[ "color_vertex" ],
				THREE.ShaderChunk[ "skinbase_vertex" ],

				"#ifdef USE_ENVMAP",

				THREE.ShaderChunk[ "morphnormal_vertex" ],
				THREE.ShaderChunk[ "skinnormal_vertex" ],
				THREE.ShaderChunk[ "defaultnormal_vertex" ],

				"#endif",

				THREE.ShaderChunk[ "morphtarget_vertex" ],
				THREE.ShaderChunk[ "skinning_vertex" ],
				THREE.ShaderChunk[ "default_vertex" ],

				THREE.ShaderChunk[ "worldpos_vertex" ],
				THREE.ShaderChunk[ "envmap_vertex" ],
				THREE.ShaderChunk[ "shadowmap_vertex" ],

			"}"

		].join("\n"),

		fragmentShader: [

			"uniform vec3 diffuse;",
			"uniform float opacity;",

			THREE.ShaderChunk[ "color_pars_fragment" ],
			THREE.ShaderChunk[ "map_pars_fragment" ],
			THREE.ShaderChunk[ "lightmap_pars_fragment" ],
			THREE.ShaderChunk[ "envmap_pars_fragment" ],
			THREE.ShaderChunk[ "fog_pars_fragment" ],
			THREE.ShaderChunk[ "shadowmap_pars_fragment" ],
			THREE.ShaderChunk[ "specularmap_pars_fragment" ],

			"void main() {",

				"gl_FragColor = vec4( diffuse, opacity );",

				THREE.ShaderChunk[ "map_fragment" ],
				THREE.ShaderChunk[ "alphatest_fragment" ],
				THREE.ShaderChunk[ "specularmap_fragment" ],
				THREE.ShaderChunk[ "lightmap_fragment" ],
				THREE.ShaderChunk[ "color_fragment" ],
				THREE.ShaderChunk[ "envmap_fragment" ],
				THREE.ShaderChunk[ "shadowmap_fragment" ],

				THREE.ShaderChunk[ "linear_to_gamma_fragment" ],

				THREE.ShaderChunk[ "fog_fragment" ],

			"}"

		].join("\n")

	},

	'lambert': {

		uniforms: THREE.UniformsUtils.merge( [

			THREE.UniformsLib[ "common" ],
			THREE.UniformsLib[ "fog" ],
			THREE.UniformsLib[ "lights" ],
			THREE.UniformsLib[ "shadowmap" ],

			{
				"ambient"  : { type: "c", value: new THREE.Color( 0xffffff ) },
				"emissive" : { type: "c", value: new THREE.Color( 0x000000 ) },
				"wrapRGB"  : { type: "v3", value: new THREE.Vector3( 1, 1, 1 ) }
			}

		] ),

		vertexShader: [

			"#define LAMBERT",

			"varying vec3 vLightFront;",

			"#ifdef DOUBLE_SIDED",

				"varying vec3 vLightBack;",

			"#endif",

			THREE.ShaderChunk[ "map_pars_vertex" ],
			THREE.ShaderChunk[ "lightmap_pars_vertex" ],
			THREE.ShaderChunk[ "envmap_pars_vertex" ],
			THREE.ShaderChunk[ "lights_lambert_pars_vertex" ],
			THREE.ShaderChunk[ "color_pars_vertex" ],
			THREE.ShaderChunk[ "morphtarget_pars_vertex" ],
			THREE.ShaderChunk[ "skinning_pars_vertex" ],
			THREE.ShaderChunk[ "shadowmap_pars_vertex" ],

			"void main() {",

				THREE.ShaderChunk[ "map_vertex" ],
				THREE.ShaderChunk[ "lightmap_vertex" ],
				THREE.ShaderChunk[ "color_vertex" ],

				THREE.ShaderChunk[ "morphnormal_vertex" ],
				THREE.ShaderChunk[ "skinbase_vertex" ],
				THREE.ShaderChunk[ "skinnormal_vertex" ],
				THREE.ShaderChunk[ "defaultnormal_vertex" ],

				THREE.ShaderChunk[ "morphtarget_vertex" ],
				THREE.ShaderChunk[ "skinning_vertex" ],
				THREE.ShaderChunk[ "default_vertex" ],

				THREE.ShaderChunk[ "worldpos_vertex" ],
				THREE.ShaderChunk[ "envmap_vertex" ],
				THREE.ShaderChunk[ "lights_lambert_vertex" ],
				THREE.ShaderChunk[ "shadowmap_vertex" ],

			"}"

		].join("\n"),

		fragmentShader: [

			"uniform float opacity;",

			"varying vec3 vLightFront;",

			"#ifdef DOUBLE_SIDED",

				"varying vec3 vLightBack;",

			"#endif",

			THREE.ShaderChunk[ "color_pars_fragment" ],
			THREE.ShaderChunk[ "map_pars_fragment" ],
			THREE.ShaderChunk[ "lightmap_pars_fragment" ],
			THREE.ShaderChunk[ "envmap_pars_fragment" ],
			THREE.ShaderChunk[ "fog_pars_fragment" ],
			THREE.ShaderChunk[ "shadowmap_pars_fragment" ],
			THREE.ShaderChunk[ "specularmap_pars_fragment" ],

			"void main() {",

				"gl_FragColor = vec4( vec3 ( 1.0 ), opacity );",

				THREE.ShaderChunk[ "map_fragment" ],
				THREE.ShaderChunk[ "alphatest_fragment" ],
				THREE.ShaderChunk[ "specularmap_fragment" ],

				"#ifdef DOUBLE_SIDED",

					//"float isFront = float( gl_FrontFacing );",
					//"gl_FragColor.xyz *= isFront * vLightFront + ( 1.0 - isFront ) * vLightBack;",

					"if ( gl_FrontFacing )",
						"gl_FragColor.xyz *= vLightFront;",
					"else",
						"gl_FragColor.xyz *= vLightBack;",

				"#else",

					"gl_FragColor.xyz *= vLightFront;",

				"#endif",

				THREE.ShaderChunk[ "lightmap_fragment" ],
				THREE.ShaderChunk[ "color_fragment" ],
				THREE.ShaderChunk[ "envmap_fragment" ],
				THREE.ShaderChunk[ "shadowmap_fragment" ],

				THREE.ShaderChunk[ "linear_to_gamma_fragment" ],

				THREE.ShaderChunk[ "fog_fragment" ],

			"}"

		].join("\n")

	},

	'phong': {

		uniforms: THREE.UniformsUtils.merge( [

			THREE.UniformsLib[ "common" ],
			THREE.UniformsLib[ "bump" ],
			THREE.UniformsLib[ "normalmap" ],
			THREE.UniformsLib[ "fog" ],
			THREE.UniformsLib[ "lights" ],
			THREE.UniformsLib[ "shadowmap" ],

			{
				"ambient"  : { type: "c", value: new THREE.Color( 0xffffff ) },
				"emissive" : { type: "c", value: new THREE.Color( 0x000000 ) },
				"specular" : { type: "c", value: new THREE.Color( 0x111111 ) },
				"shininess": { type: "f", value: 30 },
				"wrapRGB"  : { type: "v3", value: new THREE.Vector3( 1, 1, 1 ) }
			}

		] ),

		vertexShader: [

			"#define PHONG",

			"varying vec3 vViewPosition;",
			"varying vec3 vNormal;",

			THREE.ShaderChunk[ "map_pars_vertex" ],
			THREE.ShaderChunk[ "lightmap_pars_vertex" ],
			THREE.ShaderChunk[ "envmap_pars_vertex" ],
			THREE.ShaderChunk[ "lights_phong_pars_vertex" ],
			THREE.ShaderChunk[ "color_pars_vertex" ],
			THREE.ShaderChunk[ "morphtarget_pars_vertex" ],
			THREE.ShaderChunk[ "skinning_pars_vertex" ],
			THREE.ShaderChunk[ "shadowmap_pars_vertex" ],

			"void main() {",

				THREE.ShaderChunk[ "map_vertex" ],
				THREE.ShaderChunk[ "lightmap_vertex" ],
				THREE.ShaderChunk[ "color_vertex" ],

				THREE.ShaderChunk[ "morphnormal_vertex" ],
				THREE.ShaderChunk[ "skinbase_vertex" ],
				THREE.ShaderChunk[ "skinnormal_vertex" ],
				THREE.ShaderChunk[ "defaultnormal_vertex" ],

				"vNormal = normalize( transformedNormal );",

				THREE.ShaderChunk[ "morphtarget_vertex" ],
				THREE.ShaderChunk[ "skinning_vertex" ],
				THREE.ShaderChunk[ "default_vertex" ],

				"vViewPosition = -mvPosition.xyz;",

				THREE.ShaderChunk[ "worldpos_vertex" ],
				THREE.ShaderChunk[ "envmap_vertex" ],
				THREE.ShaderChunk[ "lights_phong_vertex" ],
				THREE.ShaderChunk[ "shadowmap_vertex" ],

			"}"

		].join("\n"),

		fragmentShader: [

			"uniform vec3 diffuse;",
			"uniform float opacity;",

			"uniform vec3 ambient;",
			"uniform vec3 emissive;",
			"uniform vec3 specular;",
			"uniform float shininess;",

			THREE.ShaderChunk[ "color_pars_fragment" ],
			THREE.ShaderChunk[ "map_pars_fragment" ],
			THREE.ShaderChunk[ "lightmap_pars_fragment" ],
			THREE.ShaderChunk[ "envmap_pars_fragment" ],
			THREE.ShaderChunk[ "fog_pars_fragment" ],
			THREE.ShaderChunk[ "lights_phong_pars_fragment" ],
			THREE.ShaderChunk[ "shadowmap_pars_fragment" ],
			THREE.ShaderChunk[ "bumpmap_pars_fragment" ],
			THREE.ShaderChunk[ "normalmap_pars_fragment" ],
			THREE.ShaderChunk[ "specularmap_pars_fragment" ],

			"void main() {",

				"gl_FragColor = vec4( vec3 ( 1.0 ), opacity );",

				THREE.ShaderChunk[ "map_fragment" ],
				THREE.ShaderChunk[ "alphatest_fragment" ],
				THREE.ShaderChunk[ "specularmap_fragment" ],

				THREE.ShaderChunk[ "lights_phong_fragment" ],

				THREE.ShaderChunk[ "lightmap_fragment" ],
				THREE.ShaderChunk[ "color_fragment" ],
				THREE.ShaderChunk[ "envmap_fragment" ],
				THREE.ShaderChunk[ "shadowmap_fragment" ],

				THREE.ShaderChunk[ "linear_to_gamma_fragment" ],

				THREE.ShaderChunk[ "fog_fragment" ],

			"}"

		].join("\n")

	},

	'particle_basic': {

		uniforms:  THREE.UniformsUtils.merge( [

			THREE.UniformsLib[ "particle" ],
			THREE.UniformsLib[ "shadowmap" ]

		] ),

		vertexShader: [

			"uniform float size;",
			"uniform float scale;",

			THREE.ShaderChunk[ "color_pars_vertex" ],
			THREE.ShaderChunk[ "shadowmap_pars_vertex" ],

			"void main() {",

				THREE.ShaderChunk[ "color_vertex" ],

				"vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );",

				"#ifdef USE_SIZEATTENUATION",
					"gl_PointSize = size * ( scale / length( mvPosition.xyz ) );",
				"#else",
					"gl_PointSize = size;",
				"#endif",

				"gl_Position = projectionMatrix * mvPosition;",

				THREE.ShaderChunk[ "worldpos_vertex" ],
				THREE.ShaderChunk[ "shadowmap_vertex" ],

			"}"

		].join("\n"),

		fragmentShader: [

			"uniform vec3 psColor;",
			"uniform float opacity;",

			THREE.ShaderChunk[ "color_pars_fragment" ],
			THREE.ShaderChunk[ "map_particle_pars_fragment" ],
			THREE.ShaderChunk[ "fog_pars_fragment" ],
			THREE.ShaderChunk[ "shadowmap_pars_fragment" ],

			"void main() {",

				"gl_FragColor = vec4( psColor, opacity );",

				THREE.ShaderChunk[ "map_particle_fragment" ],
				THREE.ShaderChunk[ "alphatest_fragment" ],
				THREE.ShaderChunk[ "color_fragment" ],
				THREE.ShaderChunk[ "shadowmap_fragment" ],
				THREE.ShaderChunk[ "fog_fragment" ],

			"}"

		].join("\n")

	},

	'dashed': {

		uniforms: THREE.UniformsUtils.merge( [

			THREE.UniformsLib[ "common" ],
			THREE.UniformsLib[ "fog" ],

			{
				"scale":     { type: "f", value: 1 },
				"dashSize":  { type: "f", value: 1 },
				"totalSize": { type: "f", value: 2 }
			}

		] ),

		vertexShader: [

			"uniform float scale;",
			"attribute float lineDistance;",

			"varying float vLineDistance;",

			THREE.ShaderChunk[ "color_pars_vertex" ],

			"void main() {",

				THREE.ShaderChunk[ "color_vertex" ],

				"vLineDistance = scale * lineDistance;",

				"vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );",
				"gl_Position = projectionMatrix * mvPosition;",

			"}"

		].join("\n"),

		fragmentShader: [

			"uniform vec3 diffuse;",
			"uniform float opacity;",

			"uniform float dashSize;",
			"uniform float totalSize;",

			"varying float vLineDistance;",

			THREE.ShaderChunk[ "color_pars_fragment" ],
			THREE.ShaderChunk[ "fog_pars_fragment" ],

			"void main() {",

				"if ( mod( vLineDistance, totalSize ) > dashSize ) {",

					"discard;",

				"}",

				"gl_FragColor = vec4( diffuse, opacity );",

				THREE.ShaderChunk[ "color_fragment" ],
				THREE.ShaderChunk[ "fog_fragment" ],

			"}"

		].join("\n")

	},

	'depth': {

		uniforms: {

			"mNear": { type: "f", value: 1.0 },
			"mFar" : { type: "f", value: 2000.0 },
			"opacity" : { type: "f", value: 1.0 }

		},

		vertexShader: [

			"void main() {",

				"gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );",

			"}"

		].join("\n"),

		fragmentShader: [

			"uniform float mNear;",
			"uniform float mFar;",
			"uniform float opacity;",

			"void main() {",

				"float depth = gl_FragCoord.z / gl_FragCoord.w;",
				"float color = 1.0 - smoothstep( mNear, mFar, depth );",
				"gl_FragColor = vec4( vec3( color ), opacity );",

			"}"

		].join("\n")

	},

	'normal': {

		uniforms: {

			"opacity" : { type: "f", value: 1.0 }

		},

		vertexShader: [

			"varying vec3 vNormal;",

			THREE.ShaderChunk[ "morphtarget_pars_vertex" ],

			"void main() {",

				"vNormal = normalize( normalMatrix * normal );",

				THREE.ShaderChunk[ "morphtarget_vertex" ],
				THREE.ShaderChunk[ "default_vertex" ],

			"}"

		].join("\n"),

		fragmentShader: [

			"uniform float opacity;",
			"varying vec3 vNormal;",

			"void main() {",

				"gl_FragColor = vec4( 0.5 * normalize( vNormal ) + 0.5, opacity );",

			"}"

		].join("\n")

	},

	/* -------------------------------------------------------------------------
	//	Normal map shader
	//		- Blinn-Phong
	//		- normal + diffuse + specular + AO + displacement + reflection + shadow maps
	//		- point and directional lights (use with "lights: true" material option)
	 ------------------------------------------------------------------------- */

	'normalmap' : {

		uniforms: THREE.UniformsUtils.merge( [

			THREE.UniformsLib[ "fog" ],
			THREE.UniformsLib[ "lights" ],
			THREE.UniformsLib[ "shadowmap" ],

			{

			"enableAO"		  : { type: "i", value: 0 },
			"enableDiffuse"	  : { type: "i", value: 0 },
			"enableSpecular"  : { type: "i", value: 0 },
			"enableReflection": { type: "i", value: 0 },
			"enableDisplacement": { type: "i", value: 0 },

			"tDisplacement": { type: "t", value: null }, // must go first as this is vertex texture
			"tDiffuse"	   : { type: "t", value: null },
			"tCube"		   : { type: "t", value: null },
			"tNormal"	   : { type: "t", value: null },
			"tSpecular"	   : { type: "t", value: null },
			"tAO"		   : { type: "t", value: null },

			"uNormalScale": { type: "v2", value: new THREE.Vector2( 1, 1 ) },

			"uDisplacementBias": { type: "f", value: 0.0 },
			"uDisplacementScale": { type: "f", value: 1.0 },

			"diffuse": { type: "c", value: new THREE.Color( 0xffffff ) },
			"specular": { type: "c", value: new THREE.Color( 0x111111 ) },
			"ambient": { type: "c", value: new THREE.Color( 0xffffff ) },
			"shininess": { type: "f", value: 30 },
			"opacity": { type: "f", value: 1 },

			"useRefract": { type: "i", value: 0 },
			"refractionRatio": { type: "f", value: 0.98 },
			"reflectivity": { type: "f", value: 0.5 },

			"uOffset" : { type: "v2", value: new THREE.Vector2( 0, 0 ) },
			"uRepeat" : { type: "v2", value: new THREE.Vector2( 1, 1 ) },

			"wrapRGB"  : { type: "v3", value: new THREE.Vector3( 1, 1, 1 ) }

			}

		] ),

		fragmentShader: [

			"uniform vec3 ambient;",
			"uniform vec3 diffuse;",
			"uniform vec3 specular;",
			"uniform float shininess;",
			"uniform float opacity;",

			"uniform bool enableDiffuse;",
			"uniform bool enableSpecular;",
			"uniform bool enableAO;",
			"uniform bool enableReflection;",

			"uniform sampler2D tDiffuse;",
			"uniform sampler2D tNormal;",
			"uniform sampler2D tSpecular;",
			"uniform sampler2D tAO;",

			"uniform samplerCube tCube;",

			"uniform vec2 uNormalScale;",

			"uniform bool useRefract;",
			"uniform float refractionRatio;",
			"uniform float reflectivity;",

			"varying vec3 vTangent;",
			"varying vec3 vBinormal;",
			"varying vec3 vNormal;",
			"varying vec2 vUv;",

			"uniform vec3 ambientLightColor;",

			"#if MAX_DIR_LIGHTS > 0",

				"uniform vec3 directionalLightColor[ MAX_DIR_LIGHTS ];",
				"uniform vec3 directionalLightDirection[ MAX_DIR_LIGHTS ];",

			"#endif",

			"#if MAX_HEMI_LIGHTS > 0",

				"uniform vec3 hemisphereLightSkyColor[ MAX_HEMI_LIGHTS ];",
				"uniform vec3 hemisphereLightGroundColor[ MAX_HEMI_LIGHTS ];",
				"uniform vec3 hemisphereLightDirection[ MAX_HEMI_LIGHTS ];",

			"#endif",

			"#if MAX_POINT_LIGHTS > 0",

				"uniform vec3 pointLightColor[ MAX_POINT_LIGHTS ];",
				"uniform vec3 pointLightPosition[ MAX_POINT_LIGHTS ];",
				"uniform float pointLightDistance[ MAX_POINT_LIGHTS ];",

			"#endif",

			"#if MAX_SPOT_LIGHTS > 0",

				"uniform vec3 spotLightColor[ MAX_SPOT_LIGHTS ];",
				"uniform vec3 spotLightPosition[ MAX_SPOT_LIGHTS ];",
				"uniform vec3 spotLightDirection[ MAX_SPOT_LIGHTS ];",
				"uniform float spotLightAngleCos[ MAX_SPOT_LIGHTS ];",
				"uniform float spotLightExponent[ MAX_SPOT_LIGHTS ];",
				"uniform float spotLightDistance[ MAX_SPOT_LIGHTS ];",

			"#endif",

			"#ifdef WRAP_AROUND",

				"uniform vec3 wrapRGB;",

			"#endif",

			"varying vec3 vWorldPosition;",
			"varying vec3 vViewPosition;",

			THREE.ShaderChunk[ "shadowmap_pars_fragment" ],
			THREE.ShaderChunk[ "fog_pars_fragment" ],

			"void main() {",

				"gl_FragColor = vec4( vec3( 1.0 ), opacity );",

				"vec3 specularTex = vec3( 1.0 );",

				"vec3 normalTex = texture2D( tNormal, vUv ).xyz * 2.0 - 1.0;",
				"normalTex.xy *= uNormalScale;",
				"normalTex = normalize( normalTex );",

				"if( enableDiffuse ) {",

					"#ifdef GAMMA_INPUT",

						"vec4 texelColor = texture2D( tDiffuse, vUv );",
						"texelColor.xyz *= texelColor.xyz;",

						"gl_FragColor = gl_FragColor * texelColor;",

					"#else",

						"gl_FragColor = gl_FragColor * texture2D( tDiffuse, vUv );",

					"#endif",

				"}",

				"if( enableAO ) {",

					"#ifdef GAMMA_INPUT",

						"vec4 aoColor = texture2D( tAO, vUv );",
						"aoColor.xyz *= aoColor.xyz;",

						"gl_FragColor.xyz = gl_FragColor.xyz * aoColor.xyz;",

					"#else",

						"gl_FragColor.xyz = gl_FragColor.xyz * texture2D( tAO, vUv ).xyz;",

					"#endif",

				"}",

				"if( enableSpecular )",
					"specularTex = texture2D( tSpecular, vUv ).xyz;",

				"mat3 tsb = mat3( normalize( vTangent ), normalize( vBinormal ), normalize( vNormal ) );",
				"vec3 finalNormal = tsb * normalTex;",

				"#ifdef FLIP_SIDED",

					"finalNormal = -finalNormal;",

				"#endif",

				"vec3 normal = normalize( finalNormal );",
				"vec3 viewPosition = normalize( vViewPosition );",

				// point lights

				"#if MAX_POINT_LIGHTS > 0",

					"vec3 pointDiffuse = vec3( 0.0 );",
					"vec3 pointSpecular = vec3( 0.0 );",

					"for ( int i = 0; i < MAX_POINT_LIGHTS; i ++ ) {",

						"vec4 lPosition = viewMatrix * vec4( pointLightPosition[ i ], 1.0 );",
						"vec3 pointVector = lPosition.xyz + vViewPosition.xyz;",

						"float pointDistance = 1.0;",
						"if ( pointLightDistance[ i ] > 0.0 )",
							"pointDistance = 1.0 - min( ( length( pointVector ) / pointLightDistance[ i ] ), 1.0 );",

						"pointVector = normalize( pointVector );",

						// diffuse

						"#ifdef WRAP_AROUND",

							"float pointDiffuseWeightFull = max( dot( normal, pointVector ), 0.0 );",
							"float pointDiffuseWeightHalf = max( 0.5 * dot( normal, pointVector ) + 0.5, 0.0 );",

							"vec3 pointDiffuseWeight = mix( vec3 ( pointDiffuseWeightFull ), vec3( pointDiffuseWeightHalf ), wrapRGB );",

						"#else",

							"float pointDiffuseWeight = max( dot( normal, pointVector ), 0.0 );",

						"#endif",

						"pointDiffuse += pointDistance * pointLightColor[ i ] * diffuse * pointDiffuseWeight;",

						// specular

						"vec3 pointHalfVector = normalize( pointVector + viewPosition );",
						"float pointDotNormalHalf = max( dot( normal, pointHalfVector ), 0.0 );",
						"float pointSpecularWeight = specularTex.r * max( pow( pointDotNormalHalf, shininess ), 0.0 );",

						// 2.0 => 2.0001 is hack to work around ANGLE bug

						"float specularNormalization = ( shininess + 2.0001 ) / 8.0;",

						"vec3 schlick = specular + vec3( 1.0 - specular ) * pow( 1.0 - dot( pointVector, pointHalfVector ), 5.0 );",
						"pointSpecular += schlick * pointLightColor[ i ] * pointSpecularWeight * pointDiffuseWeight * pointDistance * specularNormalization;",

					"}",

				"#endif",

				// spot lights

				"#if MAX_SPOT_LIGHTS > 0",

					"vec3 spotDiffuse = vec3( 0.0 );",
					"vec3 spotSpecular = vec3( 0.0 );",

					"for ( int i = 0; i < MAX_SPOT_LIGHTS; i ++ ) {",

						"vec4 lPosition = viewMatrix * vec4( spotLightPosition[ i ], 1.0 );",
						"vec3 spotVector = lPosition.xyz + vViewPosition.xyz;",

						"float spotDistance = 1.0;",
						"if ( spotLightDistance[ i ] > 0.0 )",
							"spotDistance = 1.0 - min( ( length( spotVector ) / spotLightDistance[ i ] ), 1.0 );",

						"spotVector = normalize( spotVector );",

						"float spotEffect = dot( spotLightDirection[ i ], normalize( spotLightPosition[ i ] - vWorldPosition ) );",

						"if ( spotEffect > spotLightAngleCos[ i ] ) {",

							"spotEffect = max( pow( spotEffect, spotLightExponent[ i ] ), 0.0 );",

							// diffuse

							"#ifdef WRAP_AROUND",

								"float spotDiffuseWeightFull = max( dot( normal, spotVector ), 0.0 );",
								"float spotDiffuseWeightHalf = max( 0.5 * dot( normal, spotVector ) + 0.5, 0.0 );",

								"vec3 spotDiffuseWeight = mix( vec3 ( spotDiffuseWeightFull ), vec3( spotDiffuseWeightHalf ), wrapRGB );",

							"#else",

								"float spotDiffuseWeight = max( dot( normal, spotVector ), 0.0 );",

							"#endif",

							"spotDiffuse += spotDistance * spotLightColor[ i ] * diffuse * spotDiffuseWeight * spotEffect;",

							// specular

							"vec3 spotHalfVector = normalize( spotVector + viewPosition );",
							"float spotDotNormalHalf = max( dot( normal, spotHalfVector ), 0.0 );",
							"float spotSpecularWeight = specularTex.r * max( pow( spotDotNormalHalf, shininess ), 0.0 );",

							// 2.0 => 2.0001 is hack to work around ANGLE bug

							"float specularNormalization = ( shininess + 2.0001 ) / 8.0;",

							"vec3 schlick = specular + vec3( 1.0 - specular ) * pow( 1.0 - dot( spotVector, spotHalfVector ), 5.0 );",
							"spotSpecular += schlick * spotLightColor[ i ] * spotSpecularWeight * spotDiffuseWeight * spotDistance * specularNormalization * spotEffect;",

						"}",

					"}",

				"#endif",

				// directional lights

				"#if MAX_DIR_LIGHTS > 0",

					"vec3 dirDiffuse = vec3( 0.0 );",
					"vec3 dirSpecular = vec3( 0.0 );",

					"for( int i = 0; i < MAX_DIR_LIGHTS; i++ ) {",

						"vec4 lDirection = viewMatrix * vec4( directionalLightDirection[ i ], 0.0 );",
						"vec3 dirVector = normalize( lDirection.xyz );",

						// diffuse

						"#ifdef WRAP_AROUND",

							"float directionalLightWeightingFull = max( dot( normal, dirVector ), 0.0 );",
							"float directionalLightWeightingHalf = max( 0.5 * dot( normal, dirVector ) + 0.5, 0.0 );",

							"vec3 dirDiffuseWeight = mix( vec3( directionalLightWeightingFull ), vec3( directionalLightWeightingHalf ), wrapRGB );",

						"#else",

							"float dirDiffuseWeight = max( dot( normal, dirVector ), 0.0 );",

						"#endif",

						"dirDiffuse += directionalLightColor[ i ] * diffuse * dirDiffuseWeight;",

						// specular

						"vec3 dirHalfVector = normalize( dirVector + viewPosition );",
						"float dirDotNormalHalf = max( dot( normal, dirHalfVector ), 0.0 );",
						"float dirSpecularWeight = specularTex.r * max( pow( dirDotNormalHalf, shininess ), 0.0 );",

						// 2.0 => 2.0001 is hack to work around ANGLE bug

						"float specularNormalization = ( shininess + 2.0001 ) / 8.0;",

						"vec3 schlick = specular + vec3( 1.0 - specular ) * pow( 1.0 - dot( dirVector, dirHalfVector ), 5.0 );",
						"dirSpecular += schlick * directionalLightColor[ i ] * dirSpecularWeight * dirDiffuseWeight * specularNormalization;",

					"}",

				"#endif",

				// hemisphere lights

				"#if MAX_HEMI_LIGHTS > 0",

					"vec3 hemiDiffuse  = vec3( 0.0 );",
					"vec3 hemiSpecular = vec3( 0.0 );" ,

					"for( int i = 0; i < MAX_HEMI_LIGHTS; i ++ ) {",

						"vec4 lDirection = viewMatrix * vec4( hemisphereLightDirection[ i ], 0.0 );",
						"vec3 lVector = normalize( lDirection.xyz );",

						// diffuse

						"float dotProduct = dot( normal, lVector );",
						"float hemiDiffuseWeight = 0.5 * dotProduct + 0.5;",

						"vec3 hemiColor = mix( hemisphereLightGroundColor[ i ], hemisphereLightSkyColor[ i ], hemiDiffuseWeight );",

						"hemiDiffuse += diffuse * hemiColor;",

						// specular (sky light)


						"vec3 hemiHalfVectorSky = normalize( lVector + viewPosition );",
						"float hemiDotNormalHalfSky = 0.5 * dot( normal, hemiHalfVectorSky ) + 0.5;",
						"float hemiSpecularWeightSky = specularTex.r * max( pow( hemiDotNormalHalfSky, shininess ), 0.0 );",

						// specular (ground light)

						"vec3 lVectorGround = -lVector;",

						"vec3 hemiHalfVectorGround = normalize( lVectorGround + viewPosition );",
						"float hemiDotNormalHalfGround = 0.5 * dot( normal, hemiHalfVectorGround ) + 0.5;",
						"float hemiSpecularWeightGround = specularTex.r * max( pow( hemiDotNormalHalfGround, shininess ), 0.0 );",

						"float dotProductGround = dot( normal, lVectorGround );",

						// 2.0 => 2.0001 is hack to work around ANGLE bug

						"float specularNormalization = ( shininess + 2.0001 ) / 8.0;",

						"vec3 schlickSky = specular + vec3( 1.0 - specular ) * pow( 1.0 - dot( lVector, hemiHalfVectorSky ), 5.0 );",
						"vec3 schlickGround = specular + vec3( 1.0 - specular ) * pow( 1.0 - dot( lVectorGround, hemiHalfVectorGround ), 5.0 );",
						"hemiSpecular += hemiColor * specularNormalization * ( schlickSky * hemiSpecularWeightSky * max( dotProduct, 0.0 ) + schlickGround * hemiSpecularWeightGround * max( dotProductGround, 0.0 ) );",

					"}",

				"#endif",

				// all lights contribution summation

				"vec3 totalDiffuse = vec3( 0.0 );",
				"vec3 totalSpecular = vec3( 0.0 );",

				"#if MAX_DIR_LIGHTS > 0",

					"totalDiffuse += dirDiffuse;",
					"totalSpecular += dirSpecular;",

				"#endif",

				"#if MAX_HEMI_LIGHTS > 0",

					"totalDiffuse += hemiDiffuse;",
					"totalSpecular += hemiSpecular;",

				"#endif",

				"#if MAX_POINT_LIGHTS > 0",

					"totalDiffuse += pointDiffuse;",
					"totalSpecular += pointSpecular;",

				"#endif",

				"#if MAX_SPOT_LIGHTS > 0",

					"totalDiffuse += spotDiffuse;",
					"totalSpecular += spotSpecular;",

				"#endif",

				"#ifdef METAL",

					"gl_FragColor.xyz = gl_FragColor.xyz * ( totalDiffuse + ambientLightColor * ambient + totalSpecular );",

				"#else",

					"gl_FragColor.xyz = gl_FragColor.xyz * ( totalDiffuse + ambientLightColor * ambient ) + totalSpecular;",

				"#endif",

				"if ( enableReflection ) {",

					"vec3 vReflect;",
					"vec3 cameraToVertex = normalize( vWorldPosition - cameraPosition );",

					"if ( useRefract ) {",

						"vReflect = refract( cameraToVertex, normal, refractionRatio );",

					"} else {",

						"vReflect = reflect( cameraToVertex, normal );",

					"}",

					"vec4 cubeColor = textureCube( tCube, vec3( -vReflect.x, vReflect.yz ) );",

					"#ifdef GAMMA_INPUT",

						"cubeColor.xyz *= cubeColor.xyz;",

					"#endif",

					"gl_FragColor.xyz = mix( gl_FragColor.xyz, cubeColor.xyz, specularTex.r * reflectivity );",

				"}",

				THREE.ShaderChunk[ "shadowmap_fragment" ],
				THREE.ShaderChunk[ "linear_to_gamma_fragment" ],
				THREE.ShaderChunk[ "fog_fragment" ],

			"}"

		].join("\n"),

		vertexShader: [

			"attribute vec4 tangent;",

			"uniform vec2 uOffset;",
			"uniform vec2 uRepeat;",

			"uniform bool enableDisplacement;",

			"#ifdef VERTEX_TEXTURES",

				"uniform sampler2D tDisplacement;",
				"uniform float uDisplacementScale;",
				"uniform float uDisplacementBias;",

			"#endif",

			"varying vec3 vTangent;",
			"varying vec3 vBinormal;",
			"varying vec3 vNormal;",
			"varying vec2 vUv;",

			"varying vec3 vWorldPosition;",
			"varying vec3 vViewPosition;",

			THREE.ShaderChunk[ "skinning_pars_vertex" ],
			THREE.ShaderChunk[ "shadowmap_pars_vertex" ],

			"void main() {",

				THREE.ShaderChunk[ "skinbase_vertex" ],
				THREE.ShaderChunk[ "skinnormal_vertex" ],

				// normal, tangent and binormal vectors

				"#ifdef USE_SKINNING",

					"vNormal = normalize( normalMatrix * skinnedNormal.xyz );",

					"vec4 skinnedTangent = skinMatrix * vec4( tangent.xyz, 0.0 );",
					"vTangent = normalize( normalMatrix * skinnedTangent.xyz );",

				"#else",

					"vNormal = normalize( normalMatrix * normal );",
					"vTangent = normalize( normalMatrix * tangent.xyz );",

				"#endif",

				"vBinormal = normalize( cross( vNormal, vTangent ) * tangent.w );",

				"vUv = uv * uRepeat + uOffset;",

				// displacement mapping

				"vec3 displacedPosition;",

				"#ifdef VERTEX_TEXTURES",

					"if ( enableDisplacement ) {",

						"vec3 dv = texture2D( tDisplacement, uv ).xyz;",
						"float df = uDisplacementScale * dv.x + uDisplacementBias;",
						"displacedPosition = position + normalize( normal ) * df;",

					"} else {",

						"#ifdef USE_SKINNING",

							"vec4 skinVertex = vec4( position, 1.0 );",

							"vec4 skinned  = boneMatX * skinVertex * skinWeight.x;",
							"skinned 	  += boneMatY * skinVertex * skinWeight.y;",

							"displacedPosition  = skinned.xyz;",

						"#else",

							"displacedPosition = position;",

						"#endif",

					"}",

				"#else",

					"#ifdef USE_SKINNING",

						"vec4 skinVertex = vec4( position, 1.0 );",

						"vec4 skinned  = boneMatX * skinVertex * skinWeight.x;",
						"skinned 	  += boneMatY * skinVertex * skinWeight.y;",

						"displacedPosition  = skinned.xyz;",

					"#else",

						"displacedPosition = position;",

					"#endif",

				"#endif",

				//

				"vec4 mvPosition = modelViewMatrix * vec4( displacedPosition, 1.0 );",
				"vec4 worldPosition = modelMatrix * vec4( displacedPosition, 1.0 );",

				"gl_Position = projectionMatrix * mvPosition;",

				//

				"vWorldPosition = worldPosition.xyz;",
				"vViewPosition = -mvPosition.xyz;",

				// shadows

				"#ifdef USE_SHADOWMAP",

					"for( int i = 0; i < MAX_SHADOWS; i ++ ) {",

						"vShadowCoord[ i ] = shadowMatrix[ i ] * worldPosition;",

					"}",

				"#endif",

			"}"

		].join("\n")

	},

	/* -------------------------------------------------------------------------
	//	Cube map shader
	 ------------------------------------------------------------------------- */

	'cube': {

		uniforms: { "tCube": { type: "t", value: null },
					"tFlip": { type: "f", value: -1 } },

		vertexShader: [

			"varying vec3 vWorldPosition;",

			"void main() {",

				"vec4 worldPosition = modelMatrix * vec4( position, 1.0 );",
				"vWorldPosition = worldPosition.xyz;",

				"gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );",

			"}"

		].join("\n"),

		fragmentShader: [

			"uniform samplerCube tCube;",
			"uniform float tFlip;",

			"varying vec3 vWorldPosition;",

			"void main() {",

				"gl_FragColor = textureCube( tCube, vec3( tFlip * vWorldPosition.x, vWorldPosition.yz ) );",

			"}"

		].join("\n")

	},

	// Depth encoding into RGBA texture
	// 	based on SpiderGL shadow map example
	// 		http://spidergl.org/example.php?id=6
	// 	originally from
	//		http://www.gamedev.net/topic/442138-packing-a-float-into-a-a8r8g8b8-texture-shader/page__whichpage__1%25EF%25BF%25BD
	// 	see also here:
	//		http://aras-p.info/blog/2009/07/30/encoding-floats-to-rgba-the-final/

	'depthRGBA': {

		uniforms: {},

		vertexShader: [

			THREE.ShaderChunk[ "morphtarget_pars_vertex" ],
			THREE.ShaderChunk[ "skinning_pars_vertex" ],

			"void main() {",

				THREE.ShaderChunk[ "skinbase_vertex" ],
				THREE.ShaderChunk[ "morphtarget_vertex" ],
				THREE.ShaderChunk[ "skinning_vertex" ],
				THREE.ShaderChunk[ "default_vertex" ],

			"}"

		].join("\n"),

		fragmentShader: [

			"vec4 pack_depth( const in float depth ) {",

				"const vec4 bit_shift = vec4( 256.0 * 256.0 * 256.0, 256.0 * 256.0, 256.0, 1.0 );",
				"const vec4 bit_mask  = vec4( 0.0, 1.0 / 256.0, 1.0 / 256.0, 1.0 / 256.0 );",
				"vec4 res = fract( depth * bit_shift );",
				"res -= res.xxyz * bit_mask;",
				"return res;",

			"}",

			"void main() {",

				"gl_FragData[ 0 ] = pack_depth( gl_FragCoord.z );",

				//"gl_FragData[ 0 ] = pack_depth( gl_FragCoord.z / gl_FragCoord.w );",
				//"float z = ( ( gl_FragCoord.z / gl_FragCoord.w ) - 3.0 ) / ( 4000.0 - 3.0 );",
				//"gl_FragData[ 0 ] = pack_depth( z );",
				//"gl_FragData[ 0 ] = vec4( z, z, z, 1.0 );",

			"}"

		].join("\n")

	}

};

/**
 * @author supereggbert / http://www.paulbrunt.co.uk/
 * @author mrdoob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 * @author szimek / https://github.com/szimek/
 */

THREE.WebGLRenderer = function ( parameters ) {

//	console.log( 'THREE.WebGLRenderer', THREE.REVISION );

	parameters = parameters || {};

	var _canvas = parameters.canvas !== undefined ? parameters.canvas : document.createElement( 'canvas' ),

	_precision = parameters.precision !== undefined ? parameters.precision : 'highp',

	_alpha = parameters.alpha !== undefined ? parameters.alpha : false,
	_premultipliedAlpha = parameters.premultipliedAlpha !== undefined ? parameters.premultipliedAlpha : true,
	_antialias = parameters.antialias !== undefined ? parameters.antialias : false,
	_stencil = parameters.stencil !== undefined ? parameters.stencil : true,
	_preserveDrawingBuffer = parameters.preserveDrawingBuffer !== undefined ? parameters.preserveDrawingBuffer : false,

	_clearColor = new THREE.Color( 0x000000 ),
	_clearAlpha = 0;

	// public properties

	this.domElement = _canvas;
	this.context = null;
	this.devicePixelRatio = parameters.devicePixelRatio !== undefined
				? parameters.devicePixelRatio
				: self.devicePixelRatio !== undefined
					? self.devicePixelRatio
					: 1;

	// clearing

	this.autoClear = true;
	this.autoClearColor = true;
	this.autoClearDepth = true;
	this.autoClearStencil = true;

	// scene graph

	this.sortObjects = true;
	this.autoUpdateObjects = true;

	// physically based shading

	this.gammaInput = false;
	this.gammaOutput = false;

	// shadow map

	this.shadowMapEnabled = false;
	this.shadowMapAutoUpdate = true;
	this.shadowMapType = THREE.PCFShadowMap;
	this.shadowMapCullFace = THREE.CullFaceFront;
	this.shadowMapDebug = false;
	this.shadowMapCascade = false;

	// morphs

	this.maxMorphTargets = 8;
	this.maxMorphNormals = 4;

	// flags

	this.autoScaleCubemaps = true;

	// custom render plugins

	this.renderPluginsPre = [];
	this.renderPluginsPost = [];

	// info

	this.info = {

		memory: {

			programs: 0,
			geometries: 0,
			textures: 0

		},

		render: {

			calls: 0,
			vertices: 0,
			faces: 0,
			points: 0

		}

	};

	// internal properties

	var _this = this,

	_programs = [],
	_programs_counter = 0,

	// internal state cache

	_currentProgram = null,
	_currentFramebuffer = null,
	_currentMaterialId = -1,
	_currentGeometryGroupHash = null,
	_currentCamera = null,
	_geometryGroupCounter = 0,

	_usedTextureUnits = 0,

	// GL state cache

	_oldDoubleSided = -1,
	_oldFlipSided = -1,

	_oldBlending = -1,

	_oldBlendEquation = -1,
	_oldBlendSrc = -1,
	_oldBlendDst = -1,

	_oldDepthTest = -1,
	_oldDepthWrite = -1,

	_oldPolygonOffset = null,
	_oldPolygonOffsetFactor = null,
	_oldPolygonOffsetUnits = null,

	_oldLineWidth = null,

	_viewportX = 0,
	_viewportY = 0,
	_viewportWidth = _canvas.width,
	_viewportHeight = _canvas.height,
	_currentWidth = 0,
	_currentHeight = 0,

	_enabledAttributes = {},

	// frustum

	_frustum = new THREE.Frustum(),

	 // camera matrices cache

	_projScreenMatrix = new THREE.Matrix4(),
	_projScreenMatrixPS = new THREE.Matrix4(),

	_vector3 = new THREE.Vector3(),

	// light arrays cache

	_direction = new THREE.Vector3(),

	_lightsNeedUpdate = true,

	_lights = {

		ambient: [ 0, 0, 0 ],
		directional: { length: 0, colors: new Array(), positions: new Array() },
		point: { length: 0, colors: new Array(), positions: new Array(), distances: new Array() },
		spot: { length: 0, colors: new Array(), positions: new Array(), distances: new Array(), directions: new Array(), anglesCos: new Array(), exponents: new Array() },
		hemi: { length: 0, skyColors: new Array(), groundColors: new Array(), positions: new Array() }

	};

	// initialize

	var _gl;

	var _glExtensionTextureFloat;
	var _glExtensionTextureFloatLinear;
	var _glExtensionStandardDerivatives;
	var _glExtensionTextureFilterAnisotropic;
	var _glExtensionCompressedTextureS3TC;

	initGL();

	setDefaultGLState();

	this.context = _gl;

	// GPU capabilities

	var _maxTextures = _gl.getParameter( _gl.MAX_TEXTURE_IMAGE_UNITS );
	var _maxVertexTextures = _gl.getParameter( _gl.MAX_VERTEX_TEXTURE_IMAGE_UNITS );
	var _maxTextureSize = _gl.getParameter( _gl.MAX_TEXTURE_SIZE );
	var _maxCubemapSize = _gl.getParameter( _gl.MAX_CUBE_MAP_TEXTURE_SIZE );

	var _maxAnisotropy = _glExtensionTextureFilterAnisotropic ? _gl.getParameter( _glExtensionTextureFilterAnisotropic.MAX_TEXTURE_MAX_ANISOTROPY_EXT ) : 0;

	var _supportsVertexTextures = ( _maxVertexTextures > 0 );
	var _supportsBoneTextures = _supportsVertexTextures && _glExtensionTextureFloat;

	var _compressedTextureFormats = _glExtensionCompressedTextureS3TC ? _gl.getParameter( _gl.COMPRESSED_TEXTURE_FORMATS ) : [];

	//

	var _vertexShaderPrecisionHighpFloat = _gl.getShaderPrecisionFormat( _gl.VERTEX_SHADER, _gl.HIGH_FLOAT );
	var _vertexShaderPrecisionMediumpFloat = _gl.getShaderPrecisionFormat( _gl.VERTEX_SHADER, _gl.MEDIUM_FLOAT );
	var _vertexShaderPrecisionLowpFloat = _gl.getShaderPrecisionFormat( _gl.VERTEX_SHADER, _gl.LOW_FLOAT );

	var _fragmentShaderPrecisionHighpFloat = _gl.getShaderPrecisionFormat( _gl.FRAGMENT_SHADER, _gl.HIGH_FLOAT );
	var _fragmentShaderPrecisionMediumpFloat = _gl.getShaderPrecisionFormat( _gl.FRAGMENT_SHADER, _gl.MEDIUM_FLOAT );
	var _fragmentShaderPrecisionLowpFloat = _gl.getShaderPrecisionFormat( _gl.FRAGMENT_SHADER, _gl.LOW_FLOAT );

	var _vertexShaderPrecisionHighpInt = _gl.getShaderPrecisionFormat( _gl.VERTEX_SHADER, _gl.HIGH_INT );
	var _vertexShaderPrecisionMediumpInt = _gl.getShaderPrecisionFormat( _gl.VERTEX_SHADER, _gl.MEDIUM_INT );
	var _vertexShaderPrecisionLowpInt = _gl.getShaderPrecisionFormat( _gl.VERTEX_SHADER, _gl.LOW_INT );

	var _fragmentShaderPrecisionHighpInt = _gl.getShaderPrecisionFormat( _gl.FRAGMENT_SHADER, _gl.HIGH_INT );
	var _fragmentShaderPrecisionMediumpInt = _gl.getShaderPrecisionFormat( _gl.FRAGMENT_SHADER, _gl.MEDIUM_INT );
	var _fragmentShaderPrecisionLowpInt = _gl.getShaderPrecisionFormat( _gl.FRAGMENT_SHADER, _gl.LOW_INT );

	// clamp precision to maximum available

	var highpAvailable = _vertexShaderPrecisionHighpFloat.precision > 0 && _fragmentShaderPrecisionHighpFloat.precision > 0;
	var mediumpAvailable = _vertexShaderPrecisionMediumpFloat.precision > 0 && _fragmentShaderPrecisionMediumpFloat.precision > 0;

	if ( _precision === "highp" && ! highpAvailable ) {

		if ( mediumpAvailable ) {

			_precision = "mediump";
			console.warn( "WebGLRenderer: highp not supported, using mediump" );

		} else {

			_precision = "lowp";
			console.warn( "WebGLRenderer: highp and mediump not supported, using lowp" );

		}

	}

	if ( _precision === "mediump" && ! mediumpAvailable ) {

		_precision = "lowp";
		console.warn( "WebGLRenderer: mediump not supported, using lowp" );

	}

	// API

	this.getContext = function () {

		return _gl;

	};

	this.supportsVertexTextures = function () {

		return _supportsVertexTextures;

	};

	this.supportsFloatTextures = function () {

		return _glExtensionTextureFloat;

	};

	this.supportsStandardDerivatives = function () {

		return _glExtensionStandardDerivatives;

	};

	this.supportsCompressedTextureS3TC = function () {

		return _glExtensionCompressedTextureS3TC;

	};

	this.getMaxAnisotropy  = function () {

		return _maxAnisotropy;

	};

	this.getPrecision = function () {

		return _precision;

	};

	this.setSize = function ( width, height, updateStyle ) {

		_canvas.width = width * this.devicePixelRatio;
		_canvas.height = height * this.devicePixelRatio;

		if ( this.devicePixelRatio !== 1 && updateStyle !== false ) {

			_canvas.style.width = width + 'px';
			_canvas.style.height = height + 'px';

		}

		this.setViewport( 0, 0, _canvas.width, _canvas.height );

	};

	this.setViewport = function ( x, y, width, height ) {

		_viewportX = x !== undefined ? x : 0;
		_viewportY = y !== undefined ? y : 0;

		_viewportWidth = width !== undefined ? width : _canvas.width;
		_viewportHeight = height !== undefined ? height : _canvas.height;

		_gl.viewport( _viewportX, _viewportY, _viewportWidth, _viewportHeight );

	};

	this.setScissor = function ( x, y, width, height ) {

		_gl.scissor( x, y, width, height );

	};

	this.enableScissorTest = function ( enable ) {

		enable ? _gl.enable( _gl.SCISSOR_TEST ) : _gl.disable( _gl.SCISSOR_TEST );

	};

	// Clearing

	this.setClearColor = function ( color, alpha ) {

		_clearColor.set( color );
		_clearAlpha = alpha !== undefined ? alpha : 1;

		_gl.clearColor( _clearColor.r, _clearColor.g, _clearColor.b, _clearAlpha );

	};

	this.setClearColorHex = function ( hex, alpha ) {

		console.warn( 'DEPRECATED: .setClearColorHex() is being removed. Use .setClearColor() instead.' );
		this.setClearColor( hex, alpha );

	};

	this.getClearColor = function () {

		return _clearColor;

	};

	this.getClearAlpha = function () {

		return _clearAlpha;

	};

	this.clear = function ( color, depth, stencil ) {

		var bits = 0;

		if ( color === undefined || color ) bits |= _gl.COLOR_BUFFER_BIT;
		if ( depth === undefined || depth ) bits |= _gl.DEPTH_BUFFER_BIT;
		if ( stencil === undefined || stencil ) bits |= _gl.STENCIL_BUFFER_BIT;

		_gl.clear( bits );

	};

	this.clearColor = function () {

		_gl.clear( _gl.COLOR_BUFFER_BIT );

	};

	this.clearDepth = function () {

		_gl.clear( _gl.DEPTH_BUFFER_BIT );

	};

	this.clearStencil = function () {

		_gl.clear( _gl.STENCIL_BUFFER_BIT );

	};

	this.clearTarget = function ( renderTarget, color, depth, stencil ) {

		this.setRenderTarget( renderTarget );
		this.clear( color, depth, stencil );

	};

	// Plugins

	this.addPostPlugin = function ( plugin ) {

		plugin.init( this );
		this.renderPluginsPost.push( plugin );

	};

	this.addPrePlugin = function ( plugin ) {

		plugin.init( this );
		this.renderPluginsPre.push( plugin );

	};

	// Rendering

	this.updateShadowMap = function ( scene, camera ) {

		_currentProgram = null;
		_oldBlending = -1;
		_oldDepthTest = -1;
		_oldDepthWrite = -1;
		_currentGeometryGroupHash = -1;
		_currentMaterialId = -1;
		_lightsNeedUpdate = true;
		_oldDoubleSided = -1;
		_oldFlipSided = -1;

		this.shadowMapPlugin.update( scene, camera );

	};

	// Internal functions

	// Buffer allocation

	function createParticleBuffers ( geometry ) {

		geometry.__webglVertexBuffer = _gl.createBuffer();
		geometry.__webglColorBuffer = _gl.createBuffer();

		_this.info.memory.geometries ++;

	};

	function createLineBuffers ( geometry ) {

		geometry.__webglVertexBuffer = _gl.createBuffer();
		geometry.__webglColorBuffer = _gl.createBuffer();
		geometry.__webglLineDistanceBuffer = _gl.createBuffer();

		_this.info.memory.geometries ++;

	};

	function createMeshBuffers ( geometryGroup ) {

		geometryGroup.__webglVertexBuffer = _gl.createBuffer();
		geometryGroup.__webglNormalBuffer = _gl.createBuffer();
		geometryGroup.__webglTangentBuffer = _gl.createBuffer();
		geometryGroup.__webglColorBuffer = _gl.createBuffer();
		geometryGroup.__webglUVBuffer = _gl.createBuffer();
		geometryGroup.__webglUV2Buffer = _gl.createBuffer();

		geometryGroup.__webglSkinIndicesBuffer = _gl.createBuffer();
		geometryGroup.__webglSkinWeightsBuffer = _gl.createBuffer();

		geometryGroup.__webglFaceBuffer = _gl.createBuffer();
		geometryGroup.__webglLineBuffer = _gl.createBuffer();

		var m, ml;

		if ( geometryGroup.numMorphTargets ) {

			geometryGroup.__webglMorphTargetsBuffers = [];

			for ( m = 0, ml = geometryGroup.numMorphTargets; m < ml; m ++ ) {

				geometryGroup.__webglMorphTargetsBuffers.push( _gl.createBuffer() );

			}

		}

		if ( geometryGroup.numMorphNormals ) {

			geometryGroup.__webglMorphNormalsBuffers = [];

			for ( m = 0, ml = geometryGroup.numMorphNormals; m < ml; m ++ ) {

				geometryGroup.__webglMorphNormalsBuffers.push( _gl.createBuffer() );

			}

		}

		_this.info.memory.geometries ++;

	};

	// Events

	var onGeometryDispose = function ( event ) {

		var geometry = event.target;

		geometry.removeEventListener( 'dispose', onGeometryDispose );

		deallocateGeometry( geometry );

	};

	var onTextureDispose = function ( event ) {

		var texture = event.target;

		texture.removeEventListener( 'dispose', onTextureDispose );

		deallocateTexture( texture );

		_this.info.memory.textures --;


	};

	var onRenderTargetDispose = function ( event ) {

		var renderTarget = event.target;

		renderTarget.removeEventListener( 'dispose', onRenderTargetDispose );

		deallocateRenderTarget( renderTarget );

		_this.info.memory.textures --;

	};

	var onMaterialDispose = function ( event ) {

		var material = event.target;

		material.removeEventListener( 'dispose', onMaterialDispose );

		deallocateMaterial( material );

	};

	// Buffer deallocation

	var deleteBuffers = function ( geometry ) {

		if ( geometry.__webglVertexBuffer !== undefined ) _gl.deleteBuffer( geometry.__webglVertexBuffer );
		if ( geometry.__webglNormalBuffer !== undefined ) _gl.deleteBuffer( geometry.__webglNormalBuffer );
		if ( geometry.__webglTangentBuffer !== undefined ) _gl.deleteBuffer( geometry.__webglTangentBuffer );
		if ( geometry.__webglColorBuffer !== undefined ) _gl.deleteBuffer( geometry.__webglColorBuffer );
		if ( geometry.__webglUVBuffer !== undefined ) _gl.deleteBuffer( geometry.__webglUVBuffer );
		if ( geometry.__webglUV2Buffer !== undefined ) _gl.deleteBuffer( geometry.__webglUV2Buffer );

		if ( geometry.__webglSkinIndicesBuffer !== undefined ) _gl.deleteBuffer( geometry.__webglSkinIndicesBuffer );
		if ( geometry.__webglSkinWeightsBuffer !== undefined ) _gl.deleteBuffer( geometry.__webglSkinWeightsBuffer );

		if ( geometry.__webglFaceBuffer !== undefined ) _gl.deleteBuffer( geometry.__webglFaceBuffer );
		if ( geometry.__webglLineBuffer !== undefined ) _gl.deleteBuffer( geometry.__webglLineBuffer );

		if ( geometry.__webglLineDistanceBuffer !== undefined ) _gl.deleteBuffer( geometry.__webglLineDistanceBuffer );
		// custom attributes

		if ( geometry.__webglCustomAttributesList !== undefined ) {

			for ( var id in geometry.__webglCustomAttributesList ) {

				_gl.deleteBuffer( geometry.__webglCustomAttributesList[ id ].buffer );

			}

		}

		_this.info.memory.geometries --;

	};

	var deallocateGeometry = function ( geometry ) {

		geometry.__webglInit = undefined;

		if ( geometry instanceof THREE.BufferGeometry ) {

			var attributes = geometry.attributes;

			for ( var key in attributes ) {

				if ( attributes[ key ].buffer !== undefined ) {

					_gl.deleteBuffer( attributes[ key ].buffer );

				}

			}

			_this.info.memory.geometries --;

		} else {

			if ( geometry.geometryGroups !== undefined ) {

				for ( var g in geometry.geometryGroups ) {

					var geometryGroup = geometry.geometryGroups[ g ];

					if ( geometryGroup.numMorphTargets !== undefined ) {

						for ( var m = 0, ml = geometryGroup.numMorphTargets; m < ml; m ++ ) {

							_gl.deleteBuffer( geometryGroup.__webglMorphTargetsBuffers[ m ] );

						}

					}

					if ( geometryGroup.numMorphNormals !== undefined ) {

						for ( var m = 0, ml = geometryGroup.numMorphNormals; m < ml; m ++ ) {

							_gl.deleteBuffer( geometryGroup.__webglMorphNormalsBuffers[ m ] );

						}

					}

					deleteBuffers( geometryGroup );

				}

			} else {

				deleteBuffers( geometry );

			}

		}

	};

	var deallocateTexture = function ( texture ) {

		if ( texture.image && texture.image.__webglTextureCube ) {

			// cube texture

			_gl.deleteTexture( texture.image.__webglTextureCube );

		} else {

			// 2D texture

			if ( ! texture.__webglInit ) return;

			texture.__webglInit = false;
			_gl.deleteTexture( texture.__webglTexture );

		}

	};

	var deallocateRenderTarget = function ( renderTarget ) {

		if ( !renderTarget || ! renderTarget.__webglTexture ) return;

		_gl.deleteTexture( renderTarget.__webglTexture );

		if ( renderTarget instanceof THREE.WebGLRenderTargetCube ) {

			for ( var i = 0; i < 6; i ++ ) {

				_gl.deleteFramebuffer( renderTarget.__webglFramebuffer[ i ] );
				_gl.deleteRenderbuffer( renderTarget.__webglRenderbuffer[ i ] );

			}

		} else {

			_gl.deleteFramebuffer( renderTarget.__webglFramebuffer );
			_gl.deleteRenderbuffer( renderTarget.__webglRenderbuffer );

		}

	};

	var deallocateMaterial = function ( material ) {

		var program = material.program;

		if ( program === undefined ) return;

		material.program = undefined;

		// only deallocate GL program if this was the last use of shared program
		// assumed there is only single copy of any program in the _programs list
		// (that's how it's constructed)

		var i, il, programInfo;
		var deleteProgram = false;

		for ( i = 0, il = _programs.length; i < il; i ++ ) {

			programInfo = _programs[ i ];

			if ( programInfo.program === program ) {

				programInfo.usedTimes --;

				if ( programInfo.usedTimes === 0 ) {

					deleteProgram = true;

				}

				break;

			}

		}

		if ( deleteProgram === true ) {

			// avoid using array.splice, this is costlier than creating new array from scratch

			var newPrograms = [];

			for ( i = 0, il = _programs.length; i < il; i ++ ) {

				programInfo = _programs[ i ];

				if ( programInfo.program !== program ) {

					newPrograms.push( programInfo );

				}

			}

			_programs = newPrograms;

			_gl.deleteProgram( program );

			_this.info.memory.programs --;

		}

	};

	// Buffer initialization

	function initCustomAttributes ( geometry, object ) {

		var nvertices = geometry.vertices.length;

		var material = object.material;

		if ( material.attributes ) {

			if ( geometry.__webglCustomAttributesList === undefined ) {

				geometry.__webglCustomAttributesList = [];

			}

			for ( var a in material.attributes ) {

				var attribute = material.attributes[ a ];

				if ( !attribute.__webglInitialized || attribute.createUniqueBuffers ) {

					attribute.__webglInitialized = true;

					var size = 1;		// "f" and "i"

					if ( attribute.type === "v2" ) size = 2;
					else if ( attribute.type === "v3" ) size = 3;
					else if ( attribute.type === "v4" ) size = 4;
					else if ( attribute.type === "c"  ) size = 3;

					attribute.size = size;

					attribute.array = new Float32Array( nvertices * size );

					attribute.buffer = _gl.createBuffer();
					attribute.buffer.belongsToAttribute = a;

					attribute.needsUpdate = true;

				}

				geometry.__webglCustomAttributesList.push( attribute );

			}

		}

	};

	function initParticleBuffers ( geometry, object ) {

		var nvertices = geometry.vertices.length;

		geometry.__vertexArray = new Float32Array( nvertices * 3 );
		geometry.__colorArray = new Float32Array( nvertices * 3 );

		geometry.__sortArray = [];

		geometry.__webglParticleCount = nvertices;

		initCustomAttributes ( geometry, object );

	};

	function initLineBuffers ( geometry, object ) {

		var nvertices = geometry.vertices.length;

		geometry.__vertexArray = new Float32Array( nvertices * 3 );
		geometry.__colorArray = new Float32Array( nvertices * 3 );
		geometry.__lineDistanceArray = new Float32Array( nvertices * 1 );

		geometry.__webglLineCount = nvertices;

		initCustomAttributes ( geometry, object );

	};

	function initMeshBuffers ( geometryGroup, object ) {

		var geometry = object.geometry,
			faces3 = geometryGroup.faces3,

			nvertices = faces3.length * 3,
			ntris     = faces3.length * 1,
			nlines    = faces3.length * 3,

			material = getBufferMaterial( object, geometryGroup ),

			uvType = bufferGuessUVType( material ),
			normalType = bufferGuessNormalType( material ),
			vertexColorType = bufferGuessVertexColorType( material );

		// console.log( "uvType", uvType, "normalType", normalType, "vertexColorType", vertexColorType, object, geometryGroup, material );

		geometryGroup.__vertexArray = new Float32Array( nvertices * 3 );

		if ( normalType ) {

			geometryGroup.__normalArray = new Float32Array( nvertices * 3 );

		}

		if ( geometry.hasTangents ) {

			geometryGroup.__tangentArray = new Float32Array( nvertices * 4 );

		}

		if ( vertexColorType ) {

			geometryGroup.__colorArray = new Float32Array( nvertices * 3 );

		}

		if ( uvType ) {

			if ( geometry.faceVertexUvs.length > 0 ) {

				geometryGroup.__uvArray = new Float32Array( nvertices * 2 );

			}

			if ( geometry.faceVertexUvs.length > 1 ) {

				geometryGroup.__uv2Array = new Float32Array( nvertices * 2 );

			}

		}

		if ( object.geometry.skinWeights.length && object.geometry.skinIndices.length ) {

			geometryGroup.__skinIndexArray = new Float32Array( nvertices * 4 );
			geometryGroup.__skinWeightArray = new Float32Array( nvertices * 4 );

		}

		geometryGroup.__faceArray = new Uint16Array( ntris * 3 );
		geometryGroup.__lineArray = new Uint16Array( nlines * 2 );

		var m, ml;

		if ( geometryGroup.numMorphTargets ) {

			geometryGroup.__morphTargetsArrays = [];

			for ( m = 0, ml = geometryGroup.numMorphTargets; m < ml; m ++ ) {

				geometryGroup.__morphTargetsArrays.push( new Float32Array( nvertices * 3 ) );

			}

		}

		if ( geometryGroup.numMorphNormals ) {

			geometryGroup.__morphNormalsArrays = [];

			for ( m = 0, ml = geometryGroup.numMorphNormals; m < ml; m ++ ) {

				geometryGroup.__morphNormalsArrays.push( new Float32Array( nvertices * 3 ) );

			}

		}

		geometryGroup.__webglFaceCount = ntris * 3;
		geometryGroup.__webglLineCount = nlines * 2;


		// custom attributes

		if ( material.attributes ) {

			if ( geometryGroup.__webglCustomAttributesList === undefined ) {

				geometryGroup.__webglCustomAttributesList = [];

			}

			for ( var a in material.attributes ) {

				// Do a shallow copy of the attribute object so different geometryGroup chunks use different
				// attribute buffers which are correctly indexed in the setMeshBuffers function

				var originalAttribute = material.attributes[ a ];

				var attribute = {};

				for ( var property in originalAttribute ) {

					attribute[ property ] = originalAttribute[ property ];

				}

				if ( !attribute.__webglInitialized || attribute.createUniqueBuffers ) {

					attribute.__webglInitialized = true;

					var size = 1;		// "f" and "i"

					if( attribute.type === "v2" ) size = 2;
					else if( attribute.type === "v3" ) size = 3;
					else if( attribute.type === "v4" ) size = 4;
					else if( attribute.type === "c"  ) size = 3;

					attribute.size = size;

					attribute.array = new Float32Array( nvertices * size );

					attribute.buffer = _gl.createBuffer();
					attribute.buffer.belongsToAttribute = a;

					originalAttribute.needsUpdate = true;
					attribute.__original = originalAttribute;

				}

				geometryGroup.__webglCustomAttributesList.push( attribute );

			}

		}

		geometryGroup.__inittedArrays = true;

	};

	function getBufferMaterial( object, geometryGroup ) {

		return object.material instanceof THREE.MeshFaceMaterial
			? object.material.materials[ geometryGroup.materialIndex ]
			: object.material;

	};

	function materialNeedsSmoothNormals ( material ) {

		return material && material.shading !== undefined && material.shading === THREE.SmoothShading;

	};

	function bufferGuessNormalType ( material ) {

		// only MeshBasicMaterial and MeshDepthMaterial don't need normals

		if ( ( material instanceof THREE.MeshBasicMaterial && !material.envMap ) || material instanceof THREE.MeshDepthMaterial ) {

			return false;

		}

		if ( materialNeedsSmoothNormals( material ) ) {

			return THREE.SmoothShading;

		} else {

			return THREE.FlatShading;

		}

	};

	function bufferGuessVertexColorType( material ) {

		if ( material.vertexColors ) {

			return material.vertexColors;

		}

		return false;

	};

	function bufferGuessUVType( material ) {

		// material must use some texture to require uvs

		if ( material.map ||
		     material.lightMap ||
		     material.bumpMap ||
		     material.normalMap ||
		     material.specularMap ||
		     material instanceof THREE.ShaderMaterial ) {

			return true;

		}

		return false;

	};

	//

	function initDirectBuffers( geometry ) {

		var a, attribute, type;

		for ( a in geometry.attributes ) {

			if ( a === "index" ) {

				type = _gl.ELEMENT_ARRAY_BUFFER;

			} else {

				type = _gl.ARRAY_BUFFER;

			}

			attribute = geometry.attributes[ a ];

			if ( attribute.numItems === undefined ) {

				attribute.numItems = attribute.array.length;

			}

			attribute.buffer = _gl.createBuffer();

			_gl.bindBuffer( type, attribute.buffer );
			_gl.bufferData( type, attribute.array, _gl.STATIC_DRAW );

		}

	};

	// Buffer setting

	function setParticleBuffers ( geometry, hint, object ) {

		var v, c, vertex, offset, index, color,

		vertices = geometry.vertices,
		vl = vertices.length,

		colors = geometry.colors,
		cl = colors.length,

		vertexArray = geometry.__vertexArray,
		colorArray = geometry.__colorArray,

		sortArray = geometry.__sortArray,

		dirtyVertices = geometry.verticesNeedUpdate,
		dirtyElements = geometry.elementsNeedUpdate,
		dirtyColors = geometry.colorsNeedUpdate,

		customAttributes = geometry.__webglCustomAttributesList,
		i, il,
		a, ca, cal, value,
		customAttribute;

		if ( object.sortParticles ) {

			_projScreenMatrixPS.copy( _projScreenMatrix );
			_projScreenMatrixPS.multiply( object.matrixWorld );

			for ( v = 0; v < vl; v ++ ) {

				vertex = vertices[ v ];

				_vector3.copy( vertex );
				_vector3.applyProjection( _projScreenMatrixPS );

				sortArray[ v ] = [ _vector3.z, v ];

			}

			sortArray.sort( numericalSort );

			for ( v = 0; v < vl; v ++ ) {

				vertex = vertices[ sortArray[v][1] ];

				offset = v * 3;

				vertexArray[ offset ]     = vertex.x;
				vertexArray[ offset + 1 ] = vertex.y;
				vertexArray[ offset + 2 ] = vertex.z;

			}

			for ( c = 0; c < cl; c ++ ) {

				offset = c * 3;

				color = colors[ sortArray[c][1] ];

				colorArray[ offset ]     = color.r;
				colorArray[ offset + 1 ] = color.g;
				colorArray[ offset + 2 ] = color.b;

			}

			if ( customAttributes ) {

				for ( i = 0, il = customAttributes.length; i < il; i ++ ) {

					customAttribute = customAttributes[ i ];

					if ( ! ( customAttribute.boundTo === undefined || customAttribute.boundTo === "vertices" ) ) continue;

					offset = 0;

					cal = customAttribute.value.length;

					if ( customAttribute.size === 1 ) {

						for ( ca = 0; ca < cal; ca ++ ) {

							index = sortArray[ ca ][ 1 ];

							customAttribute.array[ ca ] = customAttribute.value[ index ];

						}

					} else if ( customAttribute.size === 2 ) {

						for ( ca = 0; ca < cal; ca ++ ) {

							index = sortArray[ ca ][ 1 ];

							value = customAttribute.value[ index ];

							customAttribute.array[ offset ] 	= value.x;
							customAttribute.array[ offset + 1 ] = value.y;

							offset += 2;

						}

					} else if ( customAttribute.size === 3 ) {

						if ( customAttribute.type === "c" ) {

							for ( ca = 0; ca < cal; ca ++ ) {

								index = sortArray[ ca ][ 1 ];

								value = customAttribute.value[ index ];

								customAttribute.array[ offset ]     = value.r;
								customAttribute.array[ offset + 1 ] = value.g;
								customAttribute.array[ offset + 2 ] = value.b;

								offset += 3;

							}

						} else {

							for ( ca = 0; ca < cal; ca ++ ) {

								index = sortArray[ ca ][ 1 ];

								value = customAttribute.value[ index ];

								customAttribute.array[ offset ] 	= value.x;
								customAttribute.array[ offset + 1 ] = value.y;
								customAttribute.array[ offset + 2 ] = value.z;

								offset += 3;

							}

						}

					} else if ( customAttribute.size === 4 ) {

						for ( ca = 0; ca < cal; ca ++ ) {

							index = sortArray[ ca ][ 1 ];

							value = customAttribute.value[ index ];

							customAttribute.array[ offset ]      = value.x;
							customAttribute.array[ offset + 1  ] = value.y;
							customAttribute.array[ offset + 2  ] = value.z;
							customAttribute.array[ offset + 3  ] = value.w;

							offset += 4;

						}

					}

				}

			}

		} else {

			if ( dirtyVertices ) {

				for ( v = 0; v < vl; v ++ ) {

					vertex = vertices[ v ];

					offset = v * 3;

					vertexArray[ offset ]     = vertex.x;
					vertexArray[ offset + 1 ] = vertex.y;
					vertexArray[ offset + 2 ] = vertex.z;

				}

			}

			if ( dirtyColors ) {

				for ( c = 0; c < cl; c ++ ) {

					color = colors[ c ];

					offset = c * 3;

					colorArray[ offset ]     = color.r;
					colorArray[ offset + 1 ] = color.g;
					colorArray[ offset + 2 ] = color.b;

				}

			}

			if ( customAttributes ) {

				for ( i = 0, il = customAttributes.length; i < il; i ++ ) {

					customAttribute = customAttributes[ i ];

					if ( customAttribute.needsUpdate &&
						 ( customAttribute.boundTo === undefined ||
						   customAttribute.boundTo === "vertices") ) {

						cal = customAttribute.value.length;

						offset = 0;

						if ( customAttribute.size === 1 ) {

							for ( ca = 0; ca < cal; ca ++ ) {

								customAttribute.array[ ca ] = customAttribute.value[ ca ];

							}

						} else if ( customAttribute.size === 2 ) {

							for ( ca = 0; ca < cal; ca ++ ) {

								value = customAttribute.value[ ca ];

								customAttribute.array[ offset ] 	= value.x;
								customAttribute.array[ offset + 1 ] = value.y;

								offset += 2;

							}

						} else if ( customAttribute.size === 3 ) {

							if ( customAttribute.type === "c" ) {

								for ( ca = 0; ca < cal; ca ++ ) {

									value = customAttribute.value[ ca ];

									customAttribute.array[ offset ] 	= value.r;
									customAttribute.array[ offset + 1 ] = value.g;
									customAttribute.array[ offset + 2 ] = value.b;

									offset += 3;

								}

							} else {

								for ( ca = 0; ca < cal; ca ++ ) {

									value = customAttribute.value[ ca ];

									customAttribute.array[ offset ] 	= value.x;
									customAttribute.array[ offset + 1 ] = value.y;
									customAttribute.array[ offset + 2 ] = value.z;

									offset += 3;

								}

							}

						} else if ( customAttribute.size === 4 ) {

							for ( ca = 0; ca < cal; ca ++ ) {

								value = customAttribute.value[ ca ];

								customAttribute.array[ offset ]      = value.x;
								customAttribute.array[ offset + 1  ] = value.y;
								customAttribute.array[ offset + 2  ] = value.z;
								customAttribute.array[ offset + 3  ] = value.w;

								offset += 4;

							}

						}

					}

				}

			}

		}

		if ( dirtyVertices || object.sortParticles ) {

			_gl.bindBuffer( _gl.ARRAY_BUFFER, geometry.__webglVertexBuffer );
			_gl.bufferData( _gl.ARRAY_BUFFER, vertexArray, hint );

		}

		if ( dirtyColors || object.sortParticles ) {

			_gl.bindBuffer( _gl.ARRAY_BUFFER, geometry.__webglColorBuffer );
			_gl.bufferData( _gl.ARRAY_BUFFER, colorArray, hint );

		}

		if ( customAttributes ) {

			for ( i = 0, il = customAttributes.length; i < il; i ++ ) {

				customAttribute = customAttributes[ i ];

				if ( customAttribute.needsUpdate || object.sortParticles ) {

					_gl.bindBuffer( _gl.ARRAY_BUFFER, customAttribute.buffer );
					_gl.bufferData( _gl.ARRAY_BUFFER, customAttribute.array, hint );

				}

			}

		}


	};

	function setLineBuffers ( geometry, hint ) {

		var v, c, d, vertex, offset, color,

		vertices = geometry.vertices,
		colors = geometry.colors,
		lineDistances = geometry.lineDistances,

		vl = vertices.length,
		cl = colors.length,
		dl = lineDistances.length,

		vertexArray = geometry.__vertexArray,
		colorArray = geometry.__colorArray,
		lineDistanceArray = geometry.__lineDistanceArray,

		dirtyVertices = geometry.verticesNeedUpdate,
		dirtyColors = geometry.colorsNeedUpdate,
		dirtyLineDistances = geometry.lineDistancesNeedUpdate,

		customAttributes = geometry.__webglCustomAttributesList,

		i, il,
		a, ca, cal, value,
		customAttribute;

		if ( dirtyVertices ) {

			for ( v = 0; v < vl; v ++ ) {

				vertex = vertices[ v ];

				offset = v * 3;

				vertexArray[ offset ]     = vertex.x;
				vertexArray[ offset + 1 ] = vertex.y;
				vertexArray[ offset + 2 ] = vertex.z;

			}

			_gl.bindBuffer( _gl.ARRAY_BUFFER, geometry.__webglVertexBuffer );
			_gl.bufferData( _gl.ARRAY_BUFFER, vertexArray, hint );

		}

		if ( dirtyColors ) {

			for ( c = 0; c < cl; c ++ ) {

				color = colors[ c ];

				offset = c * 3;

				colorArray[ offset ]     = color.r;
				colorArray[ offset + 1 ] = color.g;
				colorArray[ offset + 2 ] = color.b;

			}

			_gl.bindBuffer( _gl.ARRAY_BUFFER, geometry.__webglColorBuffer );
			_gl.bufferData( _gl.ARRAY_BUFFER, colorArray, hint );

		}

		if ( dirtyLineDistances ) {

			for ( d = 0; d < dl; d ++ ) {

				lineDistanceArray[ d ] = lineDistances[ d ];

			}

			_gl.bindBuffer( _gl.ARRAY_BUFFER, geometry.__webglLineDistanceBuffer );
			_gl.bufferData( _gl.ARRAY_BUFFER, lineDistanceArray, hint );

		}

		if ( customAttributes ) {

			for ( i = 0, il = customAttributes.length; i < il; i ++ ) {

				customAttribute = customAttributes[ i ];

				if ( customAttribute.needsUpdate &&
					 ( customAttribute.boundTo === undefined ||
					   customAttribute.boundTo === "vertices" ) ) {

					offset = 0;

					cal = customAttribute.value.length;

					if ( customAttribute.size === 1 ) {

						for ( ca = 0; ca < cal; ca ++ ) {

							customAttribute.array[ ca ] = customAttribute.value[ ca ];

						}

					} else if ( customAttribute.size === 2 ) {

						for ( ca = 0; ca < cal; ca ++ ) {

							value = customAttribute.value[ ca ];

							customAttribute.array[ offset ] 	= value.x;
							customAttribute.array[ offset + 1 ] = value.y;

							offset += 2;

						}

					} else if ( customAttribute.size === 3 ) {

						if ( customAttribute.type === "c" ) {

							for ( ca = 0; ca < cal; ca ++ ) {

								value = customAttribute.value[ ca ];

								customAttribute.array[ offset ] 	= value.r;
								customAttribute.array[ offset + 1 ] = value.g;
								customAttribute.array[ offset + 2 ] = value.b;

								offset += 3;

							}

						} else {

							for ( ca = 0; ca < cal; ca ++ ) {

								value = customAttribute.value[ ca ];

								customAttribute.array[ offset ] 	= value.x;
								customAttribute.array[ offset + 1 ] = value.y;
								customAttribute.array[ offset + 2 ] = value.z;

								offset += 3;

							}

						}

					} else if ( customAttribute.size === 4 ) {

						for ( ca = 0; ca < cal; ca ++ ) {

							value = customAttribute.value[ ca ];

							customAttribute.array[ offset ] 	 = value.x;
							customAttribute.array[ offset + 1  ] = value.y;
							customAttribute.array[ offset + 2  ] = value.z;
							customAttribute.array[ offset + 3  ] = value.w;

							offset += 4;

						}

					}

					_gl.bindBuffer( _gl.ARRAY_BUFFER, customAttribute.buffer );
					_gl.bufferData( _gl.ARRAY_BUFFER, customAttribute.array, hint );

				}

			}

		}

	};

	function setMeshBuffers( geometryGroup, object, hint, dispose, material ) {

		if ( ! geometryGroup.__inittedArrays ) {

			return;

		}

		var normalType = bufferGuessNormalType( material ),
		vertexColorType = bufferGuessVertexColorType( material ),
		uvType = bufferGuessUVType( material ),

		needsSmoothNormals = ( normalType === THREE.SmoothShading );

		var f, fl, fi, face,
		vertexNormals, faceNormal, normal,
		vertexColors, faceColor,
		vertexTangents,
		uv, uv2, v1, v2, v3, v4, t1, t2, t3, t4, n1, n2, n3, n4,
		c1, c2, c3, c4,
		sw1, sw2, sw3, sw4,
		si1, si2, si3, si4,
		sa1, sa2, sa3, sa4,
		sb1, sb2, sb3, sb4,
		m, ml, i, il,
		vn, uvi, uv2i,
		vk, vkl, vka,
		nka, chf, faceVertexNormals,
		a,

		vertexIndex = 0,

		offset = 0,
		offset_uv = 0,
		offset_uv2 = 0,
		offset_face = 0,
		offset_normal = 0,
		offset_tangent = 0,
		offset_line = 0,
		offset_color = 0,
		offset_skin = 0,
		offset_morphTarget = 0,
		offset_custom = 0,
		offset_customSrc = 0,

		value,

		vertexArray = geometryGroup.__vertexArray,
		uvArray = geometryGroup.__uvArray,
		uv2Array = geometryGroup.__uv2Array,
		normalArray = geometryGroup.__normalArray,
		tangentArray = geometryGroup.__tangentArray,
		colorArray = geometryGroup.__colorArray,

		skinIndexArray = geometryGroup.__skinIndexArray,
		skinWeightArray = geometryGroup.__skinWeightArray,

		morphTargetsArrays = geometryGroup.__morphTargetsArrays,
		morphNormalsArrays = geometryGroup.__morphNormalsArrays,

		customAttributes = geometryGroup.__webglCustomAttributesList,
		customAttribute,

		faceArray = geometryGroup.__faceArray,
		lineArray = geometryGroup.__lineArray,

		geometry = object.geometry, // this is shared for all chunks

		dirtyVertices = geometry.verticesNeedUpdate,
		dirtyElements = geometry.elementsNeedUpdate,
		dirtyUvs = geometry.uvsNeedUpdate,
		dirtyNormals = geometry.normalsNeedUpdate,
		dirtyTangents = geometry.tangentsNeedUpdate,
		dirtyColors = geometry.colorsNeedUpdate,
		dirtyMorphTargets = geometry.morphTargetsNeedUpdate,

		vertices = geometry.vertices,
		chunk_faces3 = geometryGroup.faces3,
		obj_faces = geometry.faces,

		obj_uvs  = geometry.faceVertexUvs[ 0 ],
		obj_uvs2 = geometry.faceVertexUvs[ 1 ],

		obj_colors = geometry.colors,

		obj_skinIndices = geometry.skinIndices,
		obj_skinWeights = geometry.skinWeights,

		morphTargets = geometry.morphTargets,
		morphNormals = geometry.morphNormals;

		if ( dirtyVertices ) {

			for ( f = 0, fl = chunk_faces3.length; f < fl; f ++ ) {

				face = obj_faces[ chunk_faces3[ f ] ];

				v1 = vertices[ face.a ];
				v2 = vertices[ face.b ];
				v3 = vertices[ face.c ];

				vertexArray[ offset ]     = v1.x;
				vertexArray[ offset + 1 ] = v1.y;
				vertexArray[ offset + 2 ] = v1.z;

				vertexArray[ offset + 3 ] = v2.x;
				vertexArray[ offset + 4 ] = v2.y;
				vertexArray[ offset + 5 ] = v2.z;

				vertexArray[ offset + 6 ] = v3.x;
				vertexArray[ offset + 7 ] = v3.y;
				vertexArray[ offset + 8 ] = v3.z;

				offset += 9;

			}

			_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglVertexBuffer );
			_gl.bufferData( _gl.ARRAY_BUFFER, vertexArray, hint );

		}

		if ( dirtyMorphTargets ) {

			for ( vk = 0, vkl = morphTargets.length; vk < vkl; vk ++ ) {

				offset_morphTarget = 0;

				for ( f = 0, fl = chunk_faces3.length; f < fl; f ++ ) {

					chf = chunk_faces3[ f ];
					face = obj_faces[ chf ];

					// morph positions

					v1 = morphTargets[ vk ].vertices[ face.a ];
					v2 = morphTargets[ vk ].vertices[ face.b ];
					v3 = morphTargets[ vk ].vertices[ face.c ];

					vka = morphTargetsArrays[ vk ];

					vka[ offset_morphTarget ] 	  = v1.x;
					vka[ offset_morphTarget + 1 ] = v1.y;
					vka[ offset_morphTarget + 2 ] = v1.z;

					vka[ offset_morphTarget + 3 ] = v2.x;
					vka[ offset_morphTarget + 4 ] = v2.y;
					vka[ offset_morphTarget + 5 ] = v2.z;

					vka[ offset_morphTarget + 6 ] = v3.x;
					vka[ offset_morphTarget + 7 ] = v3.y;
					vka[ offset_morphTarget + 8 ] = v3.z;

					// morph normals

					if ( material.morphNormals ) {

						if ( needsSmoothNormals ) {

							faceVertexNormals = morphNormals[ vk ].vertexNormals[ chf ];

							n1 = faceVertexNormals.a;
							n2 = faceVertexNormals.b;
							n3 = faceVertexNormals.c;

						} else {

							n1 = morphNormals[ vk ].faceNormals[ chf ];
							n2 = n1;
							n3 = n1;

						}

						nka = morphNormalsArrays[ vk ];

						nka[ offset_morphTarget ] 	  = n1.x;
						nka[ offset_morphTarget + 1 ] = n1.y;
						nka[ offset_morphTarget + 2 ] = n1.z;

						nka[ offset_morphTarget + 3 ] = n2.x;
						nka[ offset_morphTarget + 4 ] = n2.y;
						nka[ offset_morphTarget + 5 ] = n2.z;

						nka[ offset_morphTarget + 6 ] = n3.x;
						nka[ offset_morphTarget + 7 ] = n3.y;
						nka[ offset_morphTarget + 8 ] = n3.z;

					}

					//

					offset_morphTarget += 9;

				}

				_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglMorphTargetsBuffers[ vk ] );
				_gl.bufferData( _gl.ARRAY_BUFFER, morphTargetsArrays[ vk ], hint );

				if ( material.morphNormals ) {

					_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglMorphNormalsBuffers[ vk ] );
					_gl.bufferData( _gl.ARRAY_BUFFER, morphNormalsArrays[ vk ], hint );

				}

			}

		}

		if ( obj_skinWeights.length ) {

			for ( f = 0, fl = chunk_faces3.length; f < fl; f ++ ) {

				face = obj_faces[ chunk_faces3[ f ]	];

				// weights

				sw1 = obj_skinWeights[ face.a ];
				sw2 = obj_skinWeights[ face.b ];
				sw3 = obj_skinWeights[ face.c ];

				skinWeightArray[ offset_skin ]     = sw1.x;
				skinWeightArray[ offset_skin + 1 ] = sw1.y;
				skinWeightArray[ offset_skin + 2 ] = sw1.z;
				skinWeightArray[ offset_skin + 3 ] = sw1.w;

				skinWeightArray[ offset_skin + 4 ] = sw2.x;
				skinWeightArray[ offset_skin + 5 ] = sw2.y;
				skinWeightArray[ offset_skin + 6 ] = sw2.z;
				skinWeightArray[ offset_skin + 7 ] = sw2.w;

				skinWeightArray[ offset_skin + 8 ]  = sw3.x;
				skinWeightArray[ offset_skin + 9 ]  = sw3.y;
				skinWeightArray[ offset_skin + 10 ] = sw3.z;
				skinWeightArray[ offset_skin + 11 ] = sw3.w;

				// indices

				si1 = obj_skinIndices[ face.a ];
				si2 = obj_skinIndices[ face.b ];
				si3 = obj_skinIndices[ face.c ];

				skinIndexArray[ offset_skin ]     = si1.x;
				skinIndexArray[ offset_skin + 1 ] = si1.y;
				skinIndexArray[ offset_skin + 2 ] = si1.z;
				skinIndexArray[ offset_skin + 3 ] = si1.w;

				skinIndexArray[ offset_skin + 4 ] = si2.x;
				skinIndexArray[ offset_skin + 5 ] = si2.y;
				skinIndexArray[ offset_skin + 6 ] = si2.z;
				skinIndexArray[ offset_skin + 7 ] = si2.w;

				skinIndexArray[ offset_skin + 8 ]  = si3.x;
				skinIndexArray[ offset_skin + 9 ]  = si3.y;
				skinIndexArray[ offset_skin + 10 ] = si3.z;
				skinIndexArray[ offset_skin + 11 ] = si3.w;

				offset_skin += 12;

			}

			if ( offset_skin > 0 ) {

				_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglSkinIndicesBuffer );
				_gl.bufferData( _gl.ARRAY_BUFFER, skinIndexArray, hint );

				_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglSkinWeightsBuffer );
				_gl.bufferData( _gl.ARRAY_BUFFER, skinWeightArray, hint );

			}

		}

		if ( dirtyColors && vertexColorType ) {

			for ( f = 0, fl = chunk_faces3.length; f < fl; f ++ ) {

				face = obj_faces[ chunk_faces3[ f ]	];

				vertexColors = face.vertexColors;
				faceColor = face.color;

				if ( vertexColors.length === 3 && vertexColorType === THREE.VertexColors ) {

					c1 = vertexColors[ 0 ];
					c2 = vertexColors[ 1 ];
					c3 = vertexColors[ 2 ];

				} else {

					c1 = faceColor;
					c2 = faceColor;
					c3 = faceColor;

				}

				colorArray[ offset_color ]     = c1.r;
				colorArray[ offset_color + 1 ] = c1.g;
				colorArray[ offset_color + 2 ] = c1.b;

				colorArray[ offset_color + 3 ] = c2.r;
				colorArray[ offset_color + 4 ] = c2.g;
				colorArray[ offset_color + 5 ] = c2.b;

				colorArray[ offset_color + 6 ] = c3.r;
				colorArray[ offset_color + 7 ] = c3.g;
				colorArray[ offset_color + 8 ] = c3.b;

				offset_color += 9;

			}

			if ( offset_color > 0 ) {

				_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglColorBuffer );
				_gl.bufferData( _gl.ARRAY_BUFFER, colorArray, hint );

			}

		}

		if ( dirtyTangents && geometry.hasTangents ) {

			for ( f = 0, fl = chunk_faces3.length; f < fl; f ++ ) {

				face = obj_faces[ chunk_faces3[ f ]	];

				vertexTangents = face.vertexTangents;

				t1 = vertexTangents[ 0 ];
				t2 = vertexTangents[ 1 ];
				t3 = vertexTangents[ 2 ];

				tangentArray[ offset_tangent ]     = t1.x;
				tangentArray[ offset_tangent + 1 ] = t1.y;
				tangentArray[ offset_tangent + 2 ] = t1.z;
				tangentArray[ offset_tangent + 3 ] = t1.w;

				tangentArray[ offset_tangent + 4 ] = t2.x;
				tangentArray[ offset_tangent + 5 ] = t2.y;
				tangentArray[ offset_tangent + 6 ] = t2.z;
				tangentArray[ offset_tangent + 7 ] = t2.w;

				tangentArray[ offset_tangent + 8 ]  = t3.x;
				tangentArray[ offset_tangent + 9 ]  = t3.y;
				tangentArray[ offset_tangent + 10 ] = t3.z;
				tangentArray[ offset_tangent + 11 ] = t3.w;

				offset_tangent += 12;

			}

			_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglTangentBuffer );
			_gl.bufferData( _gl.ARRAY_BUFFER, tangentArray, hint );

		}

		if ( dirtyNormals && normalType ) {

			for ( f = 0, fl = chunk_faces3.length; f < fl; f ++ ) {

				face = obj_faces[ chunk_faces3[ f ]	];

				vertexNormals = face.vertexNormals;
				faceNormal = face.normal;

				if ( vertexNormals.length === 3 && needsSmoothNormals ) {

					for ( i = 0; i < 3; i ++ ) {

						vn = vertexNormals[ i ];

						normalArray[ offset_normal ]     = vn.x;
						normalArray[ offset_normal + 1 ] = vn.y;
						normalArray[ offset_normal + 2 ] = vn.z;

						offset_normal += 3;

					}

				} else {

					for ( i = 0; i < 3; i ++ ) {

						normalArray[ offset_normal ]     = faceNormal.x;
						normalArray[ offset_normal + 1 ] = faceNormal.y;
						normalArray[ offset_normal + 2 ] = faceNormal.z;

						offset_normal += 3;

					}

				}

			}

			_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglNormalBuffer );
			_gl.bufferData( _gl.ARRAY_BUFFER, normalArray, hint );

		}

		if ( dirtyUvs && obj_uvs && uvType ) {

			for ( f = 0, fl = chunk_faces3.length; f < fl; f ++ ) {

				fi = chunk_faces3[ f ];

				uv = obj_uvs[ fi ];

				if ( uv === undefined ) continue;

				for ( i = 0; i < 3; i ++ ) {

					uvi = uv[ i ];

					uvArray[ offset_uv ]     = uvi.x;
					uvArray[ offset_uv + 1 ] = uvi.y;

					offset_uv += 2;

				}

			}

			if ( offset_uv > 0 ) {

				_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglUVBuffer );
				_gl.bufferData( _gl.ARRAY_BUFFER, uvArray, hint );

			}

		}

		if ( dirtyUvs && obj_uvs2 && uvType ) {

			for ( f = 0, fl = chunk_faces3.length; f < fl; f ++ ) {

				fi = chunk_faces3[ f ];

				uv2 = obj_uvs2[ fi ];

				if ( uv2 === undefined ) continue;

				for ( i = 0; i < 3; i ++ ) {

					uv2i = uv2[ i ];

					uv2Array[ offset_uv2 ]     = uv2i.x;
					uv2Array[ offset_uv2 + 1 ] = uv2i.y;

					offset_uv2 += 2;

				}

			}

			if ( offset_uv2 > 0 ) {

				_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglUV2Buffer );
				_gl.bufferData( _gl.ARRAY_BUFFER, uv2Array, hint );

			}

		}

		if ( dirtyElements ) {

			for ( f = 0, fl = chunk_faces3.length; f < fl; f ++ ) {

				faceArray[ offset_face ] 	 = vertexIndex;
				faceArray[ offset_face + 1 ] = vertexIndex + 1;
				faceArray[ offset_face + 2 ] = vertexIndex + 2;

				offset_face += 3;

				lineArray[ offset_line ]     = vertexIndex;
				lineArray[ offset_line + 1 ] = vertexIndex + 1;

				lineArray[ offset_line + 2 ] = vertexIndex;
				lineArray[ offset_line + 3 ] = vertexIndex + 2;

				lineArray[ offset_line + 4 ] = vertexIndex + 1;
				lineArray[ offset_line + 5 ] = vertexIndex + 2;

				offset_line += 6;

				vertexIndex += 3;

			}

			_gl.bindBuffer( _gl.ELEMENT_ARRAY_BUFFER, geometryGroup.__webglFaceBuffer );
			_gl.bufferData( _gl.ELEMENT_ARRAY_BUFFER, faceArray, hint );

			_gl.bindBuffer( _gl.ELEMENT_ARRAY_BUFFER, geometryGroup.__webglLineBuffer );
			_gl.bufferData( _gl.ELEMENT_ARRAY_BUFFER, lineArray, hint );

		}

		if ( customAttributes ) {

			for ( i = 0, il = customAttributes.length; i < il; i ++ ) {

				customAttribute = customAttributes[ i ];

				if ( ! customAttribute.__original.needsUpdate ) continue;

				offset_custom = 0;
				offset_customSrc = 0;

				if ( customAttribute.size === 1 ) {

					if ( customAttribute.boundTo === undefined || customAttribute.boundTo === "vertices" ) {

						for ( f = 0, fl = chunk_faces3.length; f < fl; f ++ ) {

							face = obj_faces[ chunk_faces3[ f ]	];

							customAttribute.array[ offset_custom ] 	   = customAttribute.value[ face.a ];
							customAttribute.array[ offset_custom + 1 ] = customAttribute.value[ face.b ];
							customAttribute.array[ offset_custom + 2 ] = customAttribute.value[ face.c ];

							offset_custom += 3;

						}

					} else if ( customAttribute.boundTo === "faces" ) {

						for ( f = 0, fl = chunk_faces3.length; f < fl; f ++ ) {

							value = customAttribute.value[ chunk_faces3[ f ] ];

							customAttribute.array[ offset_custom ] 	   = value;
							customAttribute.array[ offset_custom + 1 ] = value;
							customAttribute.array[ offset_custom + 2 ] = value;

							offset_custom += 3;

						}

					}

				} else if ( customAttribute.size === 2 ) {

					if ( customAttribute.boundTo === undefined || customAttribute.boundTo === "vertices" ) {

						for ( f = 0, fl = chunk_faces3.length; f < fl; f ++ ) {

							face = obj_faces[ chunk_faces3[ f ]	];

							v1 = customAttribute.value[ face.a ];
							v2 = customAttribute.value[ face.b ];
							v3 = customAttribute.value[ face.c ];

							customAttribute.array[ offset_custom ] 	   = v1.x;
							customAttribute.array[ offset_custom + 1 ] = v1.y;

							customAttribute.array[ offset_custom + 2 ] = v2.x;
							customAttribute.array[ offset_custom + 3 ] = v2.y;

							customAttribute.array[ offset_custom + 4 ] = v3.x;
							customAttribute.array[ offset_custom + 5 ] = v3.y;

							offset_custom += 6;

						}

					} else if ( customAttribute.boundTo === "faces" ) {

						for ( f = 0, fl = chunk_faces3.length; f < fl; f ++ ) {

							value = customAttribute.value[ chunk_faces3[ f ] ];

							v1 = value;
							v2 = value;
							v3 = value;

							customAttribute.array[ offset_custom ] 	   = v1.x;
							customAttribute.array[ offset_custom + 1 ] = v1.y;

							customAttribute.array[ offset_custom + 2 ] = v2.x;
							customAttribute.array[ offset_custom + 3 ] = v2.y;

							customAttribute.array[ offset_custom + 4 ] = v3.x;
							customAttribute.array[ offset_custom + 5 ] = v3.y;

							offset_custom += 6;

						}

					}

				} else if ( customAttribute.size === 3 ) {

					var pp;

					if ( customAttribute.type === "c" ) {

						pp = [ "r", "g", "b" ];

					} else {

						pp = [ "x", "y", "z" ];

					}

					if ( customAttribute.boundTo === undefined || customAttribute.boundTo === "vertices" ) {

						for ( f = 0, fl = chunk_faces3.length; f < fl; f ++ ) {

							face = obj_faces[ chunk_faces3[ f ]	];

							v1 = customAttribute.value[ face.a ];
							v2 = customAttribute.value[ face.b ];
							v3 = customAttribute.value[ face.c ];

							customAttribute.array[ offset_custom ] 	   = v1[ pp[ 0 ] ];
							customAttribute.array[ offset_custom + 1 ] = v1[ pp[ 1 ] ];
							customAttribute.array[ offset_custom + 2 ] = v1[ pp[ 2 ] ];

							customAttribute.array[ offset_custom + 3 ] = v2[ pp[ 0 ] ];
							customAttribute.array[ offset_custom + 4 ] = v2[ pp[ 1 ] ];
							customAttribute.array[ offset_custom + 5 ] = v2[ pp[ 2 ] ];

							customAttribute.array[ offset_custom + 6 ] = v3[ pp[ 0 ] ];
							customAttribute.array[ offset_custom + 7 ] = v3[ pp[ 1 ] ];
							customAttribute.array[ offset_custom + 8 ] = v3[ pp[ 2 ] ];

							offset_custom += 9;

						}

					} else if ( customAttribute.boundTo === "faces" ) {

						for ( f = 0, fl = chunk_faces3.length; f < fl; f ++ ) {

							value = customAttribute.value[ chunk_faces3[ f ] ];

							v1 = value;
							v2 = value;
							v3 = value;

							customAttribute.array[ offset_custom ] 	   = v1[ pp[ 0 ] ];
							customAttribute.array[ offset_custom + 1 ] = v1[ pp[ 1 ] ];
							customAttribute.array[ offset_custom + 2 ] = v1[ pp[ 2 ] ];

							customAttribute.array[ offset_custom + 3 ] = v2[ pp[ 0 ] ];
							customAttribute.array[ offset_custom + 4 ] = v2[ pp[ 1 ] ];
							customAttribute.array[ offset_custom + 5 ] = v2[ pp[ 2 ] ];

							customAttribute.array[ offset_custom + 6 ] = v3[ pp[ 0 ] ];
							customAttribute.array[ offset_custom + 7 ] = v3[ pp[ 1 ] ];
							customAttribute.array[ offset_custom + 8 ] = v3[ pp[ 2 ] ];

							offset_custom += 9;

						}

					} else if ( customAttribute.boundTo === "faceVertices" ) {

						for ( f = 0, fl = chunk_faces3.length; f < fl; f ++ ) {

							value = customAttribute.value[ chunk_faces3[ f ] ];

							v1 = value[ 0 ];
							v2 = value[ 1 ];
							v3 = value[ 2 ];

							customAttribute.array[ offset_custom ] 	   = v1[ pp[ 0 ] ];
							customAttribute.array[ offset_custom + 1 ] = v1[ pp[ 1 ] ];
							customAttribute.array[ offset_custom + 2 ] = v1[ pp[ 2 ] ];

							customAttribute.array[ offset_custom + 3 ] = v2[ pp[ 0 ] ];
							customAttribute.array[ offset_custom + 4 ] = v2[ pp[ 1 ] ];
							customAttribute.array[ offset_custom + 5 ] = v2[ pp[ 2 ] ];

							customAttribute.array[ offset_custom + 6 ] = v3[ pp[ 0 ] ];
							customAttribute.array[ offset_custom + 7 ] = v3[ pp[ 1 ] ];
							customAttribute.array[ offset_custom + 8 ] = v3[ pp[ 2 ] ];

							offset_custom += 9;

						}

					}

				} else if ( customAttribute.size === 4 ) {

					if ( customAttribute.boundTo === undefined || customAttribute.boundTo === "vertices" ) {

						for ( f = 0, fl = chunk_faces3.length; f < fl; f ++ ) {

							face = obj_faces[ chunk_faces3[ f ]	];

							v1 = customAttribute.value[ face.a ];
							v2 = customAttribute.value[ face.b ];
							v3 = customAttribute.value[ face.c ];

							customAttribute.array[ offset_custom  ] 	= v1.x;
							customAttribute.array[ offset_custom + 1  ] = v1.y;
							customAttribute.array[ offset_custom + 2  ] = v1.z;
							customAttribute.array[ offset_custom + 3  ] = v1.w;

							customAttribute.array[ offset_custom + 4  ] = v2.x;
							customAttribute.array[ offset_custom + 5  ] = v2.y;
							customAttribute.array[ offset_custom + 6  ] = v2.z;
							customAttribute.array[ offset_custom + 7  ] = v2.w;

							customAttribute.array[ offset_custom + 8  ] = v3.x;
							customAttribute.array[ offset_custom + 9  ] = v3.y;
							customAttribute.array[ offset_custom + 10 ] = v3.z;
							customAttribute.array[ offset_custom + 11 ] = v3.w;

							offset_custom += 12;

						}

					} else if ( customAttribute.boundTo === "faces" ) {

						for ( f = 0, fl = chunk_faces3.length; f < fl; f ++ ) {

							value = customAttribute.value[ chunk_faces3[ f ] ];

							v1 = value;
							v2 = value;
							v3 = value;

							customAttribute.array[ offset_custom  ] 	= v1.x;
							customAttribute.array[ offset_custom + 1  ] = v1.y;
							customAttribute.array[ offset_custom + 2  ] = v1.z;
							customAttribute.array[ offset_custom + 3  ] = v1.w;

							customAttribute.array[ offset_custom + 4  ] = v2.x;
							customAttribute.array[ offset_custom + 5  ] = v2.y;
							customAttribute.array[ offset_custom + 6  ] = v2.z;
							customAttribute.array[ offset_custom + 7  ] = v2.w;

							customAttribute.array[ offset_custom + 8  ] = v3.x;
							customAttribute.array[ offset_custom + 9  ] = v3.y;
							customAttribute.array[ offset_custom + 10 ] = v3.z;
							customAttribute.array[ offset_custom + 11 ] = v3.w;

							offset_custom += 12;

						}

					} else if ( customAttribute.boundTo === "faceVertices" ) {

						for ( f = 0, fl = chunk_faces3.length; f < fl; f ++ ) {

							value = customAttribute.value[ chunk_faces3[ f ] ];

							v1 = value[ 0 ];
							v2 = value[ 1 ];
							v3 = value[ 2 ];

							customAttribute.array[ offset_custom  ] 	= v1.x;
							customAttribute.array[ offset_custom + 1  ] = v1.y;
							customAttribute.array[ offset_custom + 2  ] = v1.z;
							customAttribute.array[ offset_custom + 3  ] = v1.w;

							customAttribute.array[ offset_custom + 4  ] = v2.x;
							customAttribute.array[ offset_custom + 5  ] = v2.y;
							customAttribute.array[ offset_custom + 6  ] = v2.z;
							customAttribute.array[ offset_custom + 7  ] = v2.w;

							customAttribute.array[ offset_custom + 8  ] = v3.x;
							customAttribute.array[ offset_custom + 9  ] = v3.y;
							customAttribute.array[ offset_custom + 10 ] = v3.z;
							customAttribute.array[ offset_custom + 11 ] = v3.w;

							offset_custom += 12;

						}

					}

				}

				_gl.bindBuffer( _gl.ARRAY_BUFFER, customAttribute.buffer );
				_gl.bufferData( _gl.ARRAY_BUFFER, customAttribute.array, hint );

			}

		}

		if ( dispose ) {

			delete geometryGroup.__inittedArrays;
			delete geometryGroup.__colorArray;
			delete geometryGroup.__normalArray;
			delete geometryGroup.__tangentArray;
			delete geometryGroup.__uvArray;
			delete geometryGroup.__uv2Array;
			delete geometryGroup.__faceArray;
			delete geometryGroup.__vertexArray;
			delete geometryGroup.__lineArray;
			delete geometryGroup.__skinIndexArray;
			delete geometryGroup.__skinWeightArray;

		}

	};

	function setDirectBuffers ( geometry, hint, dispose ) {

		var attributes = geometry.attributes;

		var attributeName, attributeItem;

		for ( attributeName in attributes ) {

			attributeItem = attributes[ attributeName ];

			if ( attributeItem.needsUpdate ) {

				if ( attributeName === 'index' ) {

					_gl.bindBuffer( _gl.ELEMENT_ARRAY_BUFFER, attributeItem.buffer );
					_gl.bufferData( _gl.ELEMENT_ARRAY_BUFFER, attributeItem.array, hint );

				} else {

					_gl.bindBuffer( _gl.ARRAY_BUFFER, attributeItem.buffer );
					_gl.bufferData( _gl.ARRAY_BUFFER, attributeItem.array, hint );

				}

				attributeItem.needsUpdate = false;

			}

			if ( dispose && ! attributeItem.dynamic ) {

				attributeItem.array = null;

			}

		}

	};

	// Buffer rendering

	this.renderBufferImmediate = function ( object, program, material ) {

		if ( object.hasPositions && ! object.__webglVertexBuffer ) object.__webglVertexBuffer = _gl.createBuffer();
		if ( object.hasNormals && ! object.__webglNormalBuffer ) object.__webglNormalBuffer = _gl.createBuffer();
		if ( object.hasUvs && ! object.__webglUvBuffer ) object.__webglUvBuffer = _gl.createBuffer();
		if ( object.hasColors && ! object.__webglColorBuffer ) object.__webglColorBuffer = _gl.createBuffer();

		if ( object.hasPositions ) {

			_gl.bindBuffer( _gl.ARRAY_BUFFER, object.__webglVertexBuffer );
			_gl.bufferData( _gl.ARRAY_BUFFER, object.positionArray, _gl.DYNAMIC_DRAW );
			_gl.enableVertexAttribArray( program.attributes.position );
			_gl.vertexAttribPointer( program.attributes.position, 3, _gl.FLOAT, false, 0, 0 );

		}

		if ( object.hasNormals ) {

			_gl.bindBuffer( _gl.ARRAY_BUFFER, object.__webglNormalBuffer );

			if ( material.shading === THREE.FlatShading ) {

				var nx, ny, nz,
					nax, nbx, ncx, nay, nby, ncy, naz, nbz, ncz,
					normalArray,
					i, il = object.count * 3;

				for( i = 0; i < il; i += 9 ) {

					normalArray = object.normalArray;

					nax  = normalArray[ i ];
					nay  = normalArray[ i + 1 ];
					naz  = normalArray[ i + 2 ];

					nbx  = normalArray[ i + 3 ];
					nby  = normalArray[ i + 4 ];
					nbz  = normalArray[ i + 5 ];

					ncx  = normalArray[ i + 6 ];
					ncy  = normalArray[ i + 7 ];
					ncz  = normalArray[ i + 8 ];

					nx = ( nax + nbx + ncx ) / 3;
					ny = ( nay + nby + ncy ) / 3;
					nz = ( naz + nbz + ncz ) / 3;

					normalArray[ i ] 	 = nx;
					normalArray[ i + 1 ] = ny;
					normalArray[ i + 2 ] = nz;

					normalArray[ i + 3 ] = nx;
					normalArray[ i + 4 ] = ny;
					normalArray[ i + 5 ] = nz;

					normalArray[ i + 6 ] = nx;
					normalArray[ i + 7 ] = ny;
					normalArray[ i + 8 ] = nz;

				}

			}

			_gl.bufferData( _gl.ARRAY_BUFFER, object.normalArray, _gl.DYNAMIC_DRAW );
			_gl.enableVertexAttribArray( program.attributes.normal );
			_gl.vertexAttribPointer( program.attributes.normal, 3, _gl.FLOAT, false, 0, 0 );

		}

		if ( object.hasUvs && material.map ) {

			_gl.bindBuffer( _gl.ARRAY_BUFFER, object.__webglUvBuffer );
			_gl.bufferData( _gl.ARRAY_BUFFER, object.uvArray, _gl.DYNAMIC_DRAW );
			_gl.enableVertexAttribArray( program.attributes.uv );
			_gl.vertexAttribPointer( program.attributes.uv, 2, _gl.FLOAT, false, 0, 0 );

		}

		if ( object.hasColors && material.vertexColors !== THREE.NoColors ) {

			_gl.bindBuffer( _gl.ARRAY_BUFFER, object.__webglColorBuffer );
			_gl.bufferData( _gl.ARRAY_BUFFER, object.colorArray, _gl.DYNAMIC_DRAW );
			_gl.enableVertexAttribArray( program.attributes.color );
			_gl.vertexAttribPointer( program.attributes.color, 3, _gl.FLOAT, false, 0, 0 );

		}

		_gl.drawArrays( _gl.TRIANGLES, 0, object.count );

		object.count = 0;

	};

	this.renderBufferDirect = function ( camera, lights, fog, material, geometry, object ) {

		if ( material.visible === false ) return;

		var linewidth, a, attribute;
		var attributeItem, attributeName, attributePointer, attributeSize;

		var program = setProgram( camera, lights, fog, material, object );

		var programAttributes = program.attributes;
		var geometryAttributes = geometry.attributes;

		var updateBuffers = false,
			wireframeBit = material.wireframe ? 1 : 0,
			geometryHash = ( geometry.id * 0xffffff ) + ( program.id * 2 ) + wireframeBit;

		if ( geometryHash !== _currentGeometryGroupHash ) {

			_currentGeometryGroupHash = geometryHash;
			updateBuffers = true;

		}

		if ( updateBuffers ) {

			disableAttributes();

		}

		// render mesh

		if ( object instanceof THREE.Mesh ) {

			var index = geometryAttributes[ "index" ];

			// indexed triangles

			if ( index ) {

				var offsets = geometry.offsets;

				// if there is more than 1 chunk
				// must set attribute pointers to use new offsets for each chunk
				// even if geometry and materials didn't change

				if ( offsets.length > 1 ) updateBuffers = true;

				for ( var i = 0, il = offsets.length; i < il; i ++ ) {

					var startIndex = offsets[ i ].index;

					if ( updateBuffers ) {

						for ( attributeName in programAttributes ) {

							attributePointer = programAttributes[ attributeName ];
							attributeItem = geometryAttributes[ attributeName ];

							if ( attributePointer >= 0 ) {

								if ( attributeItem ) {

									attributeSize = attributeItem.itemSize;
									_gl.bindBuffer( _gl.ARRAY_BUFFER, attributeItem.buffer );
									enableAttribute( attributePointer );
									_gl.vertexAttribPointer( attributePointer, attributeSize, _gl.FLOAT, false, 0, startIndex * attributeSize * 4 ); // 4 bytes per Float32

								} else if ( material.defaultAttributeValues ) {

									if ( material.defaultAttributeValues[ attributeName ].length === 2 ) {

										_gl.vertexAttrib2fv( attributePointer, material.defaultAttributeValues[ attributeName ] );

									} else if ( material.defaultAttributeValues[ attributeName ].length === 3 ) {

										_gl.vertexAttrib3fv( attributePointer, material.defaultAttributeValues[ attributeName ] );

									}

								}

							}

						}

						// indices

						_gl.bindBuffer( _gl.ELEMENT_ARRAY_BUFFER, index.buffer );

					}

					// render indexed triangles

					_gl.drawElements( _gl.TRIANGLES, offsets[ i ].count, _gl.UNSIGNED_SHORT, offsets[ i ].start * 2 ); // 2 bytes per Uint16

					_this.info.render.calls ++;
					_this.info.render.vertices += offsets[ i ].count; // not really true, here vertices can be shared
					_this.info.render.faces += offsets[ i ].count / 3;

				}

			// non-indexed triangles

			} else {

				if ( updateBuffers ) {

					for ( attributeName in programAttributes ) {

						if ( attributeName === 'index') continue;

						attributePointer = programAttributes[ attributeName ];
						attributeItem = geometryAttributes[ attributeName ];

						if ( attributePointer >= 0 ) {

							if ( attributeItem ) {

								attributeSize = attributeItem.itemSize;
								_gl.bindBuffer( _gl.ARRAY_BUFFER, attributeItem.buffer );
								enableAttribute( attributePointer );
								_gl.vertexAttribPointer( attributePointer, attributeSize, _gl.FLOAT, false, 0, 0 );

							} else if ( material.defaultAttributeValues && material.defaultAttributeValues[ attributeName ] ) {

								if ( material.defaultAttributeValues[ attributeName ].length === 2 ) {

									_gl.vertexAttrib2fv( attributePointer, material.defaultAttributeValues[ attributeName ] );

								} else if ( material.defaultAttributeValues[ attributeName ].length === 3 ) {

									_gl.vertexAttrib3fv( attributePointer, material.defaultAttributeValues[ attributeName ] );

								}

							}

						}

					}

				}

				var position = geometry.attributes[ "position" ];

				// render non-indexed triangles

				_gl.drawArrays( _gl.TRIANGLES, 0, position.numItems / 3 );

				_this.info.render.calls ++;
				_this.info.render.vertices += position.numItems / 3;
				_this.info.render.faces += position.numItems / 3 / 3;

			}

		// render particles

		} else if ( object instanceof THREE.ParticleSystem ) {

			if ( updateBuffers ) {

				for ( attributeName in programAttributes ) {

					attributePointer = programAttributes[ attributeName ];
					attributeItem = geometryAttributes[ attributeName ];

					if ( attributePointer >= 0 ) {

						if ( attributeItem ) {

							attributeSize = attributeItem.itemSize;
							_gl.bindBuffer( _gl.ARRAY_BUFFER, attributeItem.buffer );
							enableAttribute( attributePointer );
							_gl.vertexAttribPointer( attributePointer, attributeSize, _gl.FLOAT, false, 0, 0 );

						} else if ( material.defaultAttributeValues && material.defaultAttributeValues[ attributeName ] ) {

							if ( material.defaultAttributeValues[ attributeName ].length === 2 ) {

								_gl.vertexAttrib2fv( attributePointer, material.defaultAttributeValues[ attributeName ] );

							} else if ( material.defaultAttributeValues[ attributeName ].length === 3 ) {

								_gl.vertexAttrib3fv( attributePointer, material.defaultAttributeValues[ attributeName ] );

							}

						}

					}

				}

			}

			var position = geometryAttributes[ "position" ];

			// render particles

			_gl.drawArrays( _gl.POINTS, 0, position.numItems / 3 );

			_this.info.render.calls ++;
			_this.info.render.points += position.numItems / 3;

		} else if ( object instanceof THREE.Line ) {

			if ( updateBuffers ) {

				for ( attributeName in programAttributes ) {

					attributePointer = programAttributes[ attributeName ];
					attributeItem = geometryAttributes[ attributeName ];

					if ( attributePointer >= 0 ) {

						if ( attributeItem ) {

							attributeSize = attributeItem.itemSize;
							_gl.bindBuffer( _gl.ARRAY_BUFFER, attributeItem.buffer );
							enableAttribute( attributePointer );
							_gl.vertexAttribPointer( attributePointer, attributeSize, _gl.FLOAT, false, 0, 0 );

						} else if ( material.defaultAttributeValues && material.defaultAttributeValues[ attributeName ] ) {

							if ( material.defaultAttributeValues[ attributeName ].length === 2 ) {

								_gl.vertexAttrib2fv( attributePointer, material.defaultAttributeValues[ attributeName ] );

							} else if ( material.defaultAttributeValues[ attributeName ].length === 3 ) {

								_gl.vertexAttrib3fv( attributePointer, material.defaultAttributeValues[ attributeName ] );

							}

						}

					}

				}

			}

			// render lines

			var primitives = ( object.type === THREE.LineStrip ) ? _gl.LINE_STRIP : _gl.LINES;

			setLineWidth( material.linewidth );

			var position = geometryAttributes[ "position" ];

			_gl.drawArrays( primitives, 0, position.numItems / 3 );

			_this.info.render.calls ++;
			_this.info.render.points += position.numItems;

		}

	};

	this.renderBuffer = function ( camera, lights, fog, material, geometryGroup, object ) {

		if ( material.visible === false ) return;

		var linewidth, a, attribute, i, il;

		var program = setProgram( camera, lights, fog, material, object );

		var attributes = program.attributes;

		var updateBuffers = false,
			wireframeBit = material.wireframe ? 1 : 0,
			geometryGroupHash = ( geometryGroup.id * 0xffffff ) + ( program.id * 2 ) + wireframeBit;

		if ( geometryGroupHash !== _currentGeometryGroupHash ) {

			_currentGeometryGroupHash = geometryGroupHash;
			updateBuffers = true;

		}

		if ( updateBuffers ) {

			disableAttributes();

		}

		// vertices

		if ( !material.morphTargets && attributes.position >= 0 ) {

			if ( updateBuffers ) {

				_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglVertexBuffer );
				enableAttribute( attributes.position );
				_gl.vertexAttribPointer( attributes.position, 3, _gl.FLOAT, false, 0, 0 );

			}

		} else {

			if ( object.morphTargetBase ) {

				setupMorphTargets( material, geometryGroup, object );

			}

		}


		if ( updateBuffers ) {

			// custom attributes

			// Use the per-geometryGroup custom attribute arrays which are setup in initMeshBuffers

			if ( geometryGroup.__webglCustomAttributesList ) {

				for ( i = 0, il = geometryGroup.__webglCustomAttributesList.length; i < il; i ++ ) {

					attribute = geometryGroup.__webglCustomAttributesList[ i ];

					if ( attributes[ attribute.buffer.belongsToAttribute ] >= 0 ) {

						_gl.bindBuffer( _gl.ARRAY_BUFFER, attribute.buffer );
						enableAttribute( attributes[ attribute.buffer.belongsToAttribute ] );
						_gl.vertexAttribPointer( attributes[ attribute.buffer.belongsToAttribute ], attribute.size, _gl.FLOAT, false, 0, 0 );

					}

				}

			}


			// colors

			if ( attributes.color >= 0 ) {

				if ( object.geometry.colors.length > 0 || object.geometry.faces.length > 0 ) {

					_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglColorBuffer );
					enableAttribute( attributes.color );
					_gl.vertexAttribPointer( attributes.color, 3, _gl.FLOAT, false, 0, 0 );

				} else if ( material.defaultAttributeValues ) {


					_gl.vertexAttrib3fv( attributes.color, material.defaultAttributeValues.color );

				}

			}

			// normals

			if ( attributes.normal >= 0 ) {

				_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglNormalBuffer );
				enableAttribute( attributes.normal );
				_gl.vertexAttribPointer( attributes.normal, 3, _gl.FLOAT, false, 0, 0 );

			}

			// tangents

			if ( attributes.tangent >= 0 ) {

				_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglTangentBuffer );
				enableAttribute( attributes.tangent );
				_gl.vertexAttribPointer( attributes.tangent, 4, _gl.FLOAT, false, 0, 0 );

			}

			// uvs

			if ( attributes.uv >= 0 ) {

				if ( object.geometry.faceVertexUvs[0] ) {

					_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglUVBuffer );
					enableAttribute( attributes.uv );
					_gl.vertexAttribPointer( attributes.uv, 2, _gl.FLOAT, false, 0, 0 );

				} else if ( material.defaultAttributeValues ) {


					_gl.vertexAttrib2fv( attributes.uv, material.defaultAttributeValues.uv );

				}

			}

			if ( attributes.uv2 >= 0 ) {

				if ( object.geometry.faceVertexUvs[1] ) {

					_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglUV2Buffer );
					enableAttribute( attributes.uv2 );
					_gl.vertexAttribPointer( attributes.uv2, 2, _gl.FLOAT, false, 0, 0 );

				} else if ( material.defaultAttributeValues ) {


					_gl.vertexAttrib2fv( attributes.uv2, material.defaultAttributeValues.uv2 );

				}

			}

			if ( material.skinning &&
				 attributes.skinIndex >= 0 && attributes.skinWeight >= 0 ) {

				_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglSkinIndicesBuffer );
				enableAttribute( attributes.skinIndex );
				_gl.vertexAttribPointer( attributes.skinIndex, 4, _gl.FLOAT, false, 0, 0 );

				_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglSkinWeightsBuffer );
				enableAttribute( attributes.skinWeight );
				_gl.vertexAttribPointer( attributes.skinWeight, 4, _gl.FLOAT, false, 0, 0 );

			}

			// line distances

			if ( attributes.lineDistance >= 0 ) {

				_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglLineDistanceBuffer );
				enableAttribute( attributes.lineDistance );
				_gl.vertexAttribPointer( attributes.lineDistance, 1, _gl.FLOAT, false, 0, 0 );

			}

		}

		// render mesh

		if ( object instanceof THREE.Mesh ) {

			// wireframe

			if ( material.wireframe ) {

				setLineWidth( material.wireframeLinewidth );

				if ( updateBuffers ) _gl.bindBuffer( _gl.ELEMENT_ARRAY_BUFFER, geometryGroup.__webglLineBuffer );
				_gl.drawElements( _gl.LINES, geometryGroup.__webglLineCount, _gl.UNSIGNED_SHORT, 0 );

			// triangles

			} else {

				if ( updateBuffers ) _gl.bindBuffer( _gl.ELEMENT_ARRAY_BUFFER, geometryGroup.__webglFaceBuffer );
				_gl.drawElements( _gl.TRIANGLES, geometryGroup.__webglFaceCount, _gl.UNSIGNED_SHORT, 0 );

			}

			_this.info.render.calls ++;
			_this.info.render.vertices += geometryGroup.__webglFaceCount;
			_this.info.render.faces += geometryGroup.__webglFaceCount / 3;

		// render lines

		} else if ( object instanceof THREE.Line ) {

			var primitives = ( object.type === THREE.LineStrip ) ? _gl.LINE_STRIP : _gl.LINES;

			setLineWidth( material.linewidth );

			_gl.drawArrays( primitives, 0, geometryGroup.__webglLineCount );

			_this.info.render.calls ++;

		// render particles

		} else if ( object instanceof THREE.ParticleSystem ) {

			_gl.drawArrays( _gl.POINTS, 0, geometryGroup.__webglParticleCount );

			_this.info.render.calls ++;
			_this.info.render.points += geometryGroup.__webglParticleCount;

		}

	};

	function enableAttribute( attribute ) {

		if ( ! _enabledAttributes[ attribute ] ) {

			_gl.enableVertexAttribArray( attribute );
			_enabledAttributes[ attribute ] = true;

		}

	};

	function disableAttributes() {

		for ( var attribute in _enabledAttributes ) {

			if ( _enabledAttributes[ attribute ] ) {

				_gl.disableVertexAttribArray( attribute );
				_enabledAttributes[ attribute ] = false;

			}

		}

	};

	function setupMorphTargets ( material, geometryGroup, object ) {

		// set base

		var attributes = material.program.attributes;

		if ( object.morphTargetBase !== -1 && attributes.position >= 0 ) {

			_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglMorphTargetsBuffers[ object.morphTargetBase ] );
			enableAttribute( attributes.position );
			_gl.vertexAttribPointer( attributes.position, 3, _gl.FLOAT, false, 0, 0 );

		} else if ( attributes.position >= 0 ) {

			_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglVertexBuffer );
			enableAttribute( attributes.position );
			_gl.vertexAttribPointer( attributes.position, 3, _gl.FLOAT, false, 0, 0 );

		}

		if ( object.morphTargetForcedOrder.length ) {

			// set forced order

			var m = 0;
			var order = object.morphTargetForcedOrder;
			var influences = object.morphTargetInfluences;

			while ( m < material.numSupportedMorphTargets && m < order.length ) {

				if ( attributes[ "morphTarget" + m ] >= 0 ) {

					_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglMorphTargetsBuffers[ order[ m ] ] );
					enableAttribute( attributes[ "morphTarget" + m ] );
					_gl.vertexAttribPointer( attributes[ "morphTarget" + m ], 3, _gl.FLOAT, false, 0, 0 );

				}

				if ( attributes[ "morphNormal" + m ] >= 0 && material.morphNormals ) {

					_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglMorphNormalsBuffers[ order[ m ] ] );
					enableAttribute( attributes[ "morphNormal" + m ] );
					_gl.vertexAttribPointer( attributes[ "morphNormal" + m ], 3, _gl.FLOAT, false, 0, 0 );

				}

				object.__webglMorphTargetInfluences[ m ] = influences[ order[ m ] ];

				m ++;
			}

		} else {

			// find the most influencing

			var influence, activeInfluenceIndices = [];
			var influences = object.morphTargetInfluences;
			var i, il = influences.length;

			for ( i = 0; i < il; i ++ ) {

				influence = influences[ i ];

				if ( influence > 0 ) {

					activeInfluenceIndices.push( [ influence, i ] );

				}

			}

			if ( activeInfluenceIndices.length > material.numSupportedMorphTargets ) {

				activeInfluenceIndices.sort( numericalSort );
				activeInfluenceIndices.length = material.numSupportedMorphTargets;

			} else if ( activeInfluenceIndices.length > material.numSupportedMorphNormals ) {

				activeInfluenceIndices.sort( numericalSort );

			} else if ( activeInfluenceIndices.length === 0 ) {

				activeInfluenceIndices.push( [ 0, 0 ] );

			};

			var influenceIndex, m = 0;

			while ( m < material.numSupportedMorphTargets ) {

				if ( activeInfluenceIndices[ m ] ) {

					influenceIndex = activeInfluenceIndices[ m ][ 1 ];

					if ( attributes[ "morphTarget" + m ] >= 0 ) {

						_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglMorphTargetsBuffers[ influenceIndex ] );
						enableAttribute( attributes[ "morphTarget" + m ] );
						_gl.vertexAttribPointer( attributes[ "morphTarget" + m ], 3, _gl.FLOAT, false, 0, 0 );

					}

					if ( attributes[ "morphNormal" + m ] >= 0 && material.morphNormals ) {

						_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglMorphNormalsBuffers[ influenceIndex ] );
						enableAttribute( attributes[ "morphNormal" + m ] );
						_gl.vertexAttribPointer( attributes[ "morphNormal" + m ], 3, _gl.FLOAT, false, 0, 0 );


					}

					object.__webglMorphTargetInfluences[ m ] = influences[ influenceIndex ];

				} else {

					/*
					_gl.vertexAttribPointer( attributes[ "morphTarget" + m ], 3, _gl.FLOAT, false, 0, 0 );

					if ( material.morphNormals ) {

						_gl.vertexAttribPointer( attributes[ "morphNormal" + m ], 3, _gl.FLOAT, false, 0, 0 );

					}
					*/

					object.__webglMorphTargetInfluences[ m ] = 0;

				}

				m ++;

			}

		}

		// load updated influences uniform

		if ( material.program.uniforms.morphTargetInfluences !== null ) {

			_gl.uniform1fv( material.program.uniforms.morphTargetInfluences, object.__webglMorphTargetInfluences );

		}

	};

	// Sorting

	function painterSortStable ( a, b ) {

		if ( a.z !== b.z ) {

			return b.z - a.z;

		} else {

			return a.id - b.id;

		}

	};

	function numericalSort ( a, b ) {

		return b[ 0 ] - a[ 0 ];

	};


	// Rendering

	this.render = function ( scene, camera, renderTarget, forceClear ) {

		if ( camera instanceof THREE.Camera === false ) {

			console.error( 'THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.' );
			return;

		}

		var i, il,

		webglObject, object,
		renderList,

		lights = scene.__lights,
		fog = scene.fog;

		// reset caching for this frame

		_currentMaterialId = -1;
		_lightsNeedUpdate = true;

		// update scene graph

		if ( scene.autoUpdate === true ) scene.updateMatrixWorld();

		// update camera matrices and frustum

		if ( camera.parent === undefined ) camera.updateMatrixWorld();

		camera.matrixWorldInverse.getInverse( camera.matrixWorld );

		_projScreenMatrix.multiplyMatrices( camera.projectionMatrix, camera.matrixWorldInverse );
		_frustum.setFromMatrix( _projScreenMatrix );

		// update WebGL objects

		if ( this.autoUpdateObjects ) this.initWebGLObjects( scene );

		// custom render plugins (pre pass)

		renderPlugins( this.renderPluginsPre, scene, camera );

		//

		_this.info.render.calls = 0;
		_this.info.render.vertices = 0;
		_this.info.render.faces = 0;
		_this.info.render.points = 0;

		this.setRenderTarget( renderTarget );

		if ( this.autoClear || forceClear ) {

			this.clear( this.autoClearColor, this.autoClearDepth, this.autoClearStencil );

		}

		// set matrices for regular objects (frustum culled)

		renderList = scene.__webglObjects;

		for ( i = 0, il = renderList.length; i < il; i ++ ) {

			webglObject = renderList[ i ];
			object = webglObject.object;

			webglObject.id = i;
			webglObject.render = false;

			if ( object.visible ) {

				if ( ! ( object instanceof THREE.Mesh || object instanceof THREE.ParticleSystem ) || ! ( object.frustumCulled ) || _frustum.intersectsObject( object ) ) {

					setupMatrices( object, camera );

					unrollBufferMaterial( webglObject );

					webglObject.render = true;

					if ( this.sortObjects === true ) {

						if ( object.renderDepth !== null ) {

							webglObject.z = object.renderDepth;

						} else {

							_vector3.setFromMatrixPosition( object.matrixWorld );
							_vector3.applyProjection( _projScreenMatrix );

							webglObject.z = _vector3.z;

						}

					}

				}

			}

		}

		if ( this.sortObjects ) {

			renderList.sort( painterSortStable );

		}

		// set matrices for immediate objects

		renderList = scene.__webglObjectsImmediate;

		for ( i = 0, il = renderList.length; i < il; i ++ ) {

			webglObject = renderList[ i ];
			object = webglObject.object;

			if ( object.visible ) {

				setupMatrices( object, camera );

				unrollImmediateBufferMaterial( webglObject );

			}

		}

		if ( scene.overrideMaterial ) {

			var material = scene.overrideMaterial;

			this.setBlending( material.blending, material.blendEquation, material.blendSrc, material.blendDst );
			this.setDepthTest( material.depthTest );
			this.setDepthWrite( material.depthWrite );
			setPolygonOffset( material.polygonOffset, material.polygonOffsetFactor, material.polygonOffsetUnits );

			renderObjects( scene.__webglObjects, false, "", camera, lights, fog, true, material );
			renderObjectsImmediate( scene.__webglObjectsImmediate, "", camera, lights, fog, false, material );

		} else {

			var material = null;

			// opaque pass (front-to-back order)

			this.setBlending( THREE.NoBlending );

			renderObjects( scene.__webglObjects, true, "opaque", camera, lights, fog, false, material );
			renderObjectsImmediate( scene.__webglObjectsImmediate, "opaque", camera, lights, fog, false, material );

			// transparent pass (back-to-front order)

			renderObjects( scene.__webglObjects, false, "transparent", camera, lights, fog, true, material );
			renderObjectsImmediate( scene.__webglObjectsImmediate, "transparent", camera, lights, fog, true, material );

		}

		// custom render plugins (post pass)

		renderPlugins( this.renderPluginsPost, scene, camera );


		// Generate mipmap if we're using any kind of mipmap filtering

		if ( renderTarget && renderTarget.generateMipmaps && renderTarget.minFilter !== THREE.NearestFilter && renderTarget.minFilter !== THREE.LinearFilter ) {

			updateRenderTargetMipmap( renderTarget );

		}

		// Ensure depth buffer writing is enabled so it can be cleared on next render

		this.setDepthTest( true );
		this.setDepthWrite( true );

		// _gl.finish();

	};

	function renderPlugins( plugins, scene, camera ) {

		if ( ! plugins.length ) return;

		for ( var i = 0, il = plugins.length; i < il; i ++ ) {

			// reset state for plugin (to start from clean slate)

			_currentProgram = null;
			_currentCamera = null;

			_oldBlending = -1;
			_oldDepthTest = -1;
			_oldDepthWrite = -1;
			_oldDoubleSided = -1;
			_oldFlipSided = -1;
			_currentGeometryGroupHash = -1;
			_currentMaterialId = -1;

			_lightsNeedUpdate = true;

			plugins[ i ].render( scene, camera, _currentWidth, _currentHeight );

			// reset state after plugin (anything could have changed)

			_currentProgram = null;
			_currentCamera = null;

			_oldBlending = -1;
			_oldDepthTest = -1;
			_oldDepthWrite = -1;
			_oldDoubleSided = -1;
			_oldFlipSided = -1;
			_currentGeometryGroupHash = -1;
			_currentMaterialId = -1;

			_lightsNeedUpdate = true;

		}

	};

	function renderObjects ( renderList, reverse, materialType, camera, lights, fog, useBlending, overrideMaterial ) {

		var webglObject, object, buffer, material, start, end, delta;

		if ( reverse ) {

			start = renderList.length - 1;
			end = -1;
			delta = -1;

		} else {

			start = 0;
			end = renderList.length;
			delta = 1;
		}

		for ( var i = start; i !== end; i += delta ) {

			webglObject = renderList[ i ];

			if ( webglObject.render ) {

				object = webglObject.object;
				buffer = webglObject.buffer;

				if ( overrideMaterial ) {

					material = overrideMaterial;

				} else {

					material = webglObject[ materialType ];

					if ( ! material ) continue;

					if ( useBlending ) _this.setBlending( material.blending, material.blendEquation, material.blendSrc, material.blendDst );

					_this.setDepthTest( material.depthTest );
					_this.setDepthWrite( material.depthWrite );
					setPolygonOffset( material.polygonOffset, material.polygonOffsetFactor, material.polygonOffsetUnits );

				}

				_this.setMaterialFaces( material );

				if ( buffer instanceof THREE.BufferGeometry ) {

					_this.renderBufferDirect( camera, lights, fog, material, buffer, object );

				} else {

					_this.renderBuffer( camera, lights, fog, material, buffer, object );

				}

			}

		}

	};

	function renderObjectsImmediate ( renderList, materialType, camera, lights, fog, useBlending, overrideMaterial ) {

		var webglObject, object, material, program;

		for ( var i = 0, il = renderList.length; i < il; i ++ ) {

			webglObject = renderList[ i ];
			object = webglObject.object;

			if ( object.visible ) {

				if ( overrideMaterial ) {

					material = overrideMaterial;

				} else {

					material = webglObject[ materialType ];

					if ( ! material ) continue;

					if ( useBlending ) _this.setBlending( material.blending, material.blendEquation, material.blendSrc, material.blendDst );

					_this.setDepthTest( material.depthTest );
					_this.setDepthWrite( material.depthWrite );
					setPolygonOffset( material.polygonOffset, material.polygonOffsetFactor, material.polygonOffsetUnits );

				}

				_this.renderImmediateObject( camera, lights, fog, material, object );

			}

		}

	};

	this.renderImmediateObject = function ( camera, lights, fog, material, object ) {

		var program = setProgram( camera, lights, fog, material, object );

		_currentGeometryGroupHash = -1;

		_this.setMaterialFaces( material );

		if ( object.immediateRenderCallback ) {

			object.immediateRenderCallback( program, _gl, _frustum );

		} else {

			object.render( function( object ) { _this.renderBufferImmediate( object, program, material ); } );

		}

	};

	function unrollImmediateBufferMaterial ( globject ) {

		var object = globject.object,
			material = object.material;

		if ( material.transparent ) {

			globject.transparent = material;
			globject.opaque = null;

		} else {

			globject.opaque = material;
			globject.transparent = null;

		}

	};

	function unrollBufferMaterial ( globject ) {

		var object = globject.object,
			buffer = globject.buffer,
			material, materialIndex, meshMaterial;

		meshMaterial = object.material;

		if ( meshMaterial instanceof THREE.MeshFaceMaterial ) {

			materialIndex = buffer.materialIndex;

			material = meshMaterial.materials[ materialIndex ];

			if ( material.transparent ) {

				globject.transparent = material;
				globject.opaque = null;

			} else {

				globject.opaque = material;
				globject.transparent = null;

			}

		} else {

			material = meshMaterial;

			if ( material ) {

				if ( material.transparent ) {

					globject.transparent = material;
					globject.opaque = null;

				} else {

					globject.opaque = material;
					globject.transparent = null;

				}

			}

		}

	};

	// Geometry splitting

	function sortFacesByMaterial ( geometry, material ) {

		var f, fl, face, materialIndex, vertices,
			groupHash, hash_map = {};

		var numMorphTargets = geometry.morphTargets.length;
		var numMorphNormals = geometry.morphNormals.length;

		var usesFaceMaterial = material instanceof THREE.MeshFaceMaterial;

		geometry.geometryGroups = {};

		for ( f = 0, fl = geometry.faces.length; f < fl; f ++ ) {

			face = geometry.faces[ f ];
			materialIndex = usesFaceMaterial ? face.materialIndex : 0;

			if ( hash_map[ materialIndex ] === undefined ) {

				hash_map[ materialIndex ] = { 'hash': materialIndex, 'counter': 0 };

			}

			groupHash = hash_map[ materialIndex ].hash + '_' + hash_map[ materialIndex ].counter;

			if ( geometry.geometryGroups[ groupHash ] === undefined ) {

				geometry.geometryGroups[ groupHash ] = { 'faces3': [], 'materialIndex': materialIndex, 'vertices': 0, 'numMorphTargets': numMorphTargets, 'numMorphNormals': numMorphNormals };

			}

			vertices = 3;

			if ( geometry.geometryGroups[ groupHash ].vertices + vertices > 65535 ) {

				hash_map[ materialIndex ].counter += 1;
				groupHash = hash_map[ materialIndex ].hash + '_' + hash_map[ materialIndex ].counter;

				if ( geometry.geometryGroups[ groupHash ] === undefined ) {

					geometry.geometryGroups[ groupHash ] = { 'faces3': [], 'materialIndex': materialIndex, 'vertices': 0, 'numMorphTargets': numMorphTargets, 'numMorphNormals': numMorphNormals };

				}

			}

			geometry.geometryGroups[ groupHash ].faces3.push( f );
			geometry.geometryGroups[ groupHash ].vertices += vertices;

		}

		geometry.geometryGroupsList = [];

		for ( var g in geometry.geometryGroups ) {

			geometry.geometryGroups[ g ].id = _geometryGroupCounter ++;

			geometry.geometryGroupsList.push( geometry.geometryGroups[ g ] );

		}

	};

	// Objects refresh

	this.initWebGLObjects = function ( scene ) {

		if ( !scene.__webglObjects ) {

			scene.__webglObjects = [];
			scene.__webglObjectsImmediate = [];
			scene.__webglSprites = [];
			scene.__webglFlares = [];

		}

		while ( scene.__objectsAdded.length ) {

			addObject( scene.__objectsAdded[ 0 ], scene );
			scene.__objectsAdded.splice( 0, 1 );

		}

		while ( scene.__objectsRemoved.length ) {

			removeObject( scene.__objectsRemoved[ 0 ], scene );
			scene.__objectsRemoved.splice( 0, 1 );

		}

		// update must be called after objects adding / removal

		for ( var o = 0, ol = scene.__webglObjects.length; o < ol; o ++ ) {

			var object = scene.__webglObjects[ o ].object;

			// TODO: Remove this hack (WebGLRenderer refactoring)

			if ( object.__webglInit === undefined ) {

				if ( object.__webglActive !== undefined ) {

					removeObject( object, scene );

				}

				addObject( object, scene );

			}

			updateObject( object );

		}

	};

	// Objects adding

	function addObject( object, scene ) {

		var g, geometry, material, geometryGroup;

		if ( object.__webglInit === undefined ) {

			object.__webglInit = true;

			object._modelViewMatrix = new THREE.Matrix4();
			object._normalMatrix = new THREE.Matrix3();

			if ( object.geometry !== undefined && object.geometry.__webglInit === undefined ) {

				object.geometry.__webglInit = true;
				object.geometry.addEventListener( 'dispose', onGeometryDispose );

			}

			geometry = object.geometry;

			if ( geometry === undefined ) {

				// fail silently for now

			} else if ( geometry instanceof THREE.BufferGeometry ) {

				initDirectBuffers( geometry );

			} else if ( object instanceof THREE.Mesh ) {

				material = object.material;

				if ( geometry.geometryGroups === undefined ) {

					sortFacesByMaterial( geometry, material );

				}

				// create separate VBOs per geometry chunk

				for ( g in geometry.geometryGroups ) {

					geometryGroup = geometry.geometryGroups[ g ];

					// initialise VBO on the first access

					if ( ! geometryGroup.__webglVertexBuffer ) {

						createMeshBuffers( geometryGroup );
						initMeshBuffers( geometryGroup, object );

						geometry.verticesNeedUpdate = true;
						geometry.morphTargetsNeedUpdate = true;
						geometry.elementsNeedUpdate = true;
						geometry.uvsNeedUpdate = true;
						geometry.normalsNeedUpdate = true;
						geometry.tangentsNeedUpdate = true;
						geometry.colorsNeedUpdate = true;

					}

				}

			} else if ( object instanceof THREE.Line ) {

				if ( ! geometry.__webglVertexBuffer ) {

					createLineBuffers( geometry );
					initLineBuffers( geometry, object );

					geometry.verticesNeedUpdate = true;
					geometry.colorsNeedUpdate = true;
					geometry.lineDistancesNeedUpdate = true;

				}

			} else if ( object instanceof THREE.ParticleSystem ) {

				if ( ! geometry.__webglVertexBuffer ) {

					createParticleBuffers( geometry );
					initParticleBuffers( geometry, object );

					geometry.verticesNeedUpdate = true;
					geometry.colorsNeedUpdate = true;

				}

			}

		}

		if ( object.__webglActive === undefined ) {

			if ( object instanceof THREE.Mesh ) {

				geometry = object.geometry;

				if ( geometry instanceof THREE.BufferGeometry ) {

					addBuffer( scene.__webglObjects, geometry, object );

				} else if ( geometry instanceof THREE.Geometry ) {

					for ( g in geometry.geometryGroups ) {

						geometryGroup = geometry.geometryGroups[ g ];

						addBuffer( scene.__webglObjects, geometryGroup, object );

					}

				}

			} else if ( object instanceof THREE.Line ||
						object instanceof THREE.ParticleSystem ) {

				geometry = object.geometry;
				addBuffer( scene.__webglObjects, geometry, object );

			} else if ( object instanceof THREE.ImmediateRenderObject || object.immediateRenderCallback ) {

				addBufferImmediate( scene.__webglObjectsImmediate, object );

			} else if ( object instanceof THREE.Sprite ) {

				scene.__webglSprites.push( object );

			} else if ( object instanceof THREE.LensFlare ) {

				scene.__webglFlares.push( object );

			}

			object.__webglActive = true;

		}

	};

	function addBuffer( objlist, buffer, object ) {

		objlist.push(
			{
				id: null,
				buffer: buffer,
				object: object,
				opaque: null,
				transparent: null,
				z: 0
			}
		);

	};

	function addBufferImmediate( objlist, object ) {

		objlist.push(
			{
				id: null,
				object: object,
				opaque: null,
				transparent: null,
				z: 0
			}
		);

	};

	// Objects updates

	function updateObject( object ) {

		var geometry = object.geometry,
			geometryGroup, customAttributesDirty, material;

		if ( geometry instanceof THREE.BufferGeometry ) {

			setDirectBuffers( geometry, _gl.DYNAMIC_DRAW, !geometry.dynamic );

		} else if ( object instanceof THREE.Mesh ) {

			// check all geometry groups

			for( var i = 0, il = geometry.geometryGroupsList.length; i < il; i ++ ) {

				geometryGroup = geometry.geometryGroupsList[ i ];

				material = getBufferMaterial( object, geometryGroup );

				if ( geometry.buffersNeedUpdate ) {

					initMeshBuffers( geometryGroup, object );

				}

				customAttributesDirty = material.attributes && areCustomAttributesDirty( material );

				if ( geometry.verticesNeedUpdate || geometry.morphTargetsNeedUpdate || geometry.elementsNeedUpdate ||
					 geometry.uvsNeedUpdate || geometry.normalsNeedUpdate ||
					 geometry.colorsNeedUpdate || geometry.tangentsNeedUpdate || customAttributesDirty ) {

					setMeshBuffers( geometryGroup, object, _gl.DYNAMIC_DRAW, !geometry.dynamic, material );

				}

			}

			geometry.verticesNeedUpdate = false;
			geometry.morphTargetsNeedUpdate = false;
			geometry.elementsNeedUpdate = false;
			geometry.uvsNeedUpdate = false;
			geometry.normalsNeedUpdate = false;
			geometry.colorsNeedUpdate = false;
			geometry.tangentsNeedUpdate = false;

			geometry.buffersNeedUpdate = false;

			material.attributes && clearCustomAttributes( material );

		} else if ( object instanceof THREE.Line ) {

			material = getBufferMaterial( object, geometry );

			customAttributesDirty = material.attributes && areCustomAttributesDirty( material );

			if ( geometry.verticesNeedUpdate || geometry.colorsNeedUpdate || geometry.lineDistancesNeedUpdate || customAttributesDirty ) {

				setLineBuffers( geometry, _gl.DYNAMIC_DRAW );

			}

			geometry.verticesNeedUpdate = false;
			geometry.colorsNeedUpdate = false;
			geometry.lineDistancesNeedUpdate = false;

			material.attributes && clearCustomAttributes( material );


		} else if ( object instanceof THREE.ParticleSystem ) {

			material = getBufferMaterial( object, geometry );

			customAttributesDirty = material.attributes && areCustomAttributesDirty( material );

			if ( geometry.verticesNeedUpdate || geometry.colorsNeedUpdate || object.sortParticles || customAttributesDirty ) {

				setParticleBuffers( geometry, _gl.DYNAMIC_DRAW, object );

			}

			geometry.verticesNeedUpdate = false;
			geometry.colorsNeedUpdate = false;

			material.attributes && clearCustomAttributes( material );

		}

	};

	// Objects updates - custom attributes check

	function areCustomAttributesDirty( material ) {

		for ( var a in material.attributes ) {

			if ( material.attributes[ a ].needsUpdate ) return true;

		}

		return false;

	};

	function clearCustomAttributes( material ) {

		for ( var a in material.attributes ) {

			material.attributes[ a ].needsUpdate = false;

		}

	};

	// Objects removal

	function removeObject( object, scene ) {

		if ( object instanceof THREE.Mesh  ||
			 object instanceof THREE.ParticleSystem ||
			 object instanceof THREE.Line ) {

			removeInstances( scene.__webglObjects, object );

		} else if ( object instanceof THREE.Sprite ) {

			removeInstancesDirect( scene.__webglSprites, object );

		} else if ( object instanceof THREE.LensFlare ) {

			removeInstancesDirect( scene.__webglFlares, object );

		} else if ( object instanceof THREE.ImmediateRenderObject || object.immediateRenderCallback ) {

			removeInstances( scene.__webglObjectsImmediate, object );

		}

		delete object.__webglActive;

	};

	function removeInstances( objlist, object ) {

		for ( var o = objlist.length - 1; o >= 0; o -- ) {

			if ( objlist[ o ].object === object ) {

				objlist.splice( o, 1 );

			}

		}

	};

	function removeInstancesDirect( objlist, object ) {

		for ( var o = objlist.length - 1; o >= 0; o -- ) {

			if ( objlist[ o ] === object ) {

				objlist.splice( o, 1 );

			}

		}

	};

	// Materials

	this.initMaterial = function ( material, lights, fog, object ) {

		material.addEventListener( 'dispose', onMaterialDispose );

		var u, a, identifiers, i, parameters, maxLightCount, maxBones, maxShadows, shaderID;

		if ( material instanceof THREE.MeshDepthMaterial ) {

			shaderID = 'depth';

		} else if ( material instanceof THREE.MeshNormalMaterial ) {

			shaderID = 'normal';

		} else if ( material instanceof THREE.MeshBasicMaterial ) {

			shaderID = 'basic';

		} else if ( material instanceof THREE.MeshLambertMaterial ) {

			shaderID = 'lambert';

		} else if ( material instanceof THREE.MeshPhongMaterial ) {

			shaderID = 'phong';

		} else if ( material instanceof THREE.LineBasicMaterial ) {

			shaderID = 'basic';

		} else if ( material instanceof THREE.LineDashedMaterial ) {

			shaderID = 'dashed';

		} else if ( material instanceof THREE.ParticleSystemMaterial ) {

			shaderID = 'particle_basic';

		}

		if ( shaderID ) {

			setMaterialShaders( material, THREE.ShaderLib[ shaderID ] );

		}

		// heuristics to create shader parameters according to lights in the scene
		// (not to blow over maxLights budget)

		maxLightCount = allocateLights( lights );

		maxShadows = allocateShadows( lights );

		maxBones = allocateBones( object );

		parameters = {

			map: !!material.map,
			envMap: !!material.envMap,
			lightMap: !!material.lightMap,
			bumpMap: !!material.bumpMap,
			normalMap: !!material.normalMap,
			specularMap: !!material.specularMap,

			vertexColors: material.vertexColors,

			fog: fog,
			useFog: material.fog,
			fogExp: fog instanceof THREE.FogExp2,

			sizeAttenuation: material.sizeAttenuation,

			skinning: material.skinning,
			maxBones: maxBones,
			useVertexTexture: _supportsBoneTextures && object && object.useVertexTexture,

			morphTargets: material.morphTargets,
			morphNormals: material.morphNormals,
			maxMorphTargets: this.maxMorphTargets,
			maxMorphNormals: this.maxMorphNormals,

			maxDirLights: maxLightCount.directional,
			maxPointLights: maxLightCount.point,
			maxSpotLights: maxLightCount.spot,
			maxHemiLights: maxLightCount.hemi,

			maxShadows: maxShadows,
			shadowMapEnabled: this.shadowMapEnabled && object.receiveShadow,
			shadowMapType: this.shadowMapType,
			shadowMapDebug: this.shadowMapDebug,
			shadowMapCascade: this.shadowMapCascade,

			alphaTest: material.alphaTest,
			metal: material.metal,
			perPixel: material.perPixel,
			wrapAround: material.wrapAround,
			doubleSided: material.side === THREE.DoubleSide,
			flipSided: material.side === THREE.BackSide

		};

		material.program = buildProgram( shaderID, material.fragmentShader, material.vertexShader, material.uniforms, material.attributes, material.defines, parameters, material.index0AttributeName );

		var attributes = material.program.attributes;

		if ( material.morphTargets ) {

			material.numSupportedMorphTargets = 0;

			var id, base = "morphTarget";

			for ( i = 0; i < this.maxMorphTargets; i ++ ) {

				id = base + i;

				if ( attributes[ id ] >= 0 ) {

					material.numSupportedMorphTargets ++;

				}

			}

		}

		if ( material.morphNormals ) {

			material.numSupportedMorphNormals = 0;

			var id, base = "morphNormal";

			for ( i = 0; i < this.maxMorphNormals; i ++ ) {

				id = base + i;

				if ( attributes[ id ] >= 0 ) {

					material.numSupportedMorphNormals ++;

				}

			}

		}

		material.uniformsList = [];

		for ( u in material.uniforms ) {

			material.uniformsList.push( [ material.uniforms[ u ], u ] );

		}

	};

	function setMaterialShaders( material, shaders ) {

		material.uniforms = THREE.UniformsUtils.clone( shaders.uniforms );
		material.vertexShader = shaders.vertexShader;
		material.fragmentShader = shaders.fragmentShader;

	};

	function setProgram( camera, lights, fog, material, object ) {

		_usedTextureUnits = 0;

		if ( material.needsUpdate ) {

			if ( material.program ) deallocateMaterial( material );

			_this.initMaterial( material, lights, fog, object );
			material.needsUpdate = false;

		}

		if ( material.morphTargets ) {

			if ( ! object.__webglMorphTargetInfluences ) {

				object.__webglMorphTargetInfluences = new Float32Array( _this.maxMorphTargets );

			}

		}

		var refreshMaterial = false;

		var program = material.program,
			p_uniforms = program.uniforms,
			m_uniforms = material.uniforms;

		if ( program !== _currentProgram ) {

			_gl.useProgram( program );
			_currentProgram = program;

			refreshMaterial = true;

		}

		if ( material.id !== _currentMaterialId ) {

			_currentMaterialId = material.id;
			refreshMaterial = true;

		}

		if ( refreshMaterial || camera !== _currentCamera ) {

			_gl.uniformMatrix4fv( p_uniforms.projectionMatrix, false, camera.projectionMatrix.elements );

			if ( camera !== _currentCamera ) _currentCamera = camera;

		}

		// skinning uniforms must be set even if material didn't change
		// auto-setting of texture unit for bone texture must go before other textures
		// not sure why, but otherwise weird things happen

		if ( material.skinning ) {

			if ( _supportsBoneTextures && object.useVertexTexture ) {

				if ( p_uniforms.boneTexture !== null ) {

					var textureUnit = getTextureUnit();

					_gl.uniform1i( p_uniforms.boneTexture, textureUnit );
					_this.setTexture( object.boneTexture, textureUnit );

				}

				if ( p_uniforms.boneTextureWidth !== null ) {

					_gl.uniform1i( p_uniforms.boneTextureWidth, object.boneTextureWidth );

				}

				if ( p_uniforms.boneTextureHeight !== null ) {

					_gl.uniform1i( p_uniforms.boneTextureHeight, object.boneTextureHeight );

				}

			} else {

				if ( p_uniforms.boneGlobalMatrices !== null ) {

					_gl.uniformMatrix4fv( p_uniforms.boneGlobalMatrices, false, object.boneMatrices );

				}

			}

		}

		if ( refreshMaterial ) {

			// refresh uniforms common to several materials

			if ( fog && material.fog ) {

				refreshUniformsFog( m_uniforms, fog );

			}

			if ( material instanceof THREE.MeshPhongMaterial ||
				 material instanceof THREE.MeshLambertMaterial ||
				 material.lights ) {

				if ( _lightsNeedUpdate ) {

					setupLights( program, lights );
					_lightsNeedUpdate = false;

				}

				refreshUniformsLights( m_uniforms, _lights );

			}

			if ( material instanceof THREE.MeshBasicMaterial ||
				 material instanceof THREE.MeshLambertMaterial ||
				 material instanceof THREE.MeshPhongMaterial ) {

				refreshUniformsCommon( m_uniforms, material );

			}

			// refresh single material specific uniforms

			if ( material instanceof THREE.LineBasicMaterial ) {

				refreshUniformsLine( m_uniforms, material );

			} else if ( material instanceof THREE.LineDashedMaterial ) {

				refreshUniformsLine( m_uniforms, material );
				refreshUniformsDash( m_uniforms, material );

			} else if ( material instanceof THREE.ParticleSystemMaterial ) {

				refreshUniformsParticle( m_uniforms, material );

			} else if ( material instanceof THREE.MeshPhongMaterial ) {

				refreshUniformsPhong( m_uniforms, material );

			} else if ( material instanceof THREE.MeshLambertMaterial ) {

				refreshUniformsLambert( m_uniforms, material );

			} else if ( material instanceof THREE.MeshDepthMaterial ) {

				m_uniforms.mNear.value = camera.near;
				m_uniforms.mFar.value = camera.far;
				m_uniforms.opacity.value = material.opacity;

			} else if ( material instanceof THREE.MeshNormalMaterial ) {

				m_uniforms.opacity.value = material.opacity;

			}

			if ( object.receiveShadow && ! material._shadowPass ) {

				refreshUniformsShadow( m_uniforms, lights );

			}

			// load common uniforms

			loadUniformsGeneric( program, material.uniformsList );

			// load material specific uniforms
			// (shader material also gets them for the sake of genericity)

			if ( material instanceof THREE.ShaderMaterial ||
				 material instanceof THREE.MeshPhongMaterial ||
				 material.envMap ) {

				if ( p_uniforms.cameraPosition !== null ) {

					_vector3.setFromMatrixPosition( camera.matrixWorld );
					_gl.uniform3f( p_uniforms.cameraPosition, _vector3.x, _vector3.y, _vector3.z );

				}

			}

			if ( material instanceof THREE.MeshPhongMaterial ||
				 material instanceof THREE.MeshLambertMaterial ||
				 material instanceof THREE.ShaderMaterial ||
				 material.skinning ) {

				if ( p_uniforms.viewMatrix !== null ) {

					_gl.uniformMatrix4fv( p_uniforms.viewMatrix, false, camera.matrixWorldInverse.elements );

				}

			}

		}

		loadUniformsMatrices( p_uniforms, object );

		if ( p_uniforms.modelMatrix !== null ) {

			_gl.uniformMatrix4fv( p_uniforms.modelMatrix, false, object.matrixWorld.elements );

		}

		return program;

	};

	// Uniforms (refresh uniforms objects)

	function refreshUniformsCommon ( uniforms, material ) {

		uniforms.opacity.value = material.opacity;

		if ( _this.gammaInput ) {

			uniforms.diffuse.value.copyGammaToLinear( material.color );

		} else {

			uniforms.diffuse.value = material.color;

		}

		uniforms.map.value = material.map;
		uniforms.lightMap.value = material.lightMap;
		uniforms.specularMap.value = material.specularMap;

		if ( material.bumpMap ) {

			uniforms.bumpMap.value = material.bumpMap;
			uniforms.bumpScale.value = material.bumpScale;

		}

		if ( material.normalMap ) {

			uniforms.normalMap.value = material.normalMap;
			uniforms.normalScale.value.copy( material.normalScale );

		}

		// uv repeat and offset setting priorities
		//	1. color map
		//	2. specular map
		//	3. normal map
		//	4. bump map

		var uvScaleMap;

		if ( material.map ) {

			uvScaleMap = material.map;

		} else if ( material.specularMap ) {

			uvScaleMap = material.specularMap;

		} else if ( material.normalMap ) {

			uvScaleMap = material.normalMap;

		} else if ( material.bumpMap ) {

			uvScaleMap = material.bumpMap;

		}

		if ( uvScaleMap !== undefined ) {

			var offset = uvScaleMap.offset;
			var repeat = uvScaleMap.repeat;

			uniforms.offsetRepeat.value.set( offset.x, offset.y, repeat.x, repeat.y );

		}

		uniforms.envMap.value = material.envMap;
		uniforms.flipEnvMap.value = ( material.envMap instanceof THREE.WebGLRenderTargetCube ) ? 1 : -1;

		if ( _this.gammaInput ) {

			//uniforms.reflectivity.value = material.reflectivity * material.reflectivity;
			uniforms.reflectivity.value = material.reflectivity;

		} else {

			uniforms.reflectivity.value = material.reflectivity;

		}

		uniforms.refractionRatio.value = material.refractionRatio;
		uniforms.combine.value = material.combine;
		uniforms.useRefract.value = material.envMap && material.envMap.mapping instanceof THREE.CubeRefractionMapping;

	};

	function refreshUniformsLine ( uniforms, material ) {

		uniforms.diffuse.value = material.color;
		uniforms.opacity.value = material.opacity;

	};

	function refreshUniformsDash ( uniforms, material ) {

		uniforms.dashSize.value = material.dashSize;
		uniforms.totalSize.value = material.dashSize + material.gapSize;
		uniforms.scale.value = material.scale;

	};

	function refreshUniformsParticle ( uniforms, material ) {

		uniforms.psColor.value = material.color;
		uniforms.opacity.value = material.opacity;
		uniforms.size.value = material.size;
		uniforms.scale.value = _canvas.height / 2.0; // TODO: Cache this.

		uniforms.map.value = material.map;

	};

	function refreshUniformsFog ( uniforms, fog ) {

		uniforms.fogColor.value = fog.color;

		if ( fog instanceof THREE.Fog ) {

			uniforms.fogNear.value = fog.near;
			uniforms.fogFar.value = fog.far;

		} else if ( fog instanceof THREE.FogExp2 ) {

			uniforms.fogDensity.value = fog.density;

		}

	};

	function refreshUniformsPhong ( uniforms, material ) {

		uniforms.shininess.value = material.shininess;

		if ( _this.gammaInput ) {

			uniforms.ambient.value.copyGammaToLinear( material.ambient );
			uniforms.emissive.value.copyGammaToLinear( material.emissive );
			uniforms.specular.value.copyGammaToLinear( material.specular );

		} else {

			uniforms.ambient.value = material.ambient;
			uniforms.emissive.value = material.emissive;
			uniforms.specular.value = material.specular;

		}

		if ( material.wrapAround ) {

			uniforms.wrapRGB.value.copy( material.wrapRGB );

		}

	};

	function refreshUniformsLambert ( uniforms, material ) {

		if ( _this.gammaInput ) {

			uniforms.ambient.value.copyGammaToLinear( material.ambient );
			uniforms.emissive.value.copyGammaToLinear( material.emissive );

		} else {

			uniforms.ambient.value = material.ambient;
			uniforms.emissive.value = material.emissive;

		}

		if ( material.wrapAround ) {

			uniforms.wrapRGB.value.copy( material.wrapRGB );

		}

	};

	function refreshUniformsLights ( uniforms, lights ) {

		uniforms.ambientLightColor.value = lights.ambient;

		uniforms.directionalLightColor.value = lights.directional.colors;
		uniforms.directionalLightDirection.value = lights.directional.positions;

		uniforms.pointLightColor.value = lights.point.colors;
		uniforms.pointLightPosition.value = lights.point.positions;
		uniforms.pointLightDistance.value = lights.point.distances;

		uniforms.spotLightColor.value = lights.spot.colors;
		uniforms.spotLightPosition.value = lights.spot.positions;
		uniforms.spotLightDistance.value = lights.spot.distances;
		uniforms.spotLightDirection.value = lights.spot.directions;
		uniforms.spotLightAngleCos.value = lights.spot.anglesCos;
		uniforms.spotLightExponent.value = lights.spot.exponents;

		uniforms.hemisphereLightSkyColor.value = lights.hemi.skyColors;
		uniforms.hemisphereLightGroundColor.value = lights.hemi.groundColors;
		uniforms.hemisphereLightDirection.value = lights.hemi.positions;

	};

	function refreshUniformsShadow ( uniforms, lights ) {

		if ( uniforms.shadowMatrix ) {

			var j = 0;

			for ( var i = 0, il = lights.length; i < il; i ++ ) {

				var light = lights[ i ];

				if ( ! light.castShadow ) continue;

				if ( light instanceof THREE.SpotLight || ( light instanceof THREE.DirectionalLight && ! light.shadowCascade ) ) {

					uniforms.shadowMap.value[ j ] = light.shadowMap;
					uniforms.shadowMapSize.value[ j ] = light.shadowMapSize;

					uniforms.shadowMatrix.value[ j ] = light.shadowMatrix;

					uniforms.shadowDarkness.value[ j ] = light.shadowDarkness;
					uniforms.shadowBias.value[ j ] = light.shadowBias;

					j ++;

				}

			}

		}

	};

	// Uniforms (load to GPU)

	function loadUniformsMatrices ( uniforms, object ) {

		_gl.uniformMatrix4fv( uniforms.modelViewMatrix, false, object._modelViewMatrix.elements );

		if ( uniforms.normalMatrix ) {

			_gl.uniformMatrix3fv( uniforms.normalMatrix, false, object._normalMatrix.elements );

		}

	};

	function getTextureUnit() {

		var textureUnit = _usedTextureUnits;

		if ( textureUnit >= _maxTextures ) {

			console.warn( "WebGLRenderer: trying to use " + textureUnit + " texture units while this GPU supports only " + _maxTextures );

		}

		_usedTextureUnits += 1;

		return textureUnit;

	};

	function loadUniformsGeneric ( program, uniforms ) {

		var uniform, value, type, location, texture, textureUnit, i, il, j, jl, offset;

		for ( j = 0, jl = uniforms.length; j < jl; j ++ ) {

			location = program.uniforms[ uniforms[ j ][ 1 ] ];
			if ( !location ) continue;

			uniform = uniforms[ j ][ 0 ];

			type = uniform.type;
			value = uniform.value;

			if ( type === "i" ) { // single integer

				_gl.uniform1i( location, value );

			} else if ( type === "f" ) { // single float

				_gl.uniform1f( location, value );

			} else if ( type === "v2" ) { // single THREE.Vector2

				_gl.uniform2f( location, value.x, value.y );

			} else if ( type === "v3" ) { // single THREE.Vector3

				_gl.uniform3f( location, value.x, value.y, value.z );

			} else if ( type === "v4" ) { // single THREE.Vector4

				_gl.uniform4f( location, value.x, value.y, value.z, value.w );

			} else if ( type === "c" ) { // single THREE.Color

				_gl.uniform3f( location, value.r, value.g, value.b );

			} else if ( type === "iv1" ) { // flat array of integers (JS or typed array)

				_gl.uniform1iv( location, value );

			} else if ( type === "iv" ) { // flat array of integers with 3 x N size (JS or typed array)

				_gl.uniform3iv( location, value );

			} else if ( type === "fv1" ) { // flat array of floats (JS or typed array)

				_gl.uniform1fv( location, value );

			} else if ( type === "fv" ) { // flat array of floats with 3 x N size (JS or typed array)

				_gl.uniform3fv( location, value );

			} else if ( type === "v2v" ) { // array of THREE.Vector2

				if ( uniform._array === undefined ) {

					uniform._array = new Float32Array( 2 * value.length );

				}

				for ( i = 0, il = value.length; i < il; i ++ ) {

					offset = i * 2;

					uniform._array[ offset ] 	 = value[ i ].x;
					uniform._array[ offset + 1 ] = value[ i ].y;

				}

				_gl.uniform2fv( location, uniform._array );

			} else if ( type === "v3v" ) { // array of THREE.Vector3

				if ( uniform._array === undefined ) {

					uniform._array = new Float32Array( 3 * value.length );

				}

				for ( i = 0, il = value.length; i < il; i ++ ) {

					offset = i * 3;

					uniform._array[ offset ] 	 = value[ i ].x;
					uniform._array[ offset + 1 ] = value[ i ].y;
					uniform._array[ offset + 2 ] = value[ i ].z;

				}

				_gl.uniform3fv( location, uniform._array );

			} else if ( type === "v4v" ) { // array of THREE.Vector4

				if ( uniform._array === undefined ) {

					uniform._array = new Float32Array( 4 * value.length );

				}

				for ( i = 0, il = value.length; i < il; i ++ ) {

					offset = i * 4;

					uniform._array[ offset ] 	 = value[ i ].x;
					uniform._array[ offset + 1 ] = value[ i ].y;
					uniform._array[ offset + 2 ] = value[ i ].z;
					uniform._array[ offset + 3 ] = value[ i ].w;

				}

				_gl.uniform4fv( location, uniform._array );

			} else if ( type === "m4") { // single THREE.Matrix4

				if ( uniform._array === undefined ) {

					uniform._array = new Float32Array( 16 );

				}

				value.flattenToArray( uniform._array );
				_gl.uniformMatrix4fv( location, false, uniform._array );

			} else if ( type === "m4v" ) { // array of THREE.Matrix4

				if ( uniform._array === undefined ) {

					uniform._array = new Float32Array( 16 * value.length );

				}

				for ( i = 0, il = value.length; i < il; i ++ ) {

					value[ i ].flattenToArrayOffset( uniform._array, i * 16 );

				}

				_gl.uniformMatrix4fv( location, false, uniform._array );

			} else if ( type === "t" ) { // single THREE.Texture (2d or cube)

				texture = value;
				textureUnit = getTextureUnit();

				_gl.uniform1i( location, textureUnit );

				if ( !texture ) continue;

				if ( texture.image instanceof Array && texture.image.length === 6 ) {

					setCubeTexture( texture, textureUnit );

				} else if ( texture instanceof THREE.WebGLRenderTargetCube ) {

					setCubeTextureDynamic( texture, textureUnit );

				} else {

					_this.setTexture( texture, textureUnit );

				}

			} else if ( type === "tv" ) { // array of THREE.Texture (2d)

				if ( uniform._array === undefined ) {

					uniform._array = [];

				}

				for( i = 0, il = uniform.value.length; i < il; i ++ ) {

					uniform._array[ i ] = getTextureUnit();

				}

				_gl.uniform1iv( location, uniform._array );

				for( i = 0, il = uniform.value.length; i < il; i ++ ) {

					texture = uniform.value[ i ];
					textureUnit = uniform._array[ i ];

					if ( !texture ) continue;

					_this.setTexture( texture, textureUnit );

				}

			} else {

				console.warn( 'THREE.WebGLRenderer: Unknown uniform type: ' + type );

			}

		}

	};

	function setupMatrices ( object, camera ) {

		object._modelViewMatrix.multiplyMatrices( camera.matrixWorldInverse, object.matrixWorld );
		object._normalMatrix.getNormalMatrix( object._modelViewMatrix );

	};

	//

	function setColorGamma( array, offset, color, intensitySq ) {

		array[ offset ]     = color.r * color.r * intensitySq;
		array[ offset + 1 ] = color.g * color.g * intensitySq;
		array[ offset + 2 ] = color.b * color.b * intensitySq;

	};

	function setColorLinear( array, offset, color, intensity ) {

		array[ offset ]     = color.r * intensity;
		array[ offset + 1 ] = color.g * intensity;
		array[ offset + 2 ] = color.b * intensity;

	};

	function setupLights ( program, lights ) {

		var l, ll, light, n,
		r = 0, g = 0, b = 0,
		color, skyColor, groundColor,
		intensity,  intensitySq,
		position,
		distance,

		zlights = _lights,

		dirColors = zlights.directional.colors,
		dirPositions = zlights.directional.positions,

		pointColors = zlights.point.colors,
		pointPositions = zlights.point.positions,
		pointDistances = zlights.point.distances,

		spotColors = zlights.spot.colors,
		spotPositions = zlights.spot.positions,
		spotDistances = zlights.spot.distances,
		spotDirections = zlights.spot.directions,
		spotAnglesCos = zlights.spot.anglesCos,
		spotExponents = zlights.spot.exponents,

		hemiSkyColors = zlights.hemi.skyColors,
		hemiGroundColors = zlights.hemi.groundColors,
		hemiPositions = zlights.hemi.positions,

		dirLength = 0,
		pointLength = 0,
		spotLength = 0,
		hemiLength = 0,

		dirCount = 0,
		pointCount = 0,
		spotCount = 0,
		hemiCount = 0,

		dirOffset = 0,
		pointOffset = 0,
		spotOffset = 0,
		hemiOffset = 0;

		for ( l = 0, ll = lights.length; l < ll; l ++ ) {

			light = lights[ l ];

			if ( light.onlyShadow ) continue;

			color = light.color;
			intensity = light.intensity;
			distance = light.distance;

			if ( light instanceof THREE.AmbientLight ) {

				if ( ! light.visible ) continue;

				if ( _this.gammaInput ) {

					r += color.r * color.r;
					g += color.g * color.g;
					b += color.b * color.b;

				} else {

					r += color.r;
					g += color.g;
					b += color.b;

				}

			} else if ( light instanceof THREE.DirectionalLight ) {

				dirCount += 1;

				if ( ! light.visible ) continue;

				_direction.setFromMatrixPosition( light.matrixWorld );
				_vector3.setFromMatrixPosition( light.target.matrixWorld );
				_direction.sub( _vector3 );
				_direction.normalize();

				// skip lights with undefined direction
				// these create troubles in OpenGL (making pixel black)

				if ( _direction.x === 0 && _direction.y === 0 && _direction.z === 0 ) continue;

				dirOffset = dirLength * 3;

				dirPositions[ dirOffset ]     = _direction.x;
				dirPositions[ dirOffset + 1 ] = _direction.y;
				dirPositions[ dirOffset + 2 ] = _direction.z;

				if ( _this.gammaInput ) {

					setColorGamma( dirColors, dirOffset, color, intensity * intensity );

				} else {

					setColorLinear( dirColors, dirOffset, color, intensity );

				}

				dirLength += 1;

			} else if ( light instanceof THREE.PointLight ) {

				pointCount += 1;

				if ( ! light.visible ) continue;

				pointOffset = pointLength * 3;

				if ( _this.gammaInput ) {

					setColorGamma( pointColors, pointOffset, color, intensity * intensity );

				} else {

					setColorLinear( pointColors, pointOffset, color, intensity );

				}

				_vector3.setFromMatrixPosition( light.matrixWorld );

				pointPositions[ pointOffset ]     = _vector3.x;
				pointPositions[ pointOffset + 1 ] = _vector3.y;
				pointPositions[ pointOffset + 2 ] = _vector3.z;

				pointDistances[ pointLength ] = distance;

				pointLength += 1;

			} else if ( light instanceof THREE.SpotLight ) {

				spotCount += 1;

				if ( ! light.visible ) continue;

				spotOffset = spotLength * 3;

				if ( _this.gammaInput ) {

					setColorGamma( spotColors, spotOffset, color, intensity * intensity );

				} else {

					setColorLinear( spotColors, spotOffset, color, intensity );

				}

				_vector3.setFromMatrixPosition( light.matrixWorld );

				spotPositions[ spotOffset ]     = _vector3.x;
				spotPositions[ spotOffset + 1 ] = _vector3.y;
				spotPositions[ spotOffset + 2 ] = _vector3.z;

				spotDistances[ spotLength ] = distance;

				_direction.copy( _vector3 );
				_vector3.setFromMatrixPosition( light.target.matrixWorld );
				_direction.sub( _vector3 );
				_direction.normalize();

				spotDirections[ spotOffset ]     = _direction.x;
				spotDirections[ spotOffset + 1 ] = _direction.y;
				spotDirections[ spotOffset + 2 ] = _direction.z;

				spotAnglesCos[ spotLength ] = Math.cos( light.angle );
				spotExponents[ spotLength ] = light.exponent;

				spotLength += 1;

			} else if ( light instanceof THREE.HemisphereLight ) {

				hemiCount += 1;

				if ( ! light.visible ) continue;

				_direction.setFromMatrixPosition( light.matrixWorld );
				_direction.normalize();

				// skip lights with undefined direction
				// these create troubles in OpenGL (making pixel black)

				if ( _direction.x === 0 && _direction.y === 0 && _direction.z === 0 ) continue;

				hemiOffset = hemiLength * 3;

				hemiPositions[ hemiOffset ]     = _direction.x;
				hemiPositions[ hemiOffset + 1 ] = _direction.y;
				hemiPositions[ hemiOffset + 2 ] = _direction.z;

				skyColor = light.color;
				groundColor = light.groundColor;

				if ( _this.gammaInput ) {

					intensitySq = intensity * intensity;

					setColorGamma( hemiSkyColors, hemiOffset, skyColor, intensitySq );
					setColorGamma( hemiGroundColors, hemiOffset, groundColor, intensitySq );

				} else {

					setColorLinear( hemiSkyColors, hemiOffset, skyColor, intensity );
					setColorLinear( hemiGroundColors, hemiOffset, groundColor, intensity );

				}

				hemiLength += 1;

			}

		}

		// null eventual remains from removed lights
		// (this is to avoid if in shader)

		for ( l = dirLength * 3, ll = Math.max( dirColors.length, dirCount * 3 ); l < ll; l ++ ) dirColors[ l ] = 0.0;
		for ( l = pointLength * 3, ll = Math.max( pointColors.length, pointCount * 3 ); l < ll; l ++ ) pointColors[ l ] = 0.0;
		for ( l = spotLength * 3, ll = Math.max( spotColors.length, spotCount * 3 ); l < ll; l ++ ) spotColors[ l ] = 0.0;
		for ( l = hemiLength * 3, ll = Math.max( hemiSkyColors.length, hemiCount * 3 ); l < ll; l ++ ) hemiSkyColors[ l ] = 0.0;
		for ( l = hemiLength * 3, ll = Math.max( hemiGroundColors.length, hemiCount * 3 ); l < ll; l ++ ) hemiGroundColors[ l ] = 0.0;

		zlights.directional.length = dirLength;
		zlights.point.length = pointLength;
		zlights.spot.length = spotLength;
		zlights.hemi.length = hemiLength;

		zlights.ambient[ 0 ] = r;
		zlights.ambient[ 1 ] = g;
		zlights.ambient[ 2 ] = b;

	};

	// GL state setting

	this.setFaceCulling = function ( cullFace, frontFaceDirection ) {

		if ( cullFace === THREE.CullFaceNone ) {

			_gl.disable( _gl.CULL_FACE );

		} else {

			if ( frontFaceDirection === THREE.FrontFaceDirectionCW ) {

				_gl.frontFace( _gl.CW );

			} else {

				_gl.frontFace( _gl.CCW );

			}

			if ( cullFace === THREE.CullFaceBack ) {

				_gl.cullFace( _gl.BACK );

			} else if ( cullFace === THREE.CullFaceFront ) {

				_gl.cullFace( _gl.FRONT );

			} else {

				_gl.cullFace( _gl.FRONT_AND_BACK );

			}

			_gl.enable( _gl.CULL_FACE );

		}

	};

	this.setMaterialFaces = function ( material ) {

		var doubleSided = material.side === THREE.DoubleSide;
		var flipSided = material.side === THREE.BackSide;

		if ( _oldDoubleSided !== doubleSided ) {

			if ( doubleSided ) {

				_gl.disable( _gl.CULL_FACE );

			} else {

				_gl.enable( _gl.CULL_FACE );

			}

			_oldDoubleSided = doubleSided;

		}

		if ( _oldFlipSided !== flipSided ) {

			if ( flipSided ) {

				_gl.frontFace( _gl.CW );

			} else {

				_gl.frontFace( _gl.CCW );

			}

			_oldFlipSided = flipSided;

		}

	};

	this.setDepthTest = function ( depthTest ) {

		if ( _oldDepthTest !== depthTest ) {

			if ( depthTest ) {

				_gl.enable( _gl.DEPTH_TEST );

			} else {

				_gl.disable( _gl.DEPTH_TEST );

			}

			_oldDepthTest = depthTest;

		}

	};

	this.setDepthWrite = function ( depthWrite ) {

		if ( _oldDepthWrite !== depthWrite ) {

			_gl.depthMask( depthWrite );
			_oldDepthWrite = depthWrite;

		}

	};

	function setLineWidth ( width ) {

		if ( width !== _oldLineWidth ) {

			_gl.lineWidth( width );

			_oldLineWidth = width;

		}

	};

	function setPolygonOffset ( polygonoffset, factor, units ) {

		if ( _oldPolygonOffset !== polygonoffset ) {

			if ( polygonoffset ) {

				_gl.enable( _gl.POLYGON_OFFSET_FILL );

			} else {

				_gl.disable( _gl.POLYGON_OFFSET_FILL );

			}

			_oldPolygonOffset = polygonoffset;

		}

		if ( polygonoffset && ( _oldPolygonOffsetFactor !== factor || _oldPolygonOffsetUnits !== units ) ) {

			_gl.polygonOffset( factor, units );

			_oldPolygonOffsetFactor = factor;
			_oldPolygonOffsetUnits = units;

		}

	};

	this.setBlending = function ( blending, blendEquation, blendSrc, blendDst ) {

		if ( blending !== _oldBlending ) {

			if ( blending === THREE.NoBlending ) {

				_gl.disable( _gl.BLEND );

			} else if ( blending === THREE.AdditiveBlending ) {

				_gl.enable( _gl.BLEND );
				_gl.blendEquation( _gl.FUNC_ADD );
				_gl.blendFunc( _gl.SRC_ALPHA, _gl.ONE );

			} else if ( blending === THREE.SubtractiveBlending ) {

				// TODO: Find blendFuncSeparate() combination
				_gl.enable( _gl.BLEND );
				_gl.blendEquation( _gl.FUNC_ADD );
				_gl.blendFunc( _gl.ZERO, _gl.ONE_MINUS_SRC_COLOR );

			} else if ( blending === THREE.MultiplyBlending ) {

				// TODO: Find blendFuncSeparate() combination
				_gl.enable( _gl.BLEND );
				_gl.blendEquation( _gl.FUNC_ADD );
				_gl.blendFunc( _gl.ZERO, _gl.SRC_COLOR );

			} else if ( blending === THREE.CustomBlending ) {

				_gl.enable( _gl.BLEND );

			} else {

				_gl.enable( _gl.BLEND );
				_gl.blendEquationSeparate( _gl.FUNC_ADD, _gl.FUNC_ADD );
				_gl.blendFuncSeparate( _gl.SRC_ALPHA, _gl.ONE_MINUS_SRC_ALPHA, _gl.ONE, _gl.ONE_MINUS_SRC_ALPHA );

			}

			_oldBlending = blending;

		}

		if ( blending === THREE.CustomBlending ) {

			if ( blendEquation !== _oldBlendEquation ) {

				_gl.blendEquation( paramThreeToGL( blendEquation ) );

				_oldBlendEquation = blendEquation;

			}

			if ( blendSrc !== _oldBlendSrc || blendDst !== _oldBlendDst ) {

				_gl.blendFunc( paramThreeToGL( blendSrc ), paramThreeToGL( blendDst ) );

				_oldBlendSrc = blendSrc;
				_oldBlendDst = blendDst;

			}

		} else {

			_oldBlendEquation = null;
			_oldBlendSrc = null;
			_oldBlendDst = null;

		}

	};

	// Defines

	function generateDefines ( defines ) {

		var value, chunk, chunks = [];

		for ( var d in defines ) {

			value = defines[ d ];
			if ( value === false ) continue;

			chunk = "#define " + d + " " + value;
			chunks.push( chunk );

		}

		return chunks.join( "\n" );

	};

	// Shaders

	function buildProgram ( shaderID, fragmentShader, vertexShader, uniforms, attributes, defines, parameters, index0AttributeName ) {

		var p, pl, d, program, code;
		var chunks = [];

		// Generate code

		if ( shaderID ) {

			chunks.push( shaderID );

		} else {

			chunks.push( fragmentShader );
			chunks.push( vertexShader );

		}

		for ( d in defines ) {

			chunks.push( d );
			chunks.push( defines[ d ] );

		}

		for ( p in parameters ) {

			chunks.push( p );
			chunks.push( parameters[ p ] );

		}

		code = chunks.join();

		// Check if code has been already compiled

		for ( p = 0, pl = _programs.length; p < pl; p ++ ) {

			var programInfo = _programs[ p ];

			if ( programInfo.code === code ) {

				// console.log( "Code already compiled." /*: \n\n" + code*/ );

				programInfo.usedTimes ++;

				return programInfo.program;

			}

		}

		var shadowMapTypeDefine = "SHADOWMAP_TYPE_BASIC";

		if ( parameters.shadowMapType === THREE.PCFShadowMap ) {

			shadowMapTypeDefine = "SHADOWMAP_TYPE_PCF";

		} else if ( parameters.shadowMapType === THREE.PCFSoftShadowMap ) {

			shadowMapTypeDefine = "SHADOWMAP_TYPE_PCF_SOFT";

		}

		// console.log( "building new program " );

		//

		var customDefines = generateDefines( defines );

		//

		program = _gl.createProgram();

		var prefix_vertex = [

			"precision " + _precision + " float;",
			"precision " + _precision + " int;",

			customDefines,

			_supportsVertexTextures ? "#define VERTEX_TEXTURES" : "",

			_this.gammaInput ? "#define GAMMA_INPUT" : "",
			_this.gammaOutput ? "#define GAMMA_OUTPUT" : "",

			"#define MAX_DIR_LIGHTS " + parameters.maxDirLights,
			"#define MAX_POINT_LIGHTS " + parameters.maxPointLights,
			"#define MAX_SPOT_LIGHTS " + parameters.maxSpotLights,
			"#define MAX_HEMI_LIGHTS " + parameters.maxHemiLights,

			"#define MAX_SHADOWS " + parameters.maxShadows,

			"#define MAX_BONES " + parameters.maxBones,

			parameters.map ? "#define USE_MAP" : "",
			parameters.envMap ? "#define USE_ENVMAP" : "",
			parameters.lightMap ? "#define USE_LIGHTMAP" : "",
			parameters.bumpMap ? "#define USE_BUMPMAP" : "",
			parameters.normalMap ? "#define USE_NORMALMAP" : "",
			parameters.specularMap ? "#define USE_SPECULARMAP" : "",
			parameters.vertexColors ? "#define USE_COLOR" : "",

			parameters.skinning ? "#define USE_SKINNING" : "",
			parameters.useVertexTexture ? "#define BONE_TEXTURE" : "",

			parameters.morphTargets ? "#define USE_MORPHTARGETS" : "",
			parameters.morphNormals ? "#define USE_MORPHNORMALS" : "",
			parameters.perPixel ? "#define PHONG_PER_PIXEL" : "",
			parameters.wrapAround ? "#define WRAP_AROUND" : "",
			parameters.doubleSided ? "#define DOUBLE_SIDED" : "",
			parameters.flipSided ? "#define FLIP_SIDED" : "",

			parameters.shadowMapEnabled ? "#define USE_SHADOWMAP" : "",
			parameters.shadowMapEnabled ? "#define " + shadowMapTypeDefine : "",
			parameters.shadowMapDebug ? "#define SHADOWMAP_DEBUG" : "",
			parameters.shadowMapCascade ? "#define SHADOWMAP_CASCADE" : "",

			parameters.sizeAttenuation ? "#define USE_SIZEATTENUATION" : "",

			"uniform mat4 modelMatrix;",
			"uniform mat4 modelViewMatrix;",
			"uniform mat4 projectionMatrix;",
			"uniform mat4 viewMatrix;",
			"uniform mat3 normalMatrix;",
			"uniform vec3 cameraPosition;",

			"attribute vec3 position;",
			"attribute vec3 normal;",
			"attribute vec2 uv;",
			"attribute vec2 uv2;",

			"#ifdef USE_COLOR",

				"attribute vec3 color;",

			"#endif",

			"#ifdef USE_MORPHTARGETS",

				"attribute vec3 morphTarget0;",
				"attribute vec3 morphTarget1;",
				"attribute vec3 morphTarget2;",
				"attribute vec3 morphTarget3;",

				"#ifdef USE_MORPHNORMALS",

					"attribute vec3 morphNormal0;",
					"attribute vec3 morphNormal1;",
					"attribute vec3 morphNormal2;",
					"attribute vec3 morphNormal3;",

				"#else",

					"attribute vec3 morphTarget4;",
					"attribute vec3 morphTarget5;",
					"attribute vec3 morphTarget6;",
					"attribute vec3 morphTarget7;",

				"#endif",

			"#endif",

			"#ifdef USE_SKINNING",

				"attribute vec4 skinIndex;",
				"attribute vec4 skinWeight;",

			"#endif",

			""

		].join("\n");

		var prefix_fragment = [

			"precision " + _precision + " float;",
			"precision " + _precision + " int;",

			( parameters.bumpMap || parameters.normalMap ) ? "#extension GL_OES_standard_derivatives : enable" : "",

			customDefines,

			"#define MAX_DIR_LIGHTS " + parameters.maxDirLights,
			"#define MAX_POINT_LIGHTS " + parameters.maxPointLights,
			"#define MAX_SPOT_LIGHTS " + parameters.maxSpotLights,
			"#define MAX_HEMI_LIGHTS " + parameters.maxHemiLights,

			"#define MAX_SHADOWS " + parameters.maxShadows,

			parameters.alphaTest ? "#define ALPHATEST " + parameters.alphaTest: "",

			_this.gammaInput ? "#define GAMMA_INPUT" : "",
			_this.gammaOutput ? "#define GAMMA_OUTPUT" : "",

			( parameters.useFog && parameters.fog ) ? "#define USE_FOG" : "",
			( parameters.useFog && parameters.fogExp ) ? "#define FOG_EXP2" : "",

			parameters.map ? "#define USE_MAP" : "",
			parameters.envMap ? "#define USE_ENVMAP" : "",
			parameters.lightMap ? "#define USE_LIGHTMAP" : "",
			parameters.bumpMap ? "#define USE_BUMPMAP" : "",
			parameters.normalMap ? "#define USE_NORMALMAP" : "",
			parameters.specularMap ? "#define USE_SPECULARMAP" : "",
			parameters.vertexColors ? "#define USE_COLOR" : "",

			parameters.metal ? "#define METAL" : "",
			parameters.perPixel ? "#define PHONG_PER_PIXEL" : "",
			parameters.wrapAround ? "#define WRAP_AROUND" : "",
			parameters.doubleSided ? "#define DOUBLE_SIDED" : "",
			parameters.flipSided ? "#define FLIP_SIDED" : "",

			parameters.shadowMapEnabled ? "#define USE_SHADOWMAP" : "",
			parameters.shadowMapEnabled ? "#define " + shadowMapTypeDefine : "",
			parameters.shadowMapDebug ? "#define SHADOWMAP_DEBUG" : "",
			parameters.shadowMapCascade ? "#define SHADOWMAP_CASCADE" : "",

			"uniform mat4 viewMatrix;",
			"uniform vec3 cameraPosition;",
			""

		].join("\n");

		var glVertexShader = getShader( "vertex", prefix_vertex + vertexShader );
		var glFragmentShader = getShader( "fragment", prefix_fragment + fragmentShader );

		_gl.attachShader( program, glVertexShader );
		_gl.attachShader( program, glFragmentShader );

		//Force a particular attribute to index 0.
		// because potentially expensive emulation is done by browser if attribute 0 is disabled.
		//And, color, for example is often automatically bound to index 0 so disabling it
		if ( index0AttributeName ) {
			_gl.bindAttribLocation( program, 0, index0AttributeName );
		}

		_gl.linkProgram( program );

		if ( !_gl.getProgramParameter( program, _gl.LINK_STATUS ) ) {

			console.error( "Could not initialise shader\n" + "VALIDATE_STATUS: " + _gl.getProgramParameter( program, _gl.VALIDATE_STATUS ) + ", gl error [" + _gl.getError() + "]" );
			console.error( "Program Info Log: " + _gl.getProgramInfoLog( program ) );
		}

		// clean up

		_gl.deleteShader( glFragmentShader );
		_gl.deleteShader( glVertexShader );

		// console.log( prefix_fragment + fragmentShader );
		// console.log( prefix_vertex + vertexShader );

		program.uniforms = {};
		program.attributes = {};

		var identifiers, u, a, i;

		// cache uniform locations

		identifiers = [

			'viewMatrix', 'modelViewMatrix', 'projectionMatrix', 'normalMatrix', 'modelMatrix', 'cameraPosition',
			'morphTargetInfluences'

		];

		if ( parameters.useVertexTexture ) {

			identifiers.push( 'boneTexture' );
			identifiers.push( 'boneTextureWidth' );
			identifiers.push( 'boneTextureHeight' );

		} else {

			identifiers.push( 'boneGlobalMatrices' );

		}

		for ( u in uniforms ) {

			identifiers.push( u );

		}

		cacheUniformLocations( program, identifiers );

		// cache attributes locations

		identifiers = [

			"position", "normal", "uv", "uv2", "tangent", "color",
			"skinIndex", "skinWeight", "lineDistance"

		];

		for ( i = 0; i < parameters.maxMorphTargets; i ++ ) {

			identifiers.push( "morphTarget" + i );

		}

		for ( i = 0; i < parameters.maxMorphNormals; i ++ ) {

			identifiers.push( "morphNormal" + i );

		}

		for ( a in attributes ) {

			identifiers.push( a );

		}

		cacheAttributeLocations( program, identifiers );

		program.id = _programs_counter ++;

		_programs.push( { program: program, code: code, usedTimes: 1 } );

		_this.info.memory.programs = _programs.length;

		return program;

	};

	// Shader parameters cache

	function cacheUniformLocations ( program, identifiers ) {

		var i, l, id;

		for( i = 0, l = identifiers.length; i < l; i ++ ) {

			id = identifiers[ i ];
			program.uniforms[ id ] = _gl.getUniformLocation( program, id );

		}

	};

	function cacheAttributeLocations ( program, identifiers ) {

		var i, l, id;

		for( i = 0, l = identifiers.length; i < l; i ++ ) {

			id = identifiers[ i ];
			program.attributes[ id ] = _gl.getAttribLocation( program, id );

		}

	};

	function addLineNumbers ( string ) {

		var chunks = string.split( "\n" );

		for ( var i = 0, il = chunks.length; i < il; i ++ ) {

			// Chrome reports shader errors on lines
			// starting counting from 1

			chunks[ i ] = ( i + 1 ) + ": " + chunks[ i ];

		}

		return chunks.join( "\n" );

	};

	function getShader ( type, string ) {

		var shader;

		if ( type === "fragment" ) {

			shader = _gl.createShader( _gl.FRAGMENT_SHADER );

		} else if ( type === "vertex" ) {

			shader = _gl.createShader( _gl.VERTEX_SHADER );

		}

		_gl.shaderSource( shader, string );
		_gl.compileShader( shader );

		if ( !_gl.getShaderParameter( shader, _gl.COMPILE_STATUS ) ) {

			console.error( _gl.getShaderInfoLog( shader ) );
			console.error( addLineNumbers( string ) );
			return null;

		}

		return shader;

	};

	// Textures


	function isPowerOfTwo ( value ) {

		return ( value & ( value - 1 ) ) === 0;

	};

	function setTextureParameters ( textureType, texture, isImagePowerOfTwo ) {

		if ( isImagePowerOfTwo ) {

			_gl.texParameteri( textureType, _gl.TEXTURE_WRAP_S, paramThreeToGL( texture.wrapS ) );
			_gl.texParameteri( textureType, _gl.TEXTURE_WRAP_T, paramThreeToGL( texture.wrapT ) );

			_gl.texParameteri( textureType, _gl.TEXTURE_MAG_FILTER, paramThreeToGL( texture.magFilter ) );
			_gl.texParameteri( textureType, _gl.TEXTURE_MIN_FILTER, paramThreeToGL( texture.minFilter ) );

		} else {

			_gl.texParameteri( textureType, _gl.TEXTURE_WRAP_S, _gl.CLAMP_TO_EDGE );
			_gl.texParameteri( textureType, _gl.TEXTURE_WRAP_T, _gl.CLAMP_TO_EDGE );

			_gl.texParameteri( textureType, _gl.TEXTURE_MAG_FILTER, filterFallback( texture.magFilter ) );
			_gl.texParameteri( textureType, _gl.TEXTURE_MIN_FILTER, filterFallback( texture.minFilter ) );

		}

		if ( _glExtensionTextureFilterAnisotropic && texture.type !== THREE.FloatType ) {

			if ( texture.anisotropy > 1 || texture.__oldAnisotropy ) {

				_gl.texParameterf( textureType, _glExtensionTextureFilterAnisotropic.TEXTURE_MAX_ANISOTROPY_EXT, Math.min( texture.anisotropy, _maxAnisotropy ) );
				texture.__oldAnisotropy = texture.anisotropy;

			}

		}

	};

	this.setTexture = function ( texture, slot ) {

		if ( texture.needsUpdate ) {

			if ( ! texture.__webglInit ) {

				texture.__webglInit = true;

				texture.addEventListener( 'dispose', onTextureDispose );

				texture.__webglTexture = _gl.createTexture();

				_this.info.memory.textures ++;

			}

			_gl.activeTexture( _gl.TEXTURE0 + slot );
			_gl.bindTexture( _gl.TEXTURE_2D, texture.__webglTexture );

			_gl.pixelStorei( _gl.UNPACK_FLIP_Y_WEBGL, texture.flipY );
			_gl.pixelStorei( _gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, texture.premultiplyAlpha );
			_gl.pixelStorei( _gl.UNPACK_ALIGNMENT, texture.unpackAlignment );

			var image = texture.image,
			isImagePowerOfTwo = isPowerOfTwo( image.width ) && isPowerOfTwo( image.height ),
			glFormat = paramThreeToGL( texture.format ),
			glType = paramThreeToGL( texture.type );

			setTextureParameters( _gl.TEXTURE_2D, texture, isImagePowerOfTwo );

			var mipmap, mipmaps = texture.mipmaps;

			if ( texture instanceof THREE.DataTexture ) {

				// use manually created mipmaps if available
				// if there are no manual mipmaps
				// set 0 level mipmap and then use GL to generate other mipmap levels

				if ( mipmaps.length > 0 && isImagePowerOfTwo ) {

					for ( var i = 0, il = mipmaps.length; i < il; i ++ ) {

						mipmap = mipmaps[ i ];
						_gl.texImage2D( _gl.TEXTURE_2D, i, glFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data );

					}

					texture.generateMipmaps = false;

				} else {

					_gl.texImage2D( _gl.TEXTURE_2D, 0, glFormat, image.width, image.height, 0, glFormat, glType, image.data );

				}

			} else if ( texture instanceof THREE.CompressedTexture ) {

				for( var i = 0, il = mipmaps.length; i < il; i ++ ) {

					mipmap = mipmaps[ i ];
					if ( texture.format!==THREE.RGBAFormat ) {
						_gl.compressedTexImage2D( _gl.TEXTURE_2D, i, glFormat, mipmap.width, mipmap.height, 0, mipmap.data );
					} else {
						_gl.texImage2D( _gl.TEXTURE_2D, i, glFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data );
					}

				}

			} else { // regular Texture (image, video, canvas)

				// use manually created mipmaps if available
				// if there are no manual mipmaps
				// set 0 level mipmap and then use GL to generate other mipmap levels

				if ( mipmaps.length > 0 && isImagePowerOfTwo ) {

					for ( var i = 0, il = mipmaps.length; i < il; i ++ ) {

						mipmap = mipmaps[ i ];
						_gl.texImage2D( _gl.TEXTURE_2D, i, glFormat, glFormat, glType, mipmap );

					}

					texture.generateMipmaps = false;

				} else {

					_gl.texImage2D( _gl.TEXTURE_2D, 0, glFormat, glFormat, glType, texture.image );

				}

			}

			if ( texture.generateMipmaps && isImagePowerOfTwo ) _gl.generateMipmap( _gl.TEXTURE_2D );

			texture.needsUpdate = false;

			if ( texture.onUpdate ) texture.onUpdate();

		} else {

			_gl.activeTexture( _gl.TEXTURE0 + slot );
			_gl.bindTexture( _gl.TEXTURE_2D, texture.__webglTexture );

		}

	};

	function clampToMaxSize ( image, maxSize ) {

		if ( image.width <= maxSize && image.height <= maxSize ) {

			return image;

		}

		// Warning: Scaling through the canvas will only work with images that use
		// premultiplied alpha.

		var maxDimension = Math.max( image.width, image.height );
		var newWidth = Math.floor( image.width * maxSize / maxDimension );
		var newHeight = Math.floor( image.height * maxSize / maxDimension );

		var canvas = document.createElement( 'canvas' );
		canvas.width = newWidth;
		canvas.height = newHeight;

		var ctx = canvas.getContext( "2d" );
		ctx.drawImage( image, 0, 0, image.width, image.height, 0, 0, newWidth, newHeight );

		return canvas;

	}

	function setCubeTexture ( texture, slot ) {

		if ( texture.image.length === 6 ) {

			if ( texture.needsUpdate ) {

				if ( ! texture.image.__webglTextureCube ) {

					texture.addEventListener( 'dispose', onTextureDispose );

					texture.image.__webglTextureCube = _gl.createTexture();

					_this.info.memory.textures ++;

				}

				_gl.activeTexture( _gl.TEXTURE0 + slot );
				_gl.bindTexture( _gl.TEXTURE_CUBE_MAP, texture.image.__webglTextureCube );

				_gl.pixelStorei( _gl.UNPACK_FLIP_Y_WEBGL, texture.flipY );

				var isCompressed = texture instanceof THREE.CompressedTexture;

				var cubeImage = [];

				for ( var i = 0; i < 6; i ++ ) {

					if ( _this.autoScaleCubemaps && ! isCompressed ) {

						cubeImage[ i ] = clampToMaxSize( texture.image[ i ], _maxCubemapSize );

					} else {

						cubeImage[ i ] = texture.image[ i ];

					}

				}

				var image = cubeImage[ 0 ],
				isImagePowerOfTwo = isPowerOfTwo( image.width ) && isPowerOfTwo( image.height ),
				glFormat = paramThreeToGL( texture.format ),
				glType = paramThreeToGL( texture.type );

				setTextureParameters( _gl.TEXTURE_CUBE_MAP, texture, isImagePowerOfTwo );

				for ( var i = 0; i < 6; i ++ ) {

					if( !isCompressed ) {

						_gl.texImage2D( _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, 0, glFormat, glFormat, glType, cubeImage[ i ] );

					} else {

						var mipmap, mipmaps = cubeImage[ i ].mipmaps;

						for( var j = 0, jl = mipmaps.length; j < jl; j ++ ) {

							mipmap = mipmaps[ j ];
							if ( texture.format!==THREE.RGBAFormat ) {

								_gl.compressedTexImage2D( _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, j, glFormat, mipmap.width, mipmap.height, 0, mipmap.data );

							} else {
								_gl.texImage2D( _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, j, glFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data );
							}

						}
					}
				}

				if ( texture.generateMipmaps && isImagePowerOfTwo ) {

					_gl.generateMipmap( _gl.TEXTURE_CUBE_MAP );

				}

				texture.needsUpdate = false;

				if ( texture.onUpdate ) texture.onUpdate();

			} else {

				_gl.activeTexture( _gl.TEXTURE0 + slot );
				_gl.bindTexture( _gl.TEXTURE_CUBE_MAP, texture.image.__webglTextureCube );

			}

		}

	};

	function setCubeTextureDynamic ( texture, slot ) {

		_gl.activeTexture( _gl.TEXTURE0 + slot );
		_gl.bindTexture( _gl.TEXTURE_CUBE_MAP, texture.__webglTexture );

	};

	// Render targets

	function setupFrameBuffer ( framebuffer, renderTarget, textureTarget ) {

		_gl.bindFramebuffer( _gl.FRAMEBUFFER, framebuffer );
		_gl.framebufferTexture2D( _gl.FRAMEBUFFER, _gl.COLOR_ATTACHMENT0, textureTarget, renderTarget.__webglTexture, 0 );

	};

	function setupRenderBuffer ( renderbuffer, renderTarget  ) {

		_gl.bindRenderbuffer( _gl.RENDERBUFFER, renderbuffer );

		if ( renderTarget.depthBuffer && ! renderTarget.stencilBuffer ) {

			_gl.renderbufferStorage( _gl.RENDERBUFFER, _gl.DEPTH_COMPONENT16, renderTarget.width, renderTarget.height );
			_gl.framebufferRenderbuffer( _gl.FRAMEBUFFER, _gl.DEPTH_ATTACHMENT, _gl.RENDERBUFFER, renderbuffer );

		/* For some reason this is not working. Defaulting to RGBA4.
		} else if( ! renderTarget.depthBuffer && renderTarget.stencilBuffer ) {

			_gl.renderbufferStorage( _gl.RENDERBUFFER, _gl.STENCIL_INDEX8, renderTarget.width, renderTarget.height );
			_gl.framebufferRenderbuffer( _gl.FRAMEBUFFER, _gl.STENCIL_ATTACHMENT, _gl.RENDERBUFFER, renderbuffer );
		*/
		} else if ( renderTarget.depthBuffer && renderTarget.stencilBuffer ) {

			_gl.renderbufferStorage( _gl.RENDERBUFFER, _gl.DEPTH_STENCIL, renderTarget.width, renderTarget.height );
			_gl.framebufferRenderbuffer( _gl.FRAMEBUFFER, _gl.DEPTH_STENCIL_ATTACHMENT, _gl.RENDERBUFFER, renderbuffer );

		} else {

			_gl.renderbufferStorage( _gl.RENDERBUFFER, _gl.RGBA4, renderTarget.width, renderTarget.height );

		}

	};

	this.setRenderTarget = function ( renderTarget ) {

		var isCube = ( renderTarget instanceof THREE.WebGLRenderTargetCube );

		if ( renderTarget && ! renderTarget.__webglFramebuffer ) {

			if ( renderTarget.depthBuffer === undefined ) renderTarget.depthBuffer = true;
			if ( renderTarget.stencilBuffer === undefined ) renderTarget.stencilBuffer = true;

			renderTarget.addEventListener( 'dispose', onRenderTargetDispose );

			renderTarget.__webglTexture = _gl.createTexture();

			_this.info.memory.textures ++;

			// Setup texture, create render and frame buffers

			var isTargetPowerOfTwo = isPowerOfTwo( renderTarget.width ) && isPowerOfTwo( renderTarget.height ),
				glFormat = paramThreeToGL( renderTarget.format ),
				glType = paramThreeToGL( renderTarget.type );

			if ( isCube ) {

				renderTarget.__webglFramebuffer = [];
				renderTarget.__webglRenderbuffer = [];

				_gl.bindTexture( _gl.TEXTURE_CUBE_MAP, renderTarget.__webglTexture );
				setTextureParameters( _gl.TEXTURE_CUBE_MAP, renderTarget, isTargetPowerOfTwo );

				for ( var i = 0; i < 6; i ++ ) {

					renderTarget.__webglFramebuffer[ i ] = _gl.createFramebuffer();
					renderTarget.__webglRenderbuffer[ i ] = _gl.createRenderbuffer();

					_gl.texImage2D( _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, 0, glFormat, renderTarget.width, renderTarget.height, 0, glFormat, glType, null );

					setupFrameBuffer( renderTarget.__webglFramebuffer[ i ], renderTarget, _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i );
					setupRenderBuffer( renderTarget.__webglRenderbuffer[ i ], renderTarget );

				}

				if ( isTargetPowerOfTwo ) _gl.generateMipmap( _gl.TEXTURE_CUBE_MAP );

			} else {

				renderTarget.__webglFramebuffer = _gl.createFramebuffer();

				if ( renderTarget.shareDepthFrom ) {

					renderTarget.__webglRenderbuffer = renderTarget.shareDepthFrom.__webglRenderbuffer;

				} else {

					renderTarget.__webglRenderbuffer = _gl.createRenderbuffer();

				}

				_gl.bindTexture( _gl.TEXTURE_2D, renderTarget.__webglTexture );
				setTextureParameters( _gl.TEXTURE_2D, renderTarget, isTargetPowerOfTwo );

				_gl.texImage2D( _gl.TEXTURE_2D, 0, glFormat, renderTarget.width, renderTarget.height, 0, glFormat, glType, null );

				setupFrameBuffer( renderTarget.__webglFramebuffer, renderTarget, _gl.TEXTURE_2D );

				if ( renderTarget.shareDepthFrom ) {

					if ( renderTarget.depthBuffer && ! renderTarget.stencilBuffer ) {

						_gl.framebufferRenderbuffer( _gl.FRAMEBUFFER, _gl.DEPTH_ATTACHMENT, _gl.RENDERBUFFER, renderTarget.__webglRenderbuffer );

					} else if ( renderTarget.depthBuffer && renderTarget.stencilBuffer ) {

						_gl.framebufferRenderbuffer( _gl.FRAMEBUFFER, _gl.DEPTH_STENCIL_ATTACHMENT, _gl.RENDERBUFFER, renderTarget.__webglRenderbuffer );

					}

				} else {

					setupRenderBuffer( renderTarget.__webglRenderbuffer, renderTarget );

				}

				if ( isTargetPowerOfTwo ) _gl.generateMipmap( _gl.TEXTURE_2D );

			}

			// Release everything

			if ( isCube ) {

				_gl.bindTexture( _gl.TEXTURE_CUBE_MAP, null );

			} else {

				_gl.bindTexture( _gl.TEXTURE_2D, null );

			}

			_gl.bindRenderbuffer( _gl.RENDERBUFFER, null );
			_gl.bindFramebuffer( _gl.FRAMEBUFFER, null );

		}

		var framebuffer, width, height, vx, vy;

		if ( renderTarget ) {

			if ( isCube ) {

				framebuffer = renderTarget.__webglFramebuffer[ renderTarget.activeCubeFace ];

			} else {

				framebuffer = renderTarget.__webglFramebuffer;

			}

			width = renderTarget.width;
			height = renderTarget.height;

			vx = 0;
			vy = 0;

		} else {

			framebuffer = null;

			width = _viewportWidth;
			height = _viewportHeight;

			vx = _viewportX;
			vy = _viewportY;

		}

		if ( framebuffer !== _currentFramebuffer ) {

			_gl.bindFramebuffer( _gl.FRAMEBUFFER, framebuffer );
			_gl.viewport( vx, vy, width, height );

			_currentFramebuffer = framebuffer;

		}

		_currentWidth = width;
		_currentHeight = height;

	};

	function updateRenderTargetMipmap ( renderTarget ) {

		if ( renderTarget instanceof THREE.WebGLRenderTargetCube ) {

			_gl.bindTexture( _gl.TEXTURE_CUBE_MAP, renderTarget.__webglTexture );
			_gl.generateMipmap( _gl.TEXTURE_CUBE_MAP );
			_gl.bindTexture( _gl.TEXTURE_CUBE_MAP, null );

		} else {

			_gl.bindTexture( _gl.TEXTURE_2D, renderTarget.__webglTexture );
			_gl.generateMipmap( _gl.TEXTURE_2D );
			_gl.bindTexture( _gl.TEXTURE_2D, null );

		}

	};

	// Fallback filters for non-power-of-2 textures

	function filterFallback ( f ) {

		if ( f === THREE.NearestFilter || f === THREE.NearestMipMapNearestFilter || f === THREE.NearestMipMapLinearFilter ) {

			return _gl.NEAREST;

		}

		return _gl.LINEAR;

	};

	// Map three.js constants to WebGL constants

	function paramThreeToGL ( p ) {

		if ( p === THREE.RepeatWrapping ) return _gl.REPEAT;
		if ( p === THREE.ClampToEdgeWrapping ) return _gl.CLAMP_TO_EDGE;
		if ( p === THREE.MirroredRepeatWrapping ) return _gl.MIRRORED_REPEAT;

		if ( p === THREE.NearestFilter ) return _gl.NEAREST;
		if ( p === THREE.NearestMipMapNearestFilter ) return _gl.NEAREST_MIPMAP_NEAREST;
		if ( p === THREE.NearestMipMapLinearFilter ) return _gl.NEAREST_MIPMAP_LINEAR;

		if ( p === THREE.LinearFilter ) return _gl.LINEAR;
		if ( p === THREE.LinearMipMapNearestFilter ) return _gl.LINEAR_MIPMAP_NEAREST;
		if ( p === THREE.LinearMipMapLinearFilter ) return _gl.LINEAR_MIPMAP_LINEAR;

		if ( p === THREE.UnsignedByteType ) return _gl.UNSIGNED_BYTE;
		if ( p === THREE.UnsignedShort4444Type ) return _gl.UNSIGNED_SHORT_4_4_4_4;
		if ( p === THREE.UnsignedShort5551Type ) return _gl.UNSIGNED_SHORT_5_5_5_1;
		if ( p === THREE.UnsignedShort565Type ) return _gl.UNSIGNED_SHORT_5_6_5;

		if ( p === THREE.ByteType ) return _gl.BYTE;
		if ( p === THREE.ShortType ) return _gl.SHORT;
		if ( p === THREE.UnsignedShortType ) return _gl.UNSIGNED_SHORT;
		if ( p === THREE.IntType ) return _gl.INT;
		if ( p === THREE.UnsignedIntType ) return _gl.UNSIGNED_INT;
		if ( p === THREE.FloatType ) return _gl.FLOAT;

		if ( p === THREE.AlphaFormat ) return _gl.ALPHA;
		if ( p === THREE.RGBFormat ) return _gl.RGB;
		if ( p === THREE.RGBAFormat ) return _gl.RGBA;
		if ( p === THREE.LuminanceFormat ) return _gl.LUMINANCE;
		if ( p === THREE.LuminanceAlphaFormat ) return _gl.LUMINANCE_ALPHA;

		if ( p === THREE.AddEquation ) return _gl.FUNC_ADD;
		if ( p === THREE.SubtractEquation ) return _gl.FUNC_SUBTRACT;
		if ( p === THREE.ReverseSubtractEquation ) return _gl.FUNC_REVERSE_SUBTRACT;

		if ( p === THREE.ZeroFactor ) return _gl.ZERO;
		if ( p === THREE.OneFactor ) return _gl.ONE;
		if ( p === THREE.SrcColorFactor ) return _gl.SRC_COLOR;
		if ( p === THREE.OneMinusSrcColorFactor ) return _gl.ONE_MINUS_SRC_COLOR;
		if ( p === THREE.SrcAlphaFactor ) return _gl.SRC_ALPHA;
		if ( p === THREE.OneMinusSrcAlphaFactor ) return _gl.ONE_MINUS_SRC_ALPHA;
		if ( p === THREE.DstAlphaFactor ) return _gl.DST_ALPHA;
		if ( p === THREE.OneMinusDstAlphaFactor ) return _gl.ONE_MINUS_DST_ALPHA;

		if ( p === THREE.DstColorFactor ) return _gl.DST_COLOR;
		if ( p === THREE.OneMinusDstColorFactor ) return _gl.ONE_MINUS_DST_COLOR;
		if ( p === THREE.SrcAlphaSaturateFactor ) return _gl.SRC_ALPHA_SATURATE;

		if ( _glExtensionCompressedTextureS3TC !== undefined ) {

			if ( p === THREE.RGB_S3TC_DXT1_Format ) return _glExtensionCompressedTextureS3TC.COMPRESSED_RGB_S3TC_DXT1_EXT;
			if ( p === THREE.RGBA_S3TC_DXT1_Format ) return _glExtensionCompressedTextureS3TC.COMPRESSED_RGBA_S3TC_DXT1_EXT;
			if ( p === THREE.RGBA_S3TC_DXT3_Format ) return _glExtensionCompressedTextureS3TC.COMPRESSED_RGBA_S3TC_DXT3_EXT;
			if ( p === THREE.RGBA_S3TC_DXT5_Format ) return _glExtensionCompressedTextureS3TC.COMPRESSED_RGBA_S3TC_DXT5_EXT;

		}

		return 0;

	};

	// Allocations

	function allocateBones ( object ) {

		if ( _supportsBoneTextures && object && object.useVertexTexture ) {

			return 1024;

		} else {

			// default for when object is not specified
			// ( for example when prebuilding shader
			//   to be used with multiple objects )
			//
			// 	- leave some extra space for other uniforms
			//  - limit here is ANGLE's 254 max uniform vectors
			//    (up to 54 should be safe)

			var nVertexUniforms = _gl.getParameter( _gl.MAX_VERTEX_UNIFORM_VECTORS );
			var nVertexMatrices = Math.floor( ( nVertexUniforms - 20 ) / 4 );

			var maxBones = nVertexMatrices;

			if ( object !== undefined && object instanceof THREE.SkinnedMesh ) {

				maxBones = Math.min( object.bones.length, maxBones );

				if ( maxBones < object.bones.length ) {

					console.warn( "WebGLRenderer: too many bones - " + object.bones.length + ", this GPU supports just " + maxBones + " (try OpenGL instead of ANGLE)" );

				}

			}

			return maxBones;

		}

	};

	function allocateLights( lights ) {

		var dirLights = 0;
		var pointLights = 0;
		var spotLights = 0;
		var hemiLights = 0;

		for ( var l = 0, ll = lights.length; l < ll; l ++ ) {

			var light = lights[ l ];

			if ( light.onlyShadow ) continue;

			if ( light instanceof THREE.DirectionalLight ) dirLights ++;
			if ( light instanceof THREE.PointLight ) pointLights ++;
			if ( light instanceof THREE.SpotLight ) spotLights ++;
			if ( light instanceof THREE.HemisphereLight ) hemiLights ++;

		}

		return { 'directional' : dirLights, 'point' : pointLights, 'spot': spotLights, 'hemi': hemiLights };

	};

	function allocateShadows( lights ) {

		var maxShadows = 0;

		for ( var l = 0, ll = lights.length; l < ll; l++ ) {

			var light = lights[ l ];

			if ( ! light.castShadow ) continue;

			if ( light instanceof THREE.SpotLight ) maxShadows ++;
			if ( light instanceof THREE.DirectionalLight && ! light.shadowCascade ) maxShadows ++;

		}

		return maxShadows;

	};

	// Initialization

	function initGL() {

		try {

			var attributes = {
				alpha: _alpha,
				premultipliedAlpha: _premultipliedAlpha,
				antialias: _antialias,
				stencil: _stencil,
				preserveDrawingBuffer: _preserveDrawingBuffer
			};

			_gl = _canvas.getContext( 'webgl', attributes ) || _canvas.getContext( 'experimental-webgl', attributes );

			if ( _gl === null ) {

				throw 'Error creating WebGL context.';

			}

		} catch ( error ) {

			console.error( error );

		}

		_glExtensionTextureFloat = _gl.getExtension( 'OES_texture_float' );
		_glExtensionTextureFloatLinear = _gl.getExtension( 'OES_texture_float_linear' );
		_glExtensionStandardDerivatives = _gl.getExtension( 'OES_standard_derivatives' );

		_glExtensionTextureFilterAnisotropic = _gl.getExtension( 'EXT_texture_filter_anisotropic' ) || _gl.getExtension( 'MOZ_EXT_texture_filter_anisotropic' ) || _gl.getExtension( 'WEBKIT_EXT_texture_filter_anisotropic' );

		_glExtensionCompressedTextureS3TC = _gl.getExtension( 'WEBGL_compressed_texture_s3tc' ) || _gl.getExtension( 'MOZ_WEBGL_compressed_texture_s3tc' ) || _gl.getExtension( 'WEBKIT_WEBGL_compressed_texture_s3tc' );

		if ( ! _glExtensionTextureFloat ) {

			console.log( 'THREE.WebGLRenderer: Float textures not supported.' );

		}

		if ( ! _glExtensionStandardDerivatives ) {

			console.log( 'THREE.WebGLRenderer: Standard derivatives not supported.' );

		}

		if ( ! _glExtensionTextureFilterAnisotropic ) {

			console.log( 'THREE.WebGLRenderer: Anisotropic texture filtering not supported.' );

		}

		if ( ! _glExtensionCompressedTextureS3TC ) {

			console.log( 'THREE.WebGLRenderer: S3TC compressed textures not supported.' );

		}

		if ( _gl.getShaderPrecisionFormat === undefined ) {

			_gl.getShaderPrecisionFormat = function() {

				return {
					"rangeMin"  : 1,
					"rangeMax"  : 1,
					"precision" : 1
				};

			}
		}

	};

	function setDefaultGLState () {

		_gl.clearColor( 0, 0, 0, 1 );
		_gl.clearDepth( 1 );
		_gl.clearStencil( 0 );

		_gl.enable( _gl.DEPTH_TEST );
		_gl.depthFunc( _gl.LEQUAL );

		_gl.frontFace( _gl.CCW );
		_gl.cullFace( _gl.BACK );
		_gl.enable( _gl.CULL_FACE );

		_gl.enable( _gl.BLEND );
		_gl.blendEquation( _gl.FUNC_ADD );
		_gl.blendFunc( _gl.SRC_ALPHA, _gl.ONE_MINUS_SRC_ALPHA );

		_gl.viewport( _viewportX, _viewportY, _viewportWidth, _viewportHeight );

		_gl.clearColor( _clearColor.r, _clearColor.g, _clearColor.b, _clearAlpha );

	};

	// default plugins (order is important)

	this.shadowMapPlugin = new THREE.ShadowMapPlugin();
	this.addPrePlugin( this.shadowMapPlugin );

	this.addPostPlugin( new THREE.SpritePlugin() );
	this.addPostPlugin( new THREE.LensFlarePlugin() );

};

/**
 * @author szimek / https://github.com/szimek/
 * @author alteredq / http://alteredqualia.com/
 */

THREE.WebGLRenderTarget = function ( width, height, options ) {

	this.width = width;
	this.height = height;

	options = options || {};

	this.wrapS = options.wrapS !== undefined ? options.wrapS : THREE.ClampToEdgeWrapping;
	this.wrapT = options.wrapT !== undefined ? options.wrapT : THREE.ClampToEdgeWrapping;

	this.magFilter = options.magFilter !== undefined ? options.magFilter : THREE.LinearFilter;
	this.minFilter = options.minFilter !== undefined ? options.minFilter : THREE.LinearMipMapLinearFilter;

	this.anisotropy = options.anisotropy !== undefined ? options.anisotropy : 1;

	this.offset = new THREE.Vector2( 0, 0 );
	this.repeat = new THREE.Vector2( 1, 1 );

	this.format = options.format !== undefined ? options.format : THREE.RGBAFormat;
	this.type = options.type !== undefined ? options.type : THREE.UnsignedByteType;

	this.depthBuffer = options.depthBuffer !== undefined ? options.depthBuffer : true;
	this.stencilBuffer = options.stencilBuffer !== undefined ? options.stencilBuffer : true;

	this.generateMipmaps = true;

	this.shareDepthFrom = null;

};

THREE.WebGLRenderTarget.prototype = {

	constructor: THREE.WebGLRenderTarget,

	clone: function () {

		var tmp = new THREE.WebGLRenderTarget( this.width, this.height );

		tmp.wrapS = this.wrapS;
		tmp.wrapT = this.wrapT;

		tmp.magFilter = this.magFilter;
		tmp.minFilter = this.minFilter;

		tmp.anisotropy = this.anisotropy;

		tmp.offset.copy( this.offset );
		tmp.repeat.copy( this.repeat );

		tmp.format = this.format;
		tmp.type = this.type;

		tmp.depthBuffer = this.depthBuffer;
		tmp.stencilBuffer = this.stencilBuffer;

		tmp.generateMipmaps = this.generateMipmaps;

		tmp.shareDepthFrom = this.shareDepthFrom;

		return tmp;

	},

	dispose: function () {

		this.dispatchEvent( { type: 'dispose' } );

	}

};

THREE.EventDispatcher.prototype.apply( THREE.WebGLRenderTarget.prototype );

/**
 * @author alteredq / http://alteredqualia.com
 */

THREE.WebGLRenderTargetCube = function ( width, height, options ) {

	THREE.WebGLRenderTarget.call( this, width, height, options );

	this.activeCubeFace = 0; // PX 0, NX 1, PY 2, NY 3, PZ 4, NZ 5

};

THREE.WebGLRenderTargetCube.prototype = Object.create( THREE.WebGLRenderTarget.prototype );

/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.RenderableVertex = function () {

	this.position = new THREE.Vector3();
	this.positionWorld = new THREE.Vector3();
	this.positionScreen = new THREE.Vector4();

	this.visible = true;

};

THREE.RenderableVertex.prototype.copy = function ( vertex ) {

	this.positionWorld.copy( vertex.positionWorld );
	this.positionScreen.copy( vertex.positionScreen );

};

/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.RenderableFace3 = function () {

	this.id = 0;

	this.v1 = new THREE.RenderableVertex();
	this.v2 = new THREE.RenderableVertex();
	this.v3 = new THREE.RenderableVertex();

	this.centroidModel = new THREE.Vector3();

	this.normalModel = new THREE.Vector3();
	this.normalModelView = new THREE.Vector3();

	this.vertexNormalsLength = 0;
	this.vertexNormalsModel = [ new THREE.Vector3(), new THREE.Vector3(), new THREE.Vector3() ];
	this.vertexNormalsModelView = [ new THREE.Vector3(), new THREE.Vector3(), new THREE.Vector3() ];

	this.color = null;
	this.material = null;
	this.uvs = [[]];

	this.z = 0;

};

/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.RenderableObject = function () {

	this.id = 0;

	this.object = null;
	this.z = 0;

};

/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.RenderableSprite = function () {

	this.id = 0;

	this.object = null;

	this.x = 0;
	this.y = 0;
	this.z = 0;

	this.rotation = 0;
	this.scale = new THREE.Vector2();

	this.material = null;

};

/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.RenderableLine = function () {

	this.id = 0;

	this.v1 = new THREE.RenderableVertex();
	this.v2 = new THREE.RenderableVertex();

	this.vertexColors = [ new THREE.Color(), new THREE.Color() ];
	this.material = null;

	this.z = 0;

};

/**
 * @author mrdoob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 */

THREE.GeometryUtils = {

	// Merge two geometries or geometry and geometry from object (using object's transform)

	merge: function ( geometry1, object2 /* mesh | geometry */, materialIndexOffset ) {

		var matrix, normalMatrix,
		vertexOffset = geometry1.vertices.length,
		uvPosition = geometry1.faceVertexUvs[ 0 ].length,
		geometry2 = object2 instanceof THREE.Mesh ? object2.geometry : object2,
		vertices1 = geometry1.vertices,
		vertices2 = geometry2.vertices,
		faces1 = geometry1.faces,
		faces2 = geometry2.faces,
		uvs1 = geometry1.faceVertexUvs[ 0 ],
		uvs2 = geometry2.faceVertexUvs[ 0 ];

		if ( materialIndexOffset === undefined ) materialIndexOffset = 0;

		if ( object2 instanceof THREE.Mesh ) {

			object2.matrixAutoUpdate && object2.updateMatrix();

			matrix = object2.matrix;

			normalMatrix = new THREE.Matrix3().getNormalMatrix( matrix );

		}

		// vertices

		for ( var i = 0, il = vertices2.length; i < il; i ++ ) {

			var vertex = vertices2[ i ];

			var vertexCopy = vertex.clone();

			if ( matrix ) vertexCopy.applyMatrix4( matrix );

			vertices1.push( vertexCopy );

		}

		// faces

		for ( i = 0, il = faces2.length; i < il; i ++ ) {

			var face = faces2[ i ], faceCopy, normal, color,
			faceVertexNormals = face.vertexNormals,
			faceVertexColors = face.vertexColors;

			faceCopy = new THREE.Face3( face.a + vertexOffset, face.b + vertexOffset, face.c + vertexOffset );
			faceCopy.normal.copy( face.normal );

			if ( normalMatrix ) {

				faceCopy.normal.applyMatrix3( normalMatrix ).normalize();

			}

			for ( var j = 0, jl = faceVertexNormals.length; j < jl; j ++ ) {

				normal = faceVertexNormals[ j ].clone();

				if ( normalMatrix ) {

					normal.applyMatrix3( normalMatrix ).normalize();

				}

				faceCopy.vertexNormals.push( normal );

			}

			faceCopy.color.copy( face.color );

			for ( var j = 0, jl = faceVertexColors.length; j < jl; j ++ ) {

				color = faceVertexColors[ j ];
				faceCopy.vertexColors.push( color.clone() );

			}

			faceCopy.materialIndex = face.materialIndex + materialIndexOffset;

			faceCopy.centroid.copy( face.centroid );

			if ( matrix ) {

				faceCopy.centroid.applyMatrix4( matrix );

			}

			faces1.push( faceCopy );

		}

		// uvs

		for ( i = 0, il = uvs2.length; i < il; i ++ ) {

			var uv = uvs2[ i ], uvCopy = [];

			for ( var j = 0, jl = uv.length; j < jl; j ++ ) {

				uvCopy.push( new THREE.Vector2( uv[ j ].x, uv[ j ].y ) );

			}

			uvs1.push( uvCopy );

		}

	},

	// Get random point in triangle (via barycentric coordinates)
	// 	(uniform distribution)
	// 	http://www.cgafaq.info/wiki/Random_Point_In_Triangle

	randomPointInTriangle: function () {

		var vector = new THREE.Vector3();

		return function ( vectorA, vectorB, vectorC ) {

			var point = new THREE.Vector3();

			var a = THREE.Math.random16();
			var b = THREE.Math.random16();

			if ( ( a + b ) > 1 ) {

				a = 1 - a;
				b = 1 - b;

			}

			var c = 1 - a - b;

			point.copy( vectorA );
			point.multiplyScalar( a );

			vector.copy( vectorB );
			vector.multiplyScalar( b );

			point.add( vector );

			vector.copy( vectorC );
			vector.multiplyScalar( c );

			point.add( vector );

			return point;

		};

	}(),

	// Get random point in face (triangle / quad)
	// (uniform distribution)

	randomPointInFace: function ( face, geometry, useCachedAreas ) {

		var vA, vB, vC, vD;

		vA = geometry.vertices[ face.a ];
		vB = geometry.vertices[ face.b ];
		vC = geometry.vertices[ face.c ];

		return THREE.GeometryUtils.randomPointInTriangle( vA, vB, vC );

	},

	// Get uniformly distributed random points in mesh
	// 	- create array with cumulative sums of face areas
	//  - pick random number from 0 to total area
	//  - find corresponding place in area array by binary search
	//	- get random point in face

	randomPointsInGeometry: function ( geometry, n ) {

		var face, i,
			faces = geometry.faces,
			vertices = geometry.vertices,
			il = faces.length,
			totalArea = 0,
			cumulativeAreas = [],
			vA, vB, vC, vD;

		// precompute face areas

		for ( i = 0; i < il; i ++ ) {

			face = faces[ i ];

			vA = vertices[ face.a ];
			vB = vertices[ face.b ];
			vC = vertices[ face.c ];

			face._area = THREE.GeometryUtils.triangleArea( vA, vB, vC );

			totalArea += face._area;

			cumulativeAreas[ i ] = totalArea;

		}

		// binary search cumulative areas array

		function binarySearchIndices( value ) {

			function binarySearch( start, end ) {

				// return closest larger index
				// if exact number is not found

				if ( end < start )
					return start;

				var mid = start + Math.floor( ( end - start ) / 2 );

				if ( cumulativeAreas[ mid ] > value ) {

					return binarySearch( start, mid - 1 );

				} else if ( cumulativeAreas[ mid ] < value ) {

					return binarySearch( mid + 1, end );

				} else {

					return mid;

				}

			}

			var result = binarySearch( 0, cumulativeAreas.length - 1 )
			return result;

		}

		// pick random face weighted by face area

		var r, index,
			result = [];

		var stats = {};

		for ( i = 0; i < n; i ++ ) {

			r = THREE.Math.random16() * totalArea;

			index = binarySearchIndices( r );

			result[ i ] = THREE.GeometryUtils.randomPointInFace( faces[ index ], geometry, true );

			if ( ! stats[ index ] ) {

				stats[ index ] = 1;

			} else {

				stats[ index ] += 1;

			}

		}

		return result;

	},

	// Get triangle area (half of parallelogram)
	//	http://mathworld.wolfram.com/TriangleArea.html

	triangleArea: function () {

		var vector1 = new THREE.Vector3();
		var vector2 = new THREE.Vector3();

		return function ( vectorA, vectorB, vectorC ) {

			vector1.subVectors( vectorB, vectorA );
			vector2.subVectors( vectorC, vectorA );
			vector1.cross( vector2 );

			return 0.5 * vector1.length();

		};

	}(),

	// Center geometry so that 0,0,0 is in center of bounding box

	center: function ( geometry ) {

		geometry.computeBoundingBox();

		var bb = geometry.boundingBox;

		var offset = new THREE.Vector3();

		offset.addVectors( bb.min, bb.max );
		offset.multiplyScalar( -0.5 );

		geometry.applyMatrix( new THREE.Matrix4().makeTranslation( offset.x, offset.y, offset.z ) );
		geometry.computeBoundingBox();

		return offset;

	},

	triangulateQuads: function ( geometry ) {

		var i, il, j, jl;

		var faces = [];
		var faceVertexUvs = [];

		for ( i = 0, il = geometry.faceVertexUvs.length; i < il; i ++ ) {

			faceVertexUvs[ i ] = [];

		}

		for ( i = 0, il = geometry.faces.length; i < il; i ++ ) {

			var face = geometry.faces[ i ];

			faces.push( face );

			for ( j = 0, jl = geometry.faceVertexUvs.length; j < jl; j ++ ) {

				faceVertexUvs[ j ].push( geometry.faceVertexUvs[ j ][ i ] );

			}

		}

		geometry.faces = faces;
		geometry.faceVertexUvs = faceVertexUvs;

		geometry.computeCentroids();
		geometry.computeFaceNormals();
		geometry.computeVertexNormals();

		if ( geometry.hasTangents ) geometry.computeTangents();

	}

};

/**
 * @author alteredq / http://alteredqualia.com/
 * @author mrdoob / http://mrdoob.com/
 */

THREE.ImageUtils = {

	crossOrigin: undefined,

	loadTexture: function ( url, mapping, onLoad, onError ) {

		var loader = new THREE.ImageLoader();
		loader.crossOrigin = this.crossOrigin;

		var texture = new THREE.Texture( undefined, mapping );

		var image = loader.load( url, function () {

			texture.needsUpdate = true;

			if ( onLoad ) onLoad( texture );

		} );

		texture.image = image;
		texture.sourceFile = url;

		return texture;

	},

	loadCompressedTexture: function ( url, mapping, onLoad, onError ) {

		var texture = new THREE.CompressedTexture();
		texture.mapping = mapping;

		var request = new XMLHttpRequest();

		request.onload = function () {

			var buffer = request.response;
			var dds = THREE.ImageUtils.parseDDS( buffer, true );

			texture.format = dds.format;

			texture.mipmaps = dds.mipmaps;
			texture.image.width = dds.width;
			texture.image.height = dds.height;

			// gl.generateMipmap fails for compressed textures
			// mipmaps must be embedded in the DDS file
			// or texture filters must not use mipmapping

			texture.generateMipmaps = false;

			texture.needsUpdate = true;

			if ( onLoad ) onLoad( texture );

		}

		request.onerror = onError;

		request.open( 'GET', url, true );
		request.responseType = "arraybuffer";
		request.send( null );

		return texture;

	},

	loadTextureCube: function ( array, mapping, onLoad, onError ) {

		var images = [];
		images.loadCount = 0;

		var texture = new THREE.Texture();
		texture.image = images;
		if ( mapping !== undefined ) texture.mapping = mapping;

		// no flipping needed for cube textures

		texture.flipY = false;

		for ( var i = 0, il = array.length; i < il; ++ i ) {

			var cubeImage = new Image();
			images[ i ] = cubeImage;

			cubeImage.onload = function () {

				images.loadCount += 1;

				if ( images.loadCount === 6 ) {

					texture.needsUpdate = true;
					if ( onLoad ) onLoad( texture );

				}

			};

			cubeImage.onerror = onError;

			cubeImage.crossOrigin = this.crossOrigin;
			cubeImage.src = array[ i ];

		}

		return texture;

	},

	loadCompressedTextureCube: function ( array, mapping, onLoad, onError ) {

		var images = [];
		images.loadCount = 0;

		var texture = new THREE.CompressedTexture();
		texture.image = images;
		if ( mapping !== undefined ) texture.mapping = mapping;

		// no flipping for cube textures
		// (also flipping doesn't work for compressed textures )

		texture.flipY = false;

		// can't generate mipmaps for compressed textures
		// mips must be embedded in DDS files

		texture.generateMipmaps = false;

		var generateCubeFaceCallback = function ( rq, img ) {

			return function () {

				var buffer = rq.response;
				var dds = THREE.ImageUtils.parseDDS( buffer, true );

				img.format = dds.format;

				img.mipmaps = dds.mipmaps;
				img.width = dds.width;
				img.height = dds.height;

				images.loadCount += 1;

				if ( images.loadCount === 6 ) {

					texture.format = dds.format;
					texture.needsUpdate = true;
					if ( onLoad ) onLoad( texture );

				}

			}

		}

		// compressed cubemap textures as 6 separate DDS files

		if ( array instanceof Array ) {

			for ( var i = 0, il = array.length; i < il; ++ i ) {

				var cubeImage = {};
				images[ i ] = cubeImage;

				var request = new XMLHttpRequest();

				request.onload = generateCubeFaceCallback( request, cubeImage );
				request.onerror = onError;

				var url = array[ i ];

				request.open( 'GET', url, true );
				request.responseType = "arraybuffer";
				request.send( null );

			}

		// compressed cubemap texture stored in a single DDS file

		} else {

			var url = array;
			var request = new XMLHttpRequest();

			request.onload = function( ) {

				var buffer = request.response;
				var dds = THREE.ImageUtils.parseDDS( buffer, true );

				if ( dds.isCubemap ) {

					var faces = dds.mipmaps.length / dds.mipmapCount;

					for ( var f = 0; f < faces; f ++ ) {

						images[ f ] = { mipmaps : [] };

						for ( var i = 0; i < dds.mipmapCount; i ++ ) {

							images[ f ].mipmaps.push( dds.mipmaps[ f * dds.mipmapCount + i ] );
							images[ f ].format = dds.format;
							images[ f ].width = dds.width;
							images[ f ].height = dds.height;

						}

					}

					texture.format = dds.format;
					texture.needsUpdate = true;
					if ( onLoad ) onLoad( texture );

				}

			}

			request.onerror = onError;

			request.open( 'GET', url, true );
			request.responseType = "arraybuffer";
			request.send( null );

		}

		return texture;

	},

	loadDDSTexture: function ( url, mapping, onLoad, onError ) {

		var images = [];
		images.loadCount = 0;

		var texture = new THREE.CompressedTexture();
		texture.image = images;
		if ( mapping !== undefined ) texture.mapping = mapping;

		// no flipping for cube textures
		// (also flipping doesn't work for compressed textures )

		texture.flipY = false;

		// can't generate mipmaps for compressed textures
		// mips must be embedded in DDS files

		texture.generateMipmaps = false;

		{
			var request = new XMLHttpRequest();

			request.onload = function( ) {

				var buffer = request.response;
				var dds = THREE.ImageUtils.parseDDS( buffer, true );

				if ( dds.isCubemap ) {

					var faces = dds.mipmaps.length / dds.mipmapCount;

					for ( var f = 0; f < faces; f ++ ) {

						images[ f ] = { mipmaps : [] };

						for ( var i = 0; i < dds.mipmapCount; i ++ ) {

							images[ f ].mipmaps.push( dds.mipmaps[ f * dds.mipmapCount + i ] );
							images[ f ].format = dds.format;
							images[ f ].width = dds.width;
							images[ f ].height = dds.height;

						}

					}


				} else {
					texture.image.width = dds.width;
					texture.image.height = dds.height;
					texture.mipmaps = dds.mipmaps;
				}

				texture.format = dds.format;
				texture.needsUpdate = true;
				if ( onLoad ) onLoad( texture );

			}

			request.onerror = onError;

			request.open( 'GET', url, true );
			request.responseType = "arraybuffer";
			request.send( null );

		}

		return texture;

	},

	parseDDS: function ( buffer, loadMipmaps ) {

		var dds = { mipmaps: [], width: 0, height: 0, format: null, mipmapCount: 1 };

		// Adapted from @toji's DDS utils
		//	https://github.com/toji/webgl-texture-utils/blob/master/texture-util/dds.js

		// All values and structures referenced from:
		// http://msdn.microsoft.com/en-us/library/bb943991.aspx/

		var DDS_MAGIC = 0x20534444;

		var DDSD_CAPS = 0x1,
			DDSD_HEIGHT = 0x2,
			DDSD_WIDTH = 0x4,
			DDSD_PITCH = 0x8,
			DDSD_PIXELFORMAT = 0x1000,
			DDSD_MIPMAPCOUNT = 0x20000,
			DDSD_LINEARSIZE = 0x80000,
			DDSD_DEPTH = 0x800000;

		var DDSCAPS_COMPLEX = 0x8,
			DDSCAPS_MIPMAP = 0x400000,
			DDSCAPS_TEXTURE = 0x1000;

		var DDSCAPS2_CUBEMAP = 0x200,
			DDSCAPS2_CUBEMAP_POSITIVEX = 0x400,
			DDSCAPS2_CUBEMAP_NEGATIVEX = 0x800,
			DDSCAPS2_CUBEMAP_POSITIVEY = 0x1000,
			DDSCAPS2_CUBEMAP_NEGATIVEY = 0x2000,
			DDSCAPS2_CUBEMAP_POSITIVEZ = 0x4000,
			DDSCAPS2_CUBEMAP_NEGATIVEZ = 0x8000,
			DDSCAPS2_VOLUME = 0x200000;

		var DDPF_ALPHAPIXELS = 0x1,
			DDPF_ALPHA = 0x2,
			DDPF_FOURCC = 0x4,
			DDPF_RGB = 0x40,
			DDPF_YUV = 0x200,
			DDPF_LUMINANCE = 0x20000;

		function fourCCToInt32( value ) {

			return value.charCodeAt(0) +
				(value.charCodeAt(1) << 8) +
				(value.charCodeAt(2) << 16) +
				(value.charCodeAt(3) << 24);

		}

		function int32ToFourCC( value ) {

			return String.fromCharCode(
				value & 0xff,
				(value >> 8) & 0xff,
				(value >> 16) & 0xff,
				(value >> 24) & 0xff
			);
		}

		function loadARGBMip( buffer, dataOffset, width, height ) {
			var dataLength = width*height*4;
			var srcBuffer = new Uint8Array( buffer, dataOffset, dataLength );
			var byteArray = new Uint8Array( dataLength );
			var dst = 0;
			var src = 0;
			for ( var y = 0; y < height; y++ ) {
				for ( var x = 0; x < width; x++ ) {
					var b = srcBuffer[src]; src++;
					var g = srcBuffer[src]; src++;
					var r = srcBuffer[src]; src++;
					var a = srcBuffer[src]; src++;
					byteArray[dst] = r; dst++;	//r
					byteArray[dst] = g; dst++;	//g
					byteArray[dst] = b; dst++;	//b
					byteArray[dst] = a; dst++;	//a
				}
			}
			return byteArray;
		}

		var FOURCC_DXT1 = fourCCToInt32("DXT1");
		var FOURCC_DXT3 = fourCCToInt32("DXT3");
		var FOURCC_DXT5 = fourCCToInt32("DXT5");

		var headerLengthInt = 31; // The header length in 32 bit ints

		// Offsets into the header array

		var off_magic = 0;

		var off_size = 1;
		var off_flags = 2;
		var off_height = 3;
		var off_width = 4;

		var off_mipmapCount = 7;

		var off_pfFlags = 20;
		var off_pfFourCC = 21;
		var off_RGBBitCount = 22;
		var off_RBitMask = 23;
		var off_GBitMask = 24;
		var off_BBitMask = 25;
		var off_ABitMask = 26;

		var off_caps = 27;
		var off_caps2 = 28;
		var off_caps3 = 29;
		var off_caps4 = 30;

		// Parse header

		var header = new Int32Array( buffer, 0, headerLengthInt );

		if ( header[ off_magic ] !== DDS_MAGIC ) {

			console.error( "ImageUtils.parseDDS(): Invalid magic number in DDS header" );
			return dds;

		}

		if ( ! header[ off_pfFlags ] & DDPF_FOURCC ) {

			console.error( "ImageUtils.parseDDS(): Unsupported format, must contain a FourCC code" );
			return dds;

		}

		var blockBytes;

		var fourCC = header[ off_pfFourCC ];

		var isRGBAUncompressed = false;

		switch ( fourCC ) {

			case FOURCC_DXT1:

				blockBytes = 8;
				dds.format = THREE.RGB_S3TC_DXT1_Format;
				break;

			case FOURCC_DXT3:

				blockBytes = 16;
				dds.format = THREE.RGBA_S3TC_DXT3_Format;
				break;

			case FOURCC_DXT5:

				blockBytes = 16;
				dds.format = THREE.RGBA_S3TC_DXT5_Format;
				break;

			default:

				if( header[off_RGBBitCount] ==32
					&& header[off_RBitMask]&0xff0000
					&& header[off_GBitMask]&0xff00
					&& header[off_BBitMask]&0xff
					&& header[off_ABitMask]&0xff000000  ) {
					isRGBAUncompressed = true;
					blockBytes = 64;
					dds.format = THREE.RGBAFormat;
				} else {
					console.error( "ImageUtils.parseDDS(): Unsupported FourCC code: ", int32ToFourCC( fourCC ) );
					return dds;
				}
		}

		dds.mipmapCount = 1;

		if ( header[ off_flags ] & DDSD_MIPMAPCOUNT && loadMipmaps !== false ) {

			dds.mipmapCount = Math.max( 1, header[ off_mipmapCount ] );

		}

		//TODO: Verify that all faces of the cubemap are present with DDSCAPS2_CUBEMAP_POSITIVEX, etc.

		dds.isCubemap = header[ off_caps2 ] & DDSCAPS2_CUBEMAP ? true : false;

		dds.width = header[ off_width ];
		dds.height = header[ off_height ];

		var dataOffset = header[ off_size ] + 4;

		// Extract mipmaps buffers

		var width = dds.width;
		var height = dds.height;

		var faces = dds.isCubemap ? 6 : 1;

		for ( var face = 0; face < faces; face ++ ) {

			for ( var i = 0; i < dds.mipmapCount; i ++ ) {

				if( isRGBAUncompressed ) {
					var byteArray = loadARGBMip( buffer, dataOffset, width, height );
					var dataLength = byteArray.length;
				} else {
					var dataLength = Math.max( 4, width ) / 4 * Math.max( 4, height ) / 4 * blockBytes;
					var byteArray = new Uint8Array( buffer, dataOffset, dataLength );
				}

				var mipmap = { "data": byteArray, "width": width, "height": height };
				dds.mipmaps.push( mipmap );

				dataOffset += dataLength;

				width = Math.max( width * 0.5, 1 );
				height = Math.max( height * 0.5, 1 );

			}

			width = dds.width;
			height = dds.height;

		}

		return dds;

	},

	getNormalMap: function ( image, depth ) {

		// Adapted from http://www.paulbrunt.co.uk/lab/heightnormal/

		var cross = function ( a, b ) {

			return [ a[ 1 ] * b[ 2 ] - a[ 2 ] * b[ 1 ], a[ 2 ] * b[ 0 ] - a[ 0 ] * b[ 2 ], a[ 0 ] * b[ 1 ] - a[ 1 ] * b[ 0 ] ];

		}

		var subtract = function ( a, b ) {

			return [ a[ 0 ] - b[ 0 ], a[ 1 ] - b[ 1 ], a[ 2 ] - b[ 2 ] ];

		}

		var normalize = function ( a ) {

			var l = Math.sqrt( a[ 0 ] * a[ 0 ] + a[ 1 ] * a[ 1 ] + a[ 2 ] * a[ 2 ] );
			return [ a[ 0 ] / l, a[ 1 ] / l, a[ 2 ] / l ];

		}

		depth = depth | 1;

		var width = image.width;
		var height = image.height;

		var canvas = document.createElement( 'canvas' );
		canvas.width = width;
		canvas.height = height;

		var context = canvas.getContext( '2d' );
		context.drawImage( image, 0, 0 );

		var data = context.getImageData( 0, 0, width, height ).data;
		var imageData = context.createImageData( width, height );
		var output = imageData.data;

		for ( var x = 0; x < width; x ++ ) {

			for ( var y = 0; y < height; y ++ ) {

				var ly = y - 1 < 0 ? 0 : y - 1;
				var uy = y + 1 > height - 1 ? height - 1 : y + 1;
				var lx = x - 1 < 0 ? 0 : x - 1;
				var ux = x + 1 > width - 1 ? width - 1 : x + 1;

				var points = [];
				var origin = [ 0, 0, data[ ( y * width + x ) * 4 ] / 255 * depth ];
				points.push( [ - 1, 0, data[ ( y * width + lx ) * 4 ] / 255 * depth ] );
				points.push( [ - 1, - 1, data[ ( ly * width + lx ) * 4 ] / 255 * depth ] );
				points.push( [ 0, - 1, data[ ( ly * width + x ) * 4 ] / 255 * depth ] );
				points.push( [  1, - 1, data[ ( ly * width + ux ) * 4 ] / 255 * depth ] );
				points.push( [ 1, 0, data[ ( y * width + ux ) * 4 ] / 255 * depth ] );
				points.push( [ 1, 1, data[ ( uy * width + ux ) * 4 ] / 255 * depth ] );
				points.push( [ 0, 1, data[ ( uy * width + x ) * 4 ] / 255 * depth ] );
				points.push( [ - 1, 1, data[ ( uy * width + lx ) * 4 ] / 255 * depth ] );

				var normals = [];
				var num_points = points.length;

				for ( var i = 0; i < num_points; i ++ ) {

					var v1 = points[ i ];
					var v2 = points[ ( i + 1 ) % num_points ];
					v1 = subtract( v1, origin );
					v2 = subtract( v2, origin );
					normals.push( normalize( cross( v1, v2 ) ) );

				}

				var normal = [ 0, 0, 0 ];

				for ( var i = 0; i < normals.length; i ++ ) {

					normal[ 0 ] += normals[ i ][ 0 ];
					normal[ 1 ] += normals[ i ][ 1 ];
					normal[ 2 ] += normals[ i ][ 2 ];

				}

				normal[ 0 ] /= normals.length;
				normal[ 1 ] /= normals.length;
				normal[ 2 ] /= normals.length;

				var idx = ( y * width + x ) * 4;

				output[ idx ] = ( ( normal[ 0 ] + 1.0 ) / 2.0 * 255 ) | 0;
				output[ idx + 1 ] = ( ( normal[ 1 ] + 1.0 ) / 2.0 * 255 ) | 0;
				output[ idx + 2 ] = ( normal[ 2 ] * 255 ) | 0;
				output[ idx + 3 ] = 255;

			}

		}

		context.putImageData( imageData, 0, 0 );

		return canvas;

	},

	generateDataTexture: function ( width, height, color ) {

		var size = width * height;
		var data = new Uint8Array( 3 * size );

		var r = Math.floor( color.r * 255 );
		var g = Math.floor( color.g * 255 );
		var b = Math.floor( color.b * 255 );

		for ( var i = 0; i < size; i ++ ) {

			data[ i * 3 ] 	  = r;
			data[ i * 3 + 1 ] = g;
			data[ i * 3 + 2 ] = b;

		}

		var texture = new THREE.DataTexture( data, width, height, THREE.RGBFormat );
		texture.needsUpdate = true;

		return texture;

	}

};

/**
 * @author alteredq / http://alteredqualia.com/
 */

THREE.SceneUtils = {

	createMultiMaterialObject: function ( geometry, materials ) {

		var group = new THREE.Object3D();

		for ( var i = 0, l = materials.length; i < l; i ++ ) {

			group.add( new THREE.Mesh( geometry, materials[ i ] ) );

		}

		return group;

	},

	detach : function ( child, parent, scene ) {

		child.applyMatrix( parent.matrixWorld );
		parent.remove( child );
		scene.add( child );

	},

	attach: function ( child, scene, parent ) {

		var matrixWorldInverse = new THREE.Matrix4();
		matrixWorldInverse.getInverse( parent.matrixWorld );
		child.applyMatrix( matrixWorldInverse );

		scene.remove( child );
		parent.add( child );

	}

};

/**
 * @author zz85 / http://www.lab4games.net/zz85/blog
 * @author alteredq / http://alteredqualia.com/
 *
 * For Text operations in three.js (See TextGeometry)
 *
 * It uses techniques used in:
 *
 * 	typeface.js and canvastext
 * 		For converting fonts and rendering with javascript
 *		http://typeface.neocracy.org
 *
 *	Triangulation ported from AS3
 *		Simple Polygon Triangulation
 *		http://actionsnippet.com/?p=1462
 *
 * 	A Method to triangulate shapes with holes
 *		http://www.sakri.net/blog/2009/06/12/an-approach-to-triangulating-polygons-with-holes/
 *
 */

THREE.FontUtils = {

	faces : {},

	// Just for now. face[weight][style]

	face : "helvetiker",
	weight: "normal",
	style : "normal",
	size : 150,
	divisions : 10,

	getFace : function() {

		return this.faces[ this.face ][ this.weight ][ this.style ];

	},

	loadFace : function( data ) {

		var family = data.familyName.toLowerCase();

		var ThreeFont = this;

		ThreeFont.faces[ family ] = ThreeFont.faces[ family ] || {};

		ThreeFont.faces[ family ][ data.cssFontWeight ] = ThreeFont.faces[ family ][ data.cssFontWeight ] || {};
		ThreeFont.faces[ family ][ data.cssFontWeight ][ data.cssFontStyle ] = data;

		var face = ThreeFont.faces[ family ][ data.cssFontWeight ][ data.cssFontStyle ] = data;

		return data;

	},

	drawText : function( text ) {

		var characterPts = [], allPts = [];

		// RenderText

		var i, p,
			face = this.getFace(),
			scale = this.size / face.resolution,
			offset = 0,
			chars = String( text ).split( '' ),
			length = chars.length;

		var fontPaths = [];

		for ( i = 0; i < length; i ++ ) {

			var path = new THREE.Path();

			var ret = this.extractGlyphPoints( chars[ i ], face, scale, offset, path );
			offset += ret.offset;

			fontPaths.push( ret.path );

		}

		// get the width

		var width = offset / 2;
		//
		// for ( p = 0; p < allPts.length; p++ ) {
		//
		// 	allPts[ p ].x -= width;
		//
		// }

		//var extract = this.extractPoints( allPts, characterPts );
		//extract.contour = allPts;

		//extract.paths = fontPaths;
		//extract.offset = width;

		return { paths : fontPaths, offset : width };

	},




	extractGlyphPoints : function( c, face, scale, offset, path ) {

		var pts = [];

		var i, i2, divisions,
			outline, action, length,
			scaleX, scaleY,
			x, y, cpx, cpy, cpx0, cpy0, cpx1, cpy1, cpx2, cpy2,
			laste,
			glyph = face.glyphs[ c ] || face.glyphs[ '?' ];

		if ( !glyph ) return;

		if ( glyph.o ) {

			outline = glyph._cachedOutline || ( glyph._cachedOutline = glyph.o.split( ' ' ) );
			length = outline.length;

			scaleX = scale;
			scaleY = scale;

			for ( i = 0; i < length; ) {

				action = outline[ i ++ ];

				//console.log( action );

				switch( action ) {

				case 'm':

					// Move To

					x = outline[ i++ ] * scaleX + offset;
					y = outline[ i++ ] * scaleY;

					path.moveTo( x, y );
					break;

				case 'l':

					// Line To

					x = outline[ i++ ] * scaleX + offset;
					y = outline[ i++ ] * scaleY;
					path.lineTo(x,y);
					break;

				case 'q':

					// QuadraticCurveTo

					cpx  = outline[ i++ ] * scaleX + offset;
					cpy  = outline[ i++ ] * scaleY;
					cpx1 = outline[ i++ ] * scaleX + offset;
					cpy1 = outline[ i++ ] * scaleY;

					path.quadraticCurveTo(cpx1, cpy1, cpx, cpy);

					laste = pts[ pts.length - 1 ];

					if ( laste ) {

						cpx0 = laste.x;
						cpy0 = laste.y;

						for ( i2 = 1, divisions = this.divisions; i2 <= divisions; i2 ++ ) {

							var t = i2 / divisions;
							var tx = THREE.Shape.Utils.b2( t, cpx0, cpx1, cpx );
							var ty = THREE.Shape.Utils.b2( t, cpy0, cpy1, cpy );
					  }

				  }

				  break;

				case 'b':

					// Cubic Bezier Curve

					cpx  = outline[ i++ ] *  scaleX + offset;
					cpy  = outline[ i++ ] *  scaleY;
					cpx1 = outline[ i++ ] *  scaleX + offset;
					cpy1 = outline[ i++ ] * -scaleY;
					cpx2 = outline[ i++ ] *  scaleX + offset;
					cpy2 = outline[ i++ ] * -scaleY;

					path.bezierCurveTo( cpx, cpy, cpx1, cpy1, cpx2, cpy2 );

					laste = pts[ pts.length - 1 ];

					if ( laste ) {

						cpx0 = laste.x;
						cpy0 = laste.y;

						for ( i2 = 1, divisions = this.divisions; i2 <= divisions; i2 ++ ) {

							var t = i2 / divisions;
							var tx = THREE.Shape.Utils.b3( t, cpx0, cpx1, cpx2, cpx );
							var ty = THREE.Shape.Utils.b3( t, cpy0, cpy1, cpy2, cpy );

						}

					}

					break;

				}

			}
		}



		return { offset: glyph.ha*scale, path:path};
	}

};


THREE.FontUtils.generateShapes = function( text, parameters ) {

	// Parameters

	parameters = parameters || {};

	var size = parameters.size !== undefined ? parameters.size : 100;
	var curveSegments = parameters.curveSegments !== undefined ? parameters.curveSegments: 4;

	var font = parameters.font !== undefined ? parameters.font : "helvetiker";
	var weight = parameters.weight !== undefined ? parameters.weight : "normal";
	var style = parameters.style !== undefined ? parameters.style : "normal";

	THREE.FontUtils.size = size;
	THREE.FontUtils.divisions = curveSegments;

	THREE.FontUtils.face = font;
	THREE.FontUtils.weight = weight;
	THREE.FontUtils.style = style;

	// Get a Font data json object

	var data = THREE.FontUtils.drawText( text );

	var paths = data.paths;
	var shapes = [];

	for ( var p = 0, pl = paths.length; p < pl; p ++ ) {

		Array.prototype.push.apply( shapes, paths[ p ].toShapes() );

	}

	return shapes;

};


/**
 * This code is a quick port of code written in C++ which was submitted to
 * flipcode.com by John W. Ratcliff  // July 22, 2000
 * See original code and more information here:
 * http://www.flipcode.com/archives/Efficient_Polygon_Triangulation.shtml
 *
 * ported to actionscript by Zevan Rosser
 * www.actionsnippet.com
 *
 * ported to javascript by Joshua Koo
 * http://www.lab4games.net/zz85/blog
 *
 */


( function( namespace ) {

	var EPSILON = 0.0000000001;

	// takes in an contour array and returns

	var process = function( contour, indices ) {

		var n = contour.length;

		if ( n < 3 ) return null;

		var result = [],
			verts = [],
			vertIndices = [];

		/* we want a counter-clockwise polygon in verts */

		var u, v, w;

		if ( area( contour ) > 0.0 ) {

			for ( v = 0; v < n; v++ ) verts[ v ] = v;

		} else {

			for ( v = 0; v < n; v++ ) verts[ v ] = ( n - 1 ) - v;

		}

		var nv = n;

		/*  remove nv - 2 vertices, creating 1 triangle every time */

		var count = 2 * nv;   /* error detection */

		for( v = nv - 1; nv > 2; ) {

			/* if we loop, it is probably a non-simple polygon */

			if ( ( count-- ) <= 0 ) {

				//** Triangulate: ERROR - probable bad polygon!

				//throw ( "Warning, unable to triangulate polygon!" );
				//return null;
				// Sometimes warning is fine, especially polygons are triangulated in reverse.
				console.log( "Warning, unable to triangulate polygon!" );

				if ( indices ) return vertIndices;
				return result;

			}

			/* three consecutive vertices in current polygon, <u,v,w> */

			u = v; 	 	if ( nv <= u ) u = 0;     /* previous */
			v = u + 1;  if ( nv <= v ) v = 0;     /* new v    */
			w = v + 1;  if ( nv <= w ) w = 0;     /* next     */

			if ( snip( contour, u, v, w, nv, verts ) ) {

				var a, b, c, s, t;

				/* true names of the vertices */

				a = verts[ u ];
				b = verts[ v ];
				c = verts[ w ];

				/* output Triangle */

				result.push( [ contour[ a ],
					contour[ b ],
					contour[ c ] ] );


				vertIndices.push( [ verts[ u ], verts[ v ], verts[ w ] ] );

				/* remove v from the remaining polygon */

				for( s = v, t = v + 1; t < nv; s++, t++ ) {

					verts[ s ] = verts[ t ];

				}

				nv--;

				/* reset error detection counter */

				count = 2 * nv;

			}

		}

		if ( indices ) return vertIndices;
		return result;

	};

	// calculate area of the contour polygon

	var area = function ( contour ) {

		var n = contour.length;
		var a = 0.0;

		for( var p = n - 1, q = 0; q < n; p = q++ ) {

			a += contour[ p ].x * contour[ q ].y - contour[ q ].x * contour[ p ].y;

		}

		return a * 0.5;

	};

	var snip = function ( contour, u, v, w, n, verts ) {

		var p;
		var ax, ay, bx, by;
		var cx, cy, px, py;

		ax = contour[ verts[ u ] ].x;
		ay = contour[ verts[ u ] ].y;

		bx = contour[ verts[ v ] ].x;
		by = contour[ verts[ v ] ].y;

		cx = contour[ verts[ w ] ].x;
		cy = contour[ verts[ w ] ].y;

		if ( EPSILON > (((bx-ax)*(cy-ay)) - ((by-ay)*(cx-ax))) ) return false;

		var aX, aY, bX, bY, cX, cY;
		var apx, apy, bpx, bpy, cpx, cpy;
		var cCROSSap, bCROSScp, aCROSSbp;

		aX = cx - bx;  aY = cy - by;
		bX = ax - cx;  bY = ay - cy;
		cX = bx - ax;  cY = by - ay;

		for ( p = 0; p < n; p++ ) {

			if( (p === u) || (p === v) || (p === w) ) continue;

			px = contour[ verts[ p ] ].x
			py = contour[ verts[ p ] ].y

			apx = px - ax;  apy = py - ay;
			bpx = px - bx;  bpy = py - by;
			cpx = px - cx;  cpy = py - cy;

			// see if p is inside triangle abc

			aCROSSbp = aX*bpy - aY*bpx;
			cCROSSap = cX*apy - cY*apx;
			bCROSScp = bX*cpy - bY*cpx;

			if ( (aCROSSbp >= -EPSILON) && (bCROSScp >= -EPSILON) && (cCROSSap >= -EPSILON) ) return false;

		}

		return true;

	};


	namespace.Triangulate = process;
	namespace.Triangulate.area = area;

	return namespace;

})(THREE.FontUtils);

// To use the typeface.js face files, hook up the API
self._typeface_js = { faces: THREE.FontUtils.faces, loadFace: THREE.FontUtils.loadFace };
THREE.typeface_js = self._typeface_js;

/**
 * @author zz85 / http://www.lab4games.net/zz85/blog
 * Extensible curve object
 *
 * Some common of Curve methods
 * .getPoint(t), getTangent(t)
 * .getPointAt(u), getTagentAt(u)
 * .getPoints(), .getSpacedPoints()
 * .getLength()
 * .updateArcLengths()
 *
 * This following classes subclasses THREE.Curve:
 *
 * -- 2d classes --
 * THREE.LineCurve
 * THREE.QuadraticBezierCurve
 * THREE.CubicBezierCurve
 * THREE.SplineCurve
 * THREE.ArcCurve
 * THREE.EllipseCurve
 *
 * -- 3d classes --
 * THREE.LineCurve3
 * THREE.QuadraticBezierCurve3
 * THREE.CubicBezierCurve3
 * THREE.SplineCurve3
 * THREE.ClosedSplineCurve3
 *
 * A series of curves can be represented as a THREE.CurvePath
 *
 **/

/**************************************************************
 *	Abstract Curve base class
 **************************************************************/

THREE.Curve = function () {

};

// Virtual base class method to overwrite and implement in subclasses
//	- t [0 .. 1]

THREE.Curve.prototype.getPoint = function ( t ) {

	console.log( "Warning, getPoint() not implemented!" );
	return null;

};

// Get point at relative position in curve according to arc length
// - u [0 .. 1]

THREE.Curve.prototype.getPointAt = function ( u ) {

	var t = this.getUtoTmapping( u );
	return this.getPoint( t );

};

// Get sequence of points using getPoint( t )

THREE.Curve.prototype.getPoints = function ( divisions ) {

	if ( !divisions ) divisions = 5;

	var d, pts = [];

	for ( d = 0; d <= divisions; d ++ ) {

		pts.push( this.getPoint( d / divisions ) );

	}

	return pts;

};

// Get sequence of points using getPointAt( u )

THREE.Curve.prototype.getSpacedPoints = function ( divisions ) {

	if ( !divisions ) divisions = 5;

	var d, pts = [];

	for ( d = 0; d <= divisions; d ++ ) {

		pts.push( this.getPointAt( d / divisions ) );

	}

	return pts;

};

// Get total curve arc length

THREE.Curve.prototype.getLength = function () {

	var lengths = this.getLengths();
	return lengths[ lengths.length - 1 ];

};

// Get list of cumulative segment lengths

THREE.Curve.prototype.getLengths = function ( divisions ) {

	if ( !divisions ) divisions = (this.__arcLengthDivisions) ? (this.__arcLengthDivisions): 200;

	if ( this.cacheArcLengths
		&& ( this.cacheArcLengths.length == divisions + 1 )
		&& !this.needsUpdate) {

		//console.log( "cached", this.cacheArcLengths );
		return this.cacheArcLengths;

	}

	this.needsUpdate = false;

	var cache = [];
	var current, last = this.getPoint( 0 );
	var p, sum = 0;

	cache.push( 0 );

	for ( p = 1; p <= divisions; p ++ ) {

		current = this.getPoint ( p / divisions );
		sum += current.distanceTo( last );
		cache.push( sum );
		last = current;

	}

	this.cacheArcLengths = cache;

	return cache; // { sums: cache, sum:sum }; Sum is in the last element.

};


THREE.Curve.prototype.updateArcLengths = function() {
	this.needsUpdate = true;
	this.getLengths();
};

// Given u ( 0 .. 1 ), get a t to find p. This gives you points which are equi distance

THREE.Curve.prototype.getUtoTmapping = function ( u, distance ) {

	var arcLengths = this.getLengths();

	var i = 0, il = arcLengths.length;

	var targetArcLength; // The targeted u distance value to get

	if ( distance ) {

		targetArcLength = distance;

	} else {

		targetArcLength = u * arcLengths[ il - 1 ];

	}

	//var time = Date.now();

	// binary search for the index with largest value smaller than target u distance

	var low = 0, high = il - 1, comparison;

	while ( low <= high ) {

		i = Math.floor( low + ( high - low ) / 2 ); // less likely to overflow, though probably not issue here, JS doesn't really have integers, all numbers are floats

		comparison = arcLengths[ i ] - targetArcLength;

		if ( comparison < 0 ) {

			low = i + 1;
			continue;

		} else if ( comparison > 0 ) {

			high = i - 1;
			continue;

		} else {

			high = i;
			break;

			// DONE

		}

	}

	i = high;

	//console.log('b' , i, low, high, Date.now()- time);

	if ( arcLengths[ i ] == targetArcLength ) {

		var t = i / ( il - 1 );
		return t;

	}

	// we could get finer grain at lengths, or use simple interpolatation between two points

	var lengthBefore = arcLengths[ i ];
    var lengthAfter = arcLengths[ i + 1 ];

    var segmentLength = lengthAfter - lengthBefore;

    // determine where we are between the 'before' and 'after' points

    var segmentFraction = ( targetArcLength - lengthBefore ) / segmentLength;

    // add that fractional amount to t

    var t = ( i + segmentFraction ) / ( il -1 );

	return t;

};

// Returns a unit vector tangent at t
// In case any sub curve does not implement its tangent derivation,
// 2 points a small delta apart will be used to find its gradient
// which seems to give a reasonable approximation

THREE.Curve.prototype.getTangent = function( t ) {

	var delta = 0.0001;
	var t1 = t - delta;
	var t2 = t + delta;

	// Capping in case of danger

	if ( t1 < 0 ) t1 = 0;
	if ( t2 > 1 ) t2 = 1;

	var pt1 = this.getPoint( t1 );
	var pt2 = this.getPoint( t2 );

	var vec = pt2.clone().sub(pt1);
	return vec.normalize();

};


THREE.Curve.prototype.getTangentAt = function ( u ) {

	var t = this.getUtoTmapping( u );
	return this.getTangent( t );

};





/**************************************************************
 *	Utils
 **************************************************************/

THREE.Curve.Utils = {

	tangentQuadraticBezier: function ( t, p0, p1, p2 ) {

		return 2 * ( 1 - t ) * ( p1 - p0 ) + 2 * t * ( p2 - p1 );

	},

	// Puay Bing, thanks for helping with this derivative!

	tangentCubicBezier: function (t, p0, p1, p2, p3 ) {

		return -3 * p0 * (1 - t) * (1 - t)  +
			3 * p1 * (1 - t) * (1-t) - 6 *t *p1 * (1-t) +
			6 * t *  p2 * (1-t) - 3 * t * t * p2 +
			3 * t * t * p3;
	},


	tangentSpline: function ( t, p0, p1, p2, p3 ) {

		// To check if my formulas are correct

		var h00 = 6 * t * t - 6 * t; 	// derived from 2t^3  3t^2 + 1
		var h10 = 3 * t * t - 4 * t + 1; // t^3  2t^2 + t
		var h01 = -6 * t * t + 6 * t; 	//  2t3 + 3t2
		var h11 = 3 * t * t - 2 * t;	// t3  t2

		return h00 + h10 + h01 + h11;

	},

	// Catmull-Rom

	interpolate: function( p0, p1, p2, p3, t ) {

		var v0 = ( p2 - p0 ) * 0.5;
		var v1 = ( p3 - p1 ) * 0.5;
		var t2 = t * t;
		var t3 = t * t2;
		return ( 2 * p1 - 2 * p2 + v0 + v1 ) * t3 + ( - 3 * p1 + 3 * p2 - 2 * v0 - v1 ) * t2 + v0 * t + p1;

	}

};


// TODO: Transformation for Curves?

/**************************************************************
 *	3D Curves
 **************************************************************/

// A Factory method for creating new curve subclasses

THREE.Curve.create = function ( constructor, getPointFunc ) {

	constructor.prototype = Object.create( THREE.Curve.prototype );
	constructor.prototype.getPoint = getPointFunc;

	return constructor;

};

/**
 * @author zz85 / http://www.lab4games.net/zz85/blog
 *
 **/

/**************************************************************
 *	Curved Path - a curve path is simply a array of connected
 *  curves, but retains the api of a curve
 **************************************************************/

THREE.CurvePath = function () {

	this.curves = [];
	this.bends = [];

	this.autoClose = false; // Automatically closes the path
};

THREE.CurvePath.prototype = Object.create( THREE.Curve.prototype );

THREE.CurvePath.prototype.add = function ( curve ) {

	this.curves.push( curve );

};

THREE.CurvePath.prototype.checkConnection = function() {
	// TODO
	// If the ending of curve is not connected to the starting
	// or the next curve, then, this is not a real path
};

THREE.CurvePath.prototype.closePath = function() {
	// TODO Test
	// and verify for vector3 (needs to implement equals)
	// Add a line curve if start and end of lines are not connected
	var startPoint = this.curves[0].getPoint(0);
	var endPoint = this.curves[this.curves.length-1].getPoint(1);

	if (!startPoint.equals(endPoint)) {
		this.curves.push( new THREE.LineCurve(endPoint, startPoint) );
	}

};

// To get accurate point with reference to
// entire path distance at time t,
// following has to be done:

// 1. Length of each sub path have to be known
// 2. Locate and identify type of curve
// 3. Get t for the curve
// 4. Return curve.getPointAt(t')

THREE.CurvePath.prototype.getPoint = function( t ) {

	var d = t * this.getLength();
	var curveLengths = this.getCurveLengths();
	var i = 0, diff, curve;

	// To think about boundaries points.

	while ( i < curveLengths.length ) {

		if ( curveLengths[ i ] >= d ) {

			diff = curveLengths[ i ] - d;
			curve = this.curves[ i ];

			var u = 1 - diff / curve.getLength();

			return curve.getPointAt( u );

			break;
		}

		i ++;

	}

	return null;

	// loop where sum != 0, sum > d , sum+1 <d

};

/*
THREE.CurvePath.prototype.getTangent = function( t ) {
};*/


// We cannot use the default THREE.Curve getPoint() with getLength() because in
// THREE.Curve, getLength() depends on getPoint() but in THREE.CurvePath
// getPoint() depends on getLength

THREE.CurvePath.prototype.getLength = function() {

	var lens = this.getCurveLengths();
	return lens[ lens.length - 1 ];

};

// Compute lengths and cache them
// We cannot overwrite getLengths() because UtoT mapping uses it.

THREE.CurvePath.prototype.getCurveLengths = function() {

	// We use cache values if curves and cache array are same length

	if ( this.cacheLengths && this.cacheLengths.length == this.curves.length ) {

		return this.cacheLengths;

	};

	// Get length of subsurve
	// Push sums into cached array

	var lengths = [], sums = 0;
	var i, il = this.curves.length;

	for ( i = 0; i < il; i ++ ) {

		sums += this.curves[ i ].getLength();
		lengths.push( sums );

	}

	this.cacheLengths = lengths;

	return lengths;

};



// Returns min and max coordinates, as well as centroid

THREE.CurvePath.prototype.getBoundingBox = function () {

	var points = this.getPoints();

	var maxX, maxY, maxZ;
	var minX, minY, minZ;

	maxX = maxY = Number.NEGATIVE_INFINITY;
	minX = minY = Number.POSITIVE_INFINITY;

	var p, i, il, sum;

	var v3 = points[0] instanceof THREE.Vector3;

	sum = v3 ? new THREE.Vector3() : new THREE.Vector2();

	for ( i = 0, il = points.length; i < il; i ++ ) {

		p = points[ i ];

		if ( p.x > maxX ) maxX = p.x;
		else if ( p.x < minX ) minX = p.x;

		if ( p.y > maxY ) maxY = p.y;
		else if ( p.y < minY ) minY = p.y;

		if ( v3 ) {

			if ( p.z > maxZ ) maxZ = p.z;
			else if ( p.z < minZ ) minZ = p.z;

		}

		sum.add( p );

	}

	var ret = {

		minX: minX,
		minY: minY,
		maxX: maxX,
		maxY: maxY,
		centroid: sum.divideScalar( il )

	};

	if ( v3 ) {

		ret.maxZ = maxZ;
		ret.minZ = minZ;

	}

	return ret;

};

/**************************************************************
 *	Create Geometries Helpers
 **************************************************************/

/// Generate geometry from path points (for Line or ParticleSystem objects)

THREE.CurvePath.prototype.createPointsGeometry = function( divisions ) {

	var pts = this.getPoints( divisions, true );
	return this.createGeometry( pts );

};

// Generate geometry from equidistance sampling along the path

THREE.CurvePath.prototype.createSpacedPointsGeometry = function( divisions ) {

	var pts = this.getSpacedPoints( divisions, true );
	return this.createGeometry( pts );

};

THREE.CurvePath.prototype.createGeometry = function( points ) {

	var geometry = new THREE.Geometry();

	for ( var i = 0; i < points.length; i ++ ) {

		geometry.vertices.push( new THREE.Vector3( points[ i ].x, points[ i ].y, points[ i ].z || 0) );

	}

	return geometry;

};


/**************************************************************
 *	Bend / Wrap Helper Methods
 **************************************************************/

// Wrap path / Bend modifiers?

THREE.CurvePath.prototype.addWrapPath = function ( bendpath ) {

	this.bends.push( bendpath );

};

THREE.CurvePath.prototype.getTransformedPoints = function( segments, bends ) {

	var oldPts = this.getPoints( segments ); // getPoints getSpacedPoints
	var i, il;

	if ( !bends ) {

		bends = this.bends;

	}

	for ( i = 0, il = bends.length; i < il; i ++ ) {

		oldPts = this.getWrapPoints( oldPts, bends[ i ] );

	}

	return oldPts;

};

THREE.CurvePath.prototype.getTransformedSpacedPoints = function( segments, bends ) {

	var oldPts = this.getSpacedPoints( segments );

	var i, il;

	if ( !bends ) {

		bends = this.bends;

	}

	for ( i = 0, il = bends.length; i < il; i ++ ) {

		oldPts = this.getWrapPoints( oldPts, bends[ i ] );

	}

	return oldPts;

};

// This returns getPoints() bend/wrapped around the contour of a path.
// Read http://www.planetclegg.com/projects/WarpingTextToSplines.html

THREE.CurvePath.prototype.getWrapPoints = function ( oldPts, path ) {

	var bounds = this.getBoundingBox();

	var i, il, p, oldX, oldY, xNorm;

	for ( i = 0, il = oldPts.length; i < il; i ++ ) {

		p = oldPts[ i ];

		oldX = p.x;
		oldY = p.y;

		xNorm = oldX / bounds.maxX;

		// If using actual distance, for length > path, requires line extrusions
		//xNorm = path.getUtoTmapping(xNorm, oldX); // 3 styles. 1) wrap stretched. 2) wrap stretch by arc length 3) warp by actual distance

		xNorm = path.getUtoTmapping( xNorm, oldX );

		// check for out of bounds?

		var pathPt = path.getPoint( xNorm );
		var normal = path.getTangent( xNorm );
		normal.set( -normal.y, normal.x ).multiplyScalar( oldY );

		p.x = pathPt.x + normal.x;
		p.y = pathPt.y + normal.y;

	}

	return oldPts;

};


/**
 * @author alteredq / http://alteredqualia.com/
 */

THREE.Gyroscope = function () {

	THREE.Object3D.call( this );

};

THREE.Gyroscope.prototype = Object.create( THREE.Object3D.prototype );

THREE.Gyroscope.prototype.updateMatrixWorld = function ( force ) {

	this.matrixAutoUpdate && this.updateMatrix();

	// update matrixWorld

	if ( this.matrixWorldNeedsUpdate || force ) {

		if ( this.parent ) {

			this.matrixWorld.multiplyMatrices( this.parent.matrixWorld, this.matrix );

			this.matrixWorld.decompose( this.translationWorld, this.quaternionWorld, this.scaleWorld );
			this.matrix.decompose( this.translationObject, this.quaternionObject, this.scaleObject );

			this.matrixWorld.compose( this.translationWorld, this.quaternionObject, this.scaleWorld );


		} else {

			this.matrixWorld.copy( this.matrix );

		}


		this.matrixWorldNeedsUpdate = false;

		force = true;

	}

	// update children

	for ( var i = 0, l = this.children.length; i < l; i ++ ) {

		this.children[ i ].updateMatrixWorld( force );

	}

};

THREE.Gyroscope.prototype.translationWorld = new THREE.Vector3();
THREE.Gyroscope.prototype.translationObject = new THREE.Vector3();
THREE.Gyroscope.prototype.quaternionWorld = new THREE.Quaternion();
THREE.Gyroscope.prototype.quaternionObject = new THREE.Quaternion();
THREE.Gyroscope.prototype.scaleWorld = new THREE.Vector3();
THREE.Gyroscope.prototype.scaleObject = new THREE.Vector3();


/**
 * @author zz85 / http://www.lab4games.net/zz85/blog
 * Creates free form 2d path using series of points, lines or curves.
 *
 **/

THREE.Path = function ( points ) {

	THREE.CurvePath.call(this);

	this.actions = [];

	if ( points ) {

		this.fromPoints( points );

	}

};

THREE.Path.prototype = Object.create( THREE.CurvePath.prototype );

THREE.PathActions = {

	MOVE_TO: 'moveTo',
	LINE_TO: 'lineTo',
	QUADRATIC_CURVE_TO: 'quadraticCurveTo', // Bezier quadratic curve
	BEZIER_CURVE_TO: 'bezierCurveTo', 		// Bezier cubic curve
	CSPLINE_THRU: 'splineThru',				// Catmull-rom spline
	ARC: 'arc',								// Circle
	ELLIPSE: 'ellipse'
};

// TODO Clean up PATH API

// Create path using straight lines to connect all points
// - vectors: array of Vector2

THREE.Path.prototype.fromPoints = function ( vectors ) {

	this.moveTo( vectors[ 0 ].x, vectors[ 0 ].y );

	for ( var v = 1, vlen = vectors.length; v < vlen; v ++ ) {

		this.lineTo( vectors[ v ].x, vectors[ v ].y );

	};

};

// startPath() endPath()?

THREE.Path.prototype.moveTo = function ( x, y ) {

	var args = Array.prototype.slice.call( arguments );
	this.actions.push( { action: THREE.PathActions.MOVE_TO, args: args } );

};

THREE.Path.prototype.lineTo = function ( x, y ) {

	var args = Array.prototype.slice.call( arguments );

	var lastargs = this.actions[ this.actions.length - 1 ].args;

	var x0 = lastargs[ lastargs.length - 2 ];
	var y0 = lastargs[ lastargs.length - 1 ];

	var curve = new THREE.LineCurve( new THREE.Vector2( x0, y0 ), new THREE.Vector2( x, y ) );
	this.curves.push( curve );

	this.actions.push( { action: THREE.PathActions.LINE_TO, args: args } );

};

THREE.Path.prototype.quadraticCurveTo = function( aCPx, aCPy, aX, aY ) {

	var args = Array.prototype.slice.call( arguments );

	var lastargs = this.actions[ this.actions.length - 1 ].args;

	var x0 = lastargs[ lastargs.length - 2 ];
	var y0 = lastargs[ lastargs.length - 1 ];

	var curve = new THREE.QuadraticBezierCurve( new THREE.Vector2( x0, y0 ),
												new THREE.Vector2( aCPx, aCPy ),
												new THREE.Vector2( aX, aY ) );
	this.curves.push( curve );

	this.actions.push( { action: THREE.PathActions.QUADRATIC_CURVE_TO, args: args } );

};

THREE.Path.prototype.bezierCurveTo = function( aCP1x, aCP1y,
											   aCP2x, aCP2y,
											   aX, aY ) {

	var args = Array.prototype.slice.call( arguments );

	var lastargs = this.actions[ this.actions.length - 1 ].args;

	var x0 = lastargs[ lastargs.length - 2 ];
	var y0 = lastargs[ lastargs.length - 1 ];

	var curve = new THREE.CubicBezierCurve( new THREE.Vector2( x0, y0 ),
											new THREE.Vector2( aCP1x, aCP1y ),
											new THREE.Vector2( aCP2x, aCP2y ),
											new THREE.Vector2( aX, aY ) );
	this.curves.push( curve );

	this.actions.push( { action: THREE.PathActions.BEZIER_CURVE_TO, args: args } );

};

THREE.Path.prototype.splineThru = function( pts /*Array of Vector*/ ) {

	var args = Array.prototype.slice.call( arguments );
	var lastargs = this.actions[ this.actions.length - 1 ].args;

	var x0 = lastargs[ lastargs.length - 2 ];
	var y0 = lastargs[ lastargs.length - 1 ];
//---
	var npts = [ new THREE.Vector2( x0, y0 ) ];
	Array.prototype.push.apply( npts, pts );

	var curve = new THREE.SplineCurve( npts );
	this.curves.push( curve );

	this.actions.push( { action: THREE.PathActions.CSPLINE_THRU, args: args } );

};

// FUTURE: Change the API or follow canvas API?

THREE.Path.prototype.arc = function ( aX, aY, aRadius,
									  aStartAngle, aEndAngle, aClockwise ) {

	var lastargs = this.actions[ this.actions.length - 1].args;
	var x0 = lastargs[ lastargs.length - 2 ];
	var y0 = lastargs[ lastargs.length - 1 ];

	this.absarc(aX + x0, aY + y0, aRadius,
		aStartAngle, aEndAngle, aClockwise );

 };

 THREE.Path.prototype.absarc = function ( aX, aY, aRadius,
									  aStartAngle, aEndAngle, aClockwise ) {
	this.absellipse(aX, aY, aRadius, aRadius, aStartAngle, aEndAngle, aClockwise);
 };

THREE.Path.prototype.ellipse = function ( aX, aY, xRadius, yRadius,
									  aStartAngle, aEndAngle, aClockwise ) {

	var lastargs = this.actions[ this.actions.length - 1].args;
	var x0 = lastargs[ lastargs.length - 2 ];
	var y0 = lastargs[ lastargs.length - 1 ];

	this.absellipse(aX + x0, aY + y0, xRadius, yRadius,
		aStartAngle, aEndAngle, aClockwise );

 };


THREE.Path.prototype.absellipse = function ( aX, aY, xRadius, yRadius,
									  aStartAngle, aEndAngle, aClockwise ) {

	var args = Array.prototype.slice.call( arguments );
	var curve = new THREE.EllipseCurve( aX, aY, xRadius, yRadius,
									aStartAngle, aEndAngle, aClockwise );
	this.curves.push( curve );

	var lastPoint = curve.getPoint(1);
	args.push(lastPoint.x);
	args.push(lastPoint.y);

	this.actions.push( { action: THREE.PathActions.ELLIPSE, args: args } );

 };

THREE.Path.prototype.getSpacedPoints = function ( divisions, closedPath ) {

	if ( ! divisions ) divisions = 40;

	var points = [];

	for ( var i = 0; i < divisions; i ++ ) {

		points.push( this.getPoint( i / divisions ) );

		//if( !this.getPoint( i / divisions ) ) throw "DIE";

	}

	// if ( closedPath ) {
	//
	// 	points.push( points[ 0 ] );
	//
	// }

	return points;

};

/* Return an array of vectors based on contour of the path */

THREE.Path.prototype.getPoints = function( divisions, closedPath ) {

	if (this.useSpacedPoints) {
		console.log('tata');
		return this.getSpacedPoints( divisions, closedPath );
	}

	divisions = divisions || 12;

	var points = [];

	var i, il, item, action, args;
	var cpx, cpy, cpx2, cpy2, cpx1, cpy1, cpx0, cpy0,
		laste, j,
		t, tx, ty;

	for ( i = 0, il = this.actions.length; i < il; i ++ ) {

		item = this.actions[ i ];

		action = item.action;
		args = item.args;

		switch( action ) {

		case THREE.PathActions.MOVE_TO:

			points.push( new THREE.Vector2( args[ 0 ], args[ 1 ] ) );

			break;

		case THREE.PathActions.LINE_TO:

			points.push( new THREE.Vector2( args[ 0 ], args[ 1 ] ) );

			break;

		case THREE.PathActions.QUADRATIC_CURVE_TO:

			cpx  = args[ 2 ];
			cpy  = args[ 3 ];

			cpx1 = args[ 0 ];
			cpy1 = args[ 1 ];

			if ( points.length > 0 ) {

				laste = points[ points.length - 1 ];

				cpx0 = laste.x;
				cpy0 = laste.y;

			} else {

				laste = this.actions[ i - 1 ].args;

				cpx0 = laste[ laste.length - 2 ];
				cpy0 = laste[ laste.length - 1 ];

			}

			for ( j = 1; j <= divisions; j ++ ) {

				t = j / divisions;

				tx = THREE.Shape.Utils.b2( t, cpx0, cpx1, cpx );
				ty = THREE.Shape.Utils.b2( t, cpy0, cpy1, cpy );

				points.push( new THREE.Vector2( tx, ty ) );

			}

			break;

		case THREE.PathActions.BEZIER_CURVE_TO:

			cpx  = args[ 4 ];
			cpy  = args[ 5 ];

			cpx1 = args[ 0 ];
			cpy1 = args[ 1 ];

			cpx2 = args[ 2 ];
			cpy2 = args[ 3 ];

			if ( points.length > 0 ) {

				laste = points[ points.length - 1 ];

				cpx0 = laste.x;
				cpy0 = laste.y;

			} else {

				laste = this.actions[ i - 1 ].args;

				cpx0 = laste[ laste.length - 2 ];
				cpy0 = laste[ laste.length - 1 ];

			}


			for ( j = 1; j <= divisions; j ++ ) {

				t = j / divisions;

				tx = THREE.Shape.Utils.b3( t, cpx0, cpx1, cpx2, cpx );
				ty = THREE.Shape.Utils.b3( t, cpy0, cpy1, cpy2, cpy );

				points.push( new THREE.Vector2( tx, ty ) );

			}

			break;

		case THREE.PathActions.CSPLINE_THRU:

			laste = this.actions[ i - 1 ].args;

			var last = new THREE.Vector2( laste[ laste.length - 2 ], laste[ laste.length - 1 ] );
			var spts = [ last ];

			var n = divisions * args[ 0 ].length;

			spts = spts.concat( args[ 0 ] );

			var spline = new THREE.SplineCurve( spts );

			for ( j = 1; j <= n; j ++ ) {

				points.push( spline.getPointAt( j / n ) ) ;

			}

			break;

		case THREE.PathActions.ARC:

			var aX = args[ 0 ], aY = args[ 1 ],
				aRadius = args[ 2 ],
				aStartAngle = args[ 3 ], aEndAngle = args[ 4 ],
				aClockwise = !!args[ 5 ];

			var deltaAngle = aEndAngle - aStartAngle;
			var angle;
			var tdivisions = divisions * 2;

			for ( j = 1; j <= tdivisions; j ++ ) {

				t = j / tdivisions;

				if ( ! aClockwise ) {

					t = 1 - t;

				}

				angle = aStartAngle + t * deltaAngle;

				tx = aX + aRadius * Math.cos( angle );
				ty = aY + aRadius * Math.sin( angle );

				//console.log('t', t, 'angle', angle, 'tx', tx, 'ty', ty);

				points.push( new THREE.Vector2( tx, ty ) );

			}

			//console.log(points);

		  break;

		case THREE.PathActions.ELLIPSE:

			var aX = args[ 0 ], aY = args[ 1 ],
				xRadius = args[ 2 ],
				yRadius = args[ 3 ],
				aStartAngle = args[ 4 ], aEndAngle = args[ 5 ],
				aClockwise = !!args[ 6 ];


			var deltaAngle = aEndAngle - aStartAngle;
			var angle;
			var tdivisions = divisions * 2;

			for ( j = 1; j <= tdivisions; j ++ ) {

				t = j / tdivisions;

				if ( ! aClockwise ) {

					t = 1 - t;

				}

				angle = aStartAngle + t * deltaAngle;

				tx = aX + xRadius * Math.cos( angle );
				ty = aY + yRadius * Math.sin( angle );

				//console.log('t', t, 'angle', angle, 'tx', tx, 'ty', ty);

				points.push( new THREE.Vector2( tx, ty ) );

			}

			//console.log(points);

		  break;

		} // end switch

	}



	// Normalize to remove the closing point by default.
	var lastPoint = points[ points.length - 1];
	var EPSILON = 0.0000000001;
	if ( Math.abs(lastPoint.x - points[ 0 ].x) < EPSILON &&
			 Math.abs(lastPoint.y - points[ 0 ].y) < EPSILON)
		points.splice( points.length - 1, 1);
	if ( closedPath ) {

		points.push( points[ 0 ] );

	}

	return points;

};

// Breaks path into shapes

THREE.Path.prototype.toShapes = function( isCCW ) {

	var i, il, item, action, args;

	var subPaths = [], lastPath = new THREE.Path();

	for ( i = 0, il = this.actions.length; i < il; i ++ ) {

		item = this.actions[ i ];

		args = item.args;
		action = item.action;

		if ( action == THREE.PathActions.MOVE_TO ) {

			if ( lastPath.actions.length != 0 ) {

				subPaths.push( lastPath );
				lastPath = new THREE.Path();

			}

		}

		lastPath[ action ].apply( lastPath, args );

	}

	if ( lastPath.actions.length != 0 ) {

		subPaths.push( lastPath );

	}

	// console.log(subPaths);

	if ( subPaths.length == 0 ) return [];

	var solid, tmpPath, tmpShape, shapes = [];

	if ( subPaths.length == 1) {

		tmpPath = subPaths[0];
		tmpShape = new THREE.Shape();
		tmpShape.actions = tmpPath.actions;
		tmpShape.curves = tmpPath.curves;
		shapes.push( tmpShape );
		return shapes;

	}

	var holesFirst = !THREE.Shape.Utils.isClockWise( subPaths[ 0 ].getPoints() );
	holesFirst = isCCW ? !holesFirst : holesFirst;

	// console.log("Holes first", holesFirst);

	if ( holesFirst ) {

		tmpShape = new THREE.Shape();

		for ( i = 0, il = subPaths.length; i < il; i ++ ) {

			tmpPath = subPaths[ i ];
			solid = THREE.Shape.Utils.isClockWise( tmpPath.getPoints() );
			solid = isCCW ? !solid : solid;

			if ( solid ) {

				tmpShape.actions = tmpPath.actions;
				tmpShape.curves = tmpPath.curves;

				shapes.push( tmpShape );
				tmpShape = new THREE.Shape();

				//console.log('cw', i);

			} else {

				tmpShape.holes.push( tmpPath );

				//console.log('ccw', i);

			}

		}

	} else {

		// Shapes first
		tmpShape = undefined;

		for ( i = 0, il = subPaths.length; i < il; i ++ ) {

			tmpPath = subPaths[ i ];
			solid = THREE.Shape.Utils.isClockWise( tmpPath.getPoints() );
			solid = isCCW ? !solid : solid;

			if ( solid ) {

				if ( tmpShape ) shapes.push( tmpShape );

				tmpShape = new THREE.Shape();
				tmpShape.actions = tmpPath.actions;
				tmpShape.curves = tmpPath.curves;

			} else {

				tmpShape.holes.push( tmpPath );

			}

		}

		shapes.push( tmpShape );

	}

	//console.log("shape", shapes);

	return shapes;

};

/**
 * @author zz85 / http://www.lab4games.net/zz85/blog
 * Defines a 2d shape plane using paths.
 **/

// STEP 1 Create a path.
// STEP 2 Turn path into shape.
// STEP 3 ExtrudeGeometry takes in Shape/Shapes
// STEP 3a - Extract points from each shape, turn to vertices
// STEP 3b - Triangulate each shape, add faces.

THREE.Shape = function () {

	THREE.Path.apply( this, arguments );
	this.holes = [];

};

THREE.Shape.prototype = Object.create( THREE.Path.prototype );

// Convenience method to return ExtrudeGeometry

THREE.Shape.prototype.extrude = function ( options ) {

	var extruded = new THREE.ExtrudeGeometry( this, options );
	return extruded;

};

// Convenience method to return ShapeGeometry

THREE.Shape.prototype.makeGeometry = function ( options ) {

	var geometry = new THREE.ShapeGeometry( this, options );
	return geometry;

};

// Get points of holes

THREE.Shape.prototype.getPointsHoles = function ( divisions ) {

	var i, il = this.holes.length, holesPts = [];

	for ( i = 0; i < il; i ++ ) {

		holesPts[ i ] = this.holes[ i ].getTransformedPoints( divisions, this.bends );

	}

	return holesPts;

};

// Get points of holes (spaced by regular distance)

THREE.Shape.prototype.getSpacedPointsHoles = function ( divisions ) {

	var i, il = this.holes.length, holesPts = [];

	for ( i = 0; i < il; i ++ ) {

		holesPts[ i ] = this.holes[ i ].getTransformedSpacedPoints( divisions, this.bends );

	}

	return holesPts;

};


// Get points of shape and holes (keypoints based on segments parameter)

THREE.Shape.prototype.extractAllPoints = function ( divisions ) {

	return {

		shape: this.getTransformedPoints( divisions ),
		holes: this.getPointsHoles( divisions )

	};

};

THREE.Shape.prototype.extractPoints = function ( divisions ) {

	if (this.useSpacedPoints) {
		return this.extractAllSpacedPoints(divisions);
	}

	return this.extractAllPoints(divisions);

};

//
// THREE.Shape.prototype.extractAllPointsWithBend = function ( divisions, bend ) {
//
// 	return {
//
// 		shape: this.transform( bend, divisions ),
// 		holes: this.getPointsHoles( divisions, bend )
//
// 	};
//
// };

// Get points of shape and holes (spaced by regular distance)

THREE.Shape.prototype.extractAllSpacedPoints = function ( divisions ) {

	return {

		shape: this.getTransformedSpacedPoints( divisions ),
		holes: this.getSpacedPointsHoles( divisions )

	};

};

/**************************************************************
 *	Utils
 **************************************************************/

THREE.Shape.Utils = {

	/*
		contour - array of vector2 for contour
		holes   - array of array of vector2
	*/

	removeHoles: function ( contour, holes ) {

		var shape = contour.concat(); // work on this shape
		var allpoints = shape.concat();

		/* For each isolated shape, find the closest points and break to the hole to allow triangulation */


		var prevShapeVert, nextShapeVert,
			prevHoleVert, nextHoleVert,
			holeIndex, shapeIndex,
			shapeId, shapeGroup,
			h, h2,
			hole, shortest, d,
			p, pts1, pts2,
			tmpShape1, tmpShape2,
			tmpHole1, tmpHole2,
			verts = [];

		for ( h = 0; h < holes.length; h ++ ) {

			hole = holes[ h ];

			/*
			shapeholes[ h ].concat(); // preserves original
			holes.push( hole );
			*/

			Array.prototype.push.apply( allpoints, hole );

			shortest = Number.POSITIVE_INFINITY;


			// Find the shortest pair of pts between shape and hole

			// Note: Actually, I'm not sure now if we could optimize this to be faster than O(m*n)
			// Using distanceToSquared() intead of distanceTo() should speed a little
			// since running square roots operations are reduced.

			for ( h2 = 0; h2 < hole.length; h2 ++ ) {

				pts1 = hole[ h2 ];
				var dist = [];

				for ( p = 0; p < shape.length; p++ ) {

					pts2 = shape[ p ];
					d = pts1.distanceToSquared( pts2 );
					dist.push( d );

					if ( d < shortest ) {

						shortest = d;
						holeIndex = h2;
						shapeIndex = p;

					}

				}

			}

			//console.log("shortest", shortest, dist);

			prevShapeVert = ( shapeIndex - 1 ) >= 0 ? shapeIndex - 1 : shape.length - 1;
			prevHoleVert = ( holeIndex - 1 ) >= 0 ? holeIndex - 1 : hole.length - 1;

			var areaapts = [

				hole[ holeIndex ],
				shape[ shapeIndex ],
				shape[ prevShapeVert ]

			];

			var areaa = THREE.FontUtils.Triangulate.area( areaapts );

			var areabpts = [

				hole[ holeIndex ],
				hole[ prevHoleVert ],
				shape[ shapeIndex ]

			];

			var areab = THREE.FontUtils.Triangulate.area( areabpts );

			var shapeOffset = 1;
			var holeOffset = -1;

			var oldShapeIndex = shapeIndex, oldHoleIndex = holeIndex;
			shapeIndex += shapeOffset;
			holeIndex += holeOffset;

			if ( shapeIndex < 0 ) { shapeIndex += shape.length;  }
			shapeIndex %= shape.length;

			if ( holeIndex < 0 ) { holeIndex += hole.length;  }
			holeIndex %= hole.length;

			prevShapeVert = ( shapeIndex - 1 ) >= 0 ? shapeIndex - 1 : shape.length - 1;
			prevHoleVert = ( holeIndex - 1 ) >= 0 ? holeIndex - 1 : hole.length - 1;

			areaapts = [

				hole[ holeIndex ],
				shape[ shapeIndex ],
				shape[ prevShapeVert ]

			];

			var areaa2 = THREE.FontUtils.Triangulate.area( areaapts );

			areabpts = [

				hole[ holeIndex ],
				hole[ prevHoleVert ],
				shape[ shapeIndex ]

			];

			var areab2 = THREE.FontUtils.Triangulate.area( areabpts );
			//console.log(areaa,areab ,areaa2,areab2, ( areaa + areab ),  ( areaa2 + areab2 ));

			if ( ( areaa + areab ) > ( areaa2 + areab2 ) ) {

				// In case areas are not correct.
				//console.log("USE THIS");

				shapeIndex = oldShapeIndex;
				holeIndex = oldHoleIndex ;

				if ( shapeIndex < 0 ) { shapeIndex += shape.length;  }
				shapeIndex %= shape.length;

				if ( holeIndex < 0 ) { holeIndex += hole.length;  }
				holeIndex %= hole.length;

				prevShapeVert = ( shapeIndex - 1 ) >= 0 ? shapeIndex - 1 : shape.length - 1;
				prevHoleVert = ( holeIndex - 1 ) >= 0 ? holeIndex - 1 : hole.length - 1;

			} else {

				//console.log("USE THAT ")

			}

			tmpShape1 = shape.slice( 0, shapeIndex );
			tmpShape2 = shape.slice( shapeIndex );
			tmpHole1 = hole.slice( holeIndex );
			tmpHole2 = hole.slice( 0, holeIndex );

			// Should check orders here again?

			var trianglea = [

				hole[ holeIndex ],
				shape[ shapeIndex ],
				shape[ prevShapeVert ]

			];

			var triangleb = [

				hole[ holeIndex ] ,
				hole[ prevHoleVert ],
				shape[ shapeIndex ]

			];

			verts.push( trianglea );
			verts.push( triangleb );

			shape = tmpShape1.concat( tmpHole1 ).concat( tmpHole2 ).concat( tmpShape2 );

		}

		return {

			shape:shape, 		/* shape with no holes */
			isolatedPts: verts, /* isolated faces */
			allpoints: allpoints

		}


	},

	triangulateShape: function ( contour, holes ) {

		var shapeWithoutHoles = THREE.Shape.Utils.removeHoles( contour, holes );

		var shape = shapeWithoutHoles.shape,
			allpoints = shapeWithoutHoles.allpoints,
			isolatedPts = shapeWithoutHoles.isolatedPts;

		var triangles = THREE.FontUtils.Triangulate( shape, false ); // True returns indices for points of spooled shape

		// To maintain reference to old shape, one must match coordinates, or offset the indices from original arrays. It's probably easier to do the first.

		//console.log( "triangles",triangles, triangles.length );
		//console.log( "allpoints",allpoints, allpoints.length );

		var i, il, f, face,
			key, index,
			allPointsMap = {},
			isolatedPointsMap = {};

		// prepare all points map

		for ( i = 0, il = allpoints.length; i < il; i ++ ) {

			key = allpoints[ i ].x + ":" + allpoints[ i ].y;

			if ( allPointsMap[ key ] !== undefined ) {

				console.log( "Duplicate point", key );

			}

			allPointsMap[ key ] = i;

		}

		// check all face vertices against all points map

		for ( i = 0, il = triangles.length; i < il; i ++ ) {

			face = triangles[ i ];

			for ( f = 0; f < 3; f ++ ) {

				key = face[ f ].x + ":" + face[ f ].y;

				index = allPointsMap[ key ];

				if ( index !== undefined ) {

					face[ f ] = index;

				}

			}

		}

		// check isolated points vertices against all points map

		for ( i = 0, il = isolatedPts.length; i < il; i ++ ) {

			face = isolatedPts[ i ];

			for ( f = 0; f < 3; f ++ ) {

				key = face[ f ].x + ":" + face[ f ].y;

				index = allPointsMap[ key ];

				if ( index !== undefined ) {

					face[ f ] = index;

				}

			}

		}

		return triangles.concat( isolatedPts );

	}, // end triangulate shapes

	/*
	triangulate2 : function( pts, holes ) {

		// For use with Poly2Tri.js

		var allpts = pts.concat();
		var shape = [];
		for (var p in pts) {
			shape.push(new js.poly2tri.Point(pts[p].x, pts[p].y));
		}

		var swctx = new js.poly2tri.SweepContext(shape);

		for (var h in holes) {
			var aHole = holes[h];
			var newHole = []
			for (i in aHole) {
				newHole.push(new js.poly2tri.Point(aHole[i].x, aHole[i].y));
				allpts.push(aHole[i]);
			}
			swctx.AddHole(newHole);
		}

		var find;
		var findIndexForPt = function (pt) {
			find = new THREE.Vector2(pt.x, pt.y);
			var p;
			for (p=0, pl = allpts.length; p<pl; p++) {
				if (allpts[p].equals(find)) return p;
			}
			return -1;
		};

		// triangulate
		js.poly2tri.sweep.Triangulate(swctx);

		var triangles =  swctx.GetTriangles();
		var tr ;
		var facesPts = [];
		for (var t in triangles) {
			tr =  triangles[t];
			facesPts.push([
				findIndexForPt(tr.GetPoint(0)),
				findIndexForPt(tr.GetPoint(1)),
				findIndexForPt(tr.GetPoint(2))
					]);
		}


	//	console.log(facesPts);
	//	console.log("triangles", triangles.length, triangles);

		// Returns array of faces with 3 element each
	return facesPts;
	},
*/

	isClockWise: function ( pts ) {

		return THREE.FontUtils.Triangulate.area( pts ) < 0;

	},

	// Bezier Curves formulas obtained from
	// http://en.wikipedia.org/wiki/B%C3%A9zier_curve

	// Quad Bezier Functions

	b2p0: function ( t, p ) {

		var k = 1 - t;
		return k * k * p;

	},

	b2p1: function ( t, p ) {

		return 2 * ( 1 - t ) * t * p;

	},

	b2p2: function ( t, p ) {

		return t * t * p;

	},

	b2: function ( t, p0, p1, p2 ) {

		return this.b2p0( t, p0 ) + this.b2p1( t, p1 ) + this.b2p2( t, p2 );

	},

	// Cubic Bezier Functions

	b3p0: function ( t, p ) {

		var k = 1 - t;
		return k * k * k * p;

	},

	b3p1: function ( t, p ) {

		var k = 1 - t;
		return 3 * k * k * t * p;

	},

	b3p2: function ( t, p ) {

		var k = 1 - t;
		return 3 * k * t * t * p;

	},

	b3p3: function ( t, p ) {

		return t * t * t * p;

	},

	b3: function ( t, p0, p1, p2, p3 ) {

		return this.b3p0( t, p0 ) + this.b3p1( t, p1 ) + this.b3p2( t, p2 ) +  this.b3p3( t, p3 );

	}

};


/**************************************************************
 *	Line
 **************************************************************/

THREE.LineCurve = function ( v1, v2 ) {

	this.v1 = v1;
	this.v2 = v2;

};

THREE.LineCurve.prototype = Object.create( THREE.Curve.prototype );

THREE.LineCurve.prototype.getPoint = function ( t ) {

	var point = this.v2.clone().sub(this.v1);
	point.multiplyScalar( t ).add( this.v1 );

	return point;

};

// Line curve is linear, so we can overwrite default getPointAt

THREE.LineCurve.prototype.getPointAt = function ( u ) {

	return this.getPoint( u );

};

THREE.LineCurve.prototype.getTangent = function( t ) {

	var tangent = this.v2.clone().sub(this.v1);

	return tangent.normalize();

};
/**************************************************************
 *	Quadratic Bezier curve
 **************************************************************/


THREE.QuadraticBezierCurve = function ( v0, v1, v2 ) {

	this.v0 = v0;
	this.v1 = v1;
	this.v2 = v2;

};

THREE.QuadraticBezierCurve.prototype = Object.create( THREE.Curve.prototype );


THREE.QuadraticBezierCurve.prototype.getPoint = function ( t ) {

	var tx, ty;

	tx = THREE.Shape.Utils.b2( t, this.v0.x, this.v1.x, this.v2.x );
	ty = THREE.Shape.Utils.b2( t, this.v0.y, this.v1.y, this.v2.y );

	return new THREE.Vector2( tx, ty );

};


THREE.QuadraticBezierCurve.prototype.getTangent = function( t ) {

	var tx, ty;

	tx = THREE.Curve.Utils.tangentQuadraticBezier( t, this.v0.x, this.v1.x, this.v2.x );
	ty = THREE.Curve.Utils.tangentQuadraticBezier( t, this.v0.y, this.v1.y, this.v2.y );

	// returns unit vector

	var tangent = new THREE.Vector2( tx, ty );
	tangent.normalize();

	return tangent;

};
/**************************************************************
 *	Cubic Bezier curve
 **************************************************************/

THREE.CubicBezierCurve = function ( v0, v1, v2, v3 ) {

	this.v0 = v0;
	this.v1 = v1;
	this.v2 = v2;
	this.v3 = v3;

};

THREE.CubicBezierCurve.prototype = Object.create( THREE.Curve.prototype );

THREE.CubicBezierCurve.prototype.getPoint = function ( t ) {

	var tx, ty;

	tx = THREE.Shape.Utils.b3( t, this.v0.x, this.v1.x, this.v2.x, this.v3.x );
	ty = THREE.Shape.Utils.b3( t, this.v0.y, this.v1.y, this.v2.y, this.v3.y );

	return new THREE.Vector2( tx, ty );

};

THREE.CubicBezierCurve.prototype.getTangent = function( t ) {

	var tx, ty;

	tx = THREE.Curve.Utils.tangentCubicBezier( t, this.v0.x, this.v1.x, this.v2.x, this.v3.x );
	ty = THREE.Curve.Utils.tangentCubicBezier( t, this.v0.y, this.v1.y, this.v2.y, this.v3.y );

	var tangent = new THREE.Vector2( tx, ty );
	tangent.normalize();

	return tangent;

};
/**************************************************************
 *	Spline curve
 **************************************************************/

THREE.SplineCurve = function ( points /* array of Vector2 */ ) {

	this.points = (points == undefined) ? [] : points;

};

THREE.SplineCurve.prototype = Object.create( THREE.Curve.prototype );

THREE.SplineCurve.prototype.getPoint = function ( t ) {

	var v = new THREE.Vector2();
	var c = [];
	var points = this.points, point, intPoint, weight;
	point = ( points.length - 1 ) * t;

	intPoint = Math.floor( point );
	weight = point - intPoint;

	c[ 0 ] = intPoint == 0 ? intPoint : intPoint - 1;
	c[ 1 ] = intPoint;
	c[ 2 ] = intPoint  > points.length - 2 ? points.length -1 : intPoint + 1;
	c[ 3 ] = intPoint  > points.length - 3 ? points.length -1 : intPoint + 2;

	v.x = THREE.Curve.Utils.interpolate( points[ c[ 0 ] ].x, points[ c[ 1 ] ].x, points[ c[ 2 ] ].x, points[ c[ 3 ] ].x, weight );
	v.y = THREE.Curve.Utils.interpolate( points[ c[ 0 ] ].y, points[ c[ 1 ] ].y, points[ c[ 2 ] ].y, points[ c[ 3 ] ].y, weight );

	return v;

};
/**************************************************************
 *	Ellipse curve
 **************************************************************/

THREE.EllipseCurve = function ( aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise ) {

	this.aX = aX;
	this.aY = aY;

	this.xRadius = xRadius;
	this.yRadius = yRadius;

	this.aStartAngle = aStartAngle;
	this.aEndAngle = aEndAngle;

	this.aClockwise = aClockwise;

};

THREE.EllipseCurve.prototype = Object.create( THREE.Curve.prototype );

THREE.EllipseCurve.prototype.getPoint = function ( t ) {

	var angle;
	var deltaAngle = this.aEndAngle - this.aStartAngle;

	if ( deltaAngle < 0 ) deltaAngle += Math.PI * 2;
	if ( deltaAngle > Math.PI * 2 ) deltaAngle -= Math.PI * 2;

	if ( this.aClockwise === true ) {

		angle = this.aEndAngle + ( 1 - t ) * ( Math.PI * 2 - deltaAngle );

	} else {

		angle = this.aStartAngle + t * deltaAngle;

	}

	var tx = this.aX + this.xRadius * Math.cos( angle );
	var ty = this.aY + this.yRadius * Math.sin( angle );

	return new THREE.Vector2( tx, ty );

};

/**************************************************************
 *	Arc curve
 **************************************************************/

THREE.ArcCurve = function ( aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise ) {

	THREE.EllipseCurve.call( this, aX, aY, aRadius, aRadius, aStartAngle, aEndAngle, aClockwise );
};

THREE.ArcCurve.prototype = Object.create( THREE.EllipseCurve.prototype );
/**************************************************************
 *	Line3D
 **************************************************************/

THREE.LineCurve3 = THREE.Curve.create(

	function ( v1, v2 ) {

		this.v1 = v1;
		this.v2 = v2;

	},

	function ( t ) {

		var r = new THREE.Vector3();


		r.subVectors( this.v2, this.v1 ); // diff
		r.multiplyScalar( t );
		r.add( this.v1 );

		return r;

	}

);

/**************************************************************
 *	Quadratic Bezier 3D curve
 **************************************************************/

THREE.QuadraticBezierCurve3 = THREE.Curve.create(

	function ( v0, v1, v2 ) {

		this.v0 = v0;
		this.v1 = v1;
		this.v2 = v2;

	},

	function ( t ) {

		var tx, ty, tz;

		tx = THREE.Shape.Utils.b2( t, this.v0.x, this.v1.x, this.v2.x );
		ty = THREE.Shape.Utils.b2( t, this.v0.y, this.v1.y, this.v2.y );
		tz = THREE.Shape.Utils.b2( t, this.v0.z, this.v1.z, this.v2.z );

		return new THREE.Vector3( tx, ty, tz );

	}

);
/**************************************************************
 *	Cubic Bezier 3D curve
 **************************************************************/

THREE.CubicBezierCurve3 = THREE.Curve.create(

	function ( v0, v1, v2, v3 ) {

		this.v0 = v0;
		this.v1 = v1;
		this.v2 = v2;
		this.v3 = v3;

	},

	function ( t ) {

		var tx, ty, tz;

		tx = THREE.Shape.Utils.b3( t, this.v0.x, this.v1.x, this.v2.x, this.v3.x );
		ty = THREE.Shape.Utils.b3( t, this.v0.y, this.v1.y, this.v2.y, this.v3.y );
		tz = THREE.Shape.Utils.b3( t, this.v0.z, this.v1.z, this.v2.z, this.v3.z );

		return new THREE.Vector3( tx, ty, tz );

	}

);
/**************************************************************
 *	Spline 3D curve
 **************************************************************/


THREE.SplineCurve3 = THREE.Curve.create(

	function ( points /* array of Vector3 */) {

		this.points = (points == undefined) ? [] : points;

	},

	function ( t ) {

		var v = new THREE.Vector3();
		var c = [];
		var points = this.points, point, intPoint, weight;
		point = ( points.length - 1 ) * t;

		intPoint = Math.floor( point );
		weight = point - intPoint;

		c[ 0 ] = intPoint == 0 ? intPoint : intPoint - 1;
		c[ 1 ] = intPoint;
		c[ 2 ] = intPoint  > points.length - 2 ? points.length - 1 : intPoint + 1;
		c[ 3 ] = intPoint  > points.length - 3 ? points.length - 1 : intPoint + 2;

		var pt0 = points[ c[0] ],
			pt1 = points[ c[1] ],
			pt2 = points[ c[2] ],
			pt3 = points[ c[3] ];

		v.x = THREE.Curve.Utils.interpolate(pt0.x, pt1.x, pt2.x, pt3.x, weight);
		v.y = THREE.Curve.Utils.interpolate(pt0.y, pt1.y, pt2.y, pt3.y, weight);
		v.z = THREE.Curve.Utils.interpolate(pt0.z, pt1.z, pt2.z, pt3.z, weight);

		return v;

	}

);


// THREE.SplineCurve3.prototype.getTangent = function(t) {
// 		var v = new THREE.Vector3();
// 		var c = [];
// 		var points = this.points, point, intPoint, weight;
// 		point = ( points.length - 1 ) * t;

// 		intPoint = Math.floor( point );
// 		weight = point - intPoint;

// 		c[ 0 ] = intPoint == 0 ? intPoint : intPoint - 1;
// 		c[ 1 ] = intPoint;
// 		c[ 2 ] = intPoint  > points.length - 2 ? points.length - 1 : intPoint + 1;
// 		c[ 3 ] = intPoint  > points.length - 3 ? points.length - 1 : intPoint + 2;

// 		var pt0 = points[ c[0] ],
// 			pt1 = points[ c[1] ],
// 			pt2 = points[ c[2] ],
// 			pt3 = points[ c[3] ];

// 	// t = weight;
// 	v.x = THREE.Curve.Utils.tangentSpline( t, pt0.x, pt1.x, pt2.x, pt3.x );
// 	v.y = THREE.Curve.Utils.tangentSpline( t, pt0.y, pt1.y, pt2.y, pt3.y );
// 	v.z = THREE.Curve.Utils.tangentSpline( t, pt0.z, pt1.z, pt2.z, pt3.z );

// 	return v;

// }
/**************************************************************
 *	Closed Spline 3D curve
 **************************************************************/


THREE.ClosedSplineCurve3 = THREE.Curve.create(

	function ( points /* array of Vector3 */) {

		this.points = (points == undefined) ? [] : points;

	},

    function ( t ) {

        var v = new THREE.Vector3();
        var c = [];
        var points = this.points, point, intPoint, weight;
        point = ( points.length - 0 ) * t;
            // This needs to be from 0-length +1

        intPoint = Math.floor( point );
        weight = point - intPoint;

        intPoint += intPoint > 0 ? 0 : ( Math.floor( Math.abs( intPoint ) / points.length ) + 1 ) * points.length;
        c[ 0 ] = ( intPoint - 1 ) % points.length;
        c[ 1 ] = ( intPoint ) % points.length;
        c[ 2 ] = ( intPoint + 1 ) % points.length;
        c[ 3 ] = ( intPoint + 2 ) % points.length;

        v.x = THREE.Curve.Utils.interpolate( points[ c[ 0 ] ].x, points[ c[ 1 ] ].x, points[ c[ 2 ] ].x, points[ c[ 3 ] ].x, weight );
        v.y = THREE.Curve.Utils.interpolate( points[ c[ 0 ] ].y, points[ c[ 1 ] ].y, points[ c[ 2 ] ].y, points[ c[ 3 ] ].y, weight );
        v.z = THREE.Curve.Utils.interpolate( points[ c[ 0 ] ].z, points[ c[ 1 ] ].z, points[ c[ 2 ] ].z, points[ c[ 3 ] ].z, weight );

        return v;

    }

);
/**
 * @author mikael emtinger / http://gomo.se/
 */

THREE.AnimationHandler = (function() {

	var playing = [];
	var library = {};
	var that    = {};


	//--- update ---

	that.update = function( deltaTimeMS ) {

		for( var i = 0; i < playing.length; i ++ )
			playing[ i ].update( deltaTimeMS );

	};


	//--- add ---

	that.addToUpdate = function( animation ) {

		if ( playing.indexOf( animation ) === -1 )
			playing.push( animation );

	};


	//--- remove ---

	that.removeFromUpdate = function( animation ) {

		var index = playing.indexOf( animation );

		if( index !== -1 )
			playing.splice( index, 1 );

	};


	//--- add ---

	that.add = function( data ) {

		if ( library[ data.name ] !== undefined )
			console.log( "THREE.AnimationHandler.add: Warning! " + data.name + " already exists in library. Overwriting." );

		library[ data.name ] = data;
		initData( data );

	};


	//--- get ---

	that.get = function( name ) {

		if ( typeof name === "string" ) {

			if ( library[ name ] ) {

				return library[ name ];

			} else {

				console.log( "THREE.AnimationHandler.get: Couldn't find animation " + name );
				return null;

			}

		} else {

			// todo: add simple tween library

		}

	};

	//--- parse ---

	that.parse = function( root ) {

		// setup hierarchy

		var hierarchy = [];

		if ( root instanceof THREE.SkinnedMesh ) {

			for( var b = 0; b < root.bones.length; b++ ) {

				hierarchy.push( root.bones[ b ] );

			}

		} else {

			parseRecurseHierarchy( root, hierarchy );

		}

		return hierarchy;

	};

	var parseRecurseHierarchy = function( root, hierarchy ) {

		hierarchy.push( root );

		for( var c = 0; c < root.children.length; c++ )
			parseRecurseHierarchy( root.children[ c ], hierarchy );

	}


	//--- init data ---

	var initData = function( data ) {

		if( data.initialized === true )
			return;


		// loop through all keys

		for( var h = 0; h < data.hierarchy.length; h ++ ) {

			for( var k = 0; k < data.hierarchy[ h ].keys.length; k ++ ) {

				// remove minus times

				if( data.hierarchy[ h ].keys[ k ].time < 0 )
					data.hierarchy[ h ].keys[ k ].time = 0;


				// create quaternions

				if( data.hierarchy[ h ].keys[ k ].rot !== undefined &&
				 !( data.hierarchy[ h ].keys[ k ].rot instanceof THREE.Quaternion ) ) {

					var quat = data.hierarchy[ h ].keys[ k ].rot;
					data.hierarchy[ h ].keys[ k ].rot = new THREE.Quaternion( quat[0], quat[1], quat[2], quat[3] );

				}

			}


			// prepare morph target keys

			if( data.hierarchy[ h ].keys.length && data.hierarchy[ h ].keys[ 0 ].morphTargets !== undefined ) {

				// get all used

				var usedMorphTargets = {};

				for ( var k = 0; k < data.hierarchy[ h ].keys.length; k ++ ) {

					for ( var m = 0; m < data.hierarchy[ h ].keys[ k ].morphTargets.length; m ++ ) {

						var morphTargetName = data.hierarchy[ h ].keys[ k ].morphTargets[ m ];
						usedMorphTargets[ morphTargetName ] = -1;

					}

				}

				data.hierarchy[ h ].usedMorphTargets = usedMorphTargets;


				// set all used on all frames

				for ( var k = 0; k < data.hierarchy[ h ].keys.length; k ++ ) {

					var influences = {};

					for ( var morphTargetName in usedMorphTargets ) {

						for ( var m = 0; m < data.hierarchy[ h ].keys[ k ].morphTargets.length; m ++ ) {

							if ( data.hierarchy[ h ].keys[ k ].morphTargets[ m ] === morphTargetName ) {

								influences[ morphTargetName ] = data.hierarchy[ h ].keys[ k ].morphTargetsInfluences[ m ];
								break;

							}

						}

						if ( m === data.hierarchy[ h ].keys[ k ].morphTargets.length ) {

							influences[ morphTargetName ] = 0;

						}

					}

					data.hierarchy[ h ].keys[ k ].morphTargetsInfluences = influences;

				}

			}


			// remove all keys that are on the same time

			for ( var k = 1; k < data.hierarchy[ h ].keys.length; k ++ ) {

				if ( data.hierarchy[ h ].keys[ k ].time === data.hierarchy[ h ].keys[ k - 1 ].time ) {

					data.hierarchy[ h ].keys.splice( k, 1 );
					k --;

				}

			}


			// set index

			for ( var k = 0; k < data.hierarchy[ h ].keys.length; k ++ ) {

				data.hierarchy[ h ].keys[ k ].index = k;

			}

		}


		// JIT

		var lengthInFrames = parseInt( data.length * data.fps, 10 );

		data.JIT = {};
		data.JIT.hierarchy = [];

		for( var h = 0; h < data.hierarchy.length; h ++ )
			data.JIT.hierarchy.push( new Array( lengthInFrames ) );


		// done

		data.initialized = true;

	};


	// interpolation types

	that.LINEAR = 0;
	that.CATMULLROM = 1;
	that.CATMULLROM_FORWARD = 2;

	return that;

}());

/**
 * @author mikael emtinger / http://gomo.se/
 * @author mrdoob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 */

THREE.Animation = function ( root, name, interpolationType ) {

	this.root = root;
	this.data = THREE.AnimationHandler.get( name );
	this.hierarchy = THREE.AnimationHandler.parse( root );

	this.currentTime = 0;
	this.timeScale = 1;

	this.isPlaying = false;
	this.isPaused = true;
	this.loop = true;

	this.interpolationType = interpolationType !== undefined ? interpolationType : THREE.AnimationHandler.LINEAR;

	this.points = [];
	this.target = new THREE.Vector3();

};

THREE.Animation.prototype.play = function ( loop, startTimeMS ) {

	if ( this.isPlaying === false ) {

		this.isPlaying = true;
		this.loop = loop !== undefined ? loop : true;
		this.currentTime = startTimeMS !== undefined ? startTimeMS : 0;

		// reset key cache

		var h, hl = this.hierarchy.length,
			object;

		for ( h = 0; h < hl; h ++ ) {

			object = this.hierarchy[ h ];

			object.matrixAutoUpdate = true;

			if ( object.animationCache === undefined ) {

				object.animationCache = {};
				object.animationCache.prevKey = { pos: 0, rot: 0, scl: 0 };
				object.animationCache.nextKey = { pos: 0, rot: 0, scl: 0 };
				object.animationCache.originalMatrix = object instanceof THREE.Bone ? object.skinMatrix : object.matrix;

			}

			var prevKey = object.animationCache.prevKey;
			var nextKey = object.animationCache.nextKey;

			prevKey.pos = this.data.hierarchy[ h ].keys[ 0 ];
			prevKey.rot = this.data.hierarchy[ h ].keys[ 0 ];
			prevKey.scl = this.data.hierarchy[ h ].keys[ 0 ];

			nextKey.pos = this.getNextKeyWith( "pos", h, 1 );
			nextKey.rot = this.getNextKeyWith( "rot", h, 1 );
			nextKey.scl = this.getNextKeyWith( "scl", h, 1 );

		}

		this.update( 0 );

	}

	this.isPaused = false;

	THREE.AnimationHandler.addToUpdate( this );

};


THREE.Animation.prototype.pause = function() {

	if ( this.isPaused === true ) {

		THREE.AnimationHandler.addToUpdate( this );

	} else {

		THREE.AnimationHandler.removeFromUpdate( this );

	}

	this.isPaused = !this.isPaused;

};


THREE.Animation.prototype.stop = function() {

	this.isPlaying = false;
	this.isPaused  = false;
	THREE.AnimationHandler.removeFromUpdate( this );

};


THREE.Animation.prototype.update = function ( deltaTimeMS ) {

	// early out

	if ( this.isPlaying === false ) return;


	// vars

	var types = [ "pos", "rot", "scl" ];
	var type;
	var scale;
	var vector;
	var prevXYZ, nextXYZ;
	var prevKey, nextKey;
	var object;
	var animationCache;
	var frame;
	var JIThierarchy = this.data.JIT.hierarchy;
	var currentTime, unloopedCurrentTime;
	var currentPoint, forwardPoint, angle;


	this.currentTime += deltaTimeMS * this.timeScale;

	unloopedCurrentTime = this.currentTime;

	// Mod operation fails on floats
	// was this supposed to be in frames?
	while ( this.currentTime > this.data.length ) {

		this.currentTime -= this.data.length;

	}

	currentTime = this.currentTime = this.currentTime % this.data.length;


	frame = parseInt( Math.min( currentTime * this.data.fps, this.data.length * this.data.fps ), 10 );


	for ( var h = 0, hl = this.hierarchy.length; h < hl; h ++ ) {

		object = this.hierarchy[ h ];
		animationCache = object.animationCache;

		// loop through pos/rot/scl

		for ( var t = 0; t < 3; t ++ ) {

			// get keys

			type    = types[ t ];
			prevKey = animationCache.prevKey[ type ];
			nextKey = animationCache.nextKey[ type ];

			// switch keys?

			if ( nextKey.time <= unloopedCurrentTime ) {

				// did we loop?

				if ( currentTime <= unloopedCurrentTime ) {

					if ( this.loop ) {

						prevKey = this.data.hierarchy[ h ].keys[ 0 ];
						nextKey = this.getNextKeyWith( type, h, 1 );

						// if ( nextKey.index < prevKey.index ) then we have wrapped over the end, and nextKey.time < currentTime will loop forever
						while ( nextKey !== null && nextKey.time < currentTime && nextKey.index > prevKey.index) {

							prevKey = nextKey;
							nextKey = this.getNextKeyWith( type, h, nextKey.index + 1 );

						}

					} else {

						this.stop();
						return;

					}

				} else {

					do {

						prevKey = nextKey;
						nextKey = this.getNextKeyWith( type, h, nextKey.index + 1 );

					} while ( nextKey !== null && nextKey.time < currentTime && nextKey.index > prevKey.index )
					// if ( nextKey.index < prevKey.index ) then we have wrapped over the end, and nextKey.time < currentTime will loop forever

				}

				animationCache.prevKey[ type ] = prevKey;
				animationCache.nextKey[ type ] = nextKey;

			}


			object.matrixAutoUpdate = true;
			object.matrixWorldNeedsUpdate = true;

			scale = ( currentTime - prevKey.time ) / ( nextKey.time - prevKey.time );
			prevXYZ = prevKey[ type ];
			nextXYZ = nextKey[ type ];


			// check scale error

			if ( scale < 0 || scale > 1 ) {

				console.log( "THREE.Animation.update: Warning! Scale out of bounds:" + scale + " on bone " + h );
				scale = scale < 0 ? 0 : 1;

			}

			// interpolate

			if ( type === "pos" ) {

				vector = object.position;

				if ( this.interpolationType === THREE.AnimationHandler.LINEAR ) {

					vector.x = prevXYZ[ 0 ] + ( nextXYZ[ 0 ] - prevXYZ[ 0 ] ) * scale;
					vector.y = prevXYZ[ 1 ] + ( nextXYZ[ 1 ] - prevXYZ[ 1 ] ) * scale;
					vector.z = prevXYZ[ 2 ] + ( nextXYZ[ 2 ] - prevXYZ[ 2 ] ) * scale;

				} else if ( this.interpolationType === THREE.AnimationHandler.CATMULLROM ||
						    this.interpolationType === THREE.AnimationHandler.CATMULLROM_FORWARD ) {

					this.points[ 0 ] = this.getPrevKeyWith( "pos", h, prevKey.index - 1 )[ "pos" ];
					this.points[ 1 ] = prevXYZ;
					this.points[ 2 ] = nextXYZ;
					this.points[ 3 ] = this.getNextKeyWith( "pos", h, nextKey.index + 1 )[ "pos" ];

					scale = scale * 0.33 + 0.33;

					currentPoint = this.interpolateCatmullRom( this.points, scale );

					vector.x = currentPoint[ 0 ];
					vector.y = currentPoint[ 1 ];
					vector.z = currentPoint[ 2 ];

					if ( this.interpolationType === THREE.AnimationHandler.CATMULLROM_FORWARD ) {

						forwardPoint = this.interpolateCatmullRom( this.points, scale * 1.01 );

						this.target.set( forwardPoint[ 0 ], forwardPoint[ 1 ], forwardPoint[ 2 ] );
						this.target.sub( vector );
						this.target.y = 0;
						this.target.normalize();

						angle = Math.atan2( this.target.x, this.target.z );
						object.rotation.set( 0, angle, 0 );

					}

				}

			} else if ( type === "rot" ) {

				THREE.Quaternion.slerp( prevXYZ, nextXYZ, object.quaternion, scale );

			} else if ( type === "scl" ) {

				vector = object.scale;

				vector.x = prevXYZ[ 0 ] + ( nextXYZ[ 0 ] - prevXYZ[ 0 ] ) * scale;
				vector.y = prevXYZ[ 1 ] + ( nextXYZ[ 1 ] - prevXYZ[ 1 ] ) * scale;
				vector.z = prevXYZ[ 2 ] + ( nextXYZ[ 2 ] - prevXYZ[ 2 ] ) * scale;

			}

		}

	}

};

// Catmull-Rom spline

THREE.Animation.prototype.interpolateCatmullRom = function ( points, scale ) {

	var c = [], v3 = [],
	point, intPoint, weight, w2, w3,
	pa, pb, pc, pd;

	point = ( points.length - 1 ) * scale;
	intPoint = Math.floor( point );
	weight = point - intPoint;

	c[ 0 ] = intPoint === 0 ? intPoint : intPoint - 1;
	c[ 1 ] = intPoint;
	c[ 2 ] = intPoint > points.length - 2 ? intPoint : intPoint + 1;
	c[ 3 ] = intPoint > points.length - 3 ? intPoint : intPoint + 2;

	pa = points[ c[ 0 ] ];
	pb = points[ c[ 1 ] ];
	pc = points[ c[ 2 ] ];
	pd = points[ c[ 3 ] ];

	w2 = weight * weight;
	w3 = weight * w2;

	v3[ 0 ] = this.interpolate( pa[ 0 ], pb[ 0 ], pc[ 0 ], pd[ 0 ], weight, w2, w3 );
	v3[ 1 ] = this.interpolate( pa[ 1 ], pb[ 1 ], pc[ 1 ], pd[ 1 ], weight, w2, w3 );
	v3[ 2 ] = this.interpolate( pa[ 2 ], pb[ 2 ], pc[ 2 ], pd[ 2 ], weight, w2, w3 );

	return v3;

};

THREE.Animation.prototype.interpolate = function ( p0, p1, p2, p3, t, t2, t3 ) {

	var v0 = ( p2 - p0 ) * 0.5,
		v1 = ( p3 - p1 ) * 0.5;

	return ( 2 * ( p1 - p2 ) + v0 + v1 ) * t3 + ( - 3 * ( p1 - p2 ) - 2 * v0 - v1 ) * t2 + v0 * t + p1;

};



// Get next key with

THREE.Animation.prototype.getNextKeyWith = function ( type, h, key ) {

	var keys = this.data.hierarchy[ h ].keys;

	if ( this.interpolationType === THREE.AnimationHandler.CATMULLROM ||
		 this.interpolationType === THREE.AnimationHandler.CATMULLROM_FORWARD ) {

		key = key < keys.length - 1 ? key : keys.length - 1;

	} else {

		key = key % keys.length;

	}

	for ( ; key < keys.length; key++ ) {

		if ( keys[ key ][ type ] !== undefined ) {

			return keys[ key ];

		}

	}

	return this.data.hierarchy[ h ].keys[ 0 ];

};

// Get previous key with

THREE.Animation.prototype.getPrevKeyWith = function ( type, h, key ) {

	var keys = this.data.hierarchy[ h ].keys;

	if ( this.interpolationType === THREE.AnimationHandler.CATMULLROM ||
		 this.interpolationType === THREE.AnimationHandler.CATMULLROM_FORWARD ) {

		key = key > 0 ? key : 0;

	} else {

		key = key >= 0 ? key : key + keys.length;

	}


	for ( ; key >= 0; key -- ) {

		if ( keys[ key ][ type ] !== undefined ) {

			return keys[ key ];

		}

	}

	return this.data.hierarchy[ h ].keys[ keys.length - 1 ];

};

/**
 * @author mikael emtinger / http://gomo.se/
 * @author mrdoob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 * @author khang duong
 * @author erik kitson
 */

THREE.KeyFrameAnimation = function( root, data, JITCompile ) {

	this.root = root;
	this.data = THREE.AnimationHandler.get( data );
	this.hierarchy = THREE.AnimationHandler.parse( root );
	this.currentTime = 0;
	this.timeScale = 0.001;
	this.isPlaying = false;
	this.isPaused = true;
	this.loop = true;
	this.JITCompile = JITCompile !== undefined ? JITCompile : true;

	// initialize to first keyframes

	for ( var h = 0, hl = this.hierarchy.length; h < hl; h++ ) {

		var keys = this.data.hierarchy[h].keys,
			sids = this.data.hierarchy[h].sids,
			obj = this.hierarchy[h];

		if ( keys.length && sids ) {

			for ( var s = 0; s < sids.length; s++ ) {

				var sid = sids[ s ],
					next = this.getNextKeyWith( sid, h, 0 );

				if ( next ) {

					next.apply( sid );

				}

			}

			obj.matrixAutoUpdate = false;
			this.data.hierarchy[h].node.updateMatrix();
			obj.matrixWorldNeedsUpdate = true;

		}

	}

};

// Play

THREE.KeyFrameAnimation.prototype.play = function( loop, startTimeMS ) {

	if( !this.isPlaying ) {

		this.isPlaying = true;
		this.loop = loop !== undefined ? loop : true;
		this.currentTime = startTimeMS !== undefined ? startTimeMS : 0;
		this.startTimeMs = startTimeMS;
		this.startTime = 10000000;
		this.endTime = -this.startTime;


		// reset key cache

		var h, hl = this.hierarchy.length,
			object,
			node;

		for ( h = 0; h < hl; h++ ) {

			object = this.hierarchy[ h ];
			node = this.data.hierarchy[ h ];

			if ( node.animationCache === undefined ) {

				node.animationCache = {};
				node.animationCache.prevKey = null;
				node.animationCache.nextKey = null;
				node.animationCache.originalMatrix = object instanceof THREE.Bone ? object.skinMatrix : object.matrix;

			}

			var keys = this.data.hierarchy[h].keys;

			if (keys.length) {

				node.animationCache.prevKey = keys[ 0 ];
				node.animationCache.nextKey = keys[ 1 ];

				this.startTime = Math.min( keys[0].time, this.startTime );
				this.endTime = Math.max( keys[keys.length - 1].time, this.endTime );

			}

		}

		this.update( 0 );

	}

	this.isPaused = false;

	THREE.AnimationHandler.addToUpdate( this );

};



// Pause

THREE.KeyFrameAnimation.prototype.pause = function() {

	if( this.isPaused ) {

		THREE.AnimationHandler.addToUpdate( this );

	} else {

		THREE.AnimationHandler.removeFromUpdate( this );

	}

	this.isPaused = !this.isPaused;

};


// Stop

THREE.KeyFrameAnimation.prototype.stop = function() {

	this.isPlaying = false;
	this.isPaused  = false;
	THREE.AnimationHandler.removeFromUpdate( this );


	// reset JIT matrix and remove cache

	for ( var h = 0; h < this.data.hierarchy.length; h++ ) {

        var obj = this.hierarchy[ h ];
		var node = this.data.hierarchy[ h ];

		if ( node.animationCache !== undefined ) {

			var original = node.animationCache.originalMatrix;

			if( obj instanceof THREE.Bone ) {

				original.copy( obj.skinMatrix );
				obj.skinMatrix = original;

			} else {

				original.copy( obj.matrix );
				obj.matrix = original;

			}

			delete node.animationCache;

		}

	}

};


// Update

THREE.KeyFrameAnimation.prototype.update = function( deltaTimeMS ) {

	// early out

	if( !this.isPlaying ) return;


	// vars

	var prevKey, nextKey;
	var object;
	var node;
	var frame;
	var JIThierarchy = this.data.JIT.hierarchy;
	var currentTime, unloopedCurrentTime;
	var looped;


	// update

	this.currentTime += deltaTimeMS * this.timeScale;

	unloopedCurrentTime = this.currentTime;
	currentTime         = this.currentTime = this.currentTime % this.data.length;

	// if looped around, the current time should be based on the startTime
	if ( currentTime < this.startTimeMs ) {

		currentTime = this.currentTime = this.startTimeMs + currentTime;

	}

	frame               = parseInt( Math.min( currentTime * this.data.fps, this.data.length * this.data.fps ), 10 );
	looped 				= currentTime < unloopedCurrentTime;

	if ( looped && !this.loop ) {

		// Set the animation to the last keyframes and stop
		for ( var h = 0, hl = this.hierarchy.length; h < hl; h++ ) {

			var keys = this.data.hierarchy[h].keys,
				sids = this.data.hierarchy[h].sids,
				end = keys.length-1,
				obj = this.hierarchy[h];

			if ( keys.length ) {

				for ( var s = 0; s < sids.length; s++ ) {

					var sid = sids[ s ],
						prev = this.getPrevKeyWith( sid, h, end );

					if ( prev ) {
						prev.apply( sid );

					}

				}

				this.data.hierarchy[h].node.updateMatrix();
				obj.matrixWorldNeedsUpdate = true;

			}

		}

		this.stop();
		return;

	}

	// check pre-infinity
	if ( currentTime < this.startTime ) {

		return;

	}

	// update

	for ( var h = 0, hl = this.hierarchy.length; h < hl; h++ ) {

		object = this.hierarchy[ h ];
		node = this.data.hierarchy[ h ];

		var keys = node.keys,
			animationCache = node.animationCache;

		// use JIT?

		if ( this.JITCompile && JIThierarchy[ h ][ frame ] !== undefined ) {

			if( object instanceof THREE.Bone ) {

				object.skinMatrix = JIThierarchy[ h ][ frame ];
				object.matrixWorldNeedsUpdate = false;

			} else {

				object.matrix = JIThierarchy[ h ][ frame ];
				object.matrixWorldNeedsUpdate = true;

			}

		// use interpolation

		} else if ( keys.length ) {

			// make sure so original matrix and not JIT matrix is set

			if ( this.JITCompile && animationCache ) {

				if( object instanceof THREE.Bone ) {

					object.skinMatrix = animationCache.originalMatrix;

				} else {

					object.matrix = animationCache.originalMatrix;

				}

			}

			prevKey = animationCache.prevKey;
			nextKey = animationCache.nextKey;

			if ( prevKey && nextKey ) {

				// switch keys?

				if ( nextKey.time <= unloopedCurrentTime ) {

					// did we loop?

					if ( looped && this.loop ) {

						prevKey = keys[ 0 ];
						nextKey = keys[ 1 ];

						while ( nextKey.time < currentTime ) {

							prevKey = nextKey;
							nextKey = keys[ prevKey.index + 1 ];

						}

					} else if ( !looped ) {

						var lastIndex = keys.length - 1;

						while ( nextKey.time < currentTime && nextKey.index !== lastIndex ) {

							prevKey = nextKey;
							nextKey = keys[ prevKey.index + 1 ];

						}

					}

					animationCache.prevKey = prevKey;
					animationCache.nextKey = nextKey;

				}
                if(nextKey.time >= currentTime)
                    prevKey.interpolate( nextKey, currentTime );
                else
                    prevKey.interpolate( nextKey, nextKey.time);

			}

			this.data.hierarchy[h].node.updateMatrix();
			object.matrixWorldNeedsUpdate = true;

		}

	}

	// update JIT?

	if ( this.JITCompile ) {

		if ( JIThierarchy[ 0 ][ frame ] === undefined ) {

			this.hierarchy[ 0 ].updateMatrixWorld( true );

			for ( var h = 0; h < this.hierarchy.length; h++ ) {

				if( this.hierarchy[ h ] instanceof THREE.Bone ) {

					JIThierarchy[ h ][ frame ] = this.hierarchy[ h ].skinMatrix.clone();

				} else {

					JIThierarchy[ h ][ frame ] = this.hierarchy[ h ].matrix.clone();

				}

			}

		}

	}

};

// Get next key with

THREE.KeyFrameAnimation.prototype.getNextKeyWith = function( sid, h, key ) {

	var keys = this.data.hierarchy[ h ].keys;
	key = key % keys.length;

	for ( ; key < keys.length; key++ ) {

		if ( keys[ key ].hasTarget( sid ) ) {

			return keys[ key ];

		}

	}

	return keys[ 0 ];

};

// Get previous key with

THREE.KeyFrameAnimation.prototype.getPrevKeyWith = function( sid, h, key ) {

	var keys = this.data.hierarchy[ h ].keys;
	key = key >= 0 ? key : key + keys.length;

	for ( ; key >= 0; key-- ) {

		if ( keys[ key ].hasTarget( sid ) ) {

			return keys[ key ];

		}

	}

	return keys[ keys.length - 1 ];

};

/**
 * Camera for rendering cube maps
 *	- renders scene into axis-aligned cube
 *
 * @author alteredq / http://alteredqualia.com/
 */

THREE.CubeCamera = function ( near, far, cubeResolution ) {

	THREE.Object3D.call( this );

	var fov = 90, aspect = 1;

	var cameraPX = new THREE.PerspectiveCamera( fov, aspect, near, far );
	cameraPX.up.set( 0, -1, 0 );
	cameraPX.lookAt( new THREE.Vector3( 1, 0, 0 ) );
	this.add( cameraPX );

	var cameraNX = new THREE.PerspectiveCamera( fov, aspect, near, far );
	cameraNX.up.set( 0, -1, 0 );
	cameraNX.lookAt( new THREE.Vector3( -1, 0, 0 ) );
	this.add( cameraNX );

	var cameraPY = new THREE.PerspectiveCamera( fov, aspect, near, far );
	cameraPY.up.set( 0, 0, 1 );
	cameraPY.lookAt( new THREE.Vector3( 0, 1, 0 ) );
	this.add( cameraPY );

	var cameraNY = new THREE.PerspectiveCamera( fov, aspect, near, far );
	cameraNY.up.set( 0, 0, -1 );
	cameraNY.lookAt( new THREE.Vector3( 0, -1, 0 ) );
	this.add( cameraNY );

	var cameraPZ = new THREE.PerspectiveCamera( fov, aspect, near, far );
	cameraPZ.up.set( 0, -1, 0 );
	cameraPZ.lookAt( new THREE.Vector3( 0, 0, 1 ) );
	this.add( cameraPZ );

	var cameraNZ = new THREE.PerspectiveCamera( fov, aspect, near, far );
	cameraNZ.up.set( 0, -1, 0 );
	cameraNZ.lookAt( new THREE.Vector3( 0, 0, -1 ) );
	this.add( cameraNZ );

	this.renderTarget = new THREE.WebGLRenderTargetCube( cubeResolution, cubeResolution, { format: THREE.RGBFormat, magFilter: THREE.LinearFilter, minFilter: THREE.LinearFilter } );

	this.updateCubeMap = function ( renderer, scene ) {

		var renderTarget = this.renderTarget;
		var generateMipmaps = renderTarget.generateMipmaps;

		renderTarget.generateMipmaps = false;

		renderTarget.activeCubeFace = 0;
		renderer.render( scene, cameraPX, renderTarget );

		renderTarget.activeCubeFace = 1;
		renderer.render( scene, cameraNX, renderTarget );

		renderTarget.activeCubeFace = 2;
		renderer.render( scene, cameraPY, renderTarget );

		renderTarget.activeCubeFace = 3;
		renderer.render( scene, cameraNY, renderTarget );

		renderTarget.activeCubeFace = 4;
		renderer.render( scene, cameraPZ, renderTarget );

		renderTarget.generateMipmaps = generateMipmaps;

		renderTarget.activeCubeFace = 5;
		renderer.render( scene, cameraNZ, renderTarget );

	};

};

THREE.CubeCamera.prototype = Object.create( THREE.Object3D.prototype );

/**
 *	@author zz85 / http://twitter.com/blurspline / http://www.lab4games.net/zz85/blog
 *
 *	A general perpose camera, for setting FOV, Lens Focal Length,
 *		and switching between perspective and orthographic views easily.
 *		Use this only if you do not wish to manage
 *		both a Orthographic and Perspective Camera
 *
 */


THREE.CombinedCamera = function ( width, height, fov, near, far, orthoNear, orthoFar ) {

	THREE.Camera.call( this );

	this.fov = fov;

	this.left = -width / 2;
	this.right = width / 2
	this.top = height / 2;
	this.bottom = -height / 2;

	// We could also handle the projectionMatrix internally, but just wanted to test nested camera objects

	this.cameraO = new THREE.OrthographicCamera( width / - 2, width / 2, height / 2, height / - 2, 	orthoNear, orthoFar );
	this.cameraP = new THREE.PerspectiveCamera( fov, width / height, near, far );

	this.zoom = 1;

	this.toPerspective();

	var aspect = width/height;

};

THREE.CombinedCamera.prototype = Object.create( THREE.Camera.prototype );

THREE.CombinedCamera.prototype.toPerspective = function () {

	// Switches to the Perspective Camera

	this.near = this.cameraP.near;
	this.far = this.cameraP.far;

	this.cameraP.fov =  this.fov / this.zoom ;

	this.cameraP.updateProjectionMatrix();

	this.projectionMatrix = this.cameraP.projectionMatrix;

	this.inPerspectiveMode = true;
	this.inOrthographicMode = false;

};

THREE.CombinedCamera.prototype.toOrthographic = function () {

	// Switches to the Orthographic camera estimating viewport from Perspective

	var fov = this.fov;
	var aspect = this.cameraP.aspect;
	var near = this.cameraP.near;
	var far = this.cameraP.far;

	// The size that we set is the mid plane of the viewing frustum

	var hyperfocus = ( near + far ) / 2;

	var halfHeight = Math.tan( fov / 2 ) * hyperfocus;
	var planeHeight = 2 * halfHeight;
	var planeWidth = planeHeight * aspect;
	var halfWidth = planeWidth / 2;

	halfHeight /= this.zoom;
	halfWidth /= this.zoom;

	this.cameraO.left = -halfWidth;
	this.cameraO.right = halfWidth;
	this.cameraO.top = halfHeight;
	this.cameraO.bottom = -halfHeight;

	// this.cameraO.left = -farHalfWidth;
	// this.cameraO.right = farHalfWidth;
	// this.cameraO.top = farHalfHeight;
	// this.cameraO.bottom = -farHalfHeight;

	// this.cameraO.left = this.left / this.zoom;
	// this.cameraO.right = this.right / this.zoom;
	// this.cameraO.top = this.top / this.zoom;
	// this.cameraO.bottom = this.bottom / this.zoom;

	this.cameraO.updateProjectionMatrix();

	this.near = this.cameraO.near;
	this.far = this.cameraO.far;
	this.projectionMatrix = this.cameraO.projectionMatrix;

	this.inPerspectiveMode = false;
	this.inOrthographicMode = true;

};


THREE.CombinedCamera.prototype.setSize = function( width, height ) {

	this.cameraP.aspect = width / height;
	this.left = -width / 2;
	this.right = width / 2
	this.top = height / 2;
	this.bottom = -height / 2;

};


THREE.CombinedCamera.prototype.setFov = function( fov ) {

	this.fov = fov;

	if ( this.inPerspectiveMode ) {

		this.toPerspective();

	} else {

		this.toOrthographic();

	}

};

// For mantaining similar API with PerspectiveCamera

THREE.CombinedCamera.prototype.updateProjectionMatrix = function() {

	if ( this.inPerspectiveMode ) {

		this.toPerspective();

	} else {

		this.toPerspective();
		this.toOrthographic();

	}

};

/*
* Uses Focal Length (in mm) to estimate and set FOV
* 35mm (fullframe) camera is used if frame size is not specified;
* Formula based on http://www.bobatkins.com/photography/technical/field_of_view.html
*/
THREE.CombinedCamera.prototype.setLens = function ( focalLength, frameHeight ) {

	if ( frameHeight === undefined ) frameHeight = 24;

	var fov = 2 * THREE.Math.radToDeg( Math.atan( frameHeight / ( focalLength * 2 ) ) );

	this.setFov( fov );

	return fov;
};


THREE.CombinedCamera.prototype.setZoom = function( zoom ) {

	this.zoom = zoom;

	if ( this.inPerspectiveMode ) {

		this.toPerspective();

	} else {

		this.toOrthographic();

	}

};

THREE.CombinedCamera.prototype.toFrontView = function() {

	this.rotation.x = 0;
	this.rotation.y = 0;
	this.rotation.z = 0;

	// should we be modifing the matrix instead?

	this.rotationAutoUpdate = false;

};

THREE.CombinedCamera.prototype.toBackView = function() {

	this.rotation.x = 0;
	this.rotation.y = Math.PI;
	this.rotation.z = 0;
	this.rotationAutoUpdate = false;

};

THREE.CombinedCamera.prototype.toLeftView = function() {

	this.rotation.x = 0;
	this.rotation.y = - Math.PI / 2;
	this.rotation.z = 0;
	this.rotationAutoUpdate = false;

};

THREE.CombinedCamera.prototype.toRightView = function() {

	this.rotation.x = 0;
	this.rotation.y = Math.PI / 2;
	this.rotation.z = 0;
	this.rotationAutoUpdate = false;

};

THREE.CombinedCamera.prototype.toTopView = function() {

	this.rotation.x = - Math.PI / 2;
	this.rotation.y = 0;
	this.rotation.z = 0;
	this.rotationAutoUpdate = false;

};

THREE.CombinedCamera.prototype.toBottomView = function() {

	this.rotation.x = Math.PI / 2;
	this.rotation.y = 0;
	this.rotation.z = 0;
	this.rotationAutoUpdate = false;

};

/**
 * @author hughes
 */

THREE.CircleGeometry = function ( radius, segments, thetaStart, thetaLength ) {

	THREE.Geometry.call( this );

	this.radius = radius = radius || 50;
	this.segments = segments = segments !== undefined ? Math.max( 3, segments ) : 8;

	this.thetaStart = thetaStart = thetaStart !== undefined ? thetaStart : 0;
	this.thetaLength = thetaLength = thetaLength !== undefined ? thetaLength : Math.PI * 2;

	var i, uvs = [],
	center = new THREE.Vector3(), centerUV = new THREE.Vector2( 0.5, 0.5 );

	this.vertices.push(center);
	uvs.push( centerUV );

	for ( i = 0; i <= segments; i ++ ) {

		var vertex = new THREE.Vector3();
		var segment = thetaStart + i / segments * thetaLength;

		vertex.x = radius * Math.cos( segment );
		vertex.y = radius * Math.sin( segment );

		this.vertices.push( vertex );
		uvs.push( new THREE.Vector2( ( vertex.x / radius + 1 ) / 2, ( vertex.y / radius + 1 ) / 2 ) );

	}

	var n = new THREE.Vector3( 0, 0, 1 );

	for ( i = 1; i <= segments; i ++ ) {

		var v1 = i;
		var v2 = i + 1 ;
		var v3 = 0;

		this.faces.push( new THREE.Face3( v1, v2, v3, [ n.clone(), n.clone(), n.clone() ] ) );
		this.faceVertexUvs[ 0 ].push( [ uvs[ i ].clone(), uvs[ i + 1 ].clone(), centerUV.clone() ] );

	}

	this.computeCentroids();
	this.computeFaceNormals();

	this.boundingSphere = new THREE.Sphere( new THREE.Vector3(), radius );

};

THREE.CircleGeometry.prototype = Object.create( THREE.Geometry.prototype );

/**
 * @author mrdoob / http://mrdoob.com/
 * based on http://papervision3d.googlecode.com/svn/trunk/as3/trunk/src/org/papervision3d/objects/primitives/Cube.as
 */

THREE.CubeGeometry = function ( width, height, depth, widthSegments, heightSegments, depthSegments ) {

	THREE.Geometry.call( this );

	var scope = this;

	this.width = width;
	this.height = height;
	this.depth = depth;

	this.widthSegments = widthSegments || 1;
	this.heightSegments = heightSegments || 1;
	this.depthSegments = depthSegments || 1;

	var width_half = this.width / 2;
	var height_half = this.height / 2;
	var depth_half = this.depth / 2;

	buildPlane( 'z', 'y', - 1, - 1, this.depth, this.height, width_half, 0 ); // px
	buildPlane( 'z', 'y',   1, - 1, this.depth, this.height, - width_half, 1 ); // nx
	buildPlane( 'x', 'z',   1,   1, this.width, this.depth, height_half, 2 ); // py
	buildPlane( 'x', 'z',   1, - 1, this.width, this.depth, - height_half, 3 ); // ny
	buildPlane( 'x', 'y',   1, - 1, this.width, this.height, depth_half, 4 ); // pz
	buildPlane( 'x', 'y', - 1, - 1, this.width, this.height, - depth_half, 5 ); // nz

	function buildPlane( u, v, udir, vdir, width, height, depth, materialIndex ) {

		var w, ix, iy,
		gridX = scope.widthSegments,
		gridY = scope.heightSegments,
		width_half = width / 2,
		height_half = height / 2,
		offset = scope.vertices.length;

		if ( ( u === 'x' && v === 'y' ) || ( u === 'y' && v === 'x' ) ) {

			w = 'z';

		} else if ( ( u === 'x' && v === 'z' ) || ( u === 'z' && v === 'x' ) ) {

			w = 'y';
			gridY = scope.depthSegments;

		} else if ( ( u === 'z' && v === 'y' ) || ( u === 'y' && v === 'z' ) ) {

			w = 'x';
			gridX = scope.depthSegments;

		}

		var gridX1 = gridX + 1,
		gridY1 = gridY + 1,
		segment_width = width / gridX,
		segment_height = height / gridY,
		normal = new THREE.Vector3();

		normal[ w ] = depth > 0 ? 1 : - 1;

		for ( iy = 0; iy < gridY1; iy ++ ) {

			for ( ix = 0; ix < gridX1; ix ++ ) {

				var vector = new THREE.Vector3();
				vector[ u ] = ( ix * segment_width - width_half ) * udir;
				vector[ v ] = ( iy * segment_height - height_half ) * vdir;
				vector[ w ] = depth;

				scope.vertices.push( vector );

			}

		}

		for ( iy = 0; iy < gridY; iy++ ) {

			for ( ix = 0; ix < gridX; ix++ ) {

				var a = ix + gridX1 * iy;
				var b = ix + gridX1 * ( iy + 1 );
				var c = ( ix + 1 ) + gridX1 * ( iy + 1 );
				var d = ( ix + 1 ) + gridX1 * iy;

				var uva = new THREE.Vector2( ix / gridX, 1 - iy / gridY );
				var uvb = new THREE.Vector2( ix / gridX, 1 - ( iy + 1 ) / gridY );
				var uvc = new THREE.Vector2( ( ix + 1 ) / gridX, 1 - ( iy + 1 ) / gridY );
				var uvd = new THREE.Vector2( ( ix + 1 ) / gridX, 1 - iy / gridY );

				var face = new THREE.Face3( a + offset, b + offset, d + offset );
				face.normal.copy( normal );
				face.vertexNormals.push( normal.clone(), normal.clone(), normal.clone() );
				face.materialIndex = materialIndex;

				scope.faces.push( face );
				scope.faceVertexUvs[ 0 ].push( [ uva, uvb, uvd ] );

				face = new THREE.Face3( b + offset, c + offset, d + offset );
				face.normal.copy( normal );
				face.vertexNormals.push( normal.clone(), normal.clone(), normal.clone() );
				face.materialIndex = materialIndex;

				scope.faces.push( face );
				scope.faceVertexUvs[ 0 ].push( [ uvb.clone(), uvc, uvd.clone() ] );

			}

		}

	}

	this.computeCentroids();
	this.mergeVertices();

};

THREE.CubeGeometry.prototype = Object.create( THREE.Geometry.prototype );

/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.CylinderGeometry = function ( radiusTop, radiusBottom, height, radialSegments, heightSegments, openEnded ) {

	THREE.Geometry.call( this );

	this.radiusTop = radiusTop = radiusTop !== undefined ? radiusTop : 20;
	this.radiusBottom = radiusBottom = radiusBottom !== undefined ? radiusBottom : 20;
	this.height = height = height !== undefined ? height : 100;

	this.radialSegments = radialSegments = radialSegments || 8;
	this.heightSegments = heightSegments = heightSegments || 1;

	this.openEnded = openEnded = openEnded !== undefined ? openEnded : false;

	var heightHalf = height / 2;

	var x, y, vertices = [], uvs = [];

	for ( y = 0; y <= heightSegments; y ++ ) {

		var verticesRow = [];
		var uvsRow = [];

		var v = y / heightSegments;
		var radius = v * ( radiusBottom - radiusTop ) + radiusTop;

		for ( x = 0; x <= radialSegments; x ++ ) {

			var u = x / radialSegments;

			var vertex = new THREE.Vector3();
			vertex.x = radius * Math.sin( u * Math.PI * 2 );
			vertex.y = - v * height + heightHalf;
			vertex.z = radius * Math.cos( u * Math.PI * 2 );

			this.vertices.push( vertex );

			verticesRow.push( this.vertices.length - 1 );
			uvsRow.push( new THREE.Vector2( u, 1 - v ) );

		}

		vertices.push( verticesRow );
		uvs.push( uvsRow );

	}

	var tanTheta = ( radiusBottom - radiusTop ) / height;
	var na, nb;

	for ( x = 0; x < radialSegments; x ++ ) {

		if ( radiusTop !== 0 ) {

			na = this.vertices[ vertices[ 0 ][ x ] ].clone();
			nb = this.vertices[ vertices[ 0 ][ x + 1 ] ].clone();

		} else {

			na = this.vertices[ vertices[ 1 ][ x ] ].clone();
			nb = this.vertices[ vertices[ 1 ][ x + 1 ] ].clone();

		}

		na.setY( Math.sqrt( na.x * na.x + na.z * na.z ) * tanTheta ).normalize();
		nb.setY( Math.sqrt( nb.x * nb.x + nb.z * nb.z ) * tanTheta ).normalize();

		for ( y = 0; y < heightSegments; y ++ ) {

			var v1 = vertices[ y ][ x ];
			var v2 = vertices[ y + 1 ][ x ];
			var v3 = vertices[ y + 1 ][ x + 1 ];
			var v4 = vertices[ y ][ x + 1 ];

			var n1 = na.clone();
			var n2 = na.clone();
			var n3 = nb.clone();
			var n4 = nb.clone();

			var uv1 = uvs[ y ][ x ].clone();
			var uv2 = uvs[ y + 1 ][ x ].clone();
			var uv3 = uvs[ y + 1 ][ x + 1 ].clone();
			var uv4 = uvs[ y ][ x + 1 ].clone();

			this.faces.push( new THREE.Face3( v1, v2, v4, [ n1, n2, n4 ] ) );
			this.faceVertexUvs[ 0 ].push( [ uv1, uv2, uv4 ] );

			this.faces.push( new THREE.Face3( v2, v3, v4, [ n2.clone(), n3, n4.clone() ] ) );
			this.faceVertexUvs[ 0 ].push( [ uv2.clone(), uv3, uv4.clone() ] );

		}

	}

	// top cap

	if ( openEnded === false && radiusTop > 0 ) {

		this.vertices.push( new THREE.Vector3( 0, heightHalf, 0 ) );

		for ( x = 0; x < radialSegments; x ++ ) {

			var v1 = vertices[ 0 ][ x ];
			var v2 = vertices[ 0 ][ x + 1 ];
			var v3 = this.vertices.length - 1;

			var n1 = new THREE.Vector3( 0, 1, 0 );
			var n2 = new THREE.Vector3( 0, 1, 0 );
			var n3 = new THREE.Vector3( 0, 1, 0 );

			var uv1 = uvs[ 0 ][ x ].clone();
			var uv2 = uvs[ 0 ][ x + 1 ].clone();
			var uv3 = new THREE.Vector2( uv2.x, 0 );

			this.faces.push( new THREE.Face3( v1, v2, v3, [ n1, n2, n3 ] ) );
			this.faceVertexUvs[ 0 ].push( [ uv1, uv2, uv3 ] );

		}

	}

	// bottom cap

	if ( openEnded === false && radiusBottom > 0 ) {

		this.vertices.push( new THREE.Vector3( 0, - heightHalf, 0 ) );

		for ( x = 0; x < radialSegments; x ++ ) {

			var v1 = vertices[ y ][ x + 1 ];
			var v2 = vertices[ y ][ x ];
			var v3 = this.vertices.length - 1;

			var n1 = new THREE.Vector3( 0, - 1, 0 );
			var n2 = new THREE.Vector3( 0, - 1, 0 );
			var n3 = new THREE.Vector3( 0, - 1, 0 );

			var uv1 = uvs[ y ][ x + 1 ].clone();
			var uv2 = uvs[ y ][ x ].clone();
			var uv3 = new THREE.Vector2( uv2.x, 1 );

			this.faces.push( new THREE.Face3( v1, v2, v3, [ n1, n2, n3 ] ) );
			this.faceVertexUvs[ 0 ].push( [ uv1, uv2, uv3 ] );

		}

	}

	this.computeCentroids();
	this.computeFaceNormals();

}

THREE.CylinderGeometry.prototype = Object.create( THREE.Geometry.prototype );

/**
 * @author zz85 / http://www.lab4games.net/zz85/blog
 *
 * Creates extruded geometry from a path shape.
 *
 * parameters = {
 *
 *  curveSegments: <int>, // number of points on the curves
 *  steps: <int>, // number of points for z-side extrusions / used for subdividing segements of extrude spline too
 *  amount: <int>, // Depth to extrude the shape
 *
 *  bevelEnabled: <bool>, // turn on bevel
 *  bevelThickness: <float>, // how deep into the original shape bevel goes
 *  bevelSize: <float>, // how far from shape outline is bevel
 *  bevelSegments: <int>, // number of bevel layers
 *
 *  extrudePath: <THREE.CurvePath> // 3d spline path to extrude shape along. (creates Frames if .frames aren't defined)
 *  frames: <THREE.TubeGeometry.FrenetFrames> // containing arrays of tangents, normals, binormals
 *
 *  material: <int> // material index for front and back faces
 *  extrudeMaterial: <int> // material index for extrusion and beveled faces
 *  uvGenerator: <Object> // object that provides UV generator functions
 *
 * }
 **/

THREE.ExtrudeGeometry = function ( shapes, options ) {

	if ( typeof( shapes ) === "undefined" ) {
		shapes = [];
		return;
	}

	THREE.Geometry.call( this );

	shapes = shapes instanceof Array ? shapes : [ shapes ];

	this.shapebb = shapes[ shapes.length - 1 ].getBoundingBox();

	this.addShapeList( shapes, options );

	this.computeCentroids();
	this.computeFaceNormals();

	// can't really use automatic vertex normals
	// as then front and back sides get smoothed too
	// should do separate smoothing just for sides

	//this.computeVertexNormals();

	//console.log( "took", ( Date.now() - startTime ) );

};

THREE.ExtrudeGeometry.prototype = Object.create( THREE.Geometry.prototype );

THREE.ExtrudeGeometry.prototype.addShapeList = function ( shapes, options ) {
	var sl = shapes.length;

	for ( var s = 0; s < sl; s ++ ) {
		var shape = shapes[ s ];
		this.addShape( shape, options );
	}
};

THREE.ExtrudeGeometry.prototype.addShape = function ( shape, options ) {

	var amount = options.amount !== undefined ? options.amount : 100;

	var bevelThickness = options.bevelThickness !== undefined ? options.bevelThickness : 6; // 10
	var bevelSize = options.bevelSize !== undefined ? options.bevelSize : bevelThickness - 2; // 8
	var bevelSegments = options.bevelSegments !== undefined ? options.bevelSegments : 3;

	var bevelEnabled = options.bevelEnabled !== undefined ? options.bevelEnabled : true; // false

	var curveSegments = options.curveSegments !== undefined ? options.curveSegments : 12;

	var steps = options.steps !== undefined ? options.steps : 1;

	var extrudePath = options.extrudePath;
	var extrudePts, extrudeByPath = false;

	var material = options.material;
	var extrudeMaterial = options.extrudeMaterial;

	// Use default WorldUVGenerator if no UV generators are specified.
	var uvgen = options.UVGenerator !== undefined ? options.UVGenerator : THREE.ExtrudeGeometry.WorldUVGenerator;

	var shapebb = this.shapebb;
	//shapebb = shape.getBoundingBox();



	var splineTube, binormal, normal, position2;
	if ( extrudePath ) {

		extrudePts = extrudePath.getSpacedPoints( steps );

		extrudeByPath = true;
		bevelEnabled = false; // bevels not supported for path extrusion

		// SETUP TNB variables

		// Reuse TNB from TubeGeomtry for now.
		// TODO1 - have a .isClosed in spline?

		splineTube = options.frames !== undefined ? options.frames : new THREE.TubeGeometry.FrenetFrames(extrudePath, steps, false);

		// console.log(splineTube, 'splineTube', splineTube.normals.length, 'steps', steps, 'extrudePts', extrudePts.length);

		binormal = new THREE.Vector3();
		normal = new THREE.Vector3();
		position2 = new THREE.Vector3();

	}

	// Safeguards if bevels are not enabled

	if ( ! bevelEnabled ) {

		bevelSegments = 0;
		bevelThickness = 0;
		bevelSize = 0;

	}

	// Variables initalization

	var ahole, h, hl; // looping of holes
	var scope = this;
	var bevelPoints = [];

	var shapesOffset = this.vertices.length;

	var shapePoints = shape.extractPoints( curveSegments );

	var vertices = shapePoints.shape;
	var holes = shapePoints.holes;

	var reverse = !THREE.Shape.Utils.isClockWise( vertices ) ;

	if ( reverse ) {

		vertices = vertices.reverse();

		// Maybe we should also check if holes are in the opposite direction, just to be safe ...

		for ( h = 0, hl = holes.length; h < hl; h ++ ) {

			ahole = holes[ h ];

			if ( THREE.Shape.Utils.isClockWise( ahole ) ) {

				holes[ h ] = ahole.reverse();

			}

		}

		reverse = false; // If vertices are in order now, we shouldn't need to worry about them again (hopefully)!

	}


	var faces = THREE.Shape.Utils.triangulateShape ( vertices, holes );

	/* Vertices */

	var contour = vertices; // vertices has all points but contour has only points of circumference

	for ( h = 0, hl = holes.length;  h < hl; h ++ ) {

		ahole = holes[ h ];

		vertices = vertices.concat( ahole );

	}


	function scalePt2 ( pt, vec, size ) {

		if ( !vec ) console.log( "die" );

		return vec.clone().multiplyScalar( size ).add( pt );

	}

	var b, bs, t, z,
		vert, vlen = vertices.length,
		face, flen = faces.length,
		cont, clen = contour.length;


	// Find directions for point movement

	var RAD_TO_DEGREES = 180 / Math.PI;


	function getBevelVec( pt_i, pt_j, pt_k ) {

		// Algorithm 2

		return getBevelVec2( pt_i, pt_j, pt_k );

	}

	function getBevelVec1( pt_i, pt_j, pt_k ) {

		var anglea = Math.atan2( pt_j.y - pt_i.y, pt_j.x - pt_i.x );
		var angleb = Math.atan2( pt_k.y - pt_i.y, pt_k.x - pt_i.x );

		if ( anglea > angleb ) {

			angleb += Math.PI * 2;

		}

		var anglec = ( anglea + angleb ) / 2;


		//console.log('angle1', anglea * RAD_TO_DEGREES,'angle2', angleb * RAD_TO_DEGREES, 'anglec', anglec *RAD_TO_DEGREES);

		var x = - Math.cos( anglec );
		var y = - Math.sin( anglec );

		var vec = new THREE.Vector2( x, y ); //.normalize();

		return vec;

	}

	function getBevelVec2( pt_i, pt_j, pt_k ) {

		var a = THREE.ExtrudeGeometry.__v1,
			b = THREE.ExtrudeGeometry.__v2,
			v_hat = THREE.ExtrudeGeometry.__v3,
			w_hat = THREE.ExtrudeGeometry.__v4,
			p = THREE.ExtrudeGeometry.__v5,
			q = THREE.ExtrudeGeometry.__v6,
			v, w,
			v_dot_w_hat, q_sub_p_dot_w_hat,
			s, intersection;

		// good reading for line-line intersection
		// http://sputsoft.com/blog/2010/03/line-line-intersection.html

		// define a as vector j->i
		// define b as vectot k->i

		a.set( pt_i.x - pt_j.x, pt_i.y - pt_j.y );
		b.set( pt_i.x - pt_k.x, pt_i.y - pt_k.y );

		// get unit vectors

		v = a.normalize();
		w = b.normalize();

		// normals from pt i

		v_hat.set( -v.y, v.x );
		w_hat.set( w.y, -w.x );

		// pts from i

		p.copy( pt_i ).add( v_hat );
		q.copy( pt_i ).add( w_hat );

		if ( p.equals( q ) ) {

			//console.log("Warning: lines are straight");
			return w_hat.clone();

		}

		// Points from j, k. helps prevents points cross overover most of the time

		p.copy( pt_j ).add( v_hat );
		q.copy( pt_k ).add( w_hat );

		v_dot_w_hat = v.dot( w_hat );
		q_sub_p_dot_w_hat = q.sub( p ).dot( w_hat );

		// We should not reach these conditions

		if ( v_dot_w_hat === 0 ) {

			console.log( "Either infinite or no solutions!" );

			if ( q_sub_p_dot_w_hat === 0 ) {

				console.log( "Its finite solutions." );

			} else {

				console.log( "Too bad, no solutions." );

			}

		}

		s = q_sub_p_dot_w_hat / v_dot_w_hat;

		if ( s < 0 ) {

			// in case of emergecy, revert to algorithm 1.

			return getBevelVec1( pt_i, pt_j, pt_k );

		}

		intersection = v.multiplyScalar( s ).add( p );

		return intersection.sub( pt_i ).clone(); // Don't normalize!, otherwise sharp corners become ugly

	}

	var contourMovements = [];

	for ( var i = 0, il = contour.length, j = il - 1, k = i + 1; i < il; i ++, j ++, k ++ ) {

		if ( j === il ) j = 0;
		if ( k === il ) k = 0;

		//  (j)---(i)---(k)
		// console.log('i,j,k', i, j , k)

		var pt_i = contour[ i ];
		var pt_j = contour[ j ];
		var pt_k = contour[ k ];

		contourMovements[ i ]= getBevelVec( contour[ i ], contour[ j ], contour[ k ] );

	}

	var holesMovements = [], oneHoleMovements, verticesMovements = contourMovements.concat();

	for ( h = 0, hl = holes.length; h < hl; h ++ ) {

		ahole = holes[ h ];

		oneHoleMovements = [];

		for ( i = 0, il = ahole.length, j = il - 1, k = i + 1; i < il; i ++, j ++, k ++ ) {

			if ( j === il ) j = 0;
			if ( k === il ) k = 0;

			//  (j)---(i)---(k)
			oneHoleMovements[ i ]= getBevelVec( ahole[ i ], ahole[ j ], ahole[ k ] );

		}

		holesMovements.push( oneHoleMovements );
		verticesMovements = verticesMovements.concat( oneHoleMovements );

	}


	// Loop bevelSegments, 1 for the front, 1 for the back

	for ( b = 0; b < bevelSegments; b ++ ) {
	//for ( b = bevelSegments; b > 0; b -- ) {

		t = b / bevelSegments;
		z = bevelThickness * ( 1 - t );

		//z = bevelThickness * t;
		bs = bevelSize * ( Math.sin ( t * Math.PI/2 ) ) ; // curved
		//bs = bevelSize * t ; // linear

		// contract shape

		for ( i = 0, il = contour.length; i < il; i ++ ) {

			vert = scalePt2( contour[ i ], contourMovements[ i ], bs );
			//vert = scalePt( contour[ i ], contourCentroid, bs, false );
			v( vert.x, vert.y,  - z );

		}

		// expand holes

		for ( h = 0, hl = holes.length; h < hl; h++ ) {

			ahole = holes[ h ];
			oneHoleMovements = holesMovements[ h ];

			for ( i = 0, il = ahole.length; i < il; i++ ) {

				vert = scalePt2( ahole[ i ], oneHoleMovements[ i ], bs );
				//vert = scalePt( ahole[ i ], holesCentroids[ h ], bs, true );

				v( vert.x, vert.y,  -z );

			}

		}

	}

	bs = bevelSize;

	// Back facing vertices

	for ( i = 0; i < vlen; i ++ ) {

		vert = bevelEnabled ? scalePt2( vertices[ i ], verticesMovements[ i ], bs ) : vertices[ i ];

		if ( !extrudeByPath ) {

			v( vert.x, vert.y, 0 );

		} else {

			// v( vert.x, vert.y + extrudePts[ 0 ].y, extrudePts[ 0 ].x );

			normal.copy( splineTube.normals[0] ).multiplyScalar(vert.x);
			binormal.copy( splineTube.binormals[0] ).multiplyScalar(vert.y);

			position2.copy( extrudePts[0] ).add(normal).add(binormal);

			v( position2.x, position2.y, position2.z );

		}

	}

	// Add stepped vertices...
	// Including front facing vertices

	var s;

	for ( s = 1; s <= steps; s ++ ) {

		for ( i = 0; i < vlen; i ++ ) {

			vert = bevelEnabled ? scalePt2( vertices[ i ], verticesMovements[ i ], bs ) : vertices[ i ];

			if ( !extrudeByPath ) {

				v( vert.x, vert.y, amount / steps * s );

			} else {

				// v( vert.x, vert.y + extrudePts[ s - 1 ].y, extrudePts[ s - 1 ].x );

				normal.copy( splineTube.normals[s] ).multiplyScalar( vert.x );
				binormal.copy( splineTube.binormals[s] ).multiplyScalar( vert.y );

				position2.copy( extrudePts[s] ).add( normal ).add( binormal );

				v( position2.x, position2.y, position2.z );

			}

		}

	}


	// Add bevel segments planes

	//for ( b = 1; b <= bevelSegments; b ++ ) {
	for ( b = bevelSegments - 1; b >= 0; b -- ) {

		t = b / bevelSegments;
		z = bevelThickness * ( 1 - t );
		//bs = bevelSize * ( 1-Math.sin ( ( 1 - t ) * Math.PI/2 ) );
		bs = bevelSize * Math.sin ( t * Math.PI/2 ) ;

		// contract shape

		for ( i = 0, il = contour.length; i < il; i ++ ) {

			vert = scalePt2( contour[ i ], contourMovements[ i ], bs );
			v( vert.x, vert.y,  amount + z );

		}

		// expand holes

		for ( h = 0, hl = holes.length; h < hl; h ++ ) {

			ahole = holes[ h ];
			oneHoleMovements = holesMovements[ h ];

			for ( i = 0, il = ahole.length; i < il; i ++ ) {

				vert = scalePt2( ahole[ i ], oneHoleMovements[ i ], bs );

				if ( !extrudeByPath ) {

					v( vert.x, vert.y,  amount + z );

				} else {

					v( vert.x, vert.y + extrudePts[ steps - 1 ].y, extrudePts[ steps - 1 ].x + z );

				}

			}

		}

	}

	/* Faces */

	// Top and bottom faces

	buildLidFaces();

	// Sides faces

	buildSideFaces();


	/////  Internal functions

	function buildLidFaces() {

		if ( bevelEnabled ) {

			var layer = 0 ; // steps + 1
			var offset = vlen * layer;

			// Bottom faces

			for ( i = 0; i < flen; i ++ ) {

				face = faces[ i ];
				f3( face[ 2 ]+ offset, face[ 1 ]+ offset, face[ 0 ] + offset, true );

			}

			layer = steps + bevelSegments * 2;
			offset = vlen * layer;

			// Top faces

			for ( i = 0; i < flen; i ++ ) {

				face = faces[ i ];
				f3( face[ 0 ] + offset, face[ 1 ] + offset, face[ 2 ] + offset, false );

			}

		} else {

			// Bottom faces

			for ( i = 0; i < flen; i++ ) {

				face = faces[ i ];
				f3( face[ 2 ], face[ 1 ], face[ 0 ], true );

			}

			// Top faces

			for ( i = 0; i < flen; i ++ ) {

				face = faces[ i ];
				f3( face[ 0 ] + vlen * steps, face[ 1 ] + vlen * steps, face[ 2 ] + vlen * steps, false );

			}
		}

	}

	// Create faces for the z-sides of the shape

	function buildSideFaces() {

		var layeroffset = 0;
		sidewalls( contour, layeroffset );
		layeroffset += contour.length;

		for ( h = 0, hl = holes.length;  h < hl; h ++ ) {

			ahole = holes[ h ];
			sidewalls( ahole, layeroffset );

			//, true
			layeroffset += ahole.length;

		}

	}

	function sidewalls( contour, layeroffset ) {

		var j, k;
		i = contour.length;

		while ( --i >= 0 ) {

			j = i;
			k = i - 1;
			if ( k < 0 ) k = contour.length - 1;

			//console.log('b', i,j, i-1, k,vertices.length);

			var s = 0, sl = steps  + bevelSegments * 2;

			for ( s = 0; s < sl; s ++ ) {

				var slen1 = vlen * s;
				var slen2 = vlen * ( s + 1 );

				var a = layeroffset + j + slen1,
					b = layeroffset + k + slen1,
					c = layeroffset + k + slen2,
					d = layeroffset + j + slen2;

				f4( a, b, c, d, contour, s, sl, j, k );

			}
		}

	}


	function v( x, y, z ) {

		scope.vertices.push( new THREE.Vector3( x, y, z ) );

	}

	function f3( a, b, c, isBottom ) {

		a += shapesOffset;
		b += shapesOffset;
		c += shapesOffset;

		// normal, color, material
		scope.faces.push( new THREE.Face3( a, b, c, null, null, material ) );

		var uvs = isBottom ? uvgen.generateBottomUV( scope, shape, options, a, b, c ) : uvgen.generateTopUV( scope, shape, options, a, b, c );

 		scope.faceVertexUvs[ 0 ].push( uvs );

	}

	function f4( a, b, c, d, wallContour, stepIndex, stepsLength, contourIndex1, contourIndex2 ) {

		a += shapesOffset;
		b += shapesOffset;
		c += shapesOffset;
		d += shapesOffset;

 		scope.faces.push( new THREE.Face3( a, b, d, null, null, extrudeMaterial ) );
 		scope.faces.push( new THREE.Face3( b, c, d, null, null, extrudeMaterial ) );

 		var uvs = uvgen.generateSideWallUV( scope, shape, wallContour, options, a, b, c, d,
 		                                    stepIndex, stepsLength, contourIndex1, contourIndex2 );

 		scope.faceVertexUvs[ 0 ].push( [ uvs[ 0 ], uvs[ 1 ], uvs[ 3 ] ] );
 		scope.faceVertexUvs[ 0 ].push( [ uvs[ 1 ], uvs[ 2 ], uvs[ 3 ] ] );

	}

};

THREE.ExtrudeGeometry.WorldUVGenerator = {

	generateTopUV: function( geometry, extrudedShape, extrudeOptions, indexA, indexB, indexC ) {
		var ax = geometry.vertices[ indexA ].x,
			ay = geometry.vertices[ indexA ].y,

			bx = geometry.vertices[ indexB ].x,
			by = geometry.vertices[ indexB ].y,

			cx = geometry.vertices[ indexC ].x,
			cy = geometry.vertices[ indexC ].y;

		return [
			new THREE.Vector2( ax, ay ),
			new THREE.Vector2( bx, by ),
			new THREE.Vector2( cx, cy )
		];

	},

	generateBottomUV: function( geometry, extrudedShape, extrudeOptions, indexA, indexB, indexC ) {

		return this.generateTopUV( geometry, extrudedShape, extrudeOptions, indexA, indexB, indexC );

	},

	generateSideWallUV: function( geometry, extrudedShape, wallContour, extrudeOptions,
	                              indexA, indexB, indexC, indexD, stepIndex, stepsLength,
	                              contourIndex1, contourIndex2 ) {

		var ax = geometry.vertices[ indexA ].x,
			ay = geometry.vertices[ indexA ].y,
			az = geometry.vertices[ indexA ].z,

			bx = geometry.vertices[ indexB ].x,
			by = geometry.vertices[ indexB ].y,
			bz = geometry.vertices[ indexB ].z,

			cx = geometry.vertices[ indexC ].x,
			cy = geometry.vertices[ indexC ].y,
			cz = geometry.vertices[ indexC ].z,

			dx = geometry.vertices[ indexD ].x,
			dy = geometry.vertices[ indexD ].y,
			dz = geometry.vertices[ indexD ].z;

		if ( Math.abs( ay - by ) < 0.01 ) {
			return [
				new THREE.Vector2( ax, 1 - az ),
				new THREE.Vector2( bx, 1 - bz ),
				new THREE.Vector2( cx, 1 - cz ),
				new THREE.Vector2( dx, 1 - dz )
			];
		} else {
			return [
				new THREE.Vector2( ay, 1 - az ),
				new THREE.Vector2( by, 1 - bz ),
				new THREE.Vector2( cy, 1 - cz ),
				new THREE.Vector2( dy, 1 - dz )
			];
		}
	}
};

THREE.ExtrudeGeometry.__v1 = new THREE.Vector2();
THREE.ExtrudeGeometry.__v2 = new THREE.Vector2();
THREE.ExtrudeGeometry.__v3 = new THREE.Vector2();
THREE.ExtrudeGeometry.__v4 = new THREE.Vector2();
THREE.ExtrudeGeometry.__v5 = new THREE.Vector2();
THREE.ExtrudeGeometry.__v6 = new THREE.Vector2();

/**
 * @author jonobr1 / http://jonobr1.com
 *
 * Creates a one-sided polygonal geometry from a path shape. Similar to
 * ExtrudeGeometry.
 *
 * parameters = {
 *
 *	curveSegments: <int>, // number of points on the curves. NOT USED AT THE MOMENT.
 *
 *	material: <int> // material index for front and back faces
 *	uvGenerator: <Object> // object that provides UV generator functions
 *
 * }
 **/

THREE.ShapeGeometry = function ( shapes, options ) {

	THREE.Geometry.call( this );

	if ( shapes instanceof Array === false ) shapes = [ shapes ];

	this.shapebb = shapes[ shapes.length - 1 ].getBoundingBox();

	this.addShapeList( shapes, options );

	this.computeCentroids();
	this.computeFaceNormals();

};

THREE.ShapeGeometry.prototype = Object.create( THREE.Geometry.prototype );

/**
 * Add an array of shapes to THREE.ShapeGeometry.
 */
THREE.ShapeGeometry.prototype.addShapeList = function ( shapes, options ) {

	for ( var i = 0, l = shapes.length; i < l; i++ ) {

		this.addShape( shapes[ i ], options );

	}

	return this;

};

/**
 * Adds a shape to THREE.ShapeGeometry, based on THREE.ExtrudeGeometry.
 */
THREE.ShapeGeometry.prototype.addShape = function ( shape, options ) {

	if ( options === undefined ) options = {};
	var curveSegments = options.curveSegments !== undefined ? options.curveSegments : 12;

	var material = options.material;
	var uvgen = options.UVGenerator === undefined ? THREE.ExtrudeGeometry.WorldUVGenerator : options.UVGenerator;

	var shapebb = this.shapebb;

	//

	var i, l, hole, s;

	var shapesOffset = this.vertices.length;
	var shapePoints = shape.extractPoints( curveSegments );

	var vertices = shapePoints.shape;
	var holes = shapePoints.holes;

	var reverse = !THREE.Shape.Utils.isClockWise( vertices );

	if ( reverse ) {

		vertices = vertices.reverse();

		// Maybe we should also check if holes are in the opposite direction, just to be safe...

		for ( i = 0, l = holes.length; i < l; i++ ) {

			hole = holes[ i ];

			if ( THREE.Shape.Utils.isClockWise( hole ) ) {

				holes[ i ] = hole.reverse();

			}

		}

		reverse = false;

	}

	var faces = THREE.Shape.Utils.triangulateShape( vertices, holes );

	// Vertices

	var contour = vertices;

	for ( i = 0, l = holes.length; i < l; i++ ) {

		hole = holes[ i ];
		vertices = vertices.concat( hole );

	}

	//

	var vert, vlen = vertices.length;
	var face, flen = faces.length;
	var cont, clen = contour.length;

	for ( i = 0; i < vlen; i++ ) {

		vert = vertices[ i ];

		this.vertices.push( new THREE.Vector3( vert.x, vert.y, 0 ) );

	}

	for ( i = 0; i < flen; i++ ) {

		face = faces[ i ];

		var a = face[ 0 ] + shapesOffset;
		var b = face[ 1 ] + shapesOffset;
		var c = face[ 2 ] + shapesOffset;

		this.faces.push( new THREE.Face3( a, b, c, null, null, material ) );
		this.faceVertexUvs[ 0 ].push( uvgen.generateBottomUV( this, shape, options, a, b, c ) );

	}

};

/**
 * @author astrodud / http://astrodud.isgreat.org/
 * @author zz85 / https://github.com/zz85
 * @author bhouston / http://exocortex.com
 */

// points - to create a closed torus, one must use a set of points
//    like so: [ a, b, c, d, a ], see first is the same as last.
// segments - the number of circumference segments to create
// phiStart - the starting radian
// phiLength - the radian (0 to 2*PI) range of the lathed section
//    2*pi is a closed lathe, less than 2PI is a portion.
THREE.LatheGeometry = function ( points, segments, phiStart, phiLength ) {

	THREE.Geometry.call( this );

	segments = segments || 12;
	phiStart = phiStart || 0;
	phiLength = phiLength || 2 * Math.PI;

	var inversePointLength = 1.0 / ( points.length - 1 );
	var inverseSegments = 1.0 / segments;

	for ( var i = 0, il = segments; i <= il; i ++ ) {

		var phi = phiStart + i * inverseSegments * phiLength;

		var c = Math.cos( phi ),
			s = Math.sin( phi );

		for ( var j = 0, jl = points.length; j < jl; j ++ ) {

			var pt = points[ j ];

			var vertex = new THREE.Vector3();

			vertex.x = c * pt.x - s * pt.y;
			vertex.y = s * pt.x + c * pt.y;
			vertex.z = pt.z;

			this.vertices.push( vertex );

		}

	}

	var np = points.length;

	for ( var i = 0, il = segments; i < il; i ++ ) {

		for ( var j = 0, jl = points.length - 1; j < jl; j ++ ) {

			var base = j + np * i;
			var a = base;
			var b = base + np;
			var c = base + 1 + np;
			var d = base + 1;

			var u0 = i * inverseSegments;
			var v0 = j * inversePointLength;
			var u1 = u0 + inverseSegments;
			var v1 = v0 + inversePointLength;

			this.faces.push( new THREE.Face3( a, b, d ) );

			this.faceVertexUvs[ 0 ].push( [

				new THREE.Vector2( u0, v0 ),
				new THREE.Vector2( u1, v0 ),
				new THREE.Vector2( u0, v1 )

			] );

			this.faces.push( new THREE.Face3( b, c, d ) );

			this.faceVertexUvs[ 0 ].push( [

				new THREE.Vector2( u1, v0 ),
				new THREE.Vector2( u1, v1 ),
				new THREE.Vector2( u0, v1 )

			] );


		}

	}

	this.mergeVertices();
	this.computeCentroids();
	this.computeFaceNormals();
	this.computeVertexNormals();

};

THREE.LatheGeometry.prototype = Object.create( THREE.Geometry.prototype );

/**
 * @author mrdoob / http://mrdoob.com/
 * based on http://papervision3d.googlecode.com/svn/trunk/as3/trunk/src/org/papervision3d/objects/primitives/Plane.as
 */

THREE.PlaneGeometry = function ( width, height, widthSegments, heightSegments ) {

	THREE.Geometry.call( this );

	this.width = width;
	this.height = height;

	this.widthSegments = widthSegments || 1;
	this.heightSegments = heightSegments || 1;

	var ix, iz;
	var width_half = width / 2;
	var height_half = height / 2;

	var gridX = this.widthSegments;
	var gridZ = this.heightSegments;

	var gridX1 = gridX + 1;
	var gridZ1 = gridZ + 1;

	var segment_width = this.width / gridX;
	var segment_height = this.height / gridZ;

	var normal = new THREE.Vector3( 0, 0, 1 );

	for ( iz = 0; iz < gridZ1; iz ++ ) {

		for ( ix = 0; ix < gridX1; ix ++ ) {

			var x = ix * segment_width - width_half;
			var y = iz * segment_height - height_half;

			this.vertices.push( new THREE.Vector3( x, - y, 0 ) );

		}

	}

	for ( iz = 0; iz < gridZ; iz ++ ) {

		for ( ix = 0; ix < gridX; ix ++ ) {

			var a = ix + gridX1 * iz;
			var b = ix + gridX1 * ( iz + 1 );
			var c = ( ix + 1 ) + gridX1 * ( iz + 1 );
			var d = ( ix + 1 ) + gridX1 * iz;

			var uva = new THREE.Vector2( ix / gridX, 1 - iz / gridZ );
			var uvb = new THREE.Vector2( ix / gridX, 1 - ( iz + 1 ) / gridZ );
			var uvc = new THREE.Vector2( ( ix + 1 ) / gridX, 1 - ( iz + 1 ) / gridZ );
			var uvd = new THREE.Vector2( ( ix + 1 ) / gridX, 1 - iz / gridZ );

			var face = new THREE.Face3( a, b, d );
			face.normal.copy( normal );
			face.vertexNormals.push( normal.clone(), normal.clone(), normal.clone() );

			this.faces.push( face );
			this.faceVertexUvs[ 0 ].push( [ uva, uvb, uvd ] );

			face = new THREE.Face3( b, c, d );
			face.normal.copy( normal );
			face.vertexNormals.push( normal.clone(), normal.clone(), normal.clone() );

			this.faces.push( face );
			this.faceVertexUvs[ 0 ].push( [ uvb.clone(), uvc, uvd.clone() ] );

		}

	}

	this.computeCentroids();

};

THREE.PlaneGeometry.prototype = Object.create( THREE.Geometry.prototype );

/**
 * @author Kaleb Murphy
 */

THREE.RingGeometry = function ( innerRadius, outerRadius, thetaSegments, phiSegments, thetaStart, thetaLength ) {

	THREE.Geometry.call( this );

	innerRadius = innerRadius || 0;
	outerRadius = outerRadius || 50;

	thetaStart = thetaStart !== undefined ? thetaStart : 0;
	thetaLength = thetaLength !== undefined ? thetaLength : Math.PI * 2;

	thetaSegments = thetaSegments !== undefined ? Math.max( 3, thetaSegments ) : 8;
	phiSegments = phiSegments !== undefined ? Math.max( 3, phiSegments ) : 8;

	var i, o, uvs = [], radius = innerRadius, radiusStep = ( ( outerRadius - innerRadius ) / phiSegments );

	for ( i = 0; i <= phiSegments; i ++ ) { // concentric circles inside ring

		for ( o = 0; o <= thetaSegments; o ++ ) { // number of segments per circle

			var vertex = new THREE.Vector3();
			var segment = thetaStart + o / thetaSegments * thetaLength;

			vertex.x = radius * Math.cos( segment );
			vertex.y = radius * Math.sin( segment );

			this.vertices.push( vertex );
			uvs.push( new THREE.Vector2( ( vertex.x / outerRadius + 1 ) / 2, ( vertex.y / outerRadius + 1 ) / 2 ) );
		}

		radius += radiusStep;

	}

	var n = new THREE.Vector3( 0, 0, 1 );

	for ( i = 0; i < phiSegments; i ++ ) { // concentric circles inside ring

		var thetaSegment = i * thetaSegments;

		for ( o = 0; o <= thetaSegments; o ++ ) { // number of segments per circle

			var segment = o + thetaSegment;

			var v1 = segment + i;
			var v2 = segment + thetaSegments + i;
			var v3 = segment + thetaSegments + 1 + i;

			this.faces.push( new THREE.Face3( v1, v2, v3, [ n.clone(), n.clone(), n.clone() ] ) );
			this.faceVertexUvs[ 0 ].push( [ uvs[ v1 ].clone(), uvs[ v2 ].clone(), uvs[ v3 ].clone() ]);

			v1 = segment + i;
			v2 = segment + thetaSegments + 1 + i;
			v3 = segment + 1 + i;

			this.faces.push( new THREE.Face3( v1, v2, v3, [ n.clone(), n.clone(), n.clone() ] ) );
			this.faceVertexUvs[ 0 ].push( [ uvs[ v1 ].clone(), uvs[ v2 ].clone(), uvs[ v3 ].clone() ]);

		}
	}

	this.computeCentroids();
	this.computeFaceNormals();

	this.boundingSphere = new THREE.Sphere( new THREE.Vector3(), radius );

};

THREE.RingGeometry.prototype = Object.create( THREE.Geometry.prototype );

/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.SphereGeometry = function ( radius, widthSegments, heightSegments, phiStart, phiLength, thetaStart, thetaLength ) {

	THREE.Geometry.call( this );

	this.radius = radius = radius || 50;

	this.widthSegments = widthSegments = Math.max( 3, Math.floor( widthSegments ) || 8 );
	this.heightSegments = heightSegments = Math.max( 2, Math.floor( heightSegments ) || 6 );

	this.phiStart = phiStart = phiStart !== undefined ? phiStart : 0;
	this.phiLength = phiLength = phiLength !== undefined ? phiLength : Math.PI * 2;

	this.thetaStart = thetaStart = thetaStart !== undefined ? thetaStart : 0;
	this.thetaLength = thetaLength = thetaLength !== undefined ? thetaLength : Math.PI;

	var x, y, vertices = [], uvs = [];

	for ( y = 0; y <= heightSegments; y ++ ) {

		var verticesRow = [];
		var uvsRow = [];

		for ( x = 0; x <= widthSegments; x ++ ) {

			var u = x / widthSegments;
			var v = y / heightSegments;

			var vertex = new THREE.Vector3();
			vertex.x = - radius * Math.cos( phiStart + u * phiLength ) * Math.sin( thetaStart + v * thetaLength );
			vertex.y = radius * Math.cos( thetaStart + v * thetaLength );
			vertex.z = radius * Math.sin( phiStart + u * phiLength ) * Math.sin( thetaStart + v * thetaLength );

			this.vertices.push( vertex );

			verticesRow.push( this.vertices.length - 1 );
			uvsRow.push( new THREE.Vector2( u, 1 - v ) );

		}

		vertices.push( verticesRow );
		uvs.push( uvsRow );

	}

	for ( y = 0; y < this.heightSegments; y ++ ) {

		for ( x = 0; x < this.widthSegments; x ++ ) {

			var v1 = vertices[ y ][ x + 1 ];
			var v2 = vertices[ y ][ x ];
			var v3 = vertices[ y + 1 ][ x ];
			var v4 = vertices[ y + 1 ][ x + 1 ];

			var n1 = this.vertices[ v1 ].clone().normalize();
			var n2 = this.vertices[ v2 ].clone().normalize();
			var n3 = this.vertices[ v3 ].clone().normalize();
			var n4 = this.vertices[ v4 ].clone().normalize();

			var uv1 = uvs[ y ][ x + 1 ].clone();
			var uv2 = uvs[ y ][ x ].clone();
			var uv3 = uvs[ y + 1 ][ x ].clone();
			var uv4 = uvs[ y + 1 ][ x + 1 ].clone();

			if ( Math.abs( this.vertices[ v1 ].y ) === this.radius ) {

				uv1.x = ( uv1.x + uv2.x ) / 2;
				this.faces.push( new THREE.Face3( v1, v3, v4, [ n1, n3, n4 ] ) );
				this.faceVertexUvs[ 0 ].push( [ uv1, uv3, uv4 ] );

			} else if ( Math.abs( this.vertices[ v3 ].y ) === this.radius ) {

				uv3.x = ( uv3.x + uv4.x ) / 2;
				this.faces.push( new THREE.Face3( v1, v2, v3, [ n1, n2, n3 ] ) );
				this.faceVertexUvs[ 0 ].push( [ uv1, uv2, uv3 ] );

			} else {

				this.faces.push( new THREE.Face3( v1, v2, v4, [ n1, n2, n4 ] ) );
				this.faceVertexUvs[ 0 ].push( [ uv1, uv2, uv4 ] );

				this.faces.push( new THREE.Face3( v2, v3, v4, [ n2.clone(), n3, n4.clone() ] ) );
				this.faceVertexUvs[ 0 ].push( [ uv2.clone(), uv3, uv4.clone() ] );

			}

		}

	}

	this.computeCentroids();
	this.computeFaceNormals();

	this.boundingSphere = new THREE.Sphere( new THREE.Vector3(), radius );

};

THREE.SphereGeometry.prototype = Object.create( THREE.Geometry.prototype );

/**
 * @author zz85 / http://www.lab4games.net/zz85/blog
 * @author alteredq / http://alteredqualia.com/
 *
 * For creating 3D text geometry in three.js
 *
 * Text = 3D Text
 *
 * parameters = {
 *  size: 			<float>, 	// size of the text
 *  height: 		<float>, 	// thickness to extrude text
 *  curveSegments: 	<int>,		// number of points on the curves
 *
 *  font: 			<string>,		// font name
 *  weight: 		<string>,		// font weight (normal, bold)
 *  style: 			<string>,		// font style  (normal, italics)
 *
 *  bevelEnabled:	<bool>,			// turn on bevel
 *  bevelThickness: <float>, 		// how deep into text bevel goes
 *  bevelSize:		<float>, 		// how far from text outline is bevel
 *  }
 *
 */

/*	Usage Examples

	// TextGeometry wrapper

	var text3d = new TextGeometry( text, options );

	// Complete manner

	var textShapes = THREE.FontUtils.generateShapes( text, options );
	var text3d = new ExtrudeGeometry( textShapes, options );

*/


THREE.TextGeometry = function ( text, parameters ) {

	parameters = parameters || {};

	var textShapes = THREE.FontUtils.generateShapes( text, parameters );

	// translate parameters to ExtrudeGeometry API

	parameters.amount = parameters.height !== undefined ? parameters.height : 50;

	// defaults

	if ( parameters.bevelThickness === undefined ) parameters.bevelThickness = 10;
	if ( parameters.bevelSize === undefined ) parameters.bevelSize = 8;
	if ( parameters.bevelEnabled === undefined ) parameters.bevelEnabled = false;

	THREE.ExtrudeGeometry.call( this, textShapes, parameters );

};

THREE.TextGeometry.prototype = Object.create( THREE.ExtrudeGeometry.prototype );

/**
 * @author oosmoxiecode
 * @author mrdoob / http://mrdoob.com/
 * based on http://code.google.com/p/away3d/source/browse/trunk/fp10/Away3DLite/src/away3dlite/primitives/Torus.as?r=2888
 */

THREE.TorusGeometry = function ( radius, tube, radialSegments, tubularSegments, arc ) {

	THREE.Geometry.call( this );

	var scope = this;

	this.radius = radius || 100;
	this.tube = tube || 40;
	this.radialSegments = radialSegments || 8;
	this.tubularSegments = tubularSegments || 6;
	this.arc = arc || Math.PI * 2;

	var center = new THREE.Vector3(), uvs = [], normals = [];

	for ( var j = 0; j <= this.radialSegments; j ++ ) {

		for ( var i = 0; i <= this.tubularSegments; i ++ ) {

			var u = i / this.tubularSegments * this.arc;
			var v = j / this.radialSegments * Math.PI * 2;

			center.x = this.radius * Math.cos( u );
			center.y = this.radius * Math.sin( u );

			var vertex = new THREE.Vector3();
			vertex.x = ( this.radius + this.tube * Math.cos( v ) ) * Math.cos( u );
			vertex.y = ( this.radius + this.tube * Math.cos( v ) ) * Math.sin( u );
			vertex.z = this.tube * Math.sin( v );

			this.vertices.push( vertex );

			uvs.push( new THREE.Vector2( i / this.tubularSegments, j / this.radialSegments ) );
			normals.push( vertex.clone().sub( center ).normalize() );

		}

	}


	for ( var j = 1; j <= this.radialSegments; j ++ ) {

		for ( var i = 1; i <= this.tubularSegments; i ++ ) {

			var a = ( this.tubularSegments + 1 ) * j + i - 1;
			var b = ( this.tubularSegments + 1 ) * ( j - 1 ) + i - 1;
			var c = ( this.tubularSegments + 1 ) * ( j - 1 ) + i;
			var d = ( this.tubularSegments + 1 ) * j + i;

			var face = new THREE.Face3( a, b, d, [ normals[ a ].clone(), normals[ b ].clone(), normals[ d ].clone() ] );
			this.faces.push( face );
			this.faceVertexUvs[ 0 ].push( [ uvs[ a ].clone(), uvs[ b ].clone(), uvs[ d ].clone() ] );

			face = new THREE.Face3( b, c, d, [ normals[ b ].clone(), normals[ c ].clone(), normals[ d ].clone() ] );
			this.faces.push( face );
			this.faceVertexUvs[ 0 ].push( [ uvs[ b ].clone(), uvs[ c ].clone(), uvs[ d ].clone() ] );

		}

	}

	this.computeCentroids();
	this.computeFaceNormals();

};

THREE.TorusGeometry.prototype = Object.create( THREE.Geometry.prototype );

/**
 * @author oosmoxiecode
 * based on http://code.google.com/p/away3d/source/browse/trunk/fp10/Away3D/src/away3d/primitives/TorusKnot.as?spec=svn2473&r=2473
 */

THREE.TorusKnotGeometry = function ( radius, tube, radialSegments, tubularSegments, p, q, heightScale ) {

	THREE.Geometry.call( this );

	var scope = this;

	this.radius = radius || 100;
	this.tube = tube || 40;
	this.radialSegments = radialSegments || 64;
	this.tubularSegments = tubularSegments || 8;
	this.p = p || 2;
	this.q = q || 3;
	this.heightScale = heightScale || 1;
	this.grid = new Array( this.radialSegments );

	var tang = new THREE.Vector3();
	var n = new THREE.Vector3();
	var bitan = new THREE.Vector3();

	for ( var i = 0; i < this.radialSegments; ++ i ) {

		this.grid[ i ] = new Array( this.tubularSegments );
		var u = i / this.radialSegments * 2 * this.p * Math.PI;
		var p1 = getPos( u, this.q, this.p, this.radius, this.heightScale );
		var p2 = getPos( u + 0.01, this.q, this.p, this.radius, this.heightScale );
		tang.subVectors( p2, p1 );
		n.addVectors( p2, p1 );

		bitan.crossVectors( tang, n );
		n.crossVectors( bitan, tang );
		bitan.normalize();
		n.normalize();

		for ( var j = 0; j < this.tubularSegments; ++ j ) {

			var v = j / this.tubularSegments * 2 * Math.PI;
			var cx = - this.tube * Math.cos( v ); // TODO: Hack: Negating it so it faces outside.
			var cy = this.tube * Math.sin( v );

			var pos = new THREE.Vector3();
			pos.x = p1.x + cx * n.x + cy * bitan.x;
			pos.y = p1.y + cx * n.y + cy * bitan.y;
			pos.z = p1.z + cx * n.z + cy * bitan.z;

			this.grid[ i ][ j ] = scope.vertices.push( pos ) - 1;

		}

	}

	for ( var i = 0; i < this.radialSegments; ++ i ) {

		for ( var j = 0; j < this.tubularSegments; ++ j ) {

			var ip = ( i + 1 ) % this.radialSegments;
			var jp = ( j + 1 ) % this.tubularSegments;

			var a = this.grid[ i ][ j ];
			var b = this.grid[ ip ][ j ];
			var c = this.grid[ ip ][ jp ];
			var d = this.grid[ i ][ jp ];

			var uva = new THREE.Vector2( i / this.radialSegments, j / this.tubularSegments );
			var uvb = new THREE.Vector2( ( i + 1 ) / this.radialSegments, j / this.tubularSegments );
			var uvc = new THREE.Vector2( ( i + 1 ) / this.radialSegments, ( j + 1 ) / this.tubularSegments );
			var uvd = new THREE.Vector2( i / this.radialSegments, ( j + 1 ) / this.tubularSegments );

			this.faces.push( new THREE.Face3( a, b, d ) );
			this.faceVertexUvs[ 0 ].push( [ uva, uvb, uvd ] );

			this.faces.push( new THREE.Face3( b, c, d ) );
			this.faceVertexUvs[ 0 ].push( [ uvb.clone(), uvc, uvd.clone() ] );

		}
	}

	this.computeCentroids();
	this.computeFaceNormals();
	this.computeVertexNormals();

	function getPos( u, in_q, in_p, radius, heightScale ) {

		var cu = Math.cos( u );
		var su = Math.sin( u );
		var quOverP = in_q / in_p * u;
		var cs = Math.cos( quOverP );

		var tx = radius * ( 2 + cs ) * 0.5 * cu;
		var ty = radius * ( 2 + cs ) * su * 0.5;
		var tz = heightScale * radius * Math.sin( quOverP ) * 0.5;

		return new THREE.Vector3( tx, ty, tz );

	}

};

THREE.TorusKnotGeometry.prototype = Object.create( THREE.Geometry.prototype );

/**
 * @author WestLangley / https://github.com/WestLangley
 * @author zz85 / https://github.com/zz85
 * @author miningold / https://github.com/miningold
 *
 * Modified from the TorusKnotGeometry by @oosmoxiecode
 *
 * Creates a tube which extrudes along a 3d spline
 *
 * Uses parallel transport frames as described in
 * http://www.cs.indiana.edu/pub/techreports/TR425.pdf
 */

THREE.TubeGeometry = function( path, segments, radius, radialSegments, closed ) {

	THREE.Geometry.call( this );

	this.path = path;
	this.segments = segments || 64;
	this.radius = radius || 1;
	this.radialSegments = radialSegments || 8;
	this.closed = closed || false;

	this.grid = [];

	var scope = this,

		tangent,
		normal,
		binormal,

		numpoints = this.segments + 1,

		x, y, z,
		tx, ty, tz,
		u, v,

		cx, cy,
		pos, pos2 = new THREE.Vector3(),
		i, j,
		ip, jp,
		a, b, c, d,
		uva, uvb, uvc, uvd;

	var frames = new THREE.TubeGeometry.FrenetFrames( this.path, this.segments, this.closed ),
		tangents = frames.tangents,
		normals = frames.normals,
		binormals = frames.binormals;

	// proxy internals
	this.tangents = tangents;
	this.normals = normals;
	this.binormals = binormals;

	function vert( x, y, z ) {

		return scope.vertices.push( new THREE.Vector3( x, y, z ) ) - 1;

	}


	// consruct the grid

	for ( i = 0; i < numpoints; i++ ) {

		this.grid[ i ] = [];

		u = i / ( numpoints - 1 );

		pos = path.getPointAt( u );

		tangent = tangents[ i ];
		normal = normals[ i ];
		binormal = binormals[ i ];

		for ( j = 0; j < this.radialSegments; j++ ) {

			v = j / this.radialSegments * 2 * Math.PI;

			cx = -this.radius * Math.cos( v ); // TODO: Hack: Negating it so it faces outside.
			cy = this.radius * Math.sin( v );

			pos2.copy( pos );
			pos2.x += cx * normal.x + cy * binormal.x;
			pos2.y += cx * normal.y + cy * binormal.y;
			pos2.z += cx * normal.z + cy * binormal.z;

			this.grid[ i ][ j ] = vert( pos2.x, pos2.y, pos2.z );

		}
	}


	// construct the mesh

	for ( i = 0; i < this.segments; i++ ) {

		for ( j = 0; j < this.radialSegments; j++ ) {

			ip = ( this.closed ) ? (i + 1) % this.segments : i + 1;
			jp = (j + 1) % this.radialSegments;

			a = this.grid[ i ][ j ];		// *** NOT NECESSARILY PLANAR ! ***
			b = this.grid[ ip ][ j ];
			c = this.grid[ ip ][ jp ];
			d = this.grid[ i ][ jp ];

			uva = new THREE.Vector2( i / this.segments, j / this.radialSegments );
			uvb = new THREE.Vector2( ( i + 1 ) / this.segments, j / this.radialSegments );
			uvc = new THREE.Vector2( ( i + 1 ) / this.segments, ( j + 1 ) / this.radialSegments );
			uvd = new THREE.Vector2( i / this.segments, ( j + 1 ) / this.radialSegments );

			this.faces.push( new THREE.Face3( a, b, d ) );
			this.faceVertexUvs[ 0 ].push( [ uva, uvb, uvd ] );

			this.faces.push( new THREE.Face3( b, c, d ) );
			this.faceVertexUvs[ 0 ].push( [ uvb.clone(), uvc, uvd.clone() ] );

		}
	}

	this.computeCentroids();
	this.computeFaceNormals();
	this.computeVertexNormals();

};

THREE.TubeGeometry.prototype = Object.create( THREE.Geometry.prototype );


// For computing of Frenet frames, exposing the tangents, normals and binormals the spline
THREE.TubeGeometry.FrenetFrames = function(path, segments, closed) {

	var	tangent = new THREE.Vector3(),
		normal = new THREE.Vector3(),
		binormal = new THREE.Vector3(),

		tangents = [],
		normals = [],
		binormals = [],

		vec = new THREE.Vector3(),
		mat = new THREE.Matrix4(),

		numpoints = segments + 1,
		theta,
		epsilon = 0.0001,
		smallest,

		tx, ty, tz,
		i, u, v;


	// expose internals
	this.tangents = tangents;
	this.normals = normals;
	this.binormals = binormals;

	// compute the tangent vectors for each segment on the path

	for ( i = 0; i < numpoints; i++ ) {

		u = i / ( numpoints - 1 );

		tangents[ i ] = path.getTangentAt( u );
		tangents[ i ].normalize();

	}

	initialNormal3();

	function initialNormal1(lastBinormal) {
		// fixed start binormal. Has dangers of 0 vectors
		normals[ 0 ] = new THREE.Vector3();
		binormals[ 0 ] = new THREE.Vector3();
		if (lastBinormal===undefined) lastBinormal = new THREE.Vector3( 0, 0, 1 );
		normals[ 0 ].crossVectors( lastBinormal, tangents[ 0 ] ).normalize();
		binormals[ 0 ].crossVectors( tangents[ 0 ], normals[ 0 ] ).normalize();
	}

	function initialNormal2() {

		// This uses the Frenet-Serret formula for deriving binormal
		var t2 = path.getTangentAt( epsilon );

		normals[ 0 ] = new THREE.Vector3().subVectors( t2, tangents[ 0 ] ).normalize();
		binormals[ 0 ] = new THREE.Vector3().crossVectors( tangents[ 0 ], normals[ 0 ] );

		normals[ 0 ].crossVectors( binormals[ 0 ], tangents[ 0 ] ).normalize(); // last binormal x tangent
		binormals[ 0 ].crossVectors( tangents[ 0 ], normals[ 0 ] ).normalize();

	}

	function initialNormal3() {
		// select an initial normal vector perpenicular to the first tangent vector,
		// and in the direction of the smallest tangent xyz component

		normals[ 0 ] = new THREE.Vector3();
		binormals[ 0 ] = new THREE.Vector3();
		smallest = Number.MAX_VALUE;
		tx = Math.abs( tangents[ 0 ].x );
		ty = Math.abs( tangents[ 0 ].y );
		tz = Math.abs( tangents[ 0 ].z );

		if ( tx <= smallest ) {
			smallest = tx;
			normal.set( 1, 0, 0 );
		}

		if ( ty <= smallest ) {
			smallest = ty;
			normal.set( 0, 1, 0 );
		}

		if ( tz <= smallest ) {
			normal.set( 0, 0, 1 );
		}

		vec.crossVectors( tangents[ 0 ], normal ).normalize();

		normals[ 0 ].crossVectors( tangents[ 0 ], vec );
		binormals[ 0 ].crossVectors( tangents[ 0 ], normals[ 0 ] );
	}


	// compute the slowly-varying normal and binormal vectors for each segment on the path

	for ( i = 1; i < numpoints; i++ ) {

		normals[ i ] = normals[ i-1 ].clone();

		binormals[ i ] = binormals[ i-1 ].clone();

		vec.crossVectors( tangents[ i-1 ], tangents[ i ] );

		if ( vec.length() > epsilon ) {

			vec.normalize();

			theta = Math.acos( THREE.Math.clamp( tangents[ i-1 ].dot( tangents[ i ] ), -1, 1 ) ); // clamp for floating pt errors

			normals[ i ].applyMatrix4( mat.makeRotationAxis( vec, theta ) );

		}

		binormals[ i ].crossVectors( tangents[ i ], normals[ i ] );

	}


	// if the curve is closed, postprocess the vectors so the first and last normal vectors are the same

	if ( closed ) {

		theta = Math.acos( THREE.Math.clamp( normals[ 0 ].dot( normals[ numpoints-1 ] ), -1, 1 ) );
		theta /= ( numpoints - 1 );

		if ( tangents[ 0 ].dot( vec.crossVectors( normals[ 0 ], normals[ numpoints-1 ] ) ) > 0 ) {

			theta = -theta;

		}

		for ( i = 1; i < numpoints; i++ ) {

			// twist a little...
			normals[ i ].applyMatrix4( mat.makeRotationAxis( tangents[ i ], theta * i ) );
			binormals[ i ].crossVectors( tangents[ i ], normals[ i ] );

		}

	}
};

/**
 * @author clockworkgeek / https://github.com/clockworkgeek
 * @author timothypratley / https://github.com/timothypratley
 * @author WestLangley / http://github.com/WestLangley
*/

THREE.PolyhedronGeometry = function ( vertices, faces, radius, detail ) {

	THREE.Geometry.call( this );

	radius = radius || 1;
	detail = detail || 0;

	var that = this;

	for ( var i = 0, l = vertices.length; i < l; i ++ ) {

		prepare( new THREE.Vector3( vertices[ i ][ 0 ], vertices[ i ][ 1 ], vertices[ i ][ 2 ] ) );

	}

	var midpoints = [], p = this.vertices;

	var f = [];
	for ( var i = 0, l = faces.length; i < l; i ++ ) {

		var v1 = p[ faces[ i ][ 0 ] ];
		var v2 = p[ faces[ i ][ 1 ] ];
		var v3 = p[ faces[ i ][ 2 ] ];

		f[ i ] = new THREE.Face3( v1.index, v2.index, v3.index, [ v1.clone(), v2.clone(), v3.clone() ] );

	}

	for ( var i = 0, l = f.length; i < l; i ++ ) {

		subdivide(f[ i ], detail);

	}


	// Handle case when face straddles the seam

	for ( var i = 0, l = this.faceVertexUvs[ 0 ].length; i < l; i ++ ) {

		var uvs = this.faceVertexUvs[ 0 ][ i ];

		var x0 = uvs[ 0 ].x;
		var x1 = uvs[ 1 ].x;
		var x2 = uvs[ 2 ].x;

		var max = Math.max( x0, Math.max( x1, x2 ) );
		var min = Math.min( x0, Math.min( x1, x2 ) );

		if ( max > 0.9 && min < 0.1 ) { // 0.9 is somewhat arbitrary

			if ( x0 < 0.2 ) uvs[ 0 ].x += 1;
			if ( x1 < 0.2 ) uvs[ 1 ].x += 1;
			if ( x2 < 0.2 ) uvs[ 2 ].x += 1;

		}

	}


	// Apply radius

	for ( var i = 0, l = this.vertices.length; i < l; i ++ ) {

		this.vertices[ i ].multiplyScalar( radius );

	}


	// Merge vertices

	this.mergeVertices();

	this.computeCentroids();

	this.computeFaceNormals();

	this.boundingSphere = new THREE.Sphere( new THREE.Vector3(), radius );


	// Project vector onto sphere's surface

	function prepare( vector ) {

		var vertex = vector.normalize().clone();
		vertex.index = that.vertices.push( vertex ) - 1;

		// Texture coords are equivalent to map coords, calculate angle and convert to fraction of a circle.

		var u = azimuth( vector ) / 2 / Math.PI + 0.5;
		var v = inclination( vector ) / Math.PI + 0.5;
		vertex.uv = new THREE.Vector2( u, 1 - v );

		return vertex;

	}


	// Approximate a curved face with recursively sub-divided triangles.

	function make( v1, v2, v3 ) {

		var face = new THREE.Face3( v1.index, v2.index, v3.index, [ v1.clone(), v2.clone(), v3.clone() ] );
		face.centroid.add( v1 ).add( v2 ).add( v3 ).divideScalar( 3 );
		that.faces.push( face );

		var azi = azimuth( face.centroid );

		that.faceVertexUvs[ 0 ].push( [
			correctUV( v1.uv, v1, azi ),
			correctUV( v2.uv, v2, azi ),
			correctUV( v3.uv, v3, azi )
		] );

	}


	// Analytically subdivide a face to the required detail level.

	function subdivide(face, detail ) {

		var cols = Math.pow(2, detail);
		var cells = Math.pow(4, detail);
		var a = prepare( that.vertices[ face.a ] );
		var b = prepare( that.vertices[ face.b ] );
		var c = prepare( that.vertices[ face.c ] );
		var v = [];

		// Construct all of the vertices for this subdivision.

		for ( var i = 0 ; i <= cols; i ++ ) {

			v[ i ] = [];

			var aj = prepare( a.clone().lerp( c, i / cols ) );
			var bj = prepare( b.clone().lerp( c, i / cols ) );
			var rows = cols - i;

			for ( var j = 0; j <= rows; j ++) {

				if ( j == 0 && i == cols ) {

					v[ i ][ j ] = aj;

				} else {

					v[ i ][ j ] = prepare( aj.clone().lerp( bj, j / rows ) );

				}

			}

		}

		// Construct all of the faces.

		for ( var i = 0; i < cols ; i ++ ) {

			for ( var j = 0; j < 2 * (cols - i) - 1; j ++ ) {

				var k = Math.floor( j / 2 );

				if ( j % 2 == 0 ) {

					make(
						v[ i ][ k + 1],
						v[ i + 1 ][ k ],
						v[ i ][ k ]
					);

				} else {

					make(
						v[ i ][ k + 1 ],
						v[ i + 1][ k + 1],
						v[ i + 1 ][ k ]
					);

				}

			}

		}

	}


	// Angle around the Y axis, counter-clockwise when looking from above.

	function azimuth( vector ) {

		return Math.atan2( vector.z, -vector.x );

	}


	// Angle above the XZ plane.

	function inclination( vector ) {

		return Math.atan2( -vector.y, Math.sqrt( ( vector.x * vector.x ) + ( vector.z * vector.z ) ) );

	}


	// Texture fixing helper. Spheres have some odd behaviours.

	function correctUV( uv, vector, azimuth ) {

		if ( ( azimuth < 0 ) && ( uv.x === 1 ) ) uv = new THREE.Vector2( uv.x - 1, uv.y );
		if ( ( vector.x === 0 ) && ( vector.z === 0 ) ) uv = new THREE.Vector2( azimuth / 2 / Math.PI + 0.5, uv.y );
		return uv.clone();

	}


};

THREE.PolyhedronGeometry.prototype = Object.create( THREE.Geometry.prototype );

/**
 * @author timothypratley / https://github.com/timothypratley
 */

THREE.IcosahedronGeometry = function ( radius, detail ) {

	this.radius = radius;
	this.detail = detail;

	var t = ( 1 + Math.sqrt( 5 ) ) / 2;

	var vertices = [
		[ -1,  t,  0 ], [  1, t, 0 ], [ -1, -t,  0 ], [  1, -t,  0 ],
		[  0, -1,  t ], [  0, 1, t ], [  0, -1, -t ], [  0,  1, -t ],
		[  t,  0, -1 ], [  t, 0, 1 ], [ -t,  0, -1 ], [ -t,  0,  1 ]
	];

	var faces = [
		[ 0, 11,  5 ], [ 0,  5,  1 ], [  0,  1,  7 ], [  0,  7, 10 ], [  0, 10, 11 ],
		[ 1,  5,  9 ], [ 5, 11,  4 ], [ 11, 10,  2 ], [ 10,  7,  6 ], [  7,  1,  8 ],
		[ 3,  9,  4 ], [ 3,  4,  2 ], [  3,  2,  6 ], [  3,  6,  8 ], [  3,  8,  9 ],
		[ 4,  9,  5 ], [ 2,  4, 11 ], [  6,  2, 10 ], [  8,  6,  7 ], [  9,  8,  1 ]
	];

	THREE.PolyhedronGeometry.call( this, vertices, faces, radius, detail );

};

THREE.IcosahedronGeometry.prototype = Object.create( THREE.Geometry.prototype );

/**
 * @author timothypratley / https://github.com/timothypratley
 */

THREE.OctahedronGeometry = function ( radius, detail ) {

	var vertices = [
		[ 1, 0, 0 ], [ -1, 0, 0 ], [ 0, 1, 0 ], [ 0, -1, 0 ], [ 0, 0, 1 ], [ 0, 0, -1 ]
	];

	var faces = [
		[ 0, 2, 4 ], [ 0, 4, 3 ], [ 0, 3, 5 ], [ 0, 5, 2 ], [ 1, 2, 5 ], [ 1, 5, 3 ], [ 1, 3, 4 ], [ 1, 4, 2 ]
	];

	THREE.PolyhedronGeometry.call( this, vertices, faces, radius, detail );
};

THREE.OctahedronGeometry.prototype = Object.create( THREE.Geometry.prototype );

/**
 * @author timothypratley / https://github.com/timothypratley
 */

THREE.TetrahedronGeometry = function ( radius, detail ) {

	var vertices = [
		[ 1,  1,  1 ], [ -1, -1, 1 ], [ -1, 1, -1 ], [ 1, -1, -1 ]
	];

	var faces = [
		[ 2, 1, 0 ], [ 0, 3, 2 ], [ 1, 3, 0 ], [ 2, 3, 1 ]
	];

	THREE.PolyhedronGeometry.call( this, vertices, faces, radius, detail );

};

THREE.TetrahedronGeometry.prototype = Object.create( THREE.Geometry.prototype );

/**
 * @author zz85 / https://github.com/zz85
 * Parametric Surfaces Geometry
 * based on the brilliant article by @prideout http://prideout.net/blog/?p=44
 *
 * new THREE.ParametricGeometry( parametricFunction, uSegments, ySegements );
 *
 */

THREE.ParametricGeometry = function ( func, slices, stacks ) {

	THREE.Geometry.call( this );

	var verts = this.vertices;
	var faces = this.faces;
	var uvs = this.faceVertexUvs[ 0 ];

	var i, il, j, p;
	var u, v;

	var stackCount = stacks + 1;
	var sliceCount = slices + 1;

	for ( i = 0; i <= stacks; i ++ ) {

		v = i / stacks;

		for ( j = 0; j <= slices; j ++ ) {

			u = j / slices;

			p = func( u, v );
			verts.push( p );

		}
	}

	var a, b, c, d;
	var uva, uvb, uvc, uvd;

	for ( i = 0; i < stacks; i ++ ) {

		for ( j = 0; j < slices; j ++ ) {

			a = i * sliceCount + j;
			b = i * sliceCount + j + 1;
			c = (i + 1) * sliceCount + j + 1;
			d = (i + 1) * sliceCount + j;

			uva = new THREE.Vector2( j / slices, i / stacks );
			uvb = new THREE.Vector2( ( j + 1 ) / slices, i / stacks );
			uvc = new THREE.Vector2( ( j + 1 ) / slices, ( i + 1 ) / stacks );
			uvd = new THREE.Vector2( j / slices, ( i + 1 ) / stacks );

			faces.push( new THREE.Face3( a, b, d ) );
			uvs.push( [ uva, uvb, uvd ] );

			faces.push( new THREE.Face3( b, c, d ) );
			uvs.push( [ uvb.clone(), uvc, uvd.clone() ] );

		}

	}

	// console.log(this);

	// magic bullet
	// var diff = this.mergeVertices();
	// console.log('removed ', diff, ' vertices by merging');

	this.computeCentroids();
	this.computeFaceNormals();
	this.computeVertexNormals();

};

THREE.ParametricGeometry.prototype = Object.create( THREE.Geometry.prototype );

/**
 * @author sroucheray / http://sroucheray.org/
 * @author mrdoob / http://mrdoob.com/
 */

THREE.AxisHelper = function ( size ) {

	size = size || 1;

	var geometry = new THREE.Geometry();

	geometry.vertices.push(
		new THREE.Vector3(), new THREE.Vector3( size, 0, 0 ),
		new THREE.Vector3(), new THREE.Vector3( 0, size, 0 ),
		new THREE.Vector3(), new THREE.Vector3( 0, 0, size )
	);

	geometry.colors.push(
		new THREE.Color( 0xff0000 ), new THREE.Color( 0xffaa00 ),
		new THREE.Color( 0x00ff00 ), new THREE.Color( 0xaaff00 ),
		new THREE.Color( 0x0000ff ), new THREE.Color( 0x00aaff )
	);

	var material = new THREE.LineBasicMaterial( { vertexColors: THREE.VertexColors } );

	THREE.Line.call( this, geometry, material, THREE.LinePieces );

};

THREE.AxisHelper.prototype = Object.create( THREE.Line.prototype );

/**
 * @author WestLangley / http://github.com/WestLangley
 * @author zz85 / http://github.com/zz85
 * @author bhouston / http://exocortex.com
 *
 * Creates an arrow for visualizing directions
 *
 * Parameters:
 *  dir - Vector3
 *  origin - Vector3
 *  length - Number
 *  hex - color in hex value
 *  headLength - Number
 *  headWidth - Number
 */

THREE.ArrowHelper = function ( dir, origin, length, hex, headLength, headWidth ) {

	// dir is assumed to be normalized

	THREE.Object3D.call( this );

	if ( hex === undefined ) hex = 0xffff00;
	if ( length === undefined ) length = 1;
	if ( headLength === undefined ) headLength = 0.2 * length;
	if ( headWidth === undefined ) headWidth = 0.2 * headLength;

	this.position = origin;

	var lineGeometry = new THREE.Geometry();
	lineGeometry.vertices.push( new THREE.Vector3( 0, 0, 0 ) );
	lineGeometry.vertices.push( new THREE.Vector3( 0, 1, 0 ) );

	this.line = new THREE.Line( lineGeometry, new THREE.LineBasicMaterial( { color: hex } ) );
	this.line.matrixAutoUpdate = false;
	this.add( this.line );

	var coneGeometry = new THREE.CylinderGeometry( 0, 0.5, 1, 5, 1 );
	coneGeometry.applyMatrix( new THREE.Matrix4().makeTranslation( 0, - 0.5, 0 ) );

	this.cone = new THREE.Mesh( coneGeometry, new THREE.MeshBasicMaterial( { color: hex } ) );
	this.cone.matrixAutoUpdate = false;
	this.add( this.cone );

	this.setDirection( dir );
	this.setLength( length, headLength, headWidth );

};

THREE.ArrowHelper.prototype = Object.create( THREE.Object3D.prototype );

THREE.ArrowHelper.prototype.setDirection = function () {

	var axis = new THREE.Vector3();
	var radians;

	return function ( dir ) {

		// dir is assumed to be normalized

		if ( dir.y > 0.99999 ) {

			this.quaternion.set( 0, 0, 0, 1 );

		} else if ( dir.y < - 0.99999 ) {

			this.quaternion.set( 1, 0, 0, 0 );

		} else {

			axis.set( dir.z, 0, - dir.x ).normalize();

			radians = Math.acos( dir.y );

			this.quaternion.setFromAxisAngle( axis, radians );

		}

	};

}();

THREE.ArrowHelper.prototype.setLength = function ( length, headLength, headWidth ) {

	if ( headLength === undefined ) headLength = 0.2 * length;
	if ( headWidth === undefined ) headWidth = 0.2 * headLength;

	this.line.scale.set( 1, length, 1 );
	this.line.updateMatrix();

	this.cone.scale.set( headWidth, headLength, headWidth );
	this.cone.position.y = length;
	this.cone.updateMatrix();

};

THREE.ArrowHelper.prototype.setColor = function ( hex ) {

	this.line.material.color.setHex( hex );
	this.cone.material.color.setHex( hex );

};

/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.BoxHelper = function ( object ) {

	//   5____4
	// 1/___0/|
	// | 6__|_7
	// 2/___3/

	var vertices = [
		new THREE.Vector3(   1,   1,   1 ),
		new THREE.Vector3( - 1,   1,   1 ),
		new THREE.Vector3( - 1, - 1,   1 ),
		new THREE.Vector3(   1, - 1,   1 ),

		new THREE.Vector3(   1,   1, - 1 ),
		new THREE.Vector3( - 1,   1, - 1 ),
		new THREE.Vector3( - 1, - 1, - 1 ),
		new THREE.Vector3(   1, - 1, - 1 )
	];

	this.vertices = vertices;

	// TODO: Wouldn't be nice if Line had .segments?

	var geometry = new THREE.Geometry();
	geometry.vertices.push(
		vertices[ 0 ], vertices[ 1 ],
		vertices[ 1 ], vertices[ 2 ],
		vertices[ 2 ], vertices[ 3 ],
		vertices[ 3 ], vertices[ 0 ],

		vertices[ 4 ], vertices[ 5 ],
		vertices[ 5 ], vertices[ 6 ],
		vertices[ 6 ], vertices[ 7 ],
		vertices[ 7 ], vertices[ 4 ],

		vertices[ 0 ], vertices[ 4 ],
		vertices[ 1 ], vertices[ 5 ],
		vertices[ 2 ], vertices[ 6 ],
		vertices[ 3 ], vertices[ 7 ]
	);

	THREE.Line.call( this, geometry, new THREE.LineBasicMaterial( { color: 0xffff00 } ), THREE.LinePieces );

	if ( object !== undefined ) {

		this.update( object );

	}

};

THREE.BoxHelper.prototype = Object.create( THREE.Line.prototype );

THREE.BoxHelper.prototype.update = function ( object ) {

	var geometry = object.geometry;

	if ( geometry.boundingBox === null ) {

		geometry.computeBoundingBox();

	}

	var min = geometry.boundingBox.min;
	var max = geometry.boundingBox.max;
	var vertices = this.vertices;

	vertices[ 0 ].set( max.x, max.y, max.z );
	vertices[ 1 ].set( min.x, max.y, max.z );
	vertices[ 2 ].set( min.x, min.y, max.z );
	vertices[ 3 ].set( max.x, min.y, max.z );
	vertices[ 4 ].set( max.x, max.y, min.z );
	vertices[ 5 ].set( min.x, max.y, min.z );
	vertices[ 6 ].set( min.x, min.y, min.z );
	vertices[ 7 ].set( max.x, min.y, min.z );

	this.geometry.computeBoundingSphere();
	this.geometry.verticesNeedUpdate = true;

	this.matrixAutoUpdate = false;
	this.matrixWorld = object.matrixWorld;

};

/**
 * @author WestLangley / http://github.com/WestLangley
 */

// a helper to show the world-axis-aligned bounding box for an object

THREE.BoundingBoxHelper = function ( object, hex ) {

	var color = ( hex !== undefined ) ? hex : 0x888888;

	this.object = object;

	this.box = new THREE.Box3();

	THREE.Mesh.call( this, new THREE.CubeGeometry( 1, 1, 1 ), new THREE.MeshBasicMaterial( { color: color, wireframe: true } ) );

};

THREE.BoundingBoxHelper.prototype = Object.create( THREE.Mesh.prototype );

THREE.BoundingBoxHelper.prototype.update = function () {

	this.box.setFromObject( this.object );

	this.box.size( this.scale );

	this.box.center( this.position );

};

/**
 * @author alteredq / http://alteredqualia.com/
 *
 *	- shows frustum, line of sight and up of the camera
 *	- suitable for fast updates
 * 	- based on frustum visualization in lightgl.js shadowmap example
 *		http://evanw.github.com/lightgl.js/tests/shadowmap.html
 */

THREE.CameraHelper = function ( camera ) {

	var geometry = new THREE.Geometry();
	var material = new THREE.LineBasicMaterial( { color: 0xffffff, vertexColors: THREE.FaceColors } );

	var pointMap = {};

	// colors

	var hexFrustum = 0xffaa00;
	var hexCone = 0xff0000;
	var hexUp = 0x00aaff;
	var hexTarget = 0xffffff;
	var hexCross = 0x333333;

	// near

	addLine( "n1", "n2", hexFrustum );
	addLine( "n2", "n4", hexFrustum );
	addLine( "n4", "n3", hexFrustum );
	addLine( "n3", "n1", hexFrustum );

	// far

	addLine( "f1", "f2", hexFrustum );
	addLine( "f2", "f4", hexFrustum );
	addLine( "f4", "f3", hexFrustum );
	addLine( "f3", "f1", hexFrustum );

	// sides

	addLine( "n1", "f1", hexFrustum );
	addLine( "n2", "f2", hexFrustum );
	addLine( "n3", "f3", hexFrustum );
	addLine( "n4", "f4", hexFrustum );

	// cone

	addLine( "p", "n1", hexCone );
	addLine( "p", "n2", hexCone );
	addLine( "p", "n3", hexCone );
	addLine( "p", "n4", hexCone );

	// up

	addLine( "u1", "u2", hexUp );
	addLine( "u2", "u3", hexUp );
	addLine( "u3", "u1", hexUp );

	// target

	addLine( "c", "t", hexTarget );
	addLine( "p", "c", hexCross );

	// cross

	addLine( "cn1", "cn2", hexCross );
	addLine( "cn3", "cn4", hexCross );

	addLine( "cf1", "cf2", hexCross );
	addLine( "cf3", "cf4", hexCross );

	function addLine( a, b, hex ) {

		addPoint( a, hex );
		addPoint( b, hex );

	}

	function addPoint( id, hex ) {

		geometry.vertices.push( new THREE.Vector3() );
		geometry.colors.push( new THREE.Color( hex ) );

		if ( pointMap[ id ] === undefined ) {

			pointMap[ id ] = [];

		}

		pointMap[ id ].push( geometry.vertices.length - 1 );

	}

	THREE.Line.call( this, geometry, material, THREE.LinePieces );

	this.camera = camera;
	this.matrixWorld = camera.matrixWorld;
	this.matrixAutoUpdate = false;

	this.pointMap = pointMap;

	this.update();

};

THREE.CameraHelper.prototype = Object.create( THREE.Line.prototype );

THREE.CameraHelper.prototype.update = function () {

	var vector = new THREE.Vector3();
	var camera = new THREE.Camera();
	var projector = new THREE.Projector();

	return function () {

		var scope = this;

		var w = 1, h = 1;

		// we need just camera projection matrix
		// world matrix must be identity

		camera.projectionMatrix.copy( this.camera.projectionMatrix );

		// center / target

		setPoint( "c", 0, 0, -1 );
		setPoint( "t", 0, 0,  1 );

		// near

		setPoint( "n1", -w, -h, -1 );
		setPoint( "n2",  w, -h, -1 );
		setPoint( "n3", -w,  h, -1 );
		setPoint( "n4",  w,  h, -1 );

		// far

		setPoint( "f1", -w, -h, 1 );
		setPoint( "f2",  w, -h, 1 );
		setPoint( "f3", -w,  h, 1 );
		setPoint( "f4",  w,  h, 1 );

		// up

		setPoint( "u1",  w * 0.7, h * 1.1, -1 );
		setPoint( "u2", -w * 0.7, h * 1.1, -1 );
		setPoint( "u3",        0, h * 2,   -1 );

		// cross

		setPoint( "cf1", -w,  0, 1 );
		setPoint( "cf2",  w,  0, 1 );
		setPoint( "cf3",  0, -h, 1 );
		setPoint( "cf4",  0,  h, 1 );

		setPoint( "cn1", -w,  0, -1 );
		setPoint( "cn2",  w,  0, -1 );
		setPoint( "cn3",  0, -h, -1 );
		setPoint( "cn4",  0,  h, -1 );

		function setPoint( point, x, y, z ) {

			vector.set( x, y, z );
			projector.unprojectVector( vector, camera );

			var points = scope.pointMap[ point ];

			if ( points !== undefined ) {

				for ( var i = 0, il = points.length; i < il; i ++ ) {

					scope.geometry.vertices[ points[ i ] ].copy( vector );

				}

			}

		}

		this.geometry.verticesNeedUpdate = true;

	};

}();

/**
 * @author alteredq / http://alteredqualia.com/
 * @author mrdoob / http://mrdoob.com/
 * @author WestLangley / http://github.com/WestLangley
 */

THREE.DirectionalLightHelper = function ( light, size ) {

	THREE.Object3D.call( this );

	this.light = light;
	this.light.updateMatrixWorld();

	this.matrixWorld = light.matrixWorld;
	this.matrixAutoUpdate = false;

	size = size || 1;
	var geometry = new THREE.PlaneGeometry( size, size );
	var material = new THREE.MeshBasicMaterial( { wireframe: true, fog: false } );
	material.color.copy( this.light.color ).multiplyScalar( this.light.intensity );

	this.lightPlane = new THREE.Mesh( geometry, material );
	this.add( this.lightPlane );

	geometry = new THREE.Geometry();
	geometry.vertices.push( new THREE.Vector3() );
	geometry.vertices.push( new THREE.Vector3() );

	material = new THREE.LineBasicMaterial( { fog: false } );
	material.color.copy( this.light.color ).multiplyScalar( this.light.intensity );

	this.targetLine = new THREE.Line( geometry, material );
	this.add( this.targetLine );

	this.update();

};

THREE.DirectionalLightHelper.prototype = Object.create( THREE.Object3D.prototype );

THREE.DirectionalLightHelper.prototype.dispose = function () {

	this.lightPlane.geometry.dispose();
	this.lightPlane.material.dispose();
	this.targetLine.geometry.dispose();
	this.targetLine.material.dispose();
};

THREE.DirectionalLightHelper.prototype.update = function () {

	var v1 = new THREE.Vector3();
	var v2 = new THREE.Vector3();
	var v3 = new THREE.Vector3();

	return function () {

		v1.setFromMatrixPosition( this.light.matrixWorld );
		v2.setFromMatrixPosition( this.light.target.matrixWorld );
		v3.subVectors( v2, v1 );

		this.lightPlane.lookAt( v3 );
		this.lightPlane.material.color.copy( this.light.color ).multiplyScalar( this.light.intensity );

		this.targetLine.geometry.vertices[ 1 ].copy( v3 );
		this.targetLine.geometry.verticesNeedUpdate = true;
		this.targetLine.material.color.copy( this.lightPlane.material.color );

	}

}();


/**
 * @author WestLangley / http://github.com/WestLangley
 */

THREE.EdgesHelper = function ( object, hex ) {

	var color = ( hex !== undefined ) ? hex : 0xffffff;

	var edge = [ 0, 0 ], hash = {};
	var sortFunction = function ( a, b ) { return a - b };

	var keys = [ 'a', 'b', 'c' ];
	var geometry = new THREE.BufferGeometry();

	var geometry2 = object.geometry.clone();

	geometry2.mergeVertices();
	geometry2.computeFaceNormals();

	var vertices = geometry2.vertices;
	var faces = geometry2.faces;
	var numEdges = 0;

	for ( var i = 0, l = faces.length; i < l; i ++ ) {

		var face = faces[ i ];

		for ( var j = 0; j < 3; j ++ ) {

			edge[ 0 ] = face[ keys[ j ] ];
			edge[ 1 ] = face[ keys[ ( j + 1 ) % 3 ] ];
			edge.sort( sortFunction );

			var key = edge.toString();

			if ( hash[ key ] === undefined ) {

				hash[ key ] = { vert1: edge[ 0 ], vert2: edge[ 1 ], face1: i, face2: undefined };
				numEdges ++;

			} else {

				hash[ key ].face2 = i;

			}

		}

	}

	geometry.addAttribute( 'position', Float32Array, 2 * numEdges, 3 );

	var coords = geometry.attributes.position.array;

	var index = 0;

	for ( var key in hash ) {

		var h = hash[ key ];

		if ( h.face2 === undefined || faces[ h.face1 ].normal.dot( faces[ h.face2 ].normal ) < 0.9999 ) { // hardwired const OK

			var vertex = vertices[ h.vert1 ];
			coords[ index ++ ] = vertex.x;
			coords[ index ++ ] = vertex.y;
			coords[ index ++ ] = vertex.z;

			vertex = vertices[ h.vert2 ];
			coords[ index ++ ] = vertex.x;
			coords[ index ++ ] = vertex.y;
			coords[ index ++ ] = vertex.z;

		}

	}

	THREE.Line.call( this, geometry, new THREE.LineBasicMaterial( { color: color } ), THREE.LinePieces );

	this.matrixAutoUpdate = false;
	this.matrixWorld = object.matrixWorld;

};

THREE.EdgesHelper.prototype = Object.create( THREE.Line.prototype );

/**
 * @author mrdoob / http://mrdoob.com/
 * @author WestLangley / http://github.com/WestLangley
*/

THREE.FaceNormalsHelper = function ( object, size, hex, linewidth ) {

	this.object = object;

	this.size = ( size !== undefined ) ? size : 1;

	var color = ( hex !== undefined ) ? hex : 0xffff00;

	var width = ( linewidth !== undefined ) ? linewidth : 1;

	var geometry = new THREE.Geometry();

	var faces = this.object.geometry.faces;

	for ( var i = 0, l = faces.length; i < l; i ++ ) {

		geometry.vertices.push( new THREE.Vector3() );
		geometry.vertices.push( new THREE.Vector3() );

	}

	THREE.Line.call( this, geometry, new THREE.LineBasicMaterial( { color: color, linewidth: width } ), THREE.LinePieces );

	this.matrixAutoUpdate = false;

	this.normalMatrix = new THREE.Matrix3();

	this.update();

};

THREE.FaceNormalsHelper.prototype = Object.create( THREE.Line.prototype );

THREE.FaceNormalsHelper.prototype.update = ( function ( object ) {

	var v1 = new THREE.Vector3();

	return function ( object ) {

		this.object.updateMatrixWorld( true );

		this.normalMatrix.getNormalMatrix( this.object.matrixWorld );

		var vertices = this.geometry.vertices;

		var faces = this.object.geometry.faces;

		var worldMatrix = this.object.matrixWorld;

		for ( var i = 0, l = faces.length; i < l; i ++ ) {

			var face = faces[ i ];

			v1.copy( face.normal ).applyMatrix3( this.normalMatrix ).normalize().multiplyScalar( this.size );

			var idx = 2 * i;

			vertices[ idx ].copy( face.centroid ).applyMatrix4( worldMatrix );

			vertices[ idx + 1 ].addVectors( vertices[ idx ], v1 );

		}

		this.geometry.verticesNeedUpdate = true;

		return this;

	}

}());


/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.GridHelper = function ( size, step ) {

	var geometry = new THREE.Geometry();
	var material = new THREE.LineBasicMaterial( { vertexColors: THREE.VertexColors } );

	this.color1 = new THREE.Color( 0x444444 );
	this.color2 = new THREE.Color( 0x888888 );

	for ( var i = - size; i <= size; i += step ) {

		geometry.vertices.push(
			new THREE.Vector3( - size, 0, i ), new THREE.Vector3( size, 0, i ),
			new THREE.Vector3( i, 0, - size ), new THREE.Vector3( i, 0, size )
		);

		var color = i === 0 ? this.color1 : this.color2;

		geometry.colors.push( color, color, color, color );

	}

	THREE.Line.call( this, geometry, material, THREE.LinePieces );

};

THREE.GridHelper.prototype = Object.create( THREE.Line.prototype );

THREE.GridHelper.prototype.setColors = function( colorCenterLine, colorGrid ) {

	this.color1.set( colorCenterLine );
	this.color2.set( colorGrid );

	this.geometry.colorsNeedUpdate = true;

}

/**
 * @author alteredq / http://alteredqualia.com/
 * @author mrdoob / http://mrdoob.com/
 */

THREE.HemisphereLightHelper = function ( light, sphereSize, arrowLength, domeSize ) {

	THREE.Object3D.call( this );

	this.light = light;
	this.light.updateMatrixWorld();

	this.matrixWorld = light.matrixWorld;
	this.matrixAutoUpdate = false;

	this.colors = [ new THREE.Color(), new THREE.Color() ];

	var geometry = new THREE.SphereGeometry( sphereSize, 4, 2 );
	geometry.applyMatrix( new THREE.Matrix4().makeRotationX( - Math.PI / 2 ) );

	for ( var i = 0, il = 8; i < il; i ++ ) {

		geometry.faces[ i ].color = this.colors[ i < 4 ? 0 : 1 ];

	}

	var material = new THREE.MeshBasicMaterial( { vertexColors: THREE.FaceColors, wireframe: true } );

	this.lightSphere = new THREE.Mesh( geometry, material );
	this.add( this.lightSphere );

	this.update();

};

THREE.HemisphereLightHelper.prototype = Object.create( THREE.Object3D.prototype );

THREE.HemisphereLightHelper.prototype.dispose = function () {
	this.lightSphere.geometry.dispose();
	this.lightSphere.material.dispose();
};

THREE.HemisphereLightHelper.prototype.update = function () {

	var vector = new THREE.Vector3();

	return function () {

		this.colors[ 0 ].copy( this.light.color ).multiplyScalar( this.light.intensity );
		this.colors[ 1 ].copy( this.light.groundColor ).multiplyScalar( this.light.intensity );

		this.lightSphere.lookAt( vector.setFromMatrixPosition( this.light.matrixWorld ).negate() );
		this.lightSphere.geometry.colorsNeedUpdate = true;

	}

}();


/**
 * @author alteredq / http://alteredqualia.com/
 * @author mrdoob / http://mrdoob.com/
 */

THREE.PointLightHelper = function ( light, sphereSize ) {

	this.light = light;
	this.light.updateMatrixWorld();

	var geometry = new THREE.SphereGeometry( sphereSize, 4, 2 );
	var material = new THREE.MeshBasicMaterial( { wireframe: true, fog: false } );
	material.color.copy( this.light.color ).multiplyScalar( this.light.intensity );

	THREE.Mesh.call( this, geometry, material );

	this.matrixWorld = this.light.matrixWorld;
	this.matrixAutoUpdate = false;

	/*
	var distanceGeometry = new THREE.IcosahedronGeometry( 1, 2 );
	var distanceMaterial = new THREE.MeshBasicMaterial( { color: hexColor, fog: false, wireframe: true, opacity: 0.1, transparent: true } );

	this.lightSphere = new THREE.Mesh( bulbGeometry, bulbMaterial );
	this.lightDistance = new THREE.Mesh( distanceGeometry, distanceMaterial );

	var d = light.distance;

	if ( d === 0.0 ) {

		this.lightDistance.visible = false;

	} else {

		this.lightDistance.scale.set( d, d, d );

	}

	this.add( this.lightDistance );
	*/

};

THREE.PointLightHelper.prototype = Object.create( THREE.Mesh.prototype );

THREE.PointLightHelper.prototype.dispose = function () {

	this.geometry.dispose();
	this.material.dispose();
};

THREE.PointLightHelper.prototype.update = function () {

	this.material.color.copy( this.light.color ).multiplyScalar( this.light.intensity );

	/*
	var d = this.light.distance;

	if ( d === 0.0 ) {

		this.lightDistance.visible = false;

	} else {

		this.lightDistance.visible = true;
		this.lightDistance.scale.set( d, d, d );

	}
	*/

};


/**
 * @author alteredq / http://alteredqualia.com/
 * @author mrdoob / http://mrdoob.com/
 * @author WestLangley / http://github.com/WestLangley
*/

THREE.SpotLightHelper = function ( light ) {

	THREE.Object3D.call( this );

	this.light = light;
	this.light.updateMatrixWorld();

	this.matrixWorld = light.matrixWorld;
	this.matrixAutoUpdate = false;

	var geometry = new THREE.CylinderGeometry( 0, 1, 1, 8, 1, true );

	geometry.applyMatrix( new THREE.Matrix4().makeTranslation( 0, -0.5, 0 ) );
	geometry.applyMatrix( new THREE.Matrix4().makeRotationX( - Math.PI / 2 ) );

	var material = new THREE.MeshBasicMaterial( { wireframe: true, fog: false } );

	this.cone = new THREE.Mesh( geometry, material );
	this.add( this.cone );

	this.update();

};

THREE.SpotLightHelper.prototype = Object.create( THREE.Object3D.prototype );

THREE.SpotLightHelper.prototype.dispose = function () {
	this.cone.geometry.dispose();
	this.cone.material.dispose();
};

THREE.SpotLightHelper.prototype.update = function () {

	var vector = new THREE.Vector3();
	var vector2 = new THREE.Vector3();

	return function () {

		var coneLength = this.light.distance ? this.light.distance : 10000;
		var coneWidth = coneLength * Math.tan( this.light.angle );

		this.cone.scale.set( coneWidth, coneWidth, coneLength );

		vector.setFromMatrixPosition( this.light.matrixWorld );
		vector2.setFromMatrixPosition( this.light.target.matrixWorld );

		this.cone.lookAt( vector2.sub( vector ) );

		this.cone.material.color.copy( this.light.color ).multiplyScalar( this.light.intensity );

	};

}();

/**
 * @author mrdoob / http://mrdoob.com/
 * @author WestLangley / http://github.com/WestLangley
*/

THREE.VertexNormalsHelper = function ( object, size, hex, linewidth ) {

	this.object = object;

	this.size = ( size !== undefined ) ? size : 1;

	var color = ( hex !== undefined ) ? hex : 0xff0000;

	var width = ( linewidth !== undefined ) ? linewidth : 1;

	var geometry = new THREE.Geometry();

	var vertices = object.geometry.vertices;

	var faces = object.geometry.faces;

	for ( var i = 0, l = faces.length; i < l; i ++ ) {

		var face = faces[ i ];

		for ( var j = 0, jl = face.vertexNormals.length; j < jl; j ++ ) {

			geometry.vertices.push( new THREE.Vector3() );
			geometry.vertices.push( new THREE.Vector3() );

		}

	}

	THREE.Line.call( this, geometry, new THREE.LineBasicMaterial( { color: color, linewidth: width } ), THREE.LinePieces );

	this.matrixAutoUpdate = false;

	this.normalMatrix = new THREE.Matrix3();

	this.update();

};

THREE.VertexNormalsHelper.prototype = Object.create( THREE.Line.prototype );

THREE.VertexNormalsHelper.prototype.update = ( function ( object ) {

	var v1 = new THREE.Vector3();

	return function( object ) {

		var keys = [ 'a', 'b', 'c', 'd' ];

		this.object.updateMatrixWorld( true );

		this.normalMatrix.getNormalMatrix( this.object.matrixWorld );

		var vertices = this.geometry.vertices;

		var verts = this.object.geometry.vertices;

		var faces = this.object.geometry.faces;

		var worldMatrix = this.object.matrixWorld;

		var idx = 0;

		for ( var i = 0, l = faces.length; i < l; i ++ ) {

			var face = faces[ i ];

			for ( var j = 0, jl = face.vertexNormals.length; j < jl; j ++ ) {

				var vertexId = face[ keys[ j ] ];
				var vertex = verts[ vertexId ];

				var normal = face.vertexNormals[ j ];

				vertices[ idx ].copy( vertex ).applyMatrix4( worldMatrix );

				v1.copy( normal ).applyMatrix3( this.normalMatrix ).normalize().multiplyScalar( this.size );

				v1.add( vertices[ idx ] );
				idx = idx + 1;

				vertices[ idx ].copy( v1 );
				idx = idx + 1;

			}

		}

		this.geometry.verticesNeedUpdate = true;

		return this;

	}

}());

/**
 * @author mrdoob / http://mrdoob.com/
 * @author WestLangley / http://github.com/WestLangley
*/

THREE.VertexTangentsHelper = function ( object, size, hex, linewidth ) {

	this.object = object;

	this.size = ( size !== undefined ) ? size : 1;

	var color = ( hex !== undefined ) ? hex : 0x0000ff;

	var width = ( linewidth !== undefined ) ? linewidth : 1;

	var geometry = new THREE.Geometry();

	var vertices = object.geometry.vertices;

	var faces = object.geometry.faces;

	for ( var i = 0, l = faces.length; i < l; i ++ ) {

		var face = faces[ i ];

		for ( var j = 0, jl = face.vertexTangents.length; j < jl; j ++ ) {

			geometry.vertices.push( new THREE.Vector3() );
			geometry.vertices.push( new THREE.Vector3() );

		}

	}

	THREE.Line.call( this, geometry, new THREE.LineBasicMaterial( { color: color, linewidth: width } ), THREE.LinePieces );

	this.matrixAutoUpdate = false;

	this.update();

};

THREE.VertexTangentsHelper.prototype = Object.create( THREE.Line.prototype );

THREE.VertexTangentsHelper.prototype.update = ( function ( object ) {

	var v1 = new THREE.Vector3();

	return function( object ) {

		var keys = [ 'a', 'b', 'c', 'd' ];

		this.object.updateMatrixWorld( true );

		var vertices = this.geometry.vertices;

		var verts = this.object.geometry.vertices;

		var faces = this.object.geometry.faces;

		var worldMatrix = this.object.matrixWorld;

		var idx = 0;

		for ( var i = 0, l = faces.length; i < l; i ++ ) {

			var face = faces[ i ];

			for ( var j = 0, jl = face.vertexTangents.length; j < jl; j ++ ) {

				var vertexId = face[ keys[ j ] ];
				var vertex = verts[ vertexId ];

				var tangent = face.vertexTangents[ j ];

				vertices[ idx ].copy( vertex ).applyMatrix4( worldMatrix );

				v1.copy( tangent ).transformDirection( worldMatrix ).multiplyScalar( this.size );

				v1.add( vertices[ idx ] );
				idx = idx + 1;

				vertices[ idx ].copy( v1 );
				idx = idx + 1;

			}

		}

		this.geometry.verticesNeedUpdate = true;

		return this;

	}

}());

/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.WireframeHelper = function ( object, hex ) {

	var color = ( hex !== undefined ) ? hex : 0xffffff;

	var edge = [ 0, 0 ], hash = {};
	var sortFunction = function ( a, b ) { return a - b };

	var keys = [ 'a', 'b', 'c' ];
	var geometry = new THREE.BufferGeometry();

	if ( object.geometry instanceof THREE.Geometry ) {

		var vertices = object.geometry.vertices;
		var faces = object.geometry.faces;
		var numEdges = 0;

		// allocate maximal size
		var edges = new Uint32Array( 6 * faces.length );

		for ( var i = 0, l = faces.length; i < l; i ++ ) {

			var face = faces[ i ];

			for ( var j = 0; j < 3; j ++ ) {

				edge[ 0 ] = face[ keys[ j ] ];
				edge[ 1 ] = face[ keys[ ( j + 1 ) % 3 ] ];
				edge.sort( sortFunction );

				var key = edge.toString();

				if ( hash[ key ] === undefined ) {

					edges[ 2 * numEdges ] = edge[ 0 ];
					edges[ 2 * numEdges + 1 ] = edge[ 1 ];
					hash[ key ] = true;
					numEdges ++;

				}

			}

		}

		geometry.addAttribute( 'position', Float32Array, 2 * numEdges, 3 );

		var coords = geometry.attributes.position.array;

		for ( var i = 0, l = numEdges; i < l; i ++ ) {

			for ( var j = 0; j < 2; j ++ ) {

				var vertex = vertices[ edges [ 2 * i + j] ];

				var index = 6 * i + 3 * j;
				coords[ index + 0 ] = vertex.x;
				coords[ index + 1 ] = vertex.y;
				coords[ index + 2 ] = vertex.z;

			}

		}

	} else if ( object.geometry instanceof THREE.BufferGeometry && object.geometry.attributes.index !== undefined ) { // indexed BufferGeometry

		var vertices = object.geometry.attributes.position.array;
		var indices = object.geometry.attributes.index.array;
		var offsets = object.geometry.offsets;
		var numEdges = 0;

		// allocate maximal size
		var edges = new Uint32Array( 2 * indices.length );

		for ( var o = 0, ol = offsets.length; o < ol; ++ o ) {

			var start = offsets[ o ].start;
			var count = offsets[ o ].count;
			var index = offsets[ o ].index;

			for ( var i = start, il = start + count; i < il; i += 3 ) {

				for ( var j = 0; j < 3; j ++ ) {

					edge[ 0 ] = index + indices[ i + j ];
					edge[ 1 ] = index + indices[ i + ( j + 1 ) % 3 ];
					edge.sort( sortFunction );

					var key = edge.toString();

					if ( hash[ key ] === undefined ) {

						edges[ 2 * numEdges ] = edge[ 0 ];
						edges[ 2 * numEdges + 1 ] = edge[ 1 ];
						hash[ key ] = true;
						numEdges ++;

					}

				}

			}

		}

		geometry.addAttribute( 'position', Float32Array, 2 * numEdges, 3 );

		var coords = geometry.attributes.position.array;

		for ( var i = 0, l = numEdges; i < l; i ++ ) {

			for ( var j = 0; j < 2; j ++ ) {

				var index = 6 * i + 3 * j;
				var index2 = 3 * edges[ 2 * i + j];
				coords[ index + 0 ] = vertices[ index2 ];
				coords[ index + 1 ] = vertices[ index2 + 1 ];
				coords[ index + 2 ] = vertices[ index2 + 2 ];

			}

		}

	} else if ( object.geometry instanceof THREE.BufferGeometry	) { // non-indexed BufferGeometry

		var vertices = object.geometry.attributes.position.array;
		var numEdges = vertices.length / 3;
		var numTris = numEdges / 3;

		geometry.addAttribute( 'position', Float32Array, 2 * numEdges, 3 );

		var coords = geometry.attributes.position.array;

		for ( var i = 0, l = numTris; i < l; i ++ ) {

			for ( var j = 0; j < 3; j ++ ) {

				var index = 18 * i + 6 * j;

				var index1 = 9 * i + 3 * j;
				coords[ index + 0 ] = vertices[ index1 ];
				coords[ index + 1 ] = vertices[ index1 + 1 ];
				coords[ index + 2 ] = vertices[ index1 + 2 ];

				var index2 = 9 * i + 3 * ( ( j + 1 ) % 3 );
				coords[ index + 3 ] = vertices[ index2 ];
				coords[ index + 4 ] = vertices[ index2 + 1 ];
				coords[ index + 5 ] = vertices[ index2 + 2 ];

			}

		}

	}

	THREE.Line.call( this, geometry, new THREE.LineBasicMaterial( { color: color } ), THREE.LinePieces );

	this.matrixAutoUpdate = false;
	this.matrixWorld = object.matrixWorld;

};

THREE.WireframeHelper.prototype = Object.create( THREE.Line.prototype );

/**
 * @author alteredq / http://alteredqualia.com/
 */

THREE.ImmediateRenderObject = function () {

	THREE.Object3D.call( this );

	this.render = function ( renderCallback ) { };

};

THREE.ImmediateRenderObject.prototype = Object.create( THREE.Object3D.prototype );

/**
 * @author mikael emtinger / http://gomo.se/
 * @author alteredq / http://alteredqualia.com/
 */

THREE.LensFlare = function ( texture, size, distance, blending, color ) {

	THREE.Object3D.call( this );

	this.lensFlares = [];

	this.positionScreen = new THREE.Vector3();
	this.customUpdateCallback = undefined;

	if( texture !== undefined ) {

		this.add( texture, size, distance, blending, color );

	}

};

THREE.LensFlare.prototype = Object.create( THREE.Object3D.prototype );


/*
 * Add: adds another flare
 */

THREE.LensFlare.prototype.add = function ( texture, size, distance, blending, color, opacity ) {

	if( size === undefined ) size = -1;
	if( distance === undefined ) distance = 0;
	if( opacity === undefined ) opacity = 1;
	if( color === undefined ) color = new THREE.Color( 0xffffff );
	if( blending === undefined ) blending = THREE.NormalBlending;

	distance = Math.min( distance, Math.max( 0, distance ) );

	this.lensFlares.push( { texture: texture, 			// THREE.Texture
		                    size: size, 				// size in pixels (-1 = use texture.width)
		                    distance: distance, 		// distance (0-1) from light source (0=at light source)
		                    x: 0, y: 0, z: 0,			// screen position (-1 => 1) z = 0 is ontop z = 1 is back
		                    scale: 1, 					// scale
		                    rotation: 1, 				// rotation
		                    opacity: opacity,			// opacity
							color: color,				// color
		                    blending: blending } );		// blending

};


/*
 * Update lens flares update positions on all flares based on the screen position
 * Set myLensFlare.customUpdateCallback to alter the flares in your project specific way.
 */

THREE.LensFlare.prototype.updateLensFlares = function () {

	var f, fl = this.lensFlares.length;
	var flare;
	var vecX = -this.positionScreen.x * 2;
	var vecY = -this.positionScreen.y * 2;

	for( f = 0; f < fl; f ++ ) {

		flare = this.lensFlares[ f ];

		flare.x = this.positionScreen.x + vecX * flare.distance;
		flare.y = this.positionScreen.y + vecY * flare.distance;

		flare.wantedRotation = flare.x * Math.PI * 0.25;
		flare.rotation += ( flare.wantedRotation - flare.rotation ) * 0.25;

	}

};













/**
 * @author alteredq / http://alteredqualia.com/
 */

THREE.MorphBlendMesh = function( geometry, material ) {

	THREE.Mesh.call( this, geometry, material );

	this.animationsMap = {};
	this.animationsList = [];

	// prepare default animation
	// (all frames played together in 1 second)

	var numFrames = this.geometry.morphTargets.length;

	var name = "__default";

	var startFrame = 0;
	var endFrame = numFrames - 1;

	var fps = numFrames / 1;

	this.createAnimation( name, startFrame, endFrame, fps );
	this.setAnimationWeight( name, 1 );

};

THREE.MorphBlendMesh.prototype = Object.create( THREE.Mesh.prototype );

THREE.MorphBlendMesh.prototype.createAnimation = function ( name, start, end, fps ) {

	var animation = {

		startFrame: start,
		endFrame: end,

		length: end - start + 1,

		fps: fps,
		duration: ( end - start ) / fps,

		lastFrame: 0,
		currentFrame: 0,

		active: false,

		time: 0,
		direction: 1,
		weight: 1,

		directionBackwards: false,
		mirroredLoop: false

	};

	this.animationsMap[ name ] = animation;
	this.animationsList.push( animation );

};

THREE.MorphBlendMesh.prototype.autoCreateAnimations = function ( fps ) {

	var pattern = /([a-z]+)(\d+)/;

	var firstAnimation, frameRanges = {};

	var geometry = this.geometry;

	for ( var i = 0, il = geometry.morphTargets.length; i < il; i ++ ) {

		var morph = geometry.morphTargets[ i ];
		var chunks = morph.name.match( pattern );

		if ( chunks && chunks.length > 1 ) {

			var name = chunks[ 1 ];
			var num = chunks[ 2 ];

			if ( ! frameRanges[ name ] ) frameRanges[ name ] = { start: Infinity, end: -Infinity };

			var range = frameRanges[ name ];

			if ( i < range.start ) range.start = i;
			if ( i > range.end ) range.end = i;

			if ( ! firstAnimation ) firstAnimation = name;

		}

	}

	for ( var name in frameRanges ) {

		var range = frameRanges[ name ];
		this.createAnimation( name, range.start, range.end, fps );

	}

	this.firstAnimation = firstAnimation;

};

THREE.MorphBlendMesh.prototype.setAnimationDirectionForward = function ( name ) {

	var animation = this.animationsMap[ name ];

	if ( animation ) {

		animation.direction = 1;
		animation.directionBackwards = false;

	}

};

THREE.MorphBlendMesh.prototype.setAnimationDirectionBackward = function ( name ) {

	var animation = this.animationsMap[ name ];

	if ( animation ) {

		animation.direction = -1;
		animation.directionBackwards = true;

	}

};

THREE.MorphBlendMesh.prototype.setAnimationFPS = function ( name, fps ) {

	var animation = this.animationsMap[ name ];

	if ( animation ) {

		animation.fps = fps;
		animation.duration = ( animation.end - animation.start ) / animation.fps;

	}

};

THREE.MorphBlendMesh.prototype.setAnimationDuration = function ( name, duration ) {

	var animation = this.animationsMap[ name ];

	if ( animation ) {

		animation.duration = duration;
		animation.fps = ( animation.end - animation.start ) / animation.duration;

	}

};

THREE.MorphBlendMesh.prototype.setAnimationWeight = function ( name, weight ) {

	var animation = this.animationsMap[ name ];

	if ( animation ) {

		animation.weight = weight;

	}

};

THREE.MorphBlendMesh.prototype.setAnimationTime = function ( name, time ) {

	var animation = this.animationsMap[ name ];

	if ( animation ) {

		animation.time = time;

	}

};

THREE.MorphBlendMesh.prototype.getAnimationTime = function ( name ) {

	var time = 0;

	var animation = this.animationsMap[ name ];

	if ( animation ) {

		time = animation.time;

	}

	return time;

};

THREE.MorphBlendMesh.prototype.getAnimationDuration = function ( name ) {

	var duration = -1;

	var animation = this.animationsMap[ name ];

	if ( animation ) {

		duration = animation.duration;

	}

	return duration;

};

THREE.MorphBlendMesh.prototype.playAnimation = function ( name ) {

	var animation = this.animationsMap[ name ];

	if ( animation ) {

		animation.time = 0;
		animation.active = true;

	} else {

		console.warn( "animation[" + name + "] undefined" );

	}

};

THREE.MorphBlendMesh.prototype.stopAnimation = function ( name ) {

	var animation = this.animationsMap[ name ];

	if ( animation ) {

		animation.active = false;

	}

};

THREE.MorphBlendMesh.prototype.update = function ( delta ) {

	for ( var i = 0, il = this.animationsList.length; i < il; i ++ ) {

		var animation = this.animationsList[ i ];

		if ( ! animation.active ) continue;

		var frameTime = animation.duration / animation.length;

		animation.time += animation.direction * delta;

		if ( animation.mirroredLoop ) {

			if ( animation.time > animation.duration || animation.time < 0 ) {

				animation.direction *= -1;

				if ( animation.time > animation.duration ) {

					animation.time = animation.duration;
					animation.directionBackwards = true;

				}

				if ( animation.time < 0 ) {

					animation.time = 0;
					animation.directionBackwards = false;

				}

			}

		} else {

			animation.time = animation.time % animation.duration;

			if ( animation.time < 0 ) animation.time += animation.duration;

		}

		var keyframe = animation.startFrame + THREE.Math.clamp( Math.floor( animation.time / frameTime ), 0, animation.length - 1 );
		var weight = animation.weight;

		if ( keyframe !== animation.currentFrame ) {

			this.morphTargetInfluences[ animation.lastFrame ] = 0;
			this.morphTargetInfluences[ animation.currentFrame ] = 1 * weight;

			this.morphTargetInfluences[ keyframe ] = 0;

			animation.lastFrame = animation.currentFrame;
			animation.currentFrame = keyframe;

		}

		var mix = ( animation.time % frameTime ) / frameTime;

		if ( animation.directionBackwards ) mix = 1 - mix;

		this.morphTargetInfluences[ animation.currentFrame ] = mix * weight;
		this.morphTargetInfluences[ animation.lastFrame ] = ( 1 - mix ) * weight;

	}

};

/**
 * @author mikael emtinger / http://gomo.se/
 * @author alteredq / http://alteredqualia.com/
 */

THREE.LensFlarePlugin = function () {

	var _gl, _renderer, _precision, _lensFlare = {};

	this.init = function ( renderer ) {

		_gl = renderer.context;
		_renderer = renderer;

		_precision = renderer.getPrecision();

		_lensFlare.vertices = new Float32Array( 8 + 8 );
		_lensFlare.faces = new Uint16Array( 6 );

		var i = 0;
		_lensFlare.vertices[ i++ ] = -1; _lensFlare.vertices[ i++ ] = -1;	// vertex
		_lensFlare.vertices[ i++ ] = 0;  _lensFlare.vertices[ i++ ] = 0;	// uv... etc.

		_lensFlare.vertices[ i++ ] = 1;  _lensFlare.vertices[ i++ ] = -1;
		_lensFlare.vertices[ i++ ] = 1;  _lensFlare.vertices[ i++ ] = 0;

		_lensFlare.vertices[ i++ ] = 1;  _lensFlare.vertices[ i++ ] = 1;
		_lensFlare.vertices[ i++ ] = 1;  _lensFlare.vertices[ i++ ] = 1;

		_lensFlare.vertices[ i++ ] = -1; _lensFlare.vertices[ i++ ] = 1;
		_lensFlare.vertices[ i++ ] = 0;  _lensFlare.vertices[ i++ ] = 1;

		i = 0;
		_lensFlare.faces[ i++ ] = 0; _lensFlare.faces[ i++ ] = 1; _lensFlare.faces[ i++ ] = 2;
		_lensFlare.faces[ i++ ] = 0; _lensFlare.faces[ i++ ] = 2; _lensFlare.faces[ i++ ] = 3;

		// buffers

		_lensFlare.vertexBuffer     = _gl.createBuffer();
		_lensFlare.elementBuffer    = _gl.createBuffer();

		_gl.bindBuffer( _gl.ARRAY_BUFFER, _lensFlare.vertexBuffer );
		_gl.bufferData( _gl.ARRAY_BUFFER, _lensFlare.vertices, _gl.STATIC_DRAW );

		_gl.bindBuffer( _gl.ELEMENT_ARRAY_BUFFER, _lensFlare.elementBuffer );
		_gl.bufferData( _gl.ELEMENT_ARRAY_BUFFER, _lensFlare.faces, _gl.STATIC_DRAW );

		// textures

		_lensFlare.tempTexture      = _gl.createTexture();
		_lensFlare.occlusionTexture = _gl.createTexture();

		_gl.bindTexture( _gl.TEXTURE_2D, _lensFlare.tempTexture );
		_gl.texImage2D( _gl.TEXTURE_2D, 0, _gl.RGB, 16, 16, 0, _gl.RGB, _gl.UNSIGNED_BYTE, null );
		_gl.texParameteri( _gl.TEXTURE_2D, _gl.TEXTURE_WRAP_S, _gl.CLAMP_TO_EDGE );
		_gl.texParameteri( _gl.TEXTURE_2D, _gl.TEXTURE_WRAP_T, _gl.CLAMP_TO_EDGE );
		_gl.texParameteri( _gl.TEXTURE_2D, _gl.TEXTURE_MAG_FILTER, _gl.NEAREST );
		_gl.texParameteri( _gl.TEXTURE_2D, _gl.TEXTURE_MIN_FILTER, _gl.NEAREST );

		_gl.bindTexture( _gl.TEXTURE_2D, _lensFlare.occlusionTexture );
		_gl.texImage2D( _gl.TEXTURE_2D, 0, _gl.RGBA, 16, 16, 0, _gl.RGBA, _gl.UNSIGNED_BYTE, null );
		_gl.texParameteri( _gl.TEXTURE_2D, _gl.TEXTURE_WRAP_S, _gl.CLAMP_TO_EDGE );
		_gl.texParameteri( _gl.TEXTURE_2D, _gl.TEXTURE_WRAP_T, _gl.CLAMP_TO_EDGE );
		_gl.texParameteri( _gl.TEXTURE_2D, _gl.TEXTURE_MAG_FILTER, _gl.NEAREST );
		_gl.texParameteri( _gl.TEXTURE_2D, _gl.TEXTURE_MIN_FILTER, _gl.NEAREST );

		if ( _gl.getParameter( _gl.MAX_VERTEX_TEXTURE_IMAGE_UNITS ) <= 0 ) {

			_lensFlare.hasVertexTexture = false;
			_lensFlare.program = createProgram( THREE.ShaderFlares[ "lensFlare" ], _precision );

		} else {

			_lensFlare.hasVertexTexture = true;
			_lensFlare.program = createProgram( THREE.ShaderFlares[ "lensFlareVertexTexture" ], _precision );

		}

		_lensFlare.attributes = {};
		_lensFlare.uniforms = {};

		_lensFlare.attributes.vertex       = _gl.getAttribLocation ( _lensFlare.program, "position" );
		_lensFlare.attributes.uv           = _gl.getAttribLocation ( _lensFlare.program, "uv" );

		_lensFlare.uniforms.renderType     = _gl.getUniformLocation( _lensFlare.program, "renderType" );
		_lensFlare.uniforms.map            = _gl.getUniformLocation( _lensFlare.program, "map" );
		_lensFlare.uniforms.occlusionMap   = _gl.getUniformLocation( _lensFlare.program, "occlusionMap" );
		_lensFlare.uniforms.opacity        = _gl.getUniformLocation( _lensFlare.program, "opacity" );
		_lensFlare.uniforms.color          = _gl.getUniformLocation( _lensFlare.program, "color" );
		_lensFlare.uniforms.scale          = _gl.getUniformLocation( _lensFlare.program, "scale" );
		_lensFlare.uniforms.rotation       = _gl.getUniformLocation( _lensFlare.program, "rotation" );
		_lensFlare.uniforms.screenPosition = _gl.getUniformLocation( _lensFlare.program, "screenPosition" );

	};


	/*
	 * Render lens flares
	 * Method: renders 16x16 0xff00ff-colored points scattered over the light source area,
	 *         reads these back and calculates occlusion.
	 *         Then _lensFlare.update_lensFlares() is called to re-position and
	 *         update transparency of flares. Then they are rendered.
	 *
	 */

	this.render = function ( scene, camera, viewportWidth, viewportHeight ) {

		var flares = scene.__webglFlares,
			nFlares = flares.length;

		if ( ! nFlares ) return;

		var tempPosition = new THREE.Vector3();

		var invAspect = viewportHeight / viewportWidth,
			halfViewportWidth = viewportWidth * 0.5,
			halfViewportHeight = viewportHeight * 0.5;

		var size = 16 / viewportHeight,
			scale = new THREE.Vector2( size * invAspect, size );

		var screenPosition = new THREE.Vector3( 1, 1, 0 ),
			screenPositionPixels = new THREE.Vector2( 1, 1 );

		var uniforms = _lensFlare.uniforms,
			attributes = _lensFlare.attributes;

		// set _lensFlare program and reset blending

		_gl.useProgram( _lensFlare.program );

		_gl.enableVertexAttribArray( _lensFlare.attributes.vertex );
		_gl.enableVertexAttribArray( _lensFlare.attributes.uv );

		// loop through all lens flares to update their occlusion and positions
		// setup gl and common used attribs/unforms

		_gl.uniform1i( uniforms.occlusionMap, 0 );
		_gl.uniform1i( uniforms.map, 1 );

		_gl.bindBuffer( _gl.ARRAY_BUFFER, _lensFlare.vertexBuffer );
		_gl.vertexAttribPointer( attributes.vertex, 2, _gl.FLOAT, false, 2 * 8, 0 );
		_gl.vertexAttribPointer( attributes.uv, 2, _gl.FLOAT, false, 2 * 8, 8 );

		_gl.bindBuffer( _gl.ELEMENT_ARRAY_BUFFER, _lensFlare.elementBuffer );

		_gl.disable( _gl.CULL_FACE );
		_gl.depthMask( false );

		var i, j, jl, flare, sprite;

		for ( i = 0; i < nFlares; i ++ ) {

			size = 16 / viewportHeight;
			scale.set( size * invAspect, size );

			// calc object screen position

			flare = flares[ i ];

			tempPosition.set( flare.matrixWorld.elements[12], flare.matrixWorld.elements[13], flare.matrixWorld.elements[14] );

			tempPosition.applyMatrix4( camera.matrixWorldInverse );
			tempPosition.applyProjection( camera.projectionMatrix );

			// setup arrays for gl programs

			screenPosition.copy( tempPosition )

			screenPositionPixels.x = screenPosition.x * halfViewportWidth + halfViewportWidth;
			screenPositionPixels.y = screenPosition.y * halfViewportHeight + halfViewportHeight;

			// screen cull

			if ( _lensFlare.hasVertexTexture || (
				screenPositionPixels.x > 0 &&
				screenPositionPixels.x < viewportWidth &&
				screenPositionPixels.y > 0 &&
				screenPositionPixels.y < viewportHeight ) ) {

				// save current RGB to temp texture

				_gl.activeTexture( _gl.TEXTURE1 );
				_gl.bindTexture( _gl.TEXTURE_2D, _lensFlare.tempTexture );
				_gl.copyTexImage2D( _gl.TEXTURE_2D, 0, _gl.RGB, screenPositionPixels.x - 8, screenPositionPixels.y - 8, 16, 16, 0 );


				// render pink quad

				_gl.uniform1i( uniforms.renderType, 0 );
				_gl.uniform2f( uniforms.scale, scale.x, scale.y );
				_gl.uniform3f( uniforms.screenPosition, screenPosition.x, screenPosition.y, screenPosition.z );

				_gl.disable( _gl.BLEND );
				_gl.enable( _gl.DEPTH_TEST );

				_gl.drawElements( _gl.TRIANGLES, 6, _gl.UNSIGNED_SHORT, 0 );


				// copy result to occlusionMap

				_gl.activeTexture( _gl.TEXTURE0 );
				_gl.bindTexture( _gl.TEXTURE_2D, _lensFlare.occlusionTexture );
				_gl.copyTexImage2D( _gl.TEXTURE_2D, 0, _gl.RGBA, screenPositionPixels.x - 8, screenPositionPixels.y - 8, 16, 16, 0 );


				// restore graphics

				_gl.uniform1i( uniforms.renderType, 1 );
				_gl.disable( _gl.DEPTH_TEST );

				_gl.activeTexture( _gl.TEXTURE1 );
				_gl.bindTexture( _gl.TEXTURE_2D, _lensFlare.tempTexture );
				_gl.drawElements( _gl.TRIANGLES, 6, _gl.UNSIGNED_SHORT, 0 );


				// update object positions

				flare.positionScreen.copy( screenPosition )

				if ( flare.customUpdateCallback ) {

					flare.customUpdateCallback( flare );

				} else {

					flare.updateLensFlares();

				}

				// render flares

				_gl.uniform1i( uniforms.renderType, 2 );
				_gl.enable( _gl.BLEND );

				for ( j = 0, jl = flare.lensFlares.length; j < jl; j ++ ) {

					sprite = flare.lensFlares[ j ];

					if ( sprite.opacity > 0.001 && sprite.scale > 0.001 ) {

						screenPosition.x = sprite.x;
						screenPosition.y = sprite.y;
						screenPosition.z = sprite.z;

						size = sprite.size * sprite.scale / viewportHeight;

						scale.x = size * invAspect;
						scale.y = size;

						_gl.uniform3f( uniforms.screenPosition, screenPosition.x, screenPosition.y, screenPosition.z );
						_gl.uniform2f( uniforms.scale, scale.x, scale.y );
						_gl.uniform1f( uniforms.rotation, sprite.rotation );

						_gl.uniform1f( uniforms.opacity, sprite.opacity );
						_gl.uniform3f( uniforms.color, sprite.color.r, sprite.color.g, sprite.color.b );

						_renderer.setBlending( sprite.blending, sprite.blendEquation, sprite.blendSrc, sprite.blendDst );
						_renderer.setTexture( sprite.texture, 1 );

						_gl.drawElements( _gl.TRIANGLES, 6, _gl.UNSIGNED_SHORT, 0 );

					}

				}

			}

		}

		// restore gl

		_gl.enable( _gl.CULL_FACE );
		_gl.enable( _gl.DEPTH_TEST );
		_gl.depthMask( true );

	};

	function createProgram ( shader, precision ) {

		var program = _gl.createProgram();

		var fragmentShader = _gl.createShader( _gl.FRAGMENT_SHADER );
		var vertexShader = _gl.createShader( _gl.VERTEX_SHADER );

		var prefix = "precision " + precision + " float;\n";

		_gl.shaderSource( fragmentShader, prefix + shader.fragmentShader );
		_gl.shaderSource( vertexShader, prefix + shader.vertexShader );

		_gl.compileShader( fragmentShader );
		_gl.compileShader( vertexShader );

		_gl.attachShader( program, fragmentShader );
		_gl.attachShader( program, vertexShader );

		_gl.linkProgram( program );

		return program;

	};

};

/**
 * @author alteredq / http://alteredqualia.com/
 */

THREE.ShadowMapPlugin = function () {

	var _gl,
	_renderer,
	_depthMaterial, _depthMaterialMorph, _depthMaterialSkin, _depthMaterialMorphSkin,

	_frustum = new THREE.Frustum(),
	_projScreenMatrix = new THREE.Matrix4(),

	_min = new THREE.Vector3(),
	_max = new THREE.Vector3(),

	_matrixPosition = new THREE.Vector3();

	this.init = function ( renderer ) {

		_gl = renderer.context;
		_renderer = renderer;

		var depthShader = THREE.ShaderLib[ "depthRGBA" ];
		var depthUniforms = THREE.UniformsUtils.clone( depthShader.uniforms );

		_depthMaterial = new THREE.ShaderMaterial( { fragmentShader: depthShader.fragmentShader, vertexShader: depthShader.vertexShader, uniforms: depthUniforms } );
		_depthMaterialMorph = new THREE.ShaderMaterial( { fragmentShader: depthShader.fragmentShader, vertexShader: depthShader.vertexShader, uniforms: depthUniforms, morphTargets: true } );
		_depthMaterialSkin = new THREE.ShaderMaterial( { fragmentShader: depthShader.fragmentShader, vertexShader: depthShader.vertexShader, uniforms: depthUniforms, skinning: true } );
		_depthMaterialMorphSkin = new THREE.ShaderMaterial( { fragmentShader: depthShader.fragmentShader, vertexShader: depthShader.vertexShader, uniforms: depthUniforms, morphTargets: true, skinning: true } );

		_depthMaterial._shadowPass = true;
		_depthMaterialMorph._shadowPass = true;
		_depthMaterialSkin._shadowPass = true;
		_depthMaterialMorphSkin._shadowPass = true;

	};

	this.render = function ( scene, camera ) {

		if ( ! ( _renderer.shadowMapEnabled && _renderer.shadowMapAutoUpdate ) ) return;

		this.update( scene, camera );

	};

	this.update = function ( scene, camera ) {

		var i, il, j, jl, n,

		shadowMap, shadowMatrix, shadowCamera,
		program, buffer, material,
		webglObject, object, light,
		renderList,

		lights = [],
		k = 0,

		fog = null;

		// set GL state for depth map

		_gl.clearColor( 1, 1, 1, 1 );
		_gl.disable( _gl.BLEND );

		_gl.enable( _gl.CULL_FACE );
		_gl.frontFace( _gl.CCW );

		if ( _renderer.shadowMapCullFace === THREE.CullFaceFront ) {

			_gl.cullFace( _gl.FRONT );

		} else {

			_gl.cullFace( _gl.BACK );

		}

		_renderer.setDepthTest( true );

		// preprocess lights
		// 	- skip lights that are not casting shadows
		//	- create virtual lights for cascaded shadow maps

		for ( i = 0, il = scene.__lights.length; i < il; i ++ ) {

			light = scene.__lights[ i ];

			if ( ! light.castShadow ) continue;

			if ( ( light instanceof THREE.DirectionalLight ) && light.shadowCascade ) {

				for ( n = 0; n < light.shadowCascadeCount; n ++ ) {

					var virtualLight;

					if ( ! light.shadowCascadeArray[ n ] ) {

						virtualLight = createVirtualLight( light, n );
						virtualLight.originalCamera = camera;

						var gyro = new THREE.Gyroscope();
						gyro.position = light.shadowCascadeOffset;

						gyro.add( virtualLight );
						gyro.add( virtualLight.target );

						camera.add( gyro );

						light.shadowCascadeArray[ n ] = virtualLight;

						console.log( "Created virtualLight", virtualLight );

					} else {

						virtualLight = light.shadowCascadeArray[ n ];

					}

					updateVirtualLight( light, n );

					lights[ k ] = virtualLight;
					k ++;

				}

			} else {

				lights[ k ] = light;
				k ++;

			}

		}

		// render depth map

		for ( i = 0, il = lights.length; i < il; i ++ ) {

			light = lights[ i ];

			if ( ! light.shadowMap ) {

				var shadowFilter = THREE.LinearFilter;

				if ( _renderer.shadowMapType === THREE.PCFSoftShadowMap ) {

					shadowFilter = THREE.NearestFilter;

				}

				var pars = { minFilter: shadowFilter, magFilter: shadowFilter, format: THREE.RGBAFormat };

				light.shadowMap = new THREE.WebGLRenderTarget( light.shadowMapWidth, light.shadowMapHeight, pars );
				light.shadowMapSize = new THREE.Vector2( light.shadowMapWidth, light.shadowMapHeight );

				light.shadowMatrix = new THREE.Matrix4();

			}

			if ( ! light.shadowCamera ) {

				if ( light instanceof THREE.SpotLight ) {

					light.shadowCamera = new THREE.PerspectiveCamera( light.shadowCameraFov, light.shadowMapWidth / light.shadowMapHeight, light.shadowCameraNear, light.shadowCameraFar );

				} else if ( light instanceof THREE.DirectionalLight ) {

					light.shadowCamera = new THREE.OrthographicCamera( light.shadowCameraLeft, light.shadowCameraRight, light.shadowCameraTop, light.shadowCameraBottom, light.shadowCameraNear, light.shadowCameraFar );

				} else {

					console.error( "Unsupported light type for shadow" );
					continue;

				}

				scene.add( light.shadowCamera );

				if ( scene.autoUpdate === true ) scene.updateMatrixWorld();

			}

			if ( light.shadowCameraVisible && ! light.cameraHelper ) {

				light.cameraHelper = new THREE.CameraHelper( light.shadowCamera );
				light.shadowCamera.add( light.cameraHelper );

			}

			if ( light.isVirtual && virtualLight.originalCamera == camera ) {

				updateShadowCamera( camera, light );

			}

			shadowMap = light.shadowMap;
			shadowMatrix = light.shadowMatrix;
			shadowCamera = light.shadowCamera;

			shadowCamera.position.setFromMatrixPosition( light.matrixWorld );
			_matrixPosition.setFromMatrixPosition( light.target.matrixWorld );
			shadowCamera.lookAt( _matrixPosition );
			shadowCamera.updateMatrixWorld();

			shadowCamera.matrixWorldInverse.getInverse( shadowCamera.matrixWorld );

			if ( light.cameraHelper ) light.cameraHelper.visible = light.shadowCameraVisible;
			if ( light.shadowCameraVisible ) light.cameraHelper.update();

			// compute shadow matrix

			shadowMatrix.set( 0.5, 0.0, 0.0, 0.5,
							  0.0, 0.5, 0.0, 0.5,
							  0.0, 0.0, 0.5, 0.5,
							  0.0, 0.0, 0.0, 1.0 );

			shadowMatrix.multiply( shadowCamera.projectionMatrix );
			shadowMatrix.multiply( shadowCamera.matrixWorldInverse );

			// update camera matrices and frustum

			_projScreenMatrix.multiplyMatrices( shadowCamera.projectionMatrix, shadowCamera.matrixWorldInverse );
			_frustum.setFromMatrix( _projScreenMatrix );

			// render shadow map

			_renderer.setRenderTarget( shadowMap );
			_renderer.clear();

			// set object matrices & frustum culling

			renderList = scene.__webglObjects;

			for ( j = 0, jl = renderList.length; j < jl; j ++ ) {

				webglObject = renderList[ j ];
				object = webglObject.object;

				webglObject.render = false;

				if ( object.visible && object.castShadow ) {

					if ( ! ( object instanceof THREE.Mesh || object instanceof THREE.ParticleSystem ) || ! ( object.frustumCulled ) || _frustum.intersectsObject( object ) ) {

						object._modelViewMatrix.multiplyMatrices( shadowCamera.matrixWorldInverse, object.matrixWorld );

						webglObject.render = true;

					}

				}

			}

			// render regular objects

			var objectMaterial, useMorphing, useSkinning;

			for ( j = 0, jl = renderList.length; j < jl; j ++ ) {

				webglObject = renderList[ j ];

				if ( webglObject.render ) {

					object = webglObject.object;
					buffer = webglObject.buffer;

					// culling is overriden globally for all objects
					// while rendering depth map

					// need to deal with MeshFaceMaterial somehow
					// in that case just use the first of material.materials for now
					// (proper solution would require to break objects by materials
					//  similarly to regular rendering and then set corresponding
					//  depth materials per each chunk instead of just once per object)

					objectMaterial = getObjectMaterial( object );

					useMorphing = object.geometry.morphTargets.length > 0 && objectMaterial.morphTargets;
					useSkinning = object instanceof THREE.SkinnedMesh && objectMaterial.skinning;

					if ( object.customDepthMaterial ) {

						material = object.customDepthMaterial;

					} else if ( useSkinning ) {

						material = useMorphing ? _depthMaterialMorphSkin : _depthMaterialSkin;

					} else if ( useMorphing ) {

						material = _depthMaterialMorph;

					} else {

						material = _depthMaterial;

					}

					if ( buffer instanceof THREE.BufferGeometry ) {

						_renderer.renderBufferDirect( shadowCamera, scene.__lights, fog, material, buffer, object );

					} else {

						_renderer.renderBuffer( shadowCamera, scene.__lights, fog, material, buffer, object );

					}

				}

			}

			// set matrices and render immediate objects

			renderList = scene.__webglObjectsImmediate;

			for ( j = 0, jl = renderList.length; j < jl; j ++ ) {

				webglObject = renderList[ j ];
				object = webglObject.object;

				if ( object.visible && object.castShadow ) {

					object._modelViewMatrix.multiplyMatrices( shadowCamera.matrixWorldInverse, object.matrixWorld );

					_renderer.renderImmediateObject( shadowCamera, scene.__lights, fog, _depthMaterial, object );

				}

			}

		}

		// restore GL state

		var clearColor = _renderer.getClearColor(),
		clearAlpha = _renderer.getClearAlpha();

		_gl.clearColor( clearColor.r, clearColor.g, clearColor.b, clearAlpha );
		_gl.enable( _gl.BLEND );

		if ( _renderer.shadowMapCullFace === THREE.CullFaceFront ) {

			_gl.cullFace( _gl.BACK );

		}

	};

	function createVirtualLight( light, cascade ) {

		var virtualLight = new THREE.DirectionalLight();

		virtualLight.isVirtual = true;

		virtualLight.onlyShadow = true;
		virtualLight.castShadow = true;

		virtualLight.shadowCameraNear = light.shadowCameraNear;
		virtualLight.shadowCameraFar = light.shadowCameraFar;

		virtualLight.shadowCameraLeft = light.shadowCameraLeft;
		virtualLight.shadowCameraRight = light.shadowCameraRight;
		virtualLight.shadowCameraBottom = light.shadowCameraBottom;
		virtualLight.shadowCameraTop = light.shadowCameraTop;

		virtualLight.shadowCameraVisible = light.shadowCameraVisible;

		virtualLight.shadowDarkness = light.shadowDarkness;

		virtualLight.shadowBias = light.shadowCascadeBias[ cascade ];
		virtualLight.shadowMapWidth = light.shadowCascadeWidth[ cascade ];
		virtualLight.shadowMapHeight = light.shadowCascadeHeight[ cascade ];

		virtualLight.pointsWorld = [];
		virtualLight.pointsFrustum = [];

		var pointsWorld = virtualLight.pointsWorld,
			pointsFrustum = virtualLight.pointsFrustum;

		for ( var i = 0; i < 8; i ++ ) {

			pointsWorld[ i ] = new THREE.Vector3();
			pointsFrustum[ i ] = new THREE.Vector3();

		}

		var nearZ = light.shadowCascadeNearZ[ cascade ];
		var farZ = light.shadowCascadeFarZ[ cascade ];

		pointsFrustum[ 0 ].set( -1, -1, nearZ );
		pointsFrustum[ 1 ].set(  1, -1, nearZ );
		pointsFrustum[ 2 ].set( -1,  1, nearZ );
		pointsFrustum[ 3 ].set(  1,  1, nearZ );

		pointsFrustum[ 4 ].set( -1, -1, farZ );
		pointsFrustum[ 5 ].set(  1, -1, farZ );
		pointsFrustum[ 6 ].set( -1,  1, farZ );
		pointsFrustum[ 7 ].set(  1,  1, farZ );

		return virtualLight;

	}

	// Synchronize virtual light with the original light

	function updateVirtualLight( light, cascade ) {

		var virtualLight = light.shadowCascadeArray[ cascade ];

		virtualLight.position.copy( light.position );
		virtualLight.target.position.copy( light.target.position );
		virtualLight.lookAt( virtualLight.target );

		virtualLight.shadowCameraVisible = light.shadowCameraVisible;
		virtualLight.shadowDarkness = light.shadowDarkness;

		virtualLight.shadowBias = light.shadowCascadeBias[ cascade ];

		var nearZ = light.shadowCascadeNearZ[ cascade ];
		var farZ = light.shadowCascadeFarZ[ cascade ];

		var pointsFrustum = virtualLight.pointsFrustum;

		pointsFrustum[ 0 ].z = nearZ;
		pointsFrustum[ 1 ].z = nearZ;
		pointsFrustum[ 2 ].z = nearZ;
		pointsFrustum[ 3 ].z = nearZ;

		pointsFrustum[ 4 ].z = farZ;
		pointsFrustum[ 5 ].z = farZ;
		pointsFrustum[ 6 ].z = farZ;
		pointsFrustum[ 7 ].z = farZ;

	}

	// Fit shadow camera's ortho frustum to camera frustum

	function updateShadowCamera( camera, light ) {

		var shadowCamera = light.shadowCamera,
			pointsFrustum = light.pointsFrustum,
			pointsWorld = light.pointsWorld;

		_min.set( Infinity, Infinity, Infinity );
		_max.set( -Infinity, -Infinity, -Infinity );

		for ( var i = 0; i < 8; i ++ ) {

			var p = pointsWorld[ i ];

			p.copy( pointsFrustum[ i ] );
			THREE.ShadowMapPlugin.__projector.unprojectVector( p, camera );

			p.applyMatrix4( shadowCamera.matrixWorldInverse );

			if ( p.x < _min.x ) _min.x = p.x;
			if ( p.x > _max.x ) _max.x = p.x;

			if ( p.y < _min.y ) _min.y = p.y;
			if ( p.y > _max.y ) _max.y = p.y;

			if ( p.z < _min.z ) _min.z = p.z;
			if ( p.z > _max.z ) _max.z = p.z;

		}

		shadowCamera.left = _min.x;
		shadowCamera.right = _max.x;
		shadowCamera.top = _max.y;
		shadowCamera.bottom = _min.y;

		// can't really fit near/far
		//shadowCamera.near = _min.z;
		//shadowCamera.far = _max.z;

		shadowCamera.updateProjectionMatrix();

	}

	// For the moment just ignore objects that have multiple materials with different animation methods
	// Only the first material will be taken into account for deciding which depth material to use for shadow maps

	function getObjectMaterial( object ) {

		return object.material instanceof THREE.MeshFaceMaterial
			? object.material.materials[ 0 ]
			: object.material;

	};

};

THREE.ShadowMapPlugin.__projector = new THREE.Projector();

/**
 * @author mikael emtinger / http://gomo.se/
 * @author alteredq / http://alteredqualia.com/
 */

THREE.SpritePlugin = function () {

	var _gl, _renderer, _texture;

	var vertices, faces, vertexBuffer, elementBuffer;
	var program, attributes, uniforms;

	this.init = function ( renderer ) {

		_gl = renderer.context;
		_renderer = renderer;

		vertices = new Float32Array( [
			- 0.5, - 0.5, 0, 0,
			  0.5, - 0.5, 1, 0,
			  0.5,   0.5, 1, 1,
			- 0.5,   0.5, 0, 1
		] );

		faces = new Uint16Array( [
			0, 1, 2,
			0, 2, 3
		] );

		vertexBuffer  = _gl.createBuffer();
		elementBuffer = _gl.createBuffer();

		_gl.bindBuffer( _gl.ARRAY_BUFFER, vertexBuffer );
		_gl.bufferData( _gl.ARRAY_BUFFER, vertices, _gl.STATIC_DRAW );

		_gl.bindBuffer( _gl.ELEMENT_ARRAY_BUFFER, elementBuffer );
		_gl.bufferData( _gl.ELEMENT_ARRAY_BUFFER, faces, _gl.STATIC_DRAW );

		program = createProgram();

		attributes = {
			position:			_gl.getAttribLocation ( program, 'position' ),
			uv:					_gl.getAttribLocation ( program, 'uv' )
		};

		uniforms = {
			uvOffset:			_gl.getUniformLocation( program, 'uvOffset' ),
			uvScale:			_gl.getUniformLocation( program, 'uvScale' ),

			rotation:			_gl.getUniformLocation( program, 'rotation' ),
			scale:				_gl.getUniformLocation( program, 'scale' ),

			color:				_gl.getUniformLocation( program, 'color' ),
			map:				_gl.getUniformLocation( program, 'map' ),
			opacity:			_gl.getUniformLocation( program, 'opacity' ),

			modelViewMatrix: 	_gl.getUniformLocation( program, 'modelViewMatrix' ),
			projectionMatrix:	_gl.getUniformLocation( program, 'projectionMatrix' ),

			fogType:			_gl.getUniformLocation( program, 'fogType' ),
			fogDensity:			_gl.getUniformLocation( program, 'fogDensity' ),
			fogNear:			_gl.getUniformLocation( program, 'fogNear' ),
			fogFar:				_gl.getUniformLocation( program, 'fogFar' ),
			fogColor:			_gl.getUniformLocation( program, 'fogColor' ),

			alphaTest:			_gl.getUniformLocation( program, 'alphaTest' )
		};

		var canvas = document.createElement( 'canvas' );
		canvas.width = 8;
		canvas.height = 8;

		var context = canvas.getContext( '2d' );
		context.fillStyle = '#ffffff';
		context.fillRect( 0, 0, canvas.width, canvas.height );

		_texture = new THREE.Texture( canvas );
		_texture.needsUpdate = true;

	};

	this.render = function ( scene, camera, viewportWidth, viewportHeight ) {

		var sprites = scene.__webglSprites,
			nSprites = sprites.length;

		if ( ! nSprites ) return;

		// setup gl

		_gl.useProgram( program );

		_gl.enableVertexAttribArray( attributes.position );
		_gl.enableVertexAttribArray( attributes.uv );

		_gl.disable( _gl.CULL_FACE );
		_gl.enable( _gl.BLEND );

		_gl.bindBuffer( _gl.ARRAY_BUFFER, vertexBuffer );
		_gl.vertexAttribPointer( attributes.position, 2, _gl.FLOAT, false, 2 * 8, 0 );
		_gl.vertexAttribPointer( attributes.uv, 2, _gl.FLOAT, false, 2 * 8, 8 );

		_gl.bindBuffer( _gl.ELEMENT_ARRAY_BUFFER, elementBuffer );

		_gl.uniformMatrix4fv( uniforms.projectionMatrix, false, camera.projectionMatrix.elements );

		_gl.activeTexture( _gl.TEXTURE0 );
		_gl.uniform1i( uniforms.map, 0 );

		var oldFogType = 0;
		var sceneFogType = 0;
		var fog = scene.fog;

		if ( fog ) {

			_gl.uniform3f( uniforms.fogColor, fog.color.r, fog.color.g, fog.color.b );

			if ( fog instanceof THREE.Fog ) {

				_gl.uniform1f( uniforms.fogNear, fog.near );
				_gl.uniform1f( uniforms.fogFar, fog.far );

				_gl.uniform1i( uniforms.fogType, 1 );
				oldFogType = 1;
				sceneFogType = 1;

			} else if ( fog instanceof THREE.FogExp2 ) {

				_gl.uniform1f( uniforms.fogDensity, fog.density );

				_gl.uniform1i( uniforms.fogType, 2 );
				oldFogType = 2;
				sceneFogType = 2;

			}

		} else {

			_gl.uniform1i( uniforms.fogType, 0 );
			oldFogType = 0;
			sceneFogType = 0;

		}


		// update positions and sort

		var i, sprite, material, fogType, scale = [];

		for( i = 0; i < nSprites; i ++ ) {

			sprite = sprites[ i ];
			material = sprite.material;

			if ( sprite.visible === false ) continue;

			sprite._modelViewMatrix.multiplyMatrices( camera.matrixWorldInverse, sprite.matrixWorld );
			sprite.z = - sprite._modelViewMatrix.elements[ 14 ];

		}

		sprites.sort( painterSortStable );

		// render all sprites

		for( i = 0; i < nSprites; i ++ ) {

			sprite = sprites[ i ];

			if ( sprite.visible === false ) continue;

			material = sprite.material;

			_gl.uniform1f( uniforms.alphaTest, material.alphaTest );
			_gl.uniformMatrix4fv( uniforms.modelViewMatrix, false, sprite._modelViewMatrix.elements );

			scale[ 0 ] = sprite.scale.x;
			scale[ 1 ] = sprite.scale.y;

			if ( scene.fog && material.fog ) {

				fogType = sceneFogType;

			} else {

				fogType = 0;

			}

			if ( oldFogType !== fogType ) {

				_gl.uniform1i( uniforms.fogType, fogType );
				oldFogType = fogType;

			}

			if ( material.map !== null ) {

				_gl.uniform2f( uniforms.uvOffset, material.map.offset.x, material.map.offset.y );
				_gl.uniform2f( uniforms.uvScale, material.map.repeat.x, material.map.repeat.y );

			} else {

				_gl.uniform2f( uniforms.uvOffset, 0, 0 );
				_gl.uniform2f( uniforms.uvScale, 1, 1 );

			}

			_gl.uniform1f( uniforms.opacity, material.opacity );
			_gl.uniform3f( uniforms.color, material.color.r, material.color.g, material.color.b );

			_gl.uniform1f( uniforms.rotation, material.rotation );
			_gl.uniform2fv( uniforms.scale, scale );

			_renderer.setBlending( material.blending, material.blendEquation, material.blendSrc, material.blendDst );
			_renderer.setDepthTest( material.depthTest );
			_renderer.setDepthWrite( material.depthWrite );

			if ( material.map && material.map.image && material.map.image.width ) {

				_renderer.setTexture( material.map, 0 );

			} else {

				_renderer.setTexture( _texture, 0 );

			}

			_gl.drawElements( _gl.TRIANGLES, 6, _gl.UNSIGNED_SHORT, 0 );

		}

		// restore gl

		_gl.enable( _gl.CULL_FACE );

	};

	function createProgram () {

		var program = _gl.createProgram();

		var vertexShader = _gl.createShader( _gl.VERTEX_SHADER );
		var fragmentShader = _gl.createShader( _gl.FRAGMENT_SHADER );

		_gl.shaderSource( vertexShader, [

			'precision ' + _renderer.getPrecision() + ' float;',

			'uniform mat4 modelViewMatrix;',
			'uniform mat4 projectionMatrix;',
			'uniform float rotation;',
			'uniform vec2 scale;',
			'uniform vec2 uvOffset;',
			'uniform vec2 uvScale;',

			'attribute vec2 position;',
			'attribute vec2 uv;',

			'varying vec2 vUV;',

			'void main() {',

				'vUV = uvOffset + uv * uvScale;',

				'vec2 alignedPosition = position * scale;',

				'vec2 rotatedPosition;',
				'rotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;',
				'rotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;',

				'vec4 finalPosition;',

				'finalPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );',
				'finalPosition.xy += rotatedPosition;',
				'finalPosition = projectionMatrix * finalPosition;',

				'gl_Position = finalPosition;',

			'}'

		].join( '\n' ) );

		_gl.shaderSource( fragmentShader, [

			'precision ' + _renderer.getPrecision() + ' float;',

			'uniform vec3 color;',
			'uniform sampler2D map;',
			'uniform float opacity;',

			'uniform int fogType;',
			'uniform vec3 fogColor;',
			'uniform float fogDensity;',
			'uniform float fogNear;',
			'uniform float fogFar;',
			'uniform float alphaTest;',

			'varying vec2 vUV;',

			'void main() {',

				'vec4 texture = texture2D( map, vUV );',

				'if ( texture.a < alphaTest ) discard;',

				'gl_FragColor = vec4( color * texture.xyz, texture.a * opacity );',

				'if ( fogType > 0 ) {',

					'float depth = gl_FragCoord.z / gl_FragCoord.w;',
					'float fogFactor = 0.0;',

					'if ( fogType == 1 ) {',

						'fogFactor = smoothstep( fogNear, fogFar, depth );',

					'} else {',

						'const float LOG2 = 1.442695;',
						'float fogFactor = exp2( - fogDensity * fogDensity * depth * depth * LOG2 );',
						'fogFactor = 1.0 - clamp( fogFactor, 0.0, 1.0 );',

					'}',

					'gl_FragColor = mix( gl_FragColor, vec4( fogColor, gl_FragColor.w ), fogFactor );',

				'}',

			'}'

		].join( '\n' ) );

		_gl.compileShader( vertexShader );
		_gl.compileShader( fragmentShader );

		_gl.attachShader( program, vertexShader );
		_gl.attachShader( program, fragmentShader );

		_gl.linkProgram( program );

		return program;

	};

	function painterSortStable ( a, b ) {

		if ( a.z !== b.z ) {

			return b.z - a.z;

		} else {

			return b.id - a.id;

		}

	};

};

/**
 * @author alteredq / http://alteredqualia.com/
 */

THREE.DepthPassPlugin = function () {

	this.enabled = false;
	this.renderTarget = null;

	var _gl,
	_renderer,
	_depthMaterial, _depthMaterialMorph, _depthMaterialSkin, _depthMaterialMorphSkin,

	_frustum = new THREE.Frustum(),
	_projScreenMatrix = new THREE.Matrix4();

	this.init = function ( renderer ) {

		_gl = renderer.context;
		_renderer = renderer;

		var depthShader = THREE.ShaderLib[ "depthRGBA" ];
		var depthUniforms = THREE.UniformsUtils.clone( depthShader.uniforms );

		_depthMaterial = new THREE.ShaderMaterial( { fragmentShader: depthShader.fragmentShader, vertexShader: depthShader.vertexShader, uniforms: depthUniforms } );
		_depthMaterialMorph = new THREE.ShaderMaterial( { fragmentShader: depthShader.fragmentShader, vertexShader: depthShader.vertexShader, uniforms: depthUniforms, morphTargets: true } );
		_depthMaterialSkin = new THREE.ShaderMaterial( { fragmentShader: depthShader.fragmentShader, vertexShader: depthShader.vertexShader, uniforms: depthUniforms, skinning: true } );
		_depthMaterialMorphSkin = new THREE.ShaderMaterial( { fragmentShader: depthShader.fragmentShader, vertexShader: depthShader.vertexShader, uniforms: depthUniforms, morphTargets: true, skinning: true } );

		_depthMaterial._shadowPass = true;
		_depthMaterialMorph._shadowPass = true;
		_depthMaterialSkin._shadowPass = true;
		_depthMaterialMorphSkin._shadowPass = true;

	};

	this.render = function ( scene, camera ) {

		if ( ! this.enabled ) return;

		this.update( scene, camera );

	};

	this.update = function ( scene, camera ) {

		var i, il, j, jl, n,

		program, buffer, material,
		webglObject, object, light,
		renderList,

		fog = null;

		// set GL state for depth map

		_gl.clearColor( 1, 1, 1, 1 );
		_gl.disable( _gl.BLEND );

		_renderer.setDepthTest( true );

		// update scene

		if ( scene.autoUpdate === true ) scene.updateMatrixWorld();

		// update camera matrices and frustum

		camera.matrixWorldInverse.getInverse( camera.matrixWorld );

		_projScreenMatrix.multiplyMatrices( camera.projectionMatrix, camera.matrixWorldInverse );
		_frustum.setFromMatrix( _projScreenMatrix );

		// render depth map

		_renderer.setRenderTarget( this.renderTarget );
		_renderer.clear();

		// set object matrices & frustum culling

		renderList = scene.__webglObjects;

		for ( j = 0, jl = renderList.length; j < jl; j ++ ) {

			webglObject = renderList[ j ];
			object = webglObject.object;

			webglObject.render = false;

			if ( object.visible ) {

				if ( ! ( object instanceof THREE.Mesh || object instanceof THREE.ParticleSystem ) || ! ( object.frustumCulled ) || _frustum.intersectsObject( object ) ) {

					object._modelViewMatrix.multiplyMatrices( camera.matrixWorldInverse, object.matrixWorld );

					webglObject.render = true;

				}

			}

		}

		// render regular objects

		var objectMaterial, useMorphing, useSkinning;

		for ( j = 0, jl = renderList.length; j < jl; j ++ ) {

			webglObject = renderList[ j ];

			if ( webglObject.render ) {

				object = webglObject.object;
				buffer = webglObject.buffer;

				// todo: create proper depth material for particles

				if ( object instanceof THREE.ParticleSystem && !object.customDepthMaterial ) continue;

				objectMaterial = getObjectMaterial( object );

				if ( objectMaterial ) _renderer.setMaterialFaces( object.material );

				useMorphing = object.geometry.morphTargets.length > 0 && objectMaterial.morphTargets;
				useSkinning = object instanceof THREE.SkinnedMesh && objectMaterial.skinning;

				if ( object.customDepthMaterial ) {

					material = object.customDepthMaterial;

				} else if ( useSkinning ) {

					material = useMorphing ? _depthMaterialMorphSkin : _depthMaterialSkin;

				} else if ( useMorphing ) {

					material = _depthMaterialMorph;

				} else {

					material = _depthMaterial;

				}

				if ( buffer instanceof THREE.BufferGeometry ) {

					_renderer.renderBufferDirect( camera, scene.__lights, fog, material, buffer, object );

				} else {

					_renderer.renderBuffer( camera, scene.__lights, fog, material, buffer, object );

				}

			}

		}

		// set matrices and render immediate objects

		renderList = scene.__webglObjectsImmediate;

		for ( j = 0, jl = renderList.length; j < jl; j ++ ) {

			webglObject = renderList[ j ];
			object = webglObject.object;

			if ( object.visible ) {

				object._modelViewMatrix.multiplyMatrices( camera.matrixWorldInverse, object.matrixWorld );

				_renderer.renderImmediateObject( camera, scene.__lights, fog, _depthMaterial, object );

			}

		}

		// restore GL state

		var clearColor = _renderer.getClearColor(),
		clearAlpha = _renderer.getClearAlpha();

		_gl.clearColor( clearColor.r, clearColor.g, clearColor.b, clearAlpha );
		_gl.enable( _gl.BLEND );

	};

	// For the moment just ignore objects that have multiple materials with different animation methods
	// Only the first material will be taken into account for deciding which depth material to use

	function getObjectMaterial( object ) {

		return object.material instanceof THREE.MeshFaceMaterial
			? object.material.materials[ 0 ]
			: object.material;

	};

};


/**
 * @author mikael emtinger / http://gomo.se/
 */

THREE.ShaderFlares = {

	'lensFlareVertexTexture': {

		vertexShader: [

			"uniform lowp int renderType;",

			"uniform vec3 screenPosition;",
			"uniform vec2 scale;",
			"uniform float rotation;",

			"uniform sampler2D occlusionMap;",

			"attribute vec2 position;",
			"attribute vec2 uv;",

			"varying vec2 vUV;",
			"varying float vVisibility;",

			"void main() {",

				"vUV = uv;",

				"vec2 pos = position;",

				"if( renderType == 2 ) {",

					"vec4 visibility = texture2D( occlusionMap, vec2( 0.1, 0.1 ) );",
					"visibility += texture2D( occlusionMap, vec2( 0.5, 0.1 ) );",
					"visibility += texture2D( occlusionMap, vec2( 0.9, 0.1 ) );",
					"visibility += texture2D( occlusionMap, vec2( 0.9, 0.5 ) );",
					"visibility += texture2D( occlusionMap, vec2( 0.9, 0.9 ) );",
					"visibility += texture2D( occlusionMap, vec2( 0.5, 0.9 ) );",
					"visibility += texture2D( occlusionMap, vec2( 0.1, 0.9 ) );",
					"visibility += texture2D( occlusionMap, vec2( 0.1, 0.5 ) );",
					"visibility += texture2D( occlusionMap, vec2( 0.5, 0.5 ) );",

					"vVisibility =        visibility.r / 9.0;",
					"vVisibility *= 1.0 - visibility.g / 9.0;",
					"vVisibility *=       visibility.b / 9.0;",
					"vVisibility *= 1.0 - visibility.a / 9.0;",

					"pos.x = cos( rotation ) * position.x - sin( rotation ) * position.y;",
					"pos.y = sin( rotation ) * position.x + cos( rotation ) * position.y;",

				"}",

				"gl_Position = vec4( ( pos * scale + screenPosition.xy ).xy, screenPosition.z, 1.0 );",

			"}"

		].join( "\n" ),

		fragmentShader: [

			"uniform lowp int renderType;",

			"uniform sampler2D map;",
			"uniform float opacity;",
			"uniform vec3 color;",

			"varying vec2 vUV;",
			"varying float vVisibility;",

			"void main() {",

				// pink square

				"if( renderType == 0 ) {",

					"gl_FragColor = vec4( 1.0, 0.0, 1.0, 0.0 );",

				// restore

				"} else if( renderType == 1 ) {",

					"gl_FragColor = texture2D( map, vUV );",

				// flare

				"} else {",

					"vec4 texture = texture2D( map, vUV );",
					"texture.a *= opacity * vVisibility;",
					"gl_FragColor = texture;",
					"gl_FragColor.rgb *= color;",

				"}",

			"}"
		].join( "\n" )

	},


	'lensFlare': {

		vertexShader: [

			"uniform lowp int renderType;",

			"uniform vec3 screenPosition;",
			"uniform vec2 scale;",
			"uniform float rotation;",

			"attribute vec2 position;",
			"attribute vec2 uv;",

			"varying vec2 vUV;",

			"void main() {",

				"vUV = uv;",

				"vec2 pos = position;",

				"if( renderType == 2 ) {",

					"pos.x = cos( rotation ) * position.x - sin( rotation ) * position.y;",
					"pos.y = sin( rotation ) * position.x + cos( rotation ) * position.y;",

				"}",

				"gl_Position = vec4( ( pos * scale + screenPosition.xy ).xy, screenPosition.z, 1.0 );",

			"}"

		].join( "\n" ),

		fragmentShader: [

			"precision mediump float;",

			"uniform lowp int renderType;",

			"uniform sampler2D map;",
			"uniform sampler2D occlusionMap;",
			"uniform float opacity;",
			"uniform vec3 color;",

			"varying vec2 vUV;",

			"void main() {",

				// pink square

				"if( renderType == 0 ) {",

					"gl_FragColor = vec4( texture2D( map, vUV ).rgb, 0.0 );",

				// restore

				"} else if( renderType == 1 ) {",

					"gl_FragColor = texture2D( map, vUV );",

				// flare

				"} else {",

					"float visibility = texture2D( occlusionMap, vec2( 0.5, 0.1 ) ).a;",
					"visibility += texture2D( occlusionMap, vec2( 0.9, 0.5 ) ).a;",
					"visibility += texture2D( occlusionMap, vec2( 0.5, 0.9 ) ).a;",
					"visibility += texture2D( occlusionMap, vec2( 0.1, 0.5 ) ).a;",
					"visibility = ( 1.0 - visibility / 4.0 );",

					"vec4 texture = texture2D( map, vUV );",
					"texture.a *= opacity * visibility;",
					"gl_FragColor = texture;",
					"gl_FragColor.rgb *= color;",

				"}",

			"}"

		].join( "\n" )

	}

};

  /**
   * @author Eberhard Graether / http://egraether.com/
   */

  THREE.TrackballControls = function(object, domElement) {

      var _this = this;
      var STATE = {
          NONE: -1,
          ROTATE: 0,
          ZOOM: 1,
          PAN: 2,
          TOUCH_ROTATE: 3,
          TOUCH_ZOOM: 4,
          TOUCH_PAN: 5
      };

      this.object = object;
      this.domElement = (domElement !== undefined) ? domElement : document;

      // API

      this.enabled = true;

      this.screen = {
          left: 0,
          top: 0,
          width: 0,
          height: 0
      };

      this.rotateSpeed = 1.0;
      this.zoomSpeed = 1.2;
      this.panSpeed = 0.3;

      this.noRotate = false;
      this.noZoom = false;
      this.noPan = false;
      this.noRoll = false;

      this.staticMoving = false;
      this.dynamicDampingFactor = 0.2;

      this.minDistance = 0;
      this.maxDistance = Infinity;

      this.keys = [
          65 /*A*/,
          83 /*S*/,
          68 /*D*/
      ];

      // internals

      this.target = new THREE.Vector3();

      var lastPosition = new THREE.Vector3();

      var _state = STATE.NONE,
        _prevState = STATE.NONE,
        _eye = new THREE.Vector3(),
        _rotateStart = new THREE.Vector3(),
        _rotateEnd = new THREE.Vector3(),
        _zoomStart = new THREE.Vector2(),
        _zoomEnd = new THREE.Vector2(),
        _touchZoomDistanceStart = 0,
        _touchZoomDistanceEnd = 0,
        _panStart = new THREE.Vector2(),
        _panEnd = new THREE.Vector2();

      // for reset

      this.target0 = this.target.clone();
      this.position0 = this.object.position.clone();
      this.up0 = this.object.up.clone();

      // events

      var changeEvent = {
          type: 'change'
      };


      // methods

      this.handleResize = function() {

          if (this.domElement === document) {

              this.screen.left = 0;
              this.screen.top = 0;
              this.screen.width = window.innerWidth;
              this.screen.height = window.innerHeight;

          } else {

              this.screen = this.domElement.getBoundingClientRect();

          }

      };

      this.handleEvent = function(event) {

          if (typeof this[ event.type ] == 'function') {

              this[ event.type ](event);

          }

      };

      this.getMouseOnScreen = function(clientX, clientY) {

          return new THREE.Vector2(
            (clientX - _this.screen.left) / _this.screen.width,
            (clientY - _this.screen.top) / _this.screen.height
            );

      };

      this.getMouseProjectionOnBall = function(clientX, clientY) {

          var mouseOnBall = new THREE.Vector3(
            (clientX - _this.screen.width * 0.5 - _this.screen.left) / (_this.screen.width * .5),
            (_this.screen.height * 0.5 + _this.screen.top - clientY) / (_this.screen.height * .5),
            0.0
            );

          var length = mouseOnBall.length();

          if (_this.noRoll) {

              if (length < Math.SQRT1_2) {

                  mouseOnBall.z = Math.sqrt(1.0 - length * length);

              } else {

                  mouseOnBall.z = .5 / length;

              }

          } else if (length > 1.0) {

              mouseOnBall.normalize();

          } else {

              mouseOnBall.z = Math.sqrt(1.0 - length * length);

          }

          _eye.copy(_this.object.position).sub(_this.target);

          var projection = _this.object.up.clone().setLength(mouseOnBall.y);
          projection.add(_this.object.up.clone().cross(_eye).setLength(mouseOnBall.x));
          projection.add(_eye.setLength(mouseOnBall.z));

          return projection;

      };

      this.rotateCamera = function() {

          var angle = Math.acos(_rotateStart.dot(_rotateEnd) / _rotateStart.length() / _rotateEnd.length());

          if (angle) {

              var axis = (new THREE.Vector3()).crossVectors(_rotateStart, _rotateEnd).normalize(),
                quaternion = new THREE.Quaternion();

              angle *= _this.rotateSpeed;

              quaternion.setFromAxisAngle(axis, -angle);

              _eye.applyQuaternion(quaternion);
              _this.object.up.applyQuaternion(quaternion);

              _rotateEnd.applyQuaternion(quaternion);

              if (_this.staticMoving) {

                  _rotateStart.copy(_rotateEnd);

              } else {

                  quaternion.setFromAxisAngle(axis, angle * (_this.dynamicDampingFactor - 1.0));
                  _rotateStart.applyQuaternion(quaternion);

              }

          }

      };

      this.zoomCamera = function() {

          if (_state === STATE.TOUCH_ZOOM) {

              var factor = _touchZoomDistanceStart / _touchZoomDistanceEnd;
              _touchZoomDistanceStart = _touchZoomDistanceEnd;
              _eye.multiplyScalar(factor);

          } else {

              var factor = 1.0 + (_zoomEnd.y - _zoomStart.y) * _this.zoomSpeed;

              if (factor !== 1.0 && factor > 0.0) {

                  _eye.multiplyScalar(factor);

                  if (_this.staticMoving) {

                      _zoomStart.copy(_zoomEnd);

                  } else {

                      _zoomStart.y += (_zoomEnd.y - _zoomStart.y) * this.dynamicDampingFactor;

                  }

              }

          }

      };

      this.panCamera = function() {

          var mouseChange = _panEnd.clone().sub(_panStart);

          if (mouseChange.lengthSq()) {

              mouseChange.multiplyScalar(_eye.length() * _this.panSpeed);

              var pan = _eye.clone().cross(_this.object.up).setLength(mouseChange.x);
              pan.add(_this.object.up.clone().setLength(mouseChange.y));

              _this.object.position.add(pan);
              _this.target.add(pan);

              if (_this.staticMoving) {

                  _panStart = _panEnd;

              } else {

                  _panStart.add(mouseChange.subVectors(_panEnd, _panStart).multiplyScalar(_this.dynamicDampingFactor));

              }

          }

      };

      this.checkDistances = function() {

          if (!_this.noZoom || !_this.noPan) {

              if (_eye.lengthSq() > _this.maxDistance * _this.maxDistance) {

                  _this.object.position.addVectors(_this.target, _eye.setLength(_this.maxDistance));

              }

              if (_eye.lengthSq() < _this.minDistance * _this.minDistance) {

                  _this.object.position.addVectors(_this.target, _eye.setLength(_this.minDistance));

              }

          }

      };

      this.update = function() {

          _eye.subVectors(_this.object.position, _this.target);

          if (!_this.noRotate) {

              _this.rotateCamera();

          }

          if (!_this.noZoom) {

              _this.zoomCamera();

          }

          if (!_this.noPan) {

              _this.panCamera();

          }

          _this.object.position.addVectors(_this.target, _eye);

          _this.checkDistances();

          _this.object.lookAt(_this.target);

          if (lastPosition.distanceToSquared(_this.object.position) > 0) {

              _this.dispatchEvent(changeEvent);

              lastPosition.copy(_this.object.position);

          }

      };

      this.reset = function() {

          _state = STATE.NONE;
          _prevState = STATE.NONE;

          _this.target.copy(_this.target0);
          _this.object.position.copy(_this.position0);
          _this.object.up.copy(_this.up0);

          _eye.subVectors(_this.object.position, _this.target);

          _this.object.lookAt(_this.target);

          _this.dispatchEvent(changeEvent);

          lastPosition.copy(_this.object.position);

      };

      // listeners

      function keydown(event) {

          if (_this.enabled === false)
              return;

          window.removeEventListener('keydown', keydown);

          _prevState = _state;

          if (_state !== STATE.NONE) {

              return;

          } else if (event.keyCode === _this.keys[ STATE.ROTATE ] && !_this.noRotate) {

              _state = STATE.ROTATE;

          } else if (event.keyCode === _this.keys[ STATE.ZOOM ] && !_this.noZoom) {

              _state = STATE.ZOOM;

          } else if (event.keyCode === _this.keys[ STATE.PAN ] && !_this.noPan) {

              _state = STATE.PAN;

          }

      }

      function keyup(event) {

          if (_this.enabled === false)
              return;

          _state = _prevState;

          window.addEventListener('keydown', keydown, false);

      }

      function mousedown(event) {

          if (_this.enabled === false)
              return;

          event.preventDefault();
          event.stopPropagation();

          if (_state === STATE.NONE) {

              _state = event.button;

          }

          if (_state === STATE.ROTATE && !_this.noRotate) {

              _rotateStart = _this.getMouseProjectionOnBall(event.clientX, event.clientY);
              _rotateEnd.copy(_rotateStart)

          } else if (_state === STATE.ZOOM && !_this.noZoom) {

              _zoomStart = _this.getMouseOnScreen(event.clientX, event.clientY);
              _zoomEnd.copy(_zoomStart);

          } else if (_state === STATE.PAN && !_this.noPan) {

              _panStart = _this.getMouseOnScreen(event.clientX, event.clientY);
              _panEnd.copy(_panStart)

          }

          document.addEventListener('mousemove', mousemove, false);
          document.addEventListener('mouseup', mouseup, false);

      }

      function mousemove(event) {

          if (_this.enabled === false)
              return;

          event.preventDefault();
          event.stopPropagation();

          if (_state === STATE.ROTATE && !_this.noRotate) {

              _rotateEnd = _this.getMouseProjectionOnBall(event.clientX, event.clientY);

          } else if (_state === STATE.ZOOM && !_this.noZoom) {

              _zoomEnd = _this.getMouseOnScreen(event.clientX, event.clientY);

          } else if (_state === STATE.PAN && !_this.noPan) {

              _panEnd = _this.getMouseOnScreen(event.clientX, event.clientY);

          }

      }

      function mouseup(event) {

          if (_this.enabled === false)
              return;

          event.preventDefault();
          event.stopPropagation();

          _state = STATE.NONE;

          document.removeEventListener('mousemove', mousemove);
          document.removeEventListener('mouseup', mouseup);

      }

      function mousewheel(event) {

          if (_this.enabled === false)
              return;

          event.preventDefault();
          event.stopPropagation();

          var delta = 0;

          if (event.wheelDelta) { // WebKit / Opera / Explorer 9

              delta = event.wheelDelta / 40;

          } else if (event.detail) { // Firefox

              delta = -event.detail / 3;

          }

          _zoomStart.y += delta * 0.01;

      }

      function touchstart(event) {

          if (_this.enabled === false)
              return;

          switch (event.touches.length) {

              case 1:
                  _state = STATE.TOUCH_ROTATE;
                  _rotateStart = _rotateEnd = _this.getMouseProjectionOnBall(event.touches[ 0 ].pageX, event.touches[ 0 ].pageY);
                  break;

              case 2:
                  _state = STATE.TOUCH_ZOOM;
                  var dx = event.touches[ 0 ].pageX - event.touches[ 1 ].pageX;
                  var dy = event.touches[ 0 ].pageY - event.touches[ 1 ].pageY;
                  _touchZoomDistanceEnd = _touchZoomDistanceStart = Math.sqrt(dx * dx + dy * dy);
                  break;

              case 3:
                  _state = STATE.TOUCH_PAN;
                  _panStart = _panEnd = _this.getMouseOnScreen(event.touches[ 0 ].pageX, event.touches[ 0 ].pageY);
                  break;

              default:
                  _state = STATE.NONE;

          }

      }

      function touchmove(event) {

          if (_this.enabled === false)
              return;

          event.preventDefault();
          event.stopPropagation();

          switch (event.touches.length) {

              case 1:
                  _rotateEnd = _this.getMouseProjectionOnBall(event.touches[ 0 ].pageX, event.touches[ 0 ].pageY);
                  break;

              case 2:
                  var dx = event.touches[ 0 ].pageX - event.touches[ 1 ].pageX;
                  var dy = event.touches[ 0 ].pageY - event.touches[ 1 ].pageY;
                  _touchZoomDistanceEnd = Math.sqrt(dx * dx + dy * dy)
                  break;

              case 3:
                  _panEnd = _this.getMouseOnScreen(event.touches[ 0 ].pageX, event.touches[ 0 ].pageY);
                  break;

              default:
                  _state = STATE.NONE;

          }

      }

      function touchend(event) {

          if (_this.enabled === false)
              return;

          switch (event.touches.length) {

              case 1:
                  _rotateStart = _rotateEnd = _this.getMouseProjectionOnBall(event.touches[ 0 ].pageX, event.touches[ 0 ].pageY);
                  break;

              case 2:
                  _touchZoomDistanceStart = _touchZoomDistanceEnd = 0;
                  break;

              case 3:
                  _panStart = _panEnd = _this.getMouseOnScreen(event.touches[ 0 ].pageX, event.touches[ 0 ].pageY);
                  break;

          }

          _state = STATE.NONE;

      }

      this.domElement.addEventListener('contextmenu', function(event) {
          event.preventDefault();
      }, false);

      this.domElement.addEventListener('mousedown', mousedown, false);

      this.domElement.addEventListener('mousewheel', mousewheel, false);
      this.domElement.addEventListener('DOMMouseScroll', mousewheel, false); // firefox

      this.domElement.addEventListener('touchstart', touchstart, false);
      this.domElement.addEventListener('touchend', touchend, false);
      this.domElement.addEventListener('touchmove', touchmove, false);

      window.addEventListener('keydown', keydown, false);
      window.addEventListener('keyup', keyup, false);

      this.handleResize();

  };

  THREE.TrackballControls.prototype = Object.create(THREE.EventDispatcher.prototype);

  /**
   * @author qiao / https://github.com/qiao
   * @author mrdoob / http://mrdoob.com
   * @author alteredq / http://alteredqualia.com/
   * @author WestLangley / http://github.com/WestLangley
   */

  THREE.OrbitControls = function(object, domElement) {

      this.object = object;
      this.domElement = (domElement !== undefined) ? domElement : document;

      // API

      this.enabled = true;

      this.center = new THREE.Vector3();

      this.userZoom = true;
      this.userZoomSpeed = 1.0;

      this.userRotate = true;
      this.userRotateSpeed = 1.0;

      this.userPan = true;
      this.userPanSpeed = 2.0;

      this.autoRotate = false;
      this.autoRotateSpeed = 2.0; // 30 seconds per round when fps is 60

      this.minPolarAngle = 0; // radians
      this.maxPolarAngle = Math.PI; // radians

      this.minDistance = 0;
      this.maxDistance = Infinity;

      // 65 /*A*/, 83 /*S*/, 68 /*D*/
      this.keys = {
          LEFT: 37,
          UP: 38,
          RIGHT: 39,
          BOTTOM: 40,
          ROTATE: 65,
          ZOOM: 83,
          PAN: 68
      };

      // internals

      var scope = this;

      var EPS = 0.000001;
      var PIXELS_PER_ROUND = 1800;

      var rotateStart = new THREE.Vector2();
      var rotateEnd = new THREE.Vector2();
      var rotateDelta = new THREE.Vector2();

      var zoomStart = new THREE.Vector2();
      var zoomEnd = new THREE.Vector2();
      var zoomDelta = new THREE.Vector2();

      var phiDelta = 0;
      var thetaDelta = 0;
      var scale = 1;

      var lastPosition = new THREE.Vector3();

      var STATE = {
          NONE: -1,
          ROTATE: 0,
          ZOOM: 1,
          PAN: 2
      };
      var state = STATE.NONE;

      // events

      var changeEvent = {
          type: 'change'
      };


      this.rotateLeft = function(angle) {

          if (angle === undefined) {

              angle = getAutoRotationAngle();

          }

          thetaDelta -= angle;

      };

      this.rotateRight = function(angle) {

          if (angle === undefined) {

              angle = getAutoRotationAngle();

          }

          thetaDelta += angle;

      };

      this.rotateUp = function(angle) {

          if (angle === undefined) {

              angle = getAutoRotationAngle();

          }

          phiDelta -= angle;

      };

      this.rotateDown = function(angle) {

          if (angle === undefined) {

              angle = getAutoRotationAngle();

          }

          phiDelta += angle;

      };

      this.zoomIn = function(zoomScale) {

          if (zoomScale === undefined) {

              zoomScale = getZoomScale();

          }

          scale /= zoomScale;

      };

      this.zoomOut = function(zoomScale) {

          if (zoomScale === undefined) {

              zoomScale = getZoomScale();

          }

          scale *= zoomScale;

      };

      this.pan = function(distance) {

          distance.transformDirection(this.object.matrix);
          distance.multiplyScalar(scope.userPanSpeed);

          this.object.position.add(distance);
          this.center.add(distance);

      };

      this.update = function() {

          var position = this.object.position;
          var offset = position.clone().sub(this.center);

          // angle from z-axis around y-axis

          var theta = Math.atan2(offset.x, offset.z);

          // angle from y-axis

          var phi = Math.atan2(Math.sqrt(offset.x * offset.x + offset.z * offset.z), offset.y);

          if (this.autoRotate) {

              this.rotateLeft(getAutoRotationAngle());

          }

          theta += thetaDelta;
          phi += phiDelta;

          // restrict phi to be between desired limits
          phi = Math.max(this.minPolarAngle, Math.min(this.maxPolarAngle, phi));

          // restrict phi to be betwee EPS and PI-EPS
          phi = Math.max(EPS, Math.min(Math.PI - EPS, phi));

          var radius = offset.length() * scale;

          // restrict radius to be between desired limits
          radius = Math.max(this.minDistance, Math.min(this.maxDistance, radius));

          offset.x = radius * Math.sin(phi) * Math.sin(theta);
          offset.y = radius * Math.cos(phi);
          offset.z = radius * Math.sin(phi) * Math.cos(theta);

          position.copy(this.center).add(offset);

          this.object.lookAt(this.center);

          thetaDelta = 0;
          phiDelta = 0;
          scale = 1;

          if (lastPosition.distanceTo(this.object.position) > 0) {

              this.dispatchEvent(changeEvent);

              lastPosition.copy(this.object.position);

          }

      };


      function getAutoRotationAngle() {

          return 2 * Math.PI / 60 / 60 * scope.autoRotateSpeed;

      }

      function getZoomScale() {

          return Math.pow(0.95, scope.userZoomSpeed);

      }

      function onMouseDown(event) {

          if (scope.enabled === false)
              return;
          if (scope.userRotate === false)
              return;

          event.preventDefault();

          if (state === STATE.NONE)
          {
              if (event.button === 0)
                  state = STATE.ROTATE;
              if (event.button === 1)
                  state = STATE.ZOOM;
              if (event.button === 2)
                  state = STATE.PAN;
          }


          if (state === STATE.ROTATE) {

              //state = STATE.ROTATE;

              rotateStart.set(event.clientX, event.clientY);

          } else if (state === STATE.ZOOM) {

              //state = STATE.ZOOM;

              zoomStart.set(event.clientX, event.clientY);

          } else if (state === STATE.PAN) {

              //state = STATE.PAN;

          }

          document.addEventListener('mousemove', onMouseMove, false);
          document.addEventListener('mouseup', onMouseUp, false);

      }

      function onMouseMove(event) {

          if (scope.enabled === false)
              return;

          event.preventDefault();



          if (state === STATE.ROTATE) {

              rotateEnd.set(event.clientX, event.clientY);
              rotateDelta.subVectors(rotateEnd, rotateStart);

              scope.rotateLeft(2 * Math.PI * rotateDelta.x / PIXELS_PER_ROUND * scope.userRotateSpeed);
              scope.rotateUp(2 * Math.PI * rotateDelta.y / PIXELS_PER_ROUND * scope.userRotateSpeed);

              rotateStart.copy(rotateEnd);

          } else if (state === STATE.ZOOM) {

              zoomEnd.set(event.clientX, event.clientY);
              zoomDelta.subVectors(zoomEnd, zoomStart);

              if (zoomDelta.y > 0) {

                  scope.zoomIn();

              } else {

                  scope.zoomOut();

              }

              zoomStart.copy(zoomEnd);

          } else if (state === STATE.PAN) {

              var movementX = event.movementX || event.mozMovementX || event.webkitMovementX || 0;
              var movementY = event.movementY || event.mozMovementY || event.webkitMovementY || 0;

              scope.pan(new THREE.Vector3(-movementX, movementY, 0));

          }

      }

      function onMouseUp(event) {

          if (scope.enabled === false)
              return;
          if (scope.userRotate === false)
              return;

          document.removeEventListener('mousemove', onMouseMove, false);
          document.removeEventListener('mouseup', onMouseUp, false);

          state = STATE.NONE;

      }

      function onMouseWheel(event) {

          if (scope.enabled === false)
              return;
          if (scope.userZoom === false)
              return;

          var delta = 0;

          if (event.wheelDelta) { // WebKit / Opera / Explorer 9

              delta = event.wheelDelta;

          } else if (event.detail) { // Firefox

              delta = -event.detail;

          }

          if (delta > 0) {

              scope.zoomOut();

          } else {

              scope.zoomIn();

          }

      }

      function onKeyDown(event) {

          if (scope.enabled === false)
              return;
          if (scope.userPan === false)
              return;

          switch (event.keyCode) {

              /*case scope.keys.UP:
               scope.pan( new THREE.Vector3( 0, 1, 0 ) );
               break;
               case scope.keys.BOTTOM:
               scope.pan( new THREE.Vector3( 0, - 1, 0 ) );
               break;
               case scope.keys.LEFT:
               scope.pan( new THREE.Vector3( - 1, 0, 0 ) );
               break;
               case scope.keys.RIGHT:
               scope.pan( new THREE.Vector3( 1, 0, 0 ) );
               break;
               */
              case scope.keys.ROTATE:
                  state = STATE.ROTATE;
                  break;
              case scope.keys.ZOOM:
                  state = STATE.ZOOM;
                  break;
              case scope.keys.PAN:
                  state = STATE.PAN;
                  break;

          }

      }

      function onKeyUp(event) {

          switch (event.keyCode) {

              case scope.keys.ROTATE:
              case scope.keys.ZOOM:
              case scope.keys.PAN:
                  state = STATE.NONE;
                  break;
          }

      }

      this.domElement.addEventListener('contextmenu', function(event) {
          event.preventDefault();
      }, false);
      this.domElement.addEventListener('mousedown', onMouseDown, false);
      this.domElement.addEventListener('mousewheel', onMouseWheel, false);
      this.domElement.addEventListener('DOMMouseScroll', onMouseWheel, false); // firefox
      window.addEventListener('keydown', onKeyDown, false);
      window.addEventListener('keyup', onKeyUp, false);

  };

  THREE.OrbitControls.prototype = Object.create(THREE.EventDispatcher.prototype);

  /**
   * @author alteredq / http://alteredqualia.com/
   * @author mr.doob / http://mrdoob.com/
   * @author Sino Boeckmann, Werbeagentur aufwind. GmbH 2013
   */

  THREE.Detector = function() {
      return {
          canvas: !!window.CanvasRenderingContext2D,
          webgl: (function() {
              try {
                  return !!window.WebGLRenderingContext && !!document.createElement('canvas').getContext('experimental-webgl');
              } catch (e) {
                  return false;
              }
          })(),
          workers: !!window.Worker,
          fileapi: window.File && window.FileReader && window.FileList && window.Blob,
          getWebGLErrorMessage: function() {

              var element = document.createElement('div');
              element.id = 'webgl-error-message';
              element.style.fontFamily = 'monospace';
              element.style.fontSize = '13px';
              element.style.fontWeight = 'normal';
              element.style.textAlign = 'center';
              element.style.background = '#fff';
              element.style.color = '#000';
              element.style.padding = '1.5em';
              element.style.width = '400px';
              element.style.margin = '5em auto 0';

              if (!this.webgl) {

                  element.innerHTML = window.WebGLRenderingContext ? [
                      'Your graphics card does not seem to support <a href="http://khronos.org/webgl/wiki/Getting_a_WebGL_Implementation" style="color:#000">WebGL</a>.<br />',
                      'Find out how to get it <a href="http://get.webgl.org/" style="color:#000">here</a>.'
                  ].join('\n') : [
                      'Your browser does not seem to support <a href="http://khronos.org/webgl/wiki/Getting_a_WebGL_Implementation" style="color:#000">WebGL</a>.<br/>',
                      'Find out how to get it <a href="http://get.webgl.org/" style="color:#000">here</a>.'
                  ].join('\n');

              }

              return element;

          },
          addGetWebGLMessage: function(parameters) {

              var parent, id, element;

              parameters = parameters || {
              };

              parent = parameters.parent !== undefined ? parameters.parent : document.body;
              id = parameters.id !== undefined ? parameters.id : 'oldie';

              element = Detector.getWebGLErrorMessage();
              element.id = id;

              parent.appendChild(element);

          },
          isWebGlSupport: function () {
            return this.webgl;
          }

      };
  };

  THREE.Detector.prototype = Object.create(THREE.EventDispatcher.prototype);

/*! sprintf.js | Copyright (c) 2007-2013 Alexandru Marasteanu <hello at alexei dot ro> | 3 clause BSD license */

(function(ctx) {
	var sprintf = function() {
		if (!sprintf.cache.hasOwnProperty(arguments[0])) {
			sprintf.cache[arguments[0]] = sprintf.parse(arguments[0]);
		}
		return sprintf.format.call(null, sprintf.cache[arguments[0]], arguments);
	};

	sprintf.format = function(parse_tree, argv) {
		var cursor = 1, tree_length = parse_tree.length, node_type = '', arg, output = [], i, k, match, pad, pad_character, pad_length;
		for (i = 0; i < tree_length; i++) {
			node_type = get_type(parse_tree[i]);
			if (node_type === 'string') {
				output.push(parse_tree[i]);
			}
			else if (node_type === 'array') {
				match = parse_tree[i]; // convenience purposes only
				if (match[2]) { // keyword argument
					arg = argv[cursor];
					for (k = 0; k < match[2].length; k++) {
						if (!arg.hasOwnProperty(match[2][k])) {
							throw(sprintf('[sprintf] property "%s" does not exist', match[2][k]));
						}
						arg = arg[match[2][k]];
					}
				}
				else if (match[1]) { // positional argument (explicit)
					arg = argv[match[1]];
				}
				else { // positional argument (implicit)
					arg = argv[cursor++];
				}

				if (/[^s]/.test(match[8]) && (get_type(arg) != 'number')) {
					throw(sprintf('[sprintf] expecting number but found %s', get_type(arg)));
				}
				switch (match[8]) {
					case 'b': arg = arg.toString(2); break;
					case 'c': arg = String.fromCharCode(arg); break;
					case 'd': arg = parseInt(arg, 10); break;
					case 'e': arg = match[7] ? arg.toExponential(match[7]) : arg.toExponential(); break;
					case 'f': arg = match[7] ? parseFloat(arg).toFixed(match[7]) : parseFloat(arg); break;
					case 'o': arg = arg.toString(8); break;
					case 's': arg = ((arg = String(arg)) && match[7] ? arg.substring(0, match[7]) : arg); break;
					case 'u': arg = arg >>> 0; break;
					case 'x': arg = arg.toString(16); break;
					case 'X': arg = arg.toString(16).toUpperCase(); break;
				}
				arg = (/[def]/.test(match[8]) && match[3] && arg >= 0 ? '+'+ arg : arg);
				pad_character = match[4] ? match[4] == '0' ? '0' : match[4].charAt(1) : ' ';
				pad_length = match[6] - String(arg).length;
				pad = match[6] ? str_repeat(pad_character, pad_length) : '';
				output.push(match[5] ? arg + pad : pad + arg);
			}
		}
		return output.join('');
	};

	sprintf.cache = {};

	sprintf.parse = function(fmt) {
		var _fmt = fmt, match = [], parse_tree = [], arg_names = 0;
		while (_fmt) {
			if ((match = /^[^\x25]+/.exec(_fmt)) !== null) {
				parse_tree.push(match[0]);
			}
			else if ((match = /^\x25{2}/.exec(_fmt)) !== null) {
				parse_tree.push('%');
			}
			else if ((match = /^\x25(?:([1-9]\d*)\$|\(([^\)]+)\))?(\+)?(0|'[^$])?(-)?(\d+)?(?:\.(\d+))?([b-fosuxX])/.exec(_fmt)) !== null) {
				if (match[2]) {
					arg_names |= 1;
					var field_list = [], replacement_field = match[2], field_match = [];
					if ((field_match = /^([a-z_][a-z_\d]*)/i.exec(replacement_field)) !== null) {
						field_list.push(field_match[1]);
						while ((replacement_field = replacement_field.substring(field_match[0].length)) !== '') {
							if ((field_match = /^\.([a-z_][a-z_\d]*)/i.exec(replacement_field)) !== null) {
								field_list.push(field_match[1]);
							}
							else if ((field_match = /^\[(\d+)\]/.exec(replacement_field)) !== null) {
								field_list.push(field_match[1]);
							}
							else {
								throw('[sprintf] huh?');
							}
						}
					}
					else {
						throw('[sprintf] huh?');
					}
					match[2] = field_list;
				}
				else {
					arg_names |= 2;
				}
				if (arg_names === 3) {
					throw('[sprintf] mixing positional and named placeholders is not (yet) supported');
				}
				parse_tree.push(match);
			}
			else {
				throw('[sprintf] huh?');
			}
			_fmt = _fmt.substring(match[0].length);
		}
		return parse_tree;
	};

	var vsprintf = function(fmt, argv, _argv) {
		_argv = argv.slice(0);
		_argv.splice(0, 0, fmt);
		return sprintf.apply(null, _argv);
	};

	/**
	 * helpers
	 */
	function get_type(variable) {
		return Object.prototype.toString.call(variable).slice(8, -1).toLowerCase();
	}

	function str_repeat(input, multiplier) {
		for (var output = []; multiplier > 0; output[--multiplier] = input) {/* do nothing */}
		return output.join('');
	}

	/**
	 * export to either browser or node.js
	 */
	ctx.sprintf = sprintf;
	ctx.vsprintf = vsprintf;
})(typeof exports != "undefined" ? exports : window);

